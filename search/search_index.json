{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"Getting Started Installing Pacti <p>Pacti is an open-source Python package for carrying out compositional system analysis and design. Pacti represents components in a system using assume-guarantee specifications, or contracts. Pacti's capabilities, among others, include the following:</p> <ul> <li>Obtaining sensible system specifications from the specifications of the constituent subsystems.</li> <li>Computing specifications of subsystems that need to be added to a design in order to meet an objective.</li> <li>Diagnosing incompatibilities when interconnecting components.</li> </ul> <p>For questions about Pacti and to interact with the community, please go to the organization's GitHub Discussions page. Pacti's developers can be reached at info@pacti.org.</p>"},{"location":"Polyhedral/","title":"PolyhedralTerms","text":"<p>Support for linear inequality constraints, i.e., polyhedra.</p> <p>Module provides support for linear inequalities as constraints, i.e., the constraints are of the form \\(\\sum_{i} a_i x_i \\le c\\), where the \\(x_i\\) are variables and the \\(a_i\\) and \\(c\\) are constants.</p>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm","title":"<code>PolyhedralTerm</code>","text":"<p>         Bases: <code>Term</code></p> <p>Polyhedral terms are linear inequalities over a list of variables.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>class PolyhedralTerm(Term):\n\"\"\"Polyhedral terms are linear inequalities over a list of variables.\"\"\"\n\n    # Constructor: get (i) a dictionary whose keys are variables and whose\n    # values are the coefficients of those variables in the term, and (b) a\n    # constant. The term is assumed to be in the form \\Sigma_i a_i v_i +\n    # constant &lt;= 0\n    def __init__(self, variables: Dict[Var, numeric], constant: numeric):\n\"\"\"\n        Constructor for PolyhedralTerm.\n\n        Usage:\n            Polyhedral terms are initialized as follows:\n\n            ```\n                variables = {Var('x'):2, Var('y'):3}\n                constant = 3\n                term = PolyhedralTerm(variables, constant)\n            ```\n\n            `variables` is a dictionary whose keys are `Var` instances,\n            and `constant` is a number. Thus, our example represents the\n            expression $2x + 3y \\\\le 3$.\n\n        Args:\n            variables: A dictionary mapping Var keys to numeric values.\n            constant: A numeric value on the right of the inequality.\n\n        Raises:\n            ValueError: Unsupported argument type.\n        \"\"\"\n        variable_dict = {}\n        for key, value in variables.items():\n            if value != 0:\n                if isinstance(key, str):\n                    raise ValueError(\"Unsupported argument type\")\n                else:\n                    variable_dict[key] = float(value)\n        self.variables = variable_dict\n        self.constant = float(constant)\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            raise ValueError()\n        match = self.variables.keys() == other.variables.keys()\n        if match:\n            for k, v in self.variables.items():\n                match = match and (v == other.variables[k])\n        return match and self.constant == other.constant\n\n    def __str__(self) -&gt; str:\n        varlist = list(self.variables.items())\n        varlist.sort(key=lambda x: str(x[0]))\n        res = \" + \".join([str(coeff) + \"*\" + var.name for var, coeff in varlist])\n        res += \" &lt;= \" + str(self.constant)\n        return res\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __repr__(self) -&gt; str:\n        return \"&lt;Term {0}&gt;\".format(self)\n\n    def __add__(self, other: object) -&gt; PolyhedralTerm:\n        if not isinstance(other, type(self)):\n            raise ValueError()\n        varlist = list_union(self.vars, other.vars)\n        variables = {}\n        for var in varlist:  # noqa: VNE002\n            variables[var] = self.get_coefficient(var) + other.get_coefficient(var)\n        return PolyhedralTerm(variables, self.constant + other.constant)\n\n    def copy(self) -&gt; PolyhedralTerm:\n\"\"\"\n        Generates copy of polyhedral term.\n\n        Returns:\n            Copy of term.\n        \"\"\"\n        return PolyhedralTerm(self.variables, self.constant)\n\n    def rename_variable(self, source_var: Var, target_var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n        Rename a variable in a term.\n\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n\n        Returns:\n            A term with `source_var` replaced by `target_var`.\n        \"\"\"\n        new_term = self.copy()\n        if source_var in self.vars:\n            if target_var not in self.vars:\n                new_term.variables[target_var] = 0\n            new_term.variables[target_var] += new_term.variables[source_var]\n            new_term = new_term.remove_variable(source_var)\n        return new_term\n\n    @property\n    def vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"\n        Variables appearing in term with a nonzero coefficient.\n\n        Example:\n            For the term $ax + by \\\\le c$ with variables $x$ and\n            $y$, this function returns the list $\\\\{x, y\\\\}$ if\n            $a$ and $b$ are nonzero.\n\n        Returns:\n            List of variables referenced in term.\n        \"\"\"\n        varlist = self.variables.keys()\n        return list(varlist)\n\n    def contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n        Tell whether term contains a given variable.\n\n        Args:\n            var_to_seek: The variable that we are seeking in the current term.\n\n        Returns:\n            `True` if the syntax of the term refers to the given variable;\n            `False` otherwise.\n        \"\"\"\n        return var_to_seek in self.vars\n\n    def get_coefficient(self, var: Var) -&gt; numeric:  # noqa: VNE002\n\"\"\"\n        Output the coefficient multiplying the given variable in the term.\n\n        Args:\n            var: The variable whose coefficient we are seeking.\n\n        Returns:\n            The coefficient corresponding to variable in the term.\n        \"\"\"\n        if self.contains_var(var):\n            return self.variables[var]\n        return 0\n\n    def get_polarity(self, var: Var, polarity: bool = True) -&gt; bool:  # noqa: VNE002\n\"\"\"\n        Check if variable matches given polarity\n\n        The polarity of a variable in a term is defined as the polarity of the\n        coefficient that multiplies it in a term, e.g., the variables $x$\n        and $y$ in the term $-2x + y \\\\le 3$ have negative and\n        positive polarities respectively.\n\n        Args:\n            var: The variable whose polarity in the term we are seeking.\n            polarity: The polarity that we are comparing against the variable's polarity.\n\n        Returns:\n            `True` if the variable's polarity matches `polarity` and\n            `False` otherwise. If the variable's coefficient in the term\n            is zero, return `True`.\n        \"\"\"\n        if polarity:\n            return self.variables[var] &gt;= 0\n        return self.variables[var] &lt;= 0\n\n    def get_sign(self, var: Var) -&gt; int:  # noqa: VNE002\n\"\"\"\n        Get the sign of the variable in term.\n\n        The sign of a variable in a term is defined as the sign of the\n        coefficient that multiplies it in a term, e.g., the variables $x$\n        and $y$ in the term $-2x + y \\\\le 3$ have $-1$ and\n        $+1$ polarities respectively. $0$ has $+1$ sign.\n\n        Args:\n            var: The variable whose polarity in the term we are seeking.\n\n        Returns:\n            The sign of the variable in the term.\n        \"\"\"\n        if self.get_polarity(var=var, polarity=True):\n            return 1\n        return -1\n\n    def get_matching_vars(self, variable_polarity: Dict[Var, bool]) -&gt; List[Var]:\n\"\"\"\n        Get list of variables whose polarities match the polarities requested.\n\n        Example:\n\n        ```\n            x = Var('x')\n            y = Var('y')\n            z = Var('z')\n            variables = {x:-2, y:3}\n            constant  = 4\n            term = PolyhedralTerm(variables, constant)\n            polarities = {y:True}\n            term.get_matching_vars(polarities)\n        ```\n\n        The last call returns `{y, z}` because the variable y matches the\n        requested polarity in the term, and the variable z has a zero\n        coefficient.\n\n        Args:\n            variable_polarity: A dictionary mapping Var instances to Boolean\n                values indicating the polarity of the given variable.\n\n        Returns:\n            If all variables in the term match the polarities specified in the\n            argument, the routine returns the matching variables.  Otherwise,\n            it returns an empty list.\n        \"\"\"\n        variable_list = []\n        for var in variable_polarity.keys():  # noqa: VNE002\n            if self.contains_var(var):\n                if (self.get_polarity(var=var, polarity=True) == variable_polarity[var]) or (  # noqa: WPS337\n                    self.get_coefficient(var) == 0\n                ):\n                    variable_list.append(var)\n                else:\n                    variable_list = []\n                    break\n        return variable_list\n\n    def remove_variable(self, var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n        Eliminates a variable from a term.\n\n        Args:\n            var: variable to be eliminated.\n\n        Returns:\n            A new term with the variable eliminated.\n        \"\"\"\n        if self.contains_var(var):\n            that = self.copy()\n            that.variables.pop(var)\n            return that\n        return self.copy()\n\n    def multiply(self, factor: numeric) -&gt; PolyhedralTerm:\n\"\"\"Multiplies a term by a constant factor.\n\n        For example, multiplying the term $2x + 3y \\\\le 4$ by the factor 2\n        yields $4x + 6y \\\\le 8$.\n\n        Args:\n            factor: element by which the term is multiplied.\n\n        Returns:\n            A new term which is the result of the given term multiplied by\n            `factor`.\n        \"\"\"\n        variables = {key: factor * val for key, val in self.variables.items()}\n        return PolyhedralTerm(variables, factor * self.constant)\n\n    def substitute_variable(self, var: Var, subst_with_term: PolyhedralTerm) -&gt; PolyhedralTerm:  # noqa: VNE002\n\"\"\"\n        Substitutes a specified variable in a term with a given term.\n\n        Example:\n            In the term $2x - y \\\\le 6$, substituting y by the term\n            $x + z \\\\le 5$ yields $x - z \\\\le 1$. Observe that the\n            substituting term is understood as an equality.\n\n        Args:\n            var: The term variable to be substituted.\n            subst_with_term: The term used to replace var.\n\n        Returns:\n            A new term in which the variable is substituted with the given term\n            understood as an equality.\n        \"\"\"\n        if self.contains_var(var):\n            term = subst_with_term.multiply(self.get_coefficient(var))\n            logging.debug(\"Term is %s\", term)\n            that = self.remove_variable(var)\n            logging.debug(that)\n            return that + term\n        return self.copy()\n\n    def isolate_variable(self, var_to_isolate: Var) -&gt; PolyhedralTerm:\n\"\"\"\n        Isolate a variable in a term.\n\n        Example:\n            In the term $-2x + y \\\\le 6$ understood as equality, isolating the\n            variable $x$ yields $x = 0.5 y - 3$, which in PolyhedralTerm\n            notation we express as $0.5 y &lt;= -3$.\n\n        Args:\n            var_to_isolate: The variable to be isolated.\n\n        Returns:\n            A new term which corresponds to the isolation of the indicated\n            variable.\n\n        Raises:\n            ValueError: the indicated variable is not contained in the term.\n        \"\"\"\n        if var_to_isolate not in self.vars:\n            raise ValueError(\"Variable %s is not a term variable\" % (var_to_isolate))\n        return PolyhedralTerm(\n            variables={\n                k: -v / self.get_coefficient(var_to_isolate) for k, v in self.variables.items() if k != var_to_isolate\n            },\n            constant=self.constant / self.get_coefficient(var_to_isolate),\n        )\n\n    @staticmethod\n    def to_symbolic(term: PolyhedralTerm) -&gt; Any:\n\"\"\"\n        Translates the variable terms of a PolyhedralTerm into a sympy expression.\n\n        Example:\n            The code\n\n            ```\n                x = Var('x') y = Var('y') variables = {x:-2, y:3} constant  = 4\n                term = PolyhedralTerm(variables, constant) expression =\n                PolyhedralTerm.to_symbolic(term)\n            ```\n\n            yields the expression $-2x + 3y$.\n\n        Args:\n            term:\n                The term whose coefficients and variables are to be translated\n                to sympy's data structure.\n\n        Returns:\n            Sympy expression corresponding to PolyhedralTerm.\n        \"\"\"\n        ex = -term.constant\n        for var in term.vars:  # noqa: VNE002\n            sv = sympy.symbols(var.name)\n            ex += sv * term.get_coefficient(var)\n        return ex\n\n    @staticmethod\n    def to_term(expression: sympy.core.expr.Expr) -&gt; PolyhedralTerm:\n\"\"\"\n        Translates a sympy expression into a PolyhedralTerm.\n\n        Example:\n            The expression $2x + 3y - 1$ is translated into\n            `PolyhedralTerm(variables={x:2, y:3}, constant=1)`.\n\n        Args:\n            expression: The symbolic expression to be translated.\n\n        Returns:\n            PolyhedralTerm corresponding to sympy expression.\n        \"\"\"\n        expression_coefficients: dict = expression.as_coefficients_dict()\n        logging.debug(expression_coefficients)\n        keys = list(expression_coefficients.keys())\n        variable_dict = {}\n        constant = 0\n        for key in keys:\n            logging.debug(type(key))\n            if isinstance(key, (str, sympy.core.symbol.Symbol)):\n                var = Var(str(key))  # noqa: VNE002\n                variable_dict[var] = expression_coefficients[key]\n            else:\n                constant = constant - expression_coefficients[key] * key\n        return PolyhedralTerm(variable_dict, constant)\n\n    @staticmethod\n    def term_to_polytope(term: PolyhedralTerm, variable_list: List[Var]) -&gt; Tuple[List[numeric], numeric]:\n\"\"\"\n        Transform a term into a vector according to the given order.\n\n        Example:\n            The term $3x + 5y -2z \\\\le 7$ with `variable_list = [y,\n            x, w, z]` yields the tuple `[5, 3, 0, -2], 7`.\n\n        Args:\n            term: The term to be transformed.\n            variable_list:\n                A list of variables indicating the order of appearance of\n                variable coefficients.\n\n        Returns:\n            A tuple consisting of (i) the ordered list of coefficients and (ii)\n            the term's constant.\n        \"\"\"\n        coeffs = []\n        for var in variable_list:  # noqa: VNE002\n            coeffs.append(term.get_coefficient(var))\n        return coeffs, term.constant\n\n    @staticmethod\n    def polytope_to_term(poly: List[numeric], const: numeric, variables: List[Var]) -&gt; PolyhedralTerm:\n\"\"\"\n        Transform a list of coefficients and variables into a PolyhedralTerm.\n\n        Args:\n            poly: An ordered list of coefficients.\n            const: The term's coefficient.\n            variables: The variables corresponding to the list of coefficients.\n\n        Returns:\n            A PolyhedralTerm corresponding to the provided data.\n        \"\"\"\n        assert len(poly) == len(variables)\n        variable_dict = {}\n        for i, var in enumerate(variables):  # noqa: VNE002\n            variable_dict[var] = poly[i]\n        return PolyhedralTerm(variable_dict, const)\n\n    @staticmethod\n    def solve_for_variables(context: PolyhedralTermList, vars_to_elim: List[Var]) -&gt; dict:\n\"\"\"\n        Interpret termlist as equality and solve system of equations.\n\n        Args:\n            context:\n                The list of terms to be solved. Each term will be interpreted as\n                an equality.\n            vars_to_elim:\n                The list of variables whose solutions will be sought.\n\n        Assumptions: the number of equations matches the number of vars_to_elim\n        contained in the terms.\n\n        Returns:\n            A dictionary mapping variables to their solutions. The solutions are\n            expressed as PolyhedralTerm instances.\n        \"\"\"\n        logging.debug(\"GetVals: %s Vars: %s\", context, vars_to_elim)\n        vars_to_solve = list_intersection(context.vars, vars_to_elim)\n        assert len(context.terms) == len(vars_to_solve)\n        exprs = [PolyhedralTerm.to_symbolic(term) for term in context.terms]\n        logging.debug(\"Solving %s\", exprs)\n        vars_to_solve_symb = [sympy.symbols(var.name) for var in vars_to_solve]\n        sols = sympy.solve(exprs, *vars_to_solve_symb)\n        logging.debug(sols)\n        if len(sols) &gt; 0:\n            return {Var(str(key)): PolyhedralTerm.to_term(sols[key]) for key in sols.keys()}\n        return {}\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.vars","title":"<code>vars: List[Var]</code>  <code>property</code>","text":"<p>Variables appearing in term with a nonzero coefficient.</p> Example <p>For the term \\(ax + by \\le c\\) with variables \\(x\\) and \\(y\\), this function returns the list \\(\\{x, y\\}\\) if \\(a\\) and \\(b\\) are nonzero.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>List of variables referenced in term.</p>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.__init__","title":"<code>__init__(variables, constant)</code>","text":"<p>Constructor for PolyhedralTerm.</p> Usage <p>Polyhedral terms are initialized as follows:</p> <pre><code>    variables = {Var('x'):2, Var('y'):3}\n    constant = 3\n    term = PolyhedralTerm(variables, constant)\n</code></pre> <p><code>variables</code> is a dictionary whose keys are <code>Var</code> instances, and <code>constant</code> is a number. Thus, our example represents the expression \\(2x + 3y \\le 3\\).</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>Dict[Var, numeric]</code> <p>A dictionary mapping Var keys to numeric values.</p> required <code>constant</code> <code>numeric</code> <p>A numeric value on the right of the inequality.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Unsupported argument type.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def __init__(self, variables: Dict[Var, numeric], constant: numeric):\n\"\"\"\n    Constructor for PolyhedralTerm.\n\n    Usage:\n        Polyhedral terms are initialized as follows:\n\n        ```\n            variables = {Var('x'):2, Var('y'):3}\n            constant = 3\n            term = PolyhedralTerm(variables, constant)\n        ```\n\n        `variables` is a dictionary whose keys are `Var` instances,\n        and `constant` is a number. Thus, our example represents the\n        expression $2x + 3y \\\\le 3$.\n\n    Args:\n        variables: A dictionary mapping Var keys to numeric values.\n        constant: A numeric value on the right of the inequality.\n\n    Raises:\n        ValueError: Unsupported argument type.\n    \"\"\"\n    variable_dict = {}\n    for key, value in variables.items():\n        if value != 0:\n            if isinstance(key, str):\n                raise ValueError(\"Unsupported argument type\")\n            else:\n                variable_dict[key] = float(value)\n    self.variables = variable_dict\n    self.constant = float(constant)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.contains_var","title":"<code>contains_var(var_to_seek)</code>","text":"<p>Tell whether term contains a given variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_to_seek</code> <code>Var</code> <p>The variable that we are seeking in the current term.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the syntax of the term refers to the given variable;</p> <code>bool</code> <p><code>False</code> otherwise.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n    Tell whether term contains a given variable.\n\n    Args:\n        var_to_seek: The variable that we are seeking in the current term.\n\n    Returns:\n        `True` if the syntax of the term refers to the given variable;\n        `False` otherwise.\n    \"\"\"\n    return var_to_seek in self.vars\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.copy","title":"<code>copy()</code>","text":"<p>Generates copy of polyhedral term.</p> <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>Copy of term.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def copy(self) -&gt; PolyhedralTerm:\n\"\"\"\n    Generates copy of polyhedral term.\n\n    Returns:\n        Copy of term.\n    \"\"\"\n    return PolyhedralTerm(self.variables, self.constant)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_coefficient","title":"<code>get_coefficient(var)</code>","text":"<p>Output the coefficient multiplying the given variable in the term.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The variable whose coefficient we are seeking.</p> required <p>Returns:</p> Type Description <code>numeric</code> <p>The coefficient corresponding to variable in the term.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_coefficient(self, var: Var) -&gt; numeric:  # noqa: VNE002\n\"\"\"\n    Output the coefficient multiplying the given variable in the term.\n\n    Args:\n        var: The variable whose coefficient we are seeking.\n\n    Returns:\n        The coefficient corresponding to variable in the term.\n    \"\"\"\n    if self.contains_var(var):\n        return self.variables[var]\n    return 0\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_matching_vars","title":"<code>get_matching_vars(variable_polarity)</code>","text":"<p>Get list of variables whose polarities match the polarities requested.</p> <p>Example:</p> <pre><code>    x = Var('x')\n    y = Var('y')\n    z = Var('z')\n    variables = {x:-2, y:3}\n    constant  = 4\n    term = PolyhedralTerm(variables, constant)\n    polarities = {y:True}\n    term.get_matching_vars(polarities)\n</code></pre> <p>The last call returns <code>{y, z}</code> because the variable y matches the requested polarity in the term, and the variable z has a zero coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>variable_polarity</code> <code>Dict[Var, bool]</code> <p>A dictionary mapping Var instances to Boolean values indicating the polarity of the given variable.</p> required <p>Returns:</p> Type Description <code>List[Var]</code> <p>If all variables in the term match the polarities specified in the</p> <code>List[Var]</code> <p>argument, the routine returns the matching variables.  Otherwise,</p> <code>List[Var]</code> <p>it returns an empty list.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_matching_vars(self, variable_polarity: Dict[Var, bool]) -&gt; List[Var]:\n\"\"\"\n    Get list of variables whose polarities match the polarities requested.\n\n    Example:\n\n    ```\n        x = Var('x')\n        y = Var('y')\n        z = Var('z')\n        variables = {x:-2, y:3}\n        constant  = 4\n        term = PolyhedralTerm(variables, constant)\n        polarities = {y:True}\n        term.get_matching_vars(polarities)\n    ```\n\n    The last call returns `{y, z}` because the variable y matches the\n    requested polarity in the term, and the variable z has a zero\n    coefficient.\n\n    Args:\n        variable_polarity: A dictionary mapping Var instances to Boolean\n            values indicating the polarity of the given variable.\n\n    Returns:\n        If all variables in the term match the polarities specified in the\n        argument, the routine returns the matching variables.  Otherwise,\n        it returns an empty list.\n    \"\"\"\n    variable_list = []\n    for var in variable_polarity.keys():  # noqa: VNE002\n        if self.contains_var(var):\n            if (self.get_polarity(var=var, polarity=True) == variable_polarity[var]) or (  # noqa: WPS337\n                self.get_coefficient(var) == 0\n            ):\n                variable_list.append(var)\n            else:\n                variable_list = []\n                break\n    return variable_list\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_polarity","title":"<code>get_polarity(var, polarity=True)</code>","text":"<p>Check if variable matches given polarity</p> <p>The polarity of a variable in a term is defined as the polarity of the coefficient that multiplies it in a term, e.g., the variables \\(x\\) and \\(y\\) in the term \\(-2x + y \\le 3\\) have negative and positive polarities respectively.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The variable whose polarity in the term we are seeking.</p> required <code>polarity</code> <code>bool</code> <p>The polarity that we are comparing against the variable's polarity.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the variable's polarity matches <code>polarity</code> and</p> <code>bool</code> <p><code>False</code> otherwise. If the variable's coefficient in the term</p> <code>bool</code> <p>is zero, return <code>True</code>.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_polarity(self, var: Var, polarity: bool = True) -&gt; bool:  # noqa: VNE002\n\"\"\"\n    Check if variable matches given polarity\n\n    The polarity of a variable in a term is defined as the polarity of the\n    coefficient that multiplies it in a term, e.g., the variables $x$\n    and $y$ in the term $-2x + y \\\\le 3$ have negative and\n    positive polarities respectively.\n\n    Args:\n        var: The variable whose polarity in the term we are seeking.\n        polarity: The polarity that we are comparing against the variable's polarity.\n\n    Returns:\n        `True` if the variable's polarity matches `polarity` and\n        `False` otherwise. If the variable's coefficient in the term\n        is zero, return `True`.\n    \"\"\"\n    if polarity:\n        return self.variables[var] &gt;= 0\n    return self.variables[var] &lt;= 0\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_sign","title":"<code>get_sign(var)</code>","text":"<p>Get the sign of the variable in term.</p> <p>The sign of a variable in a term is defined as the sign of the coefficient that multiplies it in a term, e.g., the variables \\(x\\) and \\(y\\) in the term \\(-2x + y \\le 3\\) have \\(-1\\) and \\(+1\\) polarities respectively. \\(0\\) has \\(+1\\) sign.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The variable whose polarity in the term we are seeking.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sign of the variable in the term.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_sign(self, var: Var) -&gt; int:  # noqa: VNE002\n\"\"\"\n    Get the sign of the variable in term.\n\n    The sign of a variable in a term is defined as the sign of the\n    coefficient that multiplies it in a term, e.g., the variables $x$\n    and $y$ in the term $-2x + y \\\\le 3$ have $-1$ and\n    $+1$ polarities respectively. $0$ has $+1$ sign.\n\n    Args:\n        var: The variable whose polarity in the term we are seeking.\n\n    Returns:\n        The sign of the variable in the term.\n    \"\"\"\n    if self.get_polarity(var=var, polarity=True):\n        return 1\n    return -1\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.isolate_variable","title":"<code>isolate_variable(var_to_isolate)</code>","text":"<p>Isolate a variable in a term.</p> Example <p>In the term \\(-2x + y \\le 6\\) understood as equality, isolating the variable \\(x\\) yields \\(x = 0.5 y - 3\\), which in PolyhedralTerm notation we express as \\(0.5 y &lt;= -3\\).</p> <p>Parameters:</p> Name Type Description Default <code>var_to_isolate</code> <code>Var</code> <p>The variable to be isolated.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term which corresponds to the isolation of the indicated</p> <code>PolyhedralTerm</code> <p>variable.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>the indicated variable is not contained in the term.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def isolate_variable(self, var_to_isolate: Var) -&gt; PolyhedralTerm:\n\"\"\"\n    Isolate a variable in a term.\n\n    Example:\n        In the term $-2x + y \\\\le 6$ understood as equality, isolating the\n        variable $x$ yields $x = 0.5 y - 3$, which in PolyhedralTerm\n        notation we express as $0.5 y &lt;= -3$.\n\n    Args:\n        var_to_isolate: The variable to be isolated.\n\n    Returns:\n        A new term which corresponds to the isolation of the indicated\n        variable.\n\n    Raises:\n        ValueError: the indicated variable is not contained in the term.\n    \"\"\"\n    if var_to_isolate not in self.vars:\n        raise ValueError(\"Variable %s is not a term variable\" % (var_to_isolate))\n    return PolyhedralTerm(\n        variables={\n            k: -v / self.get_coefficient(var_to_isolate) for k, v in self.variables.items() if k != var_to_isolate\n        },\n        constant=self.constant / self.get_coefficient(var_to_isolate),\n    )\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.multiply","title":"<code>multiply(factor)</code>","text":"<p>Multiplies a term by a constant factor.</p> <p>For example, multiplying the term \\(2x + 3y \\le 4\\) by the factor 2 yields \\(4x + 6y \\le 8\\).</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>numeric</code> <p>element by which the term is multiplied.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term which is the result of the given term multiplied by</p> <code>PolyhedralTerm</code> <p><code>factor</code>.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def multiply(self, factor: numeric) -&gt; PolyhedralTerm:\n\"\"\"Multiplies a term by a constant factor.\n\n    For example, multiplying the term $2x + 3y \\\\le 4$ by the factor 2\n    yields $4x + 6y \\\\le 8$.\n\n    Args:\n        factor: element by which the term is multiplied.\n\n    Returns:\n        A new term which is the result of the given term multiplied by\n        `factor`.\n    \"\"\"\n    variables = {key: factor * val for key, val in self.variables.items()}\n    return PolyhedralTerm(variables, factor * self.constant)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.polytope_to_term","title":"<code>polytope_to_term(poly, const, variables)</code>  <code>staticmethod</code>","text":"<p>Transform a list of coefficients and variables into a PolyhedralTerm.</p> <p>Parameters:</p> Name Type Description Default <code>poly</code> <code>List[numeric]</code> <p>An ordered list of coefficients.</p> required <code>const</code> <code>numeric</code> <p>The term's coefficient.</p> required <code>variables</code> <code>List[Var]</code> <p>The variables corresponding to the list of coefficients.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A PolyhedralTerm corresponding to the provided data.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef polytope_to_term(poly: List[numeric], const: numeric, variables: List[Var]) -&gt; PolyhedralTerm:\n\"\"\"\n    Transform a list of coefficients and variables into a PolyhedralTerm.\n\n    Args:\n        poly: An ordered list of coefficients.\n        const: The term's coefficient.\n        variables: The variables corresponding to the list of coefficients.\n\n    Returns:\n        A PolyhedralTerm corresponding to the provided data.\n    \"\"\"\n    assert len(poly) == len(variables)\n    variable_dict = {}\n    for i, var in enumerate(variables):  # noqa: VNE002\n        variable_dict[var] = poly[i]\n    return PolyhedralTerm(variable_dict, const)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.remove_variable","title":"<code>remove_variable(var)</code>","text":"<p>Eliminates a variable from a term.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>variable to be eliminated.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term with the variable eliminated.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def remove_variable(self, var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n    Eliminates a variable from a term.\n\n    Args:\n        var: variable to be eliminated.\n\n    Returns:\n        A new term with the variable eliminated.\n    \"\"\"\n    if self.contains_var(var):\n        that = self.copy()\n        that.variables.pop(var)\n        return that\n    return self.copy()\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a term.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A term with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def rename_variable(self, source_var: Var, target_var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n    Rename a variable in a term.\n\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n\n    Returns:\n        A term with `source_var` replaced by `target_var`.\n    \"\"\"\n    new_term = self.copy()\n    if source_var in self.vars:\n        if target_var not in self.vars:\n            new_term.variables[target_var] = 0\n        new_term.variables[target_var] += new_term.variables[source_var]\n        new_term = new_term.remove_variable(source_var)\n    return new_term\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.solve_for_variables","title":"<code>solve_for_variables(context, vars_to_elim)</code>  <code>staticmethod</code>","text":"<p>Interpret termlist as equality and solve system of equations.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PolyhedralTermList</code> <p>The list of terms to be solved. Each term will be interpreted as an equality.</p> required <code>vars_to_elim</code> <code>List[Var]</code> <p>The list of variables whose solutions will be sought.</p> required <p>Assumptions: the number of equations matches the number of vars_to_elim contained in the terms.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary mapping variables to their solutions. The solutions are</p> <code>dict</code> <p>expressed as PolyhedralTerm instances.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef solve_for_variables(context: PolyhedralTermList, vars_to_elim: List[Var]) -&gt; dict:\n\"\"\"\n    Interpret termlist as equality and solve system of equations.\n\n    Args:\n        context:\n            The list of terms to be solved. Each term will be interpreted as\n            an equality.\n        vars_to_elim:\n            The list of variables whose solutions will be sought.\n\n    Assumptions: the number of equations matches the number of vars_to_elim\n    contained in the terms.\n\n    Returns:\n        A dictionary mapping variables to their solutions. The solutions are\n        expressed as PolyhedralTerm instances.\n    \"\"\"\n    logging.debug(\"GetVals: %s Vars: %s\", context, vars_to_elim)\n    vars_to_solve = list_intersection(context.vars, vars_to_elim)\n    assert len(context.terms) == len(vars_to_solve)\n    exprs = [PolyhedralTerm.to_symbolic(term) for term in context.terms]\n    logging.debug(\"Solving %s\", exprs)\n    vars_to_solve_symb = [sympy.symbols(var.name) for var in vars_to_solve]\n    sols = sympy.solve(exprs, *vars_to_solve_symb)\n    logging.debug(sols)\n    if len(sols) &gt; 0:\n        return {Var(str(key)): PolyhedralTerm.to_term(sols[key]) for key in sols.keys()}\n    return {}\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.substitute_variable","title":"<code>substitute_variable(var, subst_with_term)</code>","text":"<p>Substitutes a specified variable in a term with a given term.</p> Example <p>In the term \\(2x - y \\le 6\\), substituting y by the term \\(x + z \\le 5\\) yields \\(x - z \\le 1\\). Observe that the substituting term is understood as an equality.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The term variable to be substituted.</p> required <code>subst_with_term</code> <code>PolyhedralTerm</code> <p>The term used to replace var.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term in which the variable is substituted with the given term</p> <code>PolyhedralTerm</code> <p>understood as an equality.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def substitute_variable(self, var: Var, subst_with_term: PolyhedralTerm) -&gt; PolyhedralTerm:  # noqa: VNE002\n\"\"\"\n    Substitutes a specified variable in a term with a given term.\n\n    Example:\n        In the term $2x - y \\\\le 6$, substituting y by the term\n        $x + z \\\\le 5$ yields $x - z \\\\le 1$. Observe that the\n        substituting term is understood as an equality.\n\n    Args:\n        var: The term variable to be substituted.\n        subst_with_term: The term used to replace var.\n\n    Returns:\n        A new term in which the variable is substituted with the given term\n        understood as an equality.\n    \"\"\"\n    if self.contains_var(var):\n        term = subst_with_term.multiply(self.get_coefficient(var))\n        logging.debug(\"Term is %s\", term)\n        that = self.remove_variable(var)\n        logging.debug(that)\n        return that + term\n    return self.copy()\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.term_to_polytope","title":"<code>term_to_polytope(term, variable_list)</code>  <code>staticmethod</code>","text":"<p>Transform a term into a vector according to the given order.</p> Example <p>The term \\(3x + 5y -2z \\le 7\\) with <code>variable_list = [y, x, w, z]</code> yields the tuple <code>[5, 3, 0, -2], 7</code>.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>PolyhedralTerm</code> <p>The term to be transformed.</p> required <code>variable_list</code> <code>List[Var]</code> <p>A list of variables indicating the order of appearance of variable coefficients.</p> required <p>Returns:</p> Type Description <code>List[numeric]</code> <p>A tuple consisting of (i) the ordered list of coefficients and (ii)</p> <code>numeric</code> <p>the term's constant.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef term_to_polytope(term: PolyhedralTerm, variable_list: List[Var]) -&gt; Tuple[List[numeric], numeric]:\n\"\"\"\n    Transform a term into a vector according to the given order.\n\n    Example:\n        The term $3x + 5y -2z \\\\le 7$ with `variable_list = [y,\n        x, w, z]` yields the tuple `[5, 3, 0, -2], 7`.\n\n    Args:\n        term: The term to be transformed.\n        variable_list:\n            A list of variables indicating the order of appearance of\n            variable coefficients.\n\n    Returns:\n        A tuple consisting of (i) the ordered list of coefficients and (ii)\n        the term's constant.\n    \"\"\"\n    coeffs = []\n    for var in variable_list:  # noqa: VNE002\n        coeffs.append(term.get_coefficient(var))\n    return coeffs, term.constant\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.to_symbolic","title":"<code>to_symbolic(term)</code>  <code>staticmethod</code>","text":"<p>Translates the variable terms of a PolyhedralTerm into a sympy expression.</p> Example <p>The code</p> <pre><code>    x = Var('x') y = Var('y') variables = {x:-2, y:3} constant  = 4\n    term = PolyhedralTerm(variables, constant) expression =\n    PolyhedralTerm.to_symbolic(term)\n</code></pre> <p>yields the expression \\(-2x + 3y\\).</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>PolyhedralTerm</code> <p>The term whose coefficients and variables are to be translated to sympy's data structure.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Sympy expression corresponding to PolyhedralTerm.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef to_symbolic(term: PolyhedralTerm) -&gt; Any:\n\"\"\"\n    Translates the variable terms of a PolyhedralTerm into a sympy expression.\n\n    Example:\n        The code\n\n        ```\n            x = Var('x') y = Var('y') variables = {x:-2, y:3} constant  = 4\n            term = PolyhedralTerm(variables, constant) expression =\n            PolyhedralTerm.to_symbolic(term)\n        ```\n\n        yields the expression $-2x + 3y$.\n\n    Args:\n        term:\n            The term whose coefficients and variables are to be translated\n            to sympy's data structure.\n\n    Returns:\n        Sympy expression corresponding to PolyhedralTerm.\n    \"\"\"\n    ex = -term.constant\n    for var in term.vars:  # noqa: VNE002\n        sv = sympy.symbols(var.name)\n        ex += sv * term.get_coefficient(var)\n    return ex\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.to_term","title":"<code>to_term(expression)</code>  <code>staticmethod</code>","text":"<p>Translates a sympy expression into a PolyhedralTerm.</p> Example <p>The expression \\(2x + 3y - 1\\) is translated into <code>PolyhedralTerm(variables={x:2, y:3}, constant=1)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>sympy.core.expr.Expr</code> <p>The symbolic expression to be translated.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>PolyhedralTerm corresponding to sympy expression.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef to_term(expression: sympy.core.expr.Expr) -&gt; PolyhedralTerm:\n\"\"\"\n    Translates a sympy expression into a PolyhedralTerm.\n\n    Example:\n        The expression $2x + 3y - 1$ is translated into\n        `PolyhedralTerm(variables={x:2, y:3}, constant=1)`.\n\n    Args:\n        expression: The symbolic expression to be translated.\n\n    Returns:\n        PolyhedralTerm corresponding to sympy expression.\n    \"\"\"\n    expression_coefficients: dict = expression.as_coefficients_dict()\n    logging.debug(expression_coefficients)\n    keys = list(expression_coefficients.keys())\n    variable_dict = {}\n    constant = 0\n    for key in keys:\n        logging.debug(type(key))\n        if isinstance(key, (str, sympy.core.symbol.Symbol)):\n            var = Var(str(key))  # noqa: VNE002\n            variable_dict[var] = expression_coefficients[key]\n        else:\n            constant = constant - expression_coefficients[key] * key\n    return PolyhedralTerm(variable_dict, constant)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList","title":"<code>PolyhedralTermList</code>","text":"<p>         Bases: <code>TermList</code></p> <p>A TermList of PolyhedralTerm instances.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>class PolyhedralTermList(TermList):  # noqa: WPS338\n\"\"\"A TermList of PolyhedralTerm instances.\"\"\"\n\n    def __init__(self, terms: Optional[List[PolyhedralTerm]] = None):\n\"\"\"\n        Constructor for PolyhedralTermList.\n\n        Usage:\n            PolyhedralTermList objects are initialized as follows:\n\n            ```\n                term1 = PolyhedralTerm({Var('x'):2, Var('y'):3}, 3)\n                term2 = PolyhedralTerm({Var('x'):-1, Var('y'):2}, 4)\n                pt_list = [term1, term2]\n                termlist = PolyhedralTermList(pt_list)\n            ```\n\n            Our example represents the constraints $\\\\{2x + 3y \\\\le 3, -x + 2y \\\\le 4\\\\}$.\n\n        Args:\n            terms: A list of PolyhedralTerm objects.\n\n        Raises:\n            ValueError: incorrect argument type provided.\n        \"\"\"\n        if terms is None:\n            self.terms = []\n        elif all(isinstance(t, PolyhedralTerm) for t in terms):\n            self.terms = terms.copy()\n        else:\n            raise ValueError(\"PolyhedralTermList constructor argument must be a list of PolyhedralTerms.\")\n\n    def __str__(self) -&gt; str:\n        res = \"[\\n  \"\n        res += \"\\n  \".join(self.to_str_list())\n        res += \"\\n]\"\n        return res\n\n    def __hash__(self) -&gt; int:\n        return hash(tuple(self.terms))\n\n    def to_str_list(self) -&gt; List[str]:\n\"\"\"\n        Convert termlist into a list of strings.\n\n        Returns:\n            A list of strings corresponding to the terms of the termlist.\n        \"\"\"\n        str_list = []\n        ts = self.terms.copy()\n        while ts:\n            s, rest = serializer.polyhedral_term_list_to_strings(ts)\n            str_list.append(s)\n            ts = rest\n        return str_list\n\n    def evaluate(self, var_values: Dict[Var, numeric]) -&gt; PolyhedralTermList:  # noqa: WPS231\n\"\"\"\n        Replace variables in termlist with given values.\n\n        Args:\n            var_values:\n                The values that variables will take.\n\n        Returns:\n            A new PolyhedralTermList in which the variables have been\n            substituted with the values provided.\n\n        Raises:\n            ValueError: constraints are unsatisfiable under these valuation of variables.\n        \"\"\"\n        new_list = []\n        for term in self.terms:\n            new_term = term.copy()\n            for var, val in var_values.items():  # noqa: VNE002\n                new_term = new_term.substitute_variable(\n                    var=var, subst_with_term=PolyhedralTerm(variables={}, constant=-val)\n                )\n            # we may have eliminated all variables after substitution\n            if not new_term.vars:\n                if new_term.constant &lt; 0:\n                    raise ValueError(\"Term %s not satisfied\" % (term))\n                else:\n                    continue  # noqa: WPS503\n            new_list.append(new_term)\n        return PolyhedralTermList(new_list)\n\n    def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n        Tell whether TermList contains the given behavior.\n\n        Args:\n            behavior:\n                The behavior in question.\n\n        Returns:\n            True if the behavior satisfies the constraints; false otherwise.\n\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\n        excess_vars = list_diff(self.vars, list(behavior.keys()))\n        if excess_vars:\n            raise ValueError(\"The variables %s were not assigned values\" % (excess_vars))\n        retval = True\n        try:\n            self.evaluate(behavior)\n        except ValueError:\n            retval = False\n        return retval\n\n    def elim_vars_by_refining(self, context: PolyhedralTermList, vars_to_elim: list) -&gt; PolyhedralTermList:\n\"\"\"\n        Eliminate variables from PolyhedralTermList by refining it in context.\n\n        Example:\n            Suppose the current list of terms is $\\\\{x + y \\\\le 6\\\\}$, the\n            context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n            contain variable $y$. Then the current TermList could be\n            refined to $\\\\{x \\\\le 1\\\\}$ because $x \\\\le 1\n            \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x + y \\\\le 6$.\n\n        Args:\n            context:\n                The TermList providing the context for the refinement.\n            vars_to_elim:\n                Variables that should not appear in the resulting term.\n\n        Returns:\n            A list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, imply the terms contained in the\n            calling termlist.\n\n        Raises:\n            ValueError: Self has empty intersection with its context.\n        \"\"\"\n        logging.debug(\"Refining from terms: %s\", self)\n        logging.debug(\"Context: %s\", context)\n        logging.debug(\"Vars to elim: %s\", vars_to_elim)\n        try:\n            termlist = self.simplify(context)\n        except ValueError as e:\n            raise ValueError(\n                \"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n            ) from e\n        try:\n            return termlist._transform(context=context, vars_to_elim=vars_to_elim, refine=True)\n        except ValueError as e:\n            raise ValueError(\n                \"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n                + \"by refining terms \\n{}\\n\".format(self)\n                + \"in context \\n{}\\n\".format(context)\n                + \"was not possible\"\n            ) from e\n\n    def lacks_constraints(self) -&gt; bool:\n\"\"\"\n        Tell whether TermList is empty.\n\n        Returns:\n            True if empty. False otherwise.\n        \"\"\"\n        return len(self.terms) == 0\n\n    def elim_vars_by_relaxing(self, context: PolyhedralTermList, vars_to_elim: list) -&gt; PolyhedralTermList:\n\"\"\"\n        Eliminate variables from PolyhedralTermList by abstracting it in context.\n\n        Example:\n            Suppose the current list of terms is $\\\\{x - y \\\\le 6\\\\}$, the\n            context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n            contain variable $y$. Then the current TermList could be\n            relaxed to $\\\\{x \\\\le 11\\\\}$ because $x - y \\\\le 6\n            \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x \\\\le 11$.\n\n        Args:\n            context:\n                The TermList providing the context for the transformation.\n            vars_to_elim:\n                Variables that should not appear in the relaxed terms.\n\n        Returns:\n            A list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, are implied by the terms\n            contained in the calling termlist.\n\n        Raises:\n            ValueError: Constraints have empty intersection with context.\n        \"\"\"\n        logging.debug(\"Relaxing with context\")\n        logging.debug(\"Relaxing from terms %s\", self)\n        logging.debug(\"Context: %s\", context)\n        logging.debug(\"Vars to elim: %s\", vars_to_elim)\n        try:\n            termlist = self.simplify(context)\n        except ValueError as e:\n            raise ValueError(\n                \"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n            ) from e\n        try:\n            termlist = termlist._transform(context=context, vars_to_elim=vars_to_elim, refine=False)\n        except ValueError as e:\n            raise ValueError(\n                \"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n                + \"by relaxing terms \\n{}\\n\".format(self)\n                + \"in context \\n{}\\n\".format(context)\n                + \"was not possible\"\n            ) from e\n        # eliminate terms containing the variables to be eliminated\n        terms_to_elim = termlist.get_terms_with_vars(vars_to_elim)\n        termlist.terms = list_diff(termlist.terms, terms_to_elim.terms)\n        return termlist\n\n    def simplify(self, context: Optional[PolyhedralTermList] = None) -&gt; PolyhedralTermList:\n\"\"\"\n        Remove redundant terms in the PolyhedralTermList using the provided context.\n\n        Example:\n            Suppose the TermList is $\\\\{x - 2y \\\\le 5, x - y \\\\le 0\\\\}$ and\n            the context is $\\\\{x + y \\\\le 0\\\\}$. Then the TermList could be\n            simplified to $\\\\{x - y \\\\le 0\\\\}$.\n\n        Args:\n            context:\n                The TermList providing the context for the simplification.\n\n        Returns:\n            A new PolyhedralTermList with redundant terms removed using the provided context.\n\n        Raises:\n            ValueError: The intersection of self and context is empty.\n        \"\"\"\n        logging.debug(\"Starting simplification procedure\")\n        logging.debug(\"Simplifying terms: %s\", self)\n        logging.debug(\"Context: %s\", context)\n        if context:\n            new_self = self - context\n            result = PolyhedralTermList.termlist_to_polytope(new_self, context)\n        else:\n            result = PolyhedralTermList.termlist_to_polytope(self, PolyhedralTermList())\n\n        variables = result[0]\n        self_mat = result[1]\n        self_cons = result[2]\n        ctx_mat = result[3]\n        ctx_cons = result[4]\n        # logging.debug(\"Polytope is \\n%s\", self_mat)\n        try:\n            a_red, b_red = PolyhedralTermList.reduce_polytope(self_mat, self_cons, ctx_mat, ctx_cons)\n        except ValueError as e:\n            raise ValueError(\n                \"The constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n            ) from e\n        logging.debug(\"Reduction: \\n%s\", a_red)\n        simplified = PolyhedralTermList.polytope_to_termlist(a_red, b_red, variables)\n        logging.debug(\"Back to terms: \\n%s\", simplified)\n        return simplified\n\n    def refines(self, other: PolyhedralTermList) -&gt; bool:\n\"\"\"\n        Tells whether the argument is a larger specification.\n\n        Args:\n            other:\n                TermList against which we are comparing self.\n\n        Returns:\n            self &lt;= other\n        \"\"\"\n        logging.debug(\"Verifying refinement\")\n        logging.debug(\"LH term: %s\", self)\n        logging.debug(\"RH term: %s\", other)\n        if other.lacks_constraints():\n            return True\n        if self.lacks_constraints():\n            return False\n        variables, self_mat, self_cons, ctx_mat, ctx_cons = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\n            self, other\n        )\n        logging.debug(\"Polytope is \\n%s\", self_mat)\n        return PolyhedralTermList.verify_polytope_containment(self_mat, self_cons, ctx_mat, ctx_cons)\n\n    def is_empty(self) -&gt; bool:\n\"\"\"\n        Tell whether the argument has no satisfying assignments.\n\n        Returns:\n            True if constraints cannot be satisfied.\n        \"\"\"\n        _, self_mat, self_cons, _, _ = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\n            self, PolyhedralTermList([])\n        )\n        logging.debug(\"Polytope is \\n%s\", self_mat)\n        return PolyhedralTermList.is_polytope_empty(self_mat, self_cons)\n\n    def _transform(self, context: PolyhedralTermList, vars_to_elim: list, refine: bool) -&gt; PolyhedralTermList:\n        logging.debug(\"Transforming: %s\", self)\n        logging.debug(\"Context terms: %s\", context)\n        logging.debug(\"Variables to eliminate: %s\", vars_to_elim)\n        term_list = list(self.terms)\n        new_terms = self.copy()\n        for i, term in enumerate(term_list):\n            copy_new_terms = new_terms.copy()\n            copy_new_terms.terms.remove(term)\n            helpers = context | copy_new_terms\n            try:\n                new_term = PolyhedralTermList._transform_term(term, helpers, vars_to_elim, refine)\n            except ValueError:\n                new_term = term.copy()\n\n            new_terms.terms[i] = new_term.copy()\n\n        that = PolyhedralTermList(new_terms.terms)\n\n        # the last step needs to be a simplification\n        logging.debug(\"Ending transformation with simplification\")\n        return that.simplify(context)\n\n    def optimize(self, objective: Dict[Var, numeric], maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"\n        Optimizes a linear expression in the feasible region of the termlist.\n\n        Args:\n            objective:\n                The objective to optimize.\n            maximize:\n                If true, the routine maximizes; it minimizes otherwise.\n\n        Returns:\n            The optimal value of the objective. If the objective is unbounded, None is returned.\n\n        Raises:\n            ValueError: Constraints are likely unfeasible.\n        \"\"\"\n        obj = PolyhedralTermList([PolyhedralTerm(variables=objective, constant=0)])\n        _, self_mat, self_cons, obj_mat, _ = PolyhedralTermList.termlist_to_polytope(self, obj)  # noqa: WPS236\n        polarity = 1\n        if maximize:\n            polarity = -1\n        res = linprog(c=polarity * obj_mat[0], A_ub=self_mat, b_ub=self_cons, bounds=(None, None))\n        # Linprog's status values\n        # 0 : Optimization proceeding nominally.\n        # 1 : Iteration limit reached.\n        # 2 : Problem appears to be infeasible.\n        # 3 : Problem appears to be unbounded.\n        # 4 : Numerical difficulties encountered.\n        if res[\"status\"] == 3:\n            return None\n        elif res[\"status\"] == 0:\n            fun_val: float = res[\"fun\"]\n            return polarity * fun_val\n        raise ValueError(\"Constraints are unfeasible\")\n\n    @staticmethod\n    def termlist_to_polytope(\n        terms: PolyhedralTermList, context: PolyhedralTermList\n    ) -&gt; Tuple[List[Var], np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n\"\"\"\n        Converts a list of terms with its context into matrix-vector pairs.\n\n        Example:\n            Suppose the list of terms is $\\\\{x+y \\\\le 1, x - y \\\\le 4\\\\}$\n            and the context is $\\\\{x + 4w \\\\le 5\\\\}$. The routine extracts\n            all variables and generates an order for them, say, $[x, w,\n            y]$. Then the routine returns matrix-vector pairs for both the terms\n            TermList and the context. It returns $A = \\\\left(\n            \\\\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\\\\\\\ 1 &amp;0 &amp;-1\n            \\\\end{smallmatrix}\\\\right)$ and $b = \\\\left(\n            \\\\begin{smallmatrix} 1 \\\\\\\\ 4 \\\\end{smallmatrix}\\\\right)$ for the\n            current TermList and $A_{c} = \\\\left( \\\\begin{smallmatrix} 1 &amp;\n            4 &amp; 0 \\\\end{smallmatrix}\\\\right)$ and $b_c = \\\\left(\n            \\\\begin{smallmatrix} 5 \\\\end{smallmatrix}\\\\right)$ for the context.\n\n        Args:\n            terms:\n                list of terms to convert to matrix-vector form.\n            context:\n                Context terms to convert to matrix-vector form.\n\n        Returns:\n            A tuple `variables, A, b, a_h, b_h` consisting of the variable\n            order and the matrix-vector pairs for the terms and the context.\n        \"\"\"\n        variables = list(list_union(terms.vars, context.vars))\n        a = []\n        b = []\n        for term in terms.terms:\n            pol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\n            a.append(pol)\n            b.append(coeff)\n\n        a_h = []\n        b_h = []\n        for term in context.terms:\n            pol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\n            a_h.append(pol)\n            b_h.append(coeff)\n\n        if len(context.terms) == 0:\n            a_h_ret = np.array([[]])\n        else:\n            a_h_ret = np.array(a_h)\n        # logging.debug(\"a is \\n%s\", a)\n        return variables, np.array(a), np.array(b), a_h_ret, np.array(b_h)\n\n    @staticmethod\n    def polytope_to_termlist(matrix: np.ndarray, vector: np.ndarray, variables: List[Var]) -&gt; PolyhedralTermList:\n\"\"\"\n        Transforms a matrix-vector pair into a PolyhedralTermList.\n\n        Args:\n            matrix:\n                The matrix of the pair.\n            vector:\n                The vector of the pair.\n            variables:\n                A list indicating the variable which corresponds to each column\n                of the matrix.\n\n        Returns:\n            The PolyhedralTermList corresponding to the given data.\n        \"\"\"\n        term_list = []\n        # logging.debug(\"Poly is \" + str(polytope))\n        # logging.debug(\"matrix is %s\", matrix)\n        if len(matrix.shape) &gt; 1:\n            n, m = matrix.shape\n            assert m == len(variables)\n        else:\n            n = matrix.shape[0]\n            m = 0\n        for i in range(n):\n            row = list(matrix[i])\n            const = vector[i]\n            term = PolyhedralTerm.polytope_to_term(row, const, variables)\n            term_list.append(term)\n        return PolyhedralTermList(list(term_list))\n\n    @staticmethod\n    def reduce_polytope(  # noqa: WPS231\n        a: np.ndarray, b: np.ndarray, a_help: Optional[np.ndarray] = None, b_help: Optional[np.ndarray] = None\n    ) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"\n        Eliminate redundant constraints from a given polytope.\n\n        Args:\n            a:\n                Matrix of H-representation of polytope to reduce.\n            b:\n                Vector of H-representation of polytope to reduce.\n            a_help:\n                Matrix of H-representation of context polytope.\n            b_help:\n                Vector of H-representation of context polytope.\n\n        Raises:\n            ValueError: The intersection of given polytope with its context is empty.\n\n        Returns:\n            a_temp: Matrix of H-representation of reduced polytope.\n            b_temp: Vector of H-representation of reduced polytope.\n        \"\"\"\n        if not isinstance(a_help, np.ndarray):\n            a_help = np.array([[]])\n        if not isinstance(b_help, np.ndarray):\n            b_help = np.array([])\n        if len(a.shape) &gt; 1:\n            n, m = a.shape\n        else:\n            n = a.shape[0]\n            m = 0\n        n_h, m_h = a_help.shape\n        helper_present = n_h * m_h &gt; 0\n        assert n == len(b), \"n is {} and b is {}\".format(n, b)\n        if helper_present:\n            assert n_h == len(b_help)\n        else:\n            assert len(b_help) == 0\n        if helper_present and m &gt; 0:\n            assert m_h == m\n        if n == 0:\n            return a, b\n        if n == 1 and not helper_present:\n            return a, b\n\n        i = 0\n        a_temp = np.copy(a)\n        b_temp = np.copy(b)\n        while i &lt; n:\n            objective = a_temp[i, :] * -1\n            b_temp[i] += 1\n            if helper_present:\n                a_opt = np.concatenate((a_temp, a_help), axis=0)\n                b_opt = np.concatenate((b_temp, b_help))\n            else:\n                a_opt = a_temp\n                b_opt = b_temp\n            # Linprog's status values\n            # 0 : Optimization proceeding nominally.\n            # 1 : Iteration limit reached.\n            # 2 : Problem appears to be infeasible.\n            # 3 : Problem appears to be unbounded.\n            # 4 : Numerical difficulties encountered.\n            res = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\n            b_temp[i] -= 1\n            if res[\"status\"] == 3 or (res[\"status\"] == 0 and -res[\"fun\"] &lt;= b_temp[i]):  # noqa: WPS309\n                logging.debug(\"Can remove\")\n                a_temp = np.delete(a_temp, i, 0)\n                b_temp = np.delete(b_temp, i)\n                n -= 1\n            else:\n                i += 1\n            if res[\"status\"] == 2:\n                raise ValueError(\"The constraints are unsatisfiable\")\n\n        return a_temp, b_temp\n\n    @staticmethod\n    def verify_polytope_containment(  # noqa: WPS231\n        a_l: Optional[np.ndarray] = None,\n        b_l: Optional[np.ndarray] = None,\n        a_r: Optional[np.ndarray] = None,\n        b_r: Optional[np.ndarray] = None,\n    ) -&gt; bool:\n\"\"\"\n        Tell whether a polytope is contained in another.\n\n        Args:\n            a_l:\n                Matrix of H-representation of polytope on LHS of inequality.\n            b_l:\n                Vector of H-representation of polytope on LHS of inequality.\n            a_r:\n                Matrix of H-representation of polytope on RHS of inequality.\n            b_r:\n                Vector of H-representation of polytope on RHS of inequality.\n\n        Returns:\n            True if left polytope is contained in right polytope. False otherwise.\n        \"\"\"\n        if not isinstance(a_l, np.ndarray):\n            a_l = np.array([[]])\n        if not isinstance(a_r, np.ndarray):\n            a_r = np.array([[]])\n        if not isinstance(b_l, np.ndarray):\n            b_l = np.array([])\n        if not isinstance(b_r, np.ndarray):\n            b_r = np.array([])\n        # If the LHS is empty, it is a refinement\n        if PolyhedralTermList.is_polytope_empty(a_l, b_l):\n            return True\n        # If the RHS is empty, but not the LHS, not a refinement\n        if PolyhedralTermList.is_polytope_empty(a_r, b_r):\n            return False\n        # If no side is empty, check whether the RHS terms are included in the\n        # LHS\n        n_l, m_l = a_l.shape\n        n_r, m_r = a_r.shape\n        assert m_l == m_r\n        assert n_l == len(b_l)\n        assert n_r == len(b_r)\n\n        is_refinement = True\n        for i in range(n_r):\n            constraint = a_r[[i], :]\n            objective = constraint * -1\n            b_temp = b_r[i] + 1\n            logging.debug(\"Optimization objective: \\n%s\", objective)\n            logging.debug(\"a_l is \\n%s\", a_l)\n            logging.debug(\"a_r is \\n%s\", a_r)\n            logging.debug(\"b_l is \\n%s\", b_l)\n            logging.debug(\"b_r is \\n%s\", b_r)\n\n            a_opt = np.concatenate((a_l, constraint), axis=0)\n            b_opt = np.concatenate((b_l, np.array([b_temp])))\n\n            res = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\n            b_temp -= 1\n            if res[\"status\"] == 2:\n                is_refinement = False\n                break\n            else:\n                if -res[\"fun\"] &lt;= b_temp:  # noqa: WPS309\n                    logging.debug(\"Redundant constraint\")\n                else:\n                    is_refinement = False\n                    break\n            logging.debug(\"Optimal value: %s\", -res[\"fun\"])\n            logging.debug(\"Results: %s\", res)\n        return is_refinement\n\n    @staticmethod\n    def is_polytope_empty(a: np.ndarray, b: np.ndarray) -&gt; bool:\n\"\"\"\n        Say whether a polytope is empty.\n\n        Args:\n            a:\n                Matrix of H-representation of polytope to verify.\n            b:\n                Vector of H-representation of polytope to verify.\n\n        Returns:\n            True if empty. False otherwise.\n\n        Raises:\n            ValueError: Numerical difficulties encountered.\n        \"\"\"\n        logging.debug(\"Verifying polytope emptiness: a is %s a.shape is %s, b is %s\", a, a.shape, b)\n        if len(a) == 0:\n            return False\n        n, m = a.shape\n        if n * m == 0:\n            return False\n        assert n == len(b)\n        objective = np.zeros((1, m))\n        res = linprog(c=objective, A_ub=a, b_ub=b, bounds=(None, None))  # ,options={'tol':0.000001})\n        # Linprog's status values\n        # 0 : Optimization proceeding nominally.\n        # 1 : Iteration limit reached.\n        # 2 : Problem appears to be infeasible.\n        # 3 : Problem appears to be unbounded.\n        # 4 : Numerical difficulties encountered.\n        if res[\"status\"] == 2:\n            return True\n        elif res[\"status\"] in {0, 3}:\n            return False\n        raise ValueError(\"Cannot decide emptiness\")\n\n    @staticmethod\n    def _get_kaykobad_context(  # noqa: WPS231\n        term: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n    ) -&gt; Tuple[List[PolyhedralTerm], List[Var]]:\n        forbidden_vars = list_intersection(vars_to_elim, term.vars)\n        other_forbibben_vars = list_diff(vars_to_elim, term.vars)\n        n = len(forbidden_vars)\n        matrix_row_terms = []  # type: List[PolyhedralTerm]\n        partial_sums = [float(0) for i in range(n)]\n        transform_coeff = -1\n        if refine:\n            transform_coeff = 1\n        matrix_contains_others = False\n        # We add a row to the matrix in each iteration\n        for i, i_var in enumerate(forbidden_vars):\n            row_found = False\n            logging.debug(\"Iterating for variable %s\", i_var)\n            for context_term in list_diff(context.terms, matrix_row_terms):\n                logging.debug(\"Analyzing context term %s\", context_term)\n                if context_term == term:\n                    continue\n                term_is_invalid = False\n                # make sure the term does not include other forbidden variables\n                for var in other_forbibben_vars:  # noqa: VNE002\n                    if context_term.get_coefficient(var) != 0:\n                        term_is_invalid = True\n                        logging.debug(\"Term contains other forbidden vars\")\n                        break\n                if term_is_invalid:\n                    continue\n                # 1. Verify Kaykobad pair: sign of nonzero matrix terms\n                for var in forbidden_vars:  # noqa: VNE002\n                    if context_term.get_coefficient(var) != 0:\n                        if transform_coeff * context_term.get_sign(var) != term.get_sign(var):\n                            term_is_invalid = True\n                            # logging.debug(\"Failed first matrix-vector verification\")\n                            break\n                # 2. Verify Kaykobad pair: matrix diagonal terms\n                if context_term.get_coefficient(i_var) == 0 or term_is_invalid:\n                    # logging.debug(\"Failed second matrix-vector verification\")\n                    continue\n                # 3. Verify Kaykobad pair: relation between matrix and vector\n                residuals = [float(0) for i in range(n)]\n                for j, j_var in enumerate(forbidden_vars):\n                    # logging.debug(\"Verifying third condition on variable %s\", j_var)\n                    if j != i:\n                        residuals[j] = (\n                            term.get_sign(j_var)\n                            * context_term.get_coefficient(j_var)\n                            * term.get_coefficient(i_var)\n                            / context_term.get_coefficient(i_var)\n                        )\n                    if np.abs(term.get_coefficient(j_var)) &lt;= partial_sums[j] + residuals[j]:\n                        # logging.debug(\"q coefficient: %s\", term.get_coefficient(j_var))\n                        # logging.debug(\"RHS: %s\", partial_sums[j] + residuals[j])\n                        term_is_invalid = True\n                        # logging.debug(\"Failed third matrix-vector verification\")\n                        break\n                if not term_is_invalid:\n                    matrix_contains_others = (\n                        matrix_contains_others or len(list_diff(context_term.vars, forbidden_vars)) &gt; 0\n                    )\n                    row_found = True\n                    for j in range(n):\n                        partial_sums[j] += residuals[j]\n                    matrix_row_terms.append(context_term)\n                    break\n            if not row_found:\n                raise ValueError(\"Could not find the {}th row of matrix\".format(i))\n        if (not matrix_contains_others) and len(list_diff(term.vars, vars_to_elim)) == 0:\n            raise ValueError(\"Found context will produce empty transformation\")\n        # logging.debug(\"Matrix row terms %s\", matrix_row_terms)\n        return matrix_row_terms, forbidden_vars\n\n    @staticmethod\n    def _tactic_1(\n        term: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n    ) -&gt; PolyhedralTerm:\n        logging.debug(\"********** Tactic 1\")\n        logging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\n        try:\n            matrix_row_terms, forbidden_vars = PolyhedralTermList._get_kaykobad_context(\n                term, context, vars_to_elim, refine\n            )\n        except ValueError:\n            logging.debug(\"Could not transform %s using Tactic 1\", term)\n            raise ValueError(\"Could not transform term {}\".format(term))\n        matrix_row_terms_tl = PolyhedralTermList(list(matrix_row_terms))\n        sols = PolyhedralTerm.solve_for_variables(matrix_row_terms_tl, list(forbidden_vars))\n        # logging.debug(\"Sols %s\", sols)\n\n        result = term.copy()\n        # logging.debug(\"Result is %s\", result)\n        for var in sols.keys():  # noqa: VNE002\n            result = result.substitute_variable(var, sols[var])\n        logging.debug(\"Term %s transformed to %s\", term, result)\n\n        return result\n\n    @staticmethod\n    def _tactic_2(  # noqa: WPS231\n        term: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n    ) -&gt; PolyhedralTerm:\n        logging.debug(\"************ Tactic 2\")\n        logging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\n        conflict_vars = list_intersection(vars_to_elim, term.vars)\n        new_context_list = []\n        # Extract from context the terms that only contain forbidden vars\n        for context_term in context.terms:\n            if not list_diff(context_term.vars, vars_to_elim):\n                if context_term != term:\n                    new_context_list.append(context_term.copy())\n        logging.debug(\"This is what we kept\")\n        for el in new_context_list:\n            logging.debug(el)\n        if not new_context_list:\n            raise ValueError(\"No term contains only irrelevant variables\")\n        if list_diff(conflict_vars, PolyhedralTermList(new_context_list).vars):\n            raise ValueError(\"Tactic 2 unsuccessful\")\n        # now optimize\n        retval = PolyhedralTermList.termlist_to_polytope(PolyhedralTermList(new_context_list), PolyhedralTermList([]))\n        variables = retval[0]\n        new_context_mat = retval[1]\n        new_context_cons = retval[2]\n        polarity = 1\n        if refine:\n            polarity = -1\n        objective = [polarity * term.get_coefficient(var) for var in variables]\n        logging.debug(new_context_mat)\n        logging.debug(new_context_cons)\n        logging.debug(objective)\n        res = linprog(c=objective, A_ub=new_context_mat, b_ub=new_context_cons, bounds=(None, None))\n        if res[\"status\"] == 3:\n            # unbounded\n            # return term.copy()\n            raise ValueError(\"Tactic 2 did not succeed\")\n        replacement = polarity * res[\"fun\"]\n        # replace the irrelevant variables with new findings in term\n        result = term.copy()\n        for var in vars_to_elim:  # noqa: VNE002\n            result = result.remove_variable(var)\n        result.constant -= replacement\n        # check vacuity\n        if not result.vars:\n            return term.copy()\n        return result\n\n    @staticmethod\n    def _tactic_3(\n        term: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n    ) -&gt; PolyhedralTerm:\n        logging.debug(\"************ Tactic 3\")\n        logging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\n        conflict_vars = list_intersection(vars_to_elim, term.vars)\n        conflict_coeff = {var: term.get_coefficient(var) for var in conflict_vars}\n        new_term = term.copy()\n        for var in conflict_vars:  # noqa: VNE002 variable name 'var' should be clarified\n            new_term = new_term.remove_variable(var)\n        new_term.variables[Var(\"_\")] = 1\n        # modify the context\n        subst_term_vars = {Var(\"_\"): 1.0 / conflict_coeff[conflict_vars[0]]}\n        for var in conflict_vars:  # noqa: VNE002 variable name 'var' should be clarified\n            if var != conflict_vars[0]:\n                subst_term_vars[var] = -conflict_coeff[var] / conflict_coeff[conflict_vars[0]]\n        subst_term = PolyhedralTerm(variables=subst_term_vars, constant=0)\n        new_context = PolyhedralTermList(\n            [el.copy().substitute_variable(conflict_vars[0], subst_term) for el in context.terms]\n        )\n        # now we use tactic 1\n        new_elims = list_diff(list_union(vars_to_elim, [Var(\"_\")]), [conflict_vars[0]])\n        try:\n            result = PolyhedralTermList._tactic_1(new_term, new_context, new_elims, refine)\n        except ValueError as e:  # noqa: WPS329 Found useless `except` case\n            raise e\n        logging.debug(\"************ Leaving Tactic 3\")\n        logging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\n        return result\n\n    @staticmethod\n    def _tactic_4(  # noqa: WPS231\n        term: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool, no_vars: List[Var]\n    ) -&gt; PolyhedralTerm:\n        logging.debug(\"************ Tactic 4\")\n        logging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\n        if not refine:\n            raise ValueError(\"Only refinement is supported\")\n        conflict_vars = list_intersection(vars_to_elim, term.vars)\n        if len(conflict_vars) &gt; 1:\n            raise ValueError(\"Tactic 4 unsuccessful\")\n        var_to_elim = conflict_vars[0]\n        goal_context: List[PolyhedralTerm] = []\n        useful_context: List[PolyhedralTerm] = []\n        polarity = -1\n        if refine:\n            polarity = 1\n        for context_term in context.terms:\n            if list_intersection(context_term.vars, no_vars):\n                continue\n            coeff = context_term.get_coefficient(var_to_elim)\n            if coeff != 0 and polarity * coeff * term.get_coefficient(var_to_elim) &gt; 0:\n                temp_conflict_vars = list_intersection(context_term.vars, vars_to_elim)\n                if len(temp_conflict_vars) == 1:\n                    goal_context.append(context_term.copy())\n                if len(temp_conflict_vars) == 2:\n                    useful_context.append(context_term.copy())\n        if not useful_context and not goal_context:\n            raise ValueError(\"Tactic 4 unsuccessful\")\n        if goal_context:\n            return term.substitute_variable(var_to_elim, goal_context[0].isolate_variable(var_to_elim))\n        ############\n        for useful_term in useful_context:\n            new_context = context.copy()\n            new_context.terms.remove(useful_term)\n            new_term = useful_term.isolate_variable(var_to_elim)\n            new_no_vars = no_vars.copy()\n            new_no_vars.append(var_to_elim)\n            try:\n                return_term = PolyhedralTermList._tactic_4(new_term, new_context, vars_to_elim, refine, new_no_vars)\n            except ValueError:\n                continue\n            return term.substitute_variable(var_to_elim, return_term)\n        raise ValueError(\"Tactic 4 unsuccessful\")\n\n    @staticmethod\n    def _transform_term(\n        term: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n    ) -&gt; PolyhedralTerm:\n        if not list_intersection(term.vars, vars_to_elim):\n            return term\n\n        logging.debug(\"Transforming term: %s\", term)\n        logging.debug(\"Context: %s\", context)\n\n        try:\n            result = PolyhedralTermList._tactic_1(term, context, vars_to_elim, refine)\n        except ValueError:\n            try:  # noqa: WPS505\n                result = PolyhedralTermList._tactic_3(term, context, vars_to_elim, refine)\n            except ValueError:\n                try:  # noqa: WPS505 Found nested `try` block\n                    result = PolyhedralTermList._tactic_2(term, context, vars_to_elim, refine)\n                except ValueError:\n                    try:  # noqa: WPS505 Found nested `try` block\n                        result = PolyhedralTermList._tactic_4(term, context, vars_to_elim, refine, [])\n                    except ValueError:\n                        result = term.copy()\n        return result\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.__init__","title":"<code>__init__(terms=None)</code>","text":"<p>Constructor for PolyhedralTermList.</p> Usage <p>PolyhedralTermList objects are initialized as follows:</p> <pre><code>    term1 = PolyhedralTerm({Var('x'):2, Var('y'):3}, 3)\n    term2 = PolyhedralTerm({Var('x'):-1, Var('y'):2}, 4)\n    pt_list = [term1, term2]\n    termlist = PolyhedralTermList(pt_list)\n</code></pre> <p>Our example represents the constraints \\(\\{2x + 3y \\le 3, -x + 2y \\le 4\\}\\).</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>Optional[List[PolyhedralTerm]]</code> <p>A list of PolyhedralTerm objects.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>incorrect argument type provided.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def __init__(self, terms: Optional[List[PolyhedralTerm]] = None):\n\"\"\"\n    Constructor for PolyhedralTermList.\n\n    Usage:\n        PolyhedralTermList objects are initialized as follows:\n\n        ```\n            term1 = PolyhedralTerm({Var('x'):2, Var('y'):3}, 3)\n            term2 = PolyhedralTerm({Var('x'):-1, Var('y'):2}, 4)\n            pt_list = [term1, term2]\n            termlist = PolyhedralTermList(pt_list)\n        ```\n\n        Our example represents the constraints $\\\\{2x + 3y \\\\le 3, -x + 2y \\\\le 4\\\\}$.\n\n    Args:\n        terms: A list of PolyhedralTerm objects.\n\n    Raises:\n        ValueError: incorrect argument type provided.\n    \"\"\"\n    if terms is None:\n        self.terms = []\n    elif all(isinstance(t, PolyhedralTerm) for t in terms):\n        self.terms = terms.copy()\n    else:\n        raise ValueError(\"PolyhedralTermList constructor argument must be a list of PolyhedralTerms.\")\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.contains_behavior","title":"<code>contains_behavior(behavior)</code>","text":"<p>Tell whether TermList contains the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Dict[Var, numeric]</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraints; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n    Tell whether TermList contains the given behavior.\n\n    Args:\n        behavior:\n            The behavior in question.\n\n    Returns:\n        True if the behavior satisfies the constraints; false otherwise.\n\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\n    excess_vars = list_diff(self.vars, list(behavior.keys()))\n    if excess_vars:\n        raise ValueError(\"The variables %s were not assigned values\" % (excess_vars))\n    retval = True\n    try:\n        self.evaluate(behavior)\n    except ValueError:\n        retval = False\n    return retval\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.elim_vars_by_refining","title":"<code>elim_vars_by_refining(context, vars_to_elim)</code>","text":"<p>Eliminate variables from PolyhedralTermList by refining it in context.</p> Example <p>Suppose the current list of terms is \\(\\{x + y \\le 6\\}\\), the context is \\(\\{y \\le 5\\}\\), and the resulting terms should not contain variable \\(y\\). Then the current TermList could be refined to \\(\\{x \\le 1\\}\\) because \\(x \\le 1 \\;\\land\\; y \\le 5 \\Rightarrow x + y \\le 6\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PolyhedralTermList</code> <p>The TermList providing the context for the refinement.</p> required <code>vars_to_elim</code> <code>list</code> <p>Variables that should not appear in the resulting term.</p> required <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>A list of terms not containing any variables in <code>vars_to_elim</code></p> <code>PolyhedralTermList</code> <p>and which, in the context provided, imply the terms contained in the</p> <code>PolyhedralTermList</code> <p>calling termlist.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Self has empty intersection with its context.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def elim_vars_by_refining(self, context: PolyhedralTermList, vars_to_elim: list) -&gt; PolyhedralTermList:\n\"\"\"\n    Eliminate variables from PolyhedralTermList by refining it in context.\n\n    Example:\n        Suppose the current list of terms is $\\\\{x + y \\\\le 6\\\\}$, the\n        context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n        contain variable $y$. Then the current TermList could be\n        refined to $\\\\{x \\\\le 1\\\\}$ because $x \\\\le 1\n        \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x + y \\\\le 6$.\n\n    Args:\n        context:\n            The TermList providing the context for the refinement.\n        vars_to_elim:\n            Variables that should not appear in the resulting term.\n\n    Returns:\n        A list of terms not containing any variables in `vars_to_elim`\n        and which, in the context provided, imply the terms contained in the\n        calling termlist.\n\n    Raises:\n        ValueError: Self has empty intersection with its context.\n    \"\"\"\n    logging.debug(\"Refining from terms: %s\", self)\n    logging.debug(\"Context: %s\", context)\n    logging.debug(\"Vars to elim: %s\", vars_to_elim)\n    try:\n        termlist = self.simplify(context)\n    except ValueError as e:\n        raise ValueError(\n            \"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n        ) from e\n    try:\n        return termlist._transform(context=context, vars_to_elim=vars_to_elim, refine=True)\n    except ValueError as e:\n        raise ValueError(\n            \"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n            + \"by refining terms \\n{}\\n\".format(self)\n            + \"in context \\n{}\\n\".format(context)\n            + \"was not possible\"\n        ) from e\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.elim_vars_by_relaxing","title":"<code>elim_vars_by_relaxing(context, vars_to_elim)</code>","text":"<p>Eliminate variables from PolyhedralTermList by abstracting it in context.</p> Example <p>Suppose the current list of terms is \\(\\{x - y \\le 6\\}\\), the context is \\(\\{y \\le 5\\}\\), and the resulting terms should not contain variable \\(y\\). Then the current TermList could be relaxed to \\(\\{x \\le 11\\}\\) because \\(x - y \\le 6 \\;\\land\\; y \\le 5 \\Rightarrow x \\le 11\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PolyhedralTermList</code> <p>The TermList providing the context for the transformation.</p> required <code>vars_to_elim</code> <code>list</code> <p>Variables that should not appear in the relaxed terms.</p> required <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>A list of terms not containing any variables in <code>vars_to_elim</code></p> <code>PolyhedralTermList</code> <p>and which, in the context provided, are implied by the terms</p> <code>PolyhedralTermList</code> <p>contained in the calling termlist.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Constraints have empty intersection with context.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def elim_vars_by_relaxing(self, context: PolyhedralTermList, vars_to_elim: list) -&gt; PolyhedralTermList:\n\"\"\"\n    Eliminate variables from PolyhedralTermList by abstracting it in context.\n\n    Example:\n        Suppose the current list of terms is $\\\\{x - y \\\\le 6\\\\}$, the\n        context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n        contain variable $y$. Then the current TermList could be\n        relaxed to $\\\\{x \\\\le 11\\\\}$ because $x - y \\\\le 6\n        \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x \\\\le 11$.\n\n    Args:\n        context:\n            The TermList providing the context for the transformation.\n        vars_to_elim:\n            Variables that should not appear in the relaxed terms.\n\n    Returns:\n        A list of terms not containing any variables in `vars_to_elim`\n        and which, in the context provided, are implied by the terms\n        contained in the calling termlist.\n\n    Raises:\n        ValueError: Constraints have empty intersection with context.\n    \"\"\"\n    logging.debug(\"Relaxing with context\")\n    logging.debug(\"Relaxing from terms %s\", self)\n    logging.debug(\"Context: %s\", context)\n    logging.debug(\"Vars to elim: %s\", vars_to_elim)\n    try:\n        termlist = self.simplify(context)\n    except ValueError as e:\n        raise ValueError(\n            \"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n        ) from e\n    try:\n        termlist = termlist._transform(context=context, vars_to_elim=vars_to_elim, refine=False)\n    except ValueError as e:\n        raise ValueError(\n            \"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n            + \"by relaxing terms \\n{}\\n\".format(self)\n            + \"in context \\n{}\\n\".format(context)\n            + \"was not possible\"\n        ) from e\n    # eliminate terms containing the variables to be eliminated\n    terms_to_elim = termlist.get_terms_with_vars(vars_to_elim)\n    termlist.terms = list_diff(termlist.terms, terms_to_elim.terms)\n    return termlist\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.evaluate","title":"<code>evaluate(var_values)</code>","text":"<p>Replace variables in termlist with given values.</p> <p>Parameters:</p> Name Type Description Default <code>var_values</code> <code>Dict[Var, numeric]</code> <p>The values that variables will take.</p> required <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>A new PolyhedralTermList in which the variables have been</p> <code>PolyhedralTermList</code> <p>substituted with the values provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>constraints are unsatisfiable under these valuation of variables.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def evaluate(self, var_values: Dict[Var, numeric]) -&gt; PolyhedralTermList:  # noqa: WPS231\n\"\"\"\n    Replace variables in termlist with given values.\n\n    Args:\n        var_values:\n            The values that variables will take.\n\n    Returns:\n        A new PolyhedralTermList in which the variables have been\n        substituted with the values provided.\n\n    Raises:\n        ValueError: constraints are unsatisfiable under these valuation of variables.\n    \"\"\"\n    new_list = []\n    for term in self.terms:\n        new_term = term.copy()\n        for var, val in var_values.items():  # noqa: VNE002\n            new_term = new_term.substitute_variable(\n                var=var, subst_with_term=PolyhedralTerm(variables={}, constant=-val)\n            )\n        # we may have eliminated all variables after substitution\n        if not new_term.vars:\n            if new_term.constant &lt; 0:\n                raise ValueError(\"Term %s not satisfied\" % (term))\n            else:\n                continue  # noqa: WPS503\n        new_list.append(new_term)\n    return PolyhedralTermList(new_list)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.is_empty","title":"<code>is_empty()</code>","text":"<p>Tell whether the argument has no satisfying assignments.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if constraints cannot be satisfied.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def is_empty(self) -&gt; bool:\n\"\"\"\n    Tell whether the argument has no satisfying assignments.\n\n    Returns:\n        True if constraints cannot be satisfied.\n    \"\"\"\n    _, self_mat, self_cons, _, _ = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\n        self, PolyhedralTermList([])\n    )\n    logging.debug(\"Polytope is \\n%s\", self_mat)\n    return PolyhedralTermList.is_polytope_empty(self_mat, self_cons)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.is_polytope_empty","title":"<code>is_polytope_empty(a, b)</code>  <code>staticmethod</code>","text":"<p>Say whether a polytope is empty.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>np.ndarray</code> <p>Matrix of H-representation of polytope to verify.</p> required <code>b</code> <code>np.ndarray</code> <p>Vector of H-representation of polytope to verify.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if empty. False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Numerical difficulties encountered.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef is_polytope_empty(a: np.ndarray, b: np.ndarray) -&gt; bool:\n\"\"\"\n    Say whether a polytope is empty.\n\n    Args:\n        a:\n            Matrix of H-representation of polytope to verify.\n        b:\n            Vector of H-representation of polytope to verify.\n\n    Returns:\n        True if empty. False otherwise.\n\n    Raises:\n        ValueError: Numerical difficulties encountered.\n    \"\"\"\n    logging.debug(\"Verifying polytope emptiness: a is %s a.shape is %s, b is %s\", a, a.shape, b)\n    if len(a) == 0:\n        return False\n    n, m = a.shape\n    if n * m == 0:\n        return False\n    assert n == len(b)\n    objective = np.zeros((1, m))\n    res = linprog(c=objective, A_ub=a, b_ub=b, bounds=(None, None))  # ,options={'tol':0.000001})\n    # Linprog's status values\n    # 0 : Optimization proceeding nominally.\n    # 1 : Iteration limit reached.\n    # 2 : Problem appears to be infeasible.\n    # 3 : Problem appears to be unbounded.\n    # 4 : Numerical difficulties encountered.\n    if res[\"status\"] == 2:\n        return True\n    elif res[\"status\"] in {0, 3}:\n        return False\n    raise ValueError(\"Cannot decide emptiness\")\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.lacks_constraints","title":"<code>lacks_constraints()</code>","text":"<p>Tell whether TermList is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if empty. False otherwise.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def lacks_constraints(self) -&gt; bool:\n\"\"\"\n    Tell whether TermList is empty.\n\n    Returns:\n        True if empty. False otherwise.\n    \"\"\"\n    return len(self.terms) == 0\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.optimize","title":"<code>optimize(objective, maximize=True)</code>","text":"<p>Optimizes a linear expression in the feasible region of the termlist.</p> <p>Parameters:</p> Name Type Description Default <code>objective</code> <code>Dict[Var, numeric]</code> <p>The objective to optimize.</p> required <code>maximize</code> <code>bool</code> <p>If true, the routine maximizes; it minimizes otherwise.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[numeric]</code> <p>The optimal value of the objective. If the objective is unbounded, None is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Constraints are likely unfeasible.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def optimize(self, objective: Dict[Var, numeric], maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"\n    Optimizes a linear expression in the feasible region of the termlist.\n\n    Args:\n        objective:\n            The objective to optimize.\n        maximize:\n            If true, the routine maximizes; it minimizes otherwise.\n\n    Returns:\n        The optimal value of the objective. If the objective is unbounded, None is returned.\n\n    Raises:\n        ValueError: Constraints are likely unfeasible.\n    \"\"\"\n    obj = PolyhedralTermList([PolyhedralTerm(variables=objective, constant=0)])\n    _, self_mat, self_cons, obj_mat, _ = PolyhedralTermList.termlist_to_polytope(self, obj)  # noqa: WPS236\n    polarity = 1\n    if maximize:\n        polarity = -1\n    res = linprog(c=polarity * obj_mat[0], A_ub=self_mat, b_ub=self_cons, bounds=(None, None))\n    # Linprog's status values\n    # 0 : Optimization proceeding nominally.\n    # 1 : Iteration limit reached.\n    # 2 : Problem appears to be infeasible.\n    # 3 : Problem appears to be unbounded.\n    # 4 : Numerical difficulties encountered.\n    if res[\"status\"] == 3:\n        return None\n    elif res[\"status\"] == 0:\n        fun_val: float = res[\"fun\"]\n        return polarity * fun_val\n    raise ValueError(\"Constraints are unfeasible\")\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.polytope_to_termlist","title":"<code>polytope_to_termlist(matrix, vector, variables)</code>  <code>staticmethod</code>","text":"<p>Transforms a matrix-vector pair into a PolyhedralTermList.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>np.ndarray</code> <p>The matrix of the pair.</p> required <code>vector</code> <code>np.ndarray</code> <p>The vector of the pair.</p> required <code>variables</code> <code>List[Var]</code> <p>A list indicating the variable which corresponds to each column of the matrix.</p> required <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>The PolyhedralTermList corresponding to the given data.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef polytope_to_termlist(matrix: np.ndarray, vector: np.ndarray, variables: List[Var]) -&gt; PolyhedralTermList:\n\"\"\"\n    Transforms a matrix-vector pair into a PolyhedralTermList.\n\n    Args:\n        matrix:\n            The matrix of the pair.\n        vector:\n            The vector of the pair.\n        variables:\n            A list indicating the variable which corresponds to each column\n            of the matrix.\n\n    Returns:\n        The PolyhedralTermList corresponding to the given data.\n    \"\"\"\n    term_list = []\n    # logging.debug(\"Poly is \" + str(polytope))\n    # logging.debug(\"matrix is %s\", matrix)\n    if len(matrix.shape) &gt; 1:\n        n, m = matrix.shape\n        assert m == len(variables)\n    else:\n        n = matrix.shape[0]\n        m = 0\n    for i in range(n):\n        row = list(matrix[i])\n        const = vector[i]\n        term = PolyhedralTerm.polytope_to_term(row, const, variables)\n        term_list.append(term)\n    return PolyhedralTermList(list(term_list))\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.reduce_polytope","title":"<code>reduce_polytope(a, b, a_help=None, b_help=None)</code>  <code>staticmethod</code>","text":"<p>Eliminate redundant constraints from a given polytope.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>np.ndarray</code> <p>Matrix of H-representation of polytope to reduce.</p> required <code>b</code> <code>np.ndarray</code> <p>Vector of H-representation of polytope to reduce.</p> required <code>a_help</code> <code>Optional[np.ndarray]</code> <p>Matrix of H-representation of context polytope.</p> <code>None</code> <code>b_help</code> <code>Optional[np.ndarray]</code> <p>Vector of H-representation of context polytope.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>The intersection of given polytope with its context is empty.</p> <p>Returns:</p> Name Type Description <code>a_temp</code> <code>np.ndarray</code> <p>Matrix of H-representation of reduced polytope.</p> <code>b_temp</code> <code>np.ndarray</code> <p>Vector of H-representation of reduced polytope.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef reduce_polytope(  # noqa: WPS231\n    a: np.ndarray, b: np.ndarray, a_help: Optional[np.ndarray] = None, b_help: Optional[np.ndarray] = None\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"\n    Eliminate redundant constraints from a given polytope.\n\n    Args:\n        a:\n            Matrix of H-representation of polytope to reduce.\n        b:\n            Vector of H-representation of polytope to reduce.\n        a_help:\n            Matrix of H-representation of context polytope.\n        b_help:\n            Vector of H-representation of context polytope.\n\n    Raises:\n        ValueError: The intersection of given polytope with its context is empty.\n\n    Returns:\n        a_temp: Matrix of H-representation of reduced polytope.\n        b_temp: Vector of H-representation of reduced polytope.\n    \"\"\"\n    if not isinstance(a_help, np.ndarray):\n        a_help = np.array([[]])\n    if not isinstance(b_help, np.ndarray):\n        b_help = np.array([])\n    if len(a.shape) &gt; 1:\n        n, m = a.shape\n    else:\n        n = a.shape[0]\n        m = 0\n    n_h, m_h = a_help.shape\n    helper_present = n_h * m_h &gt; 0\n    assert n == len(b), \"n is {} and b is {}\".format(n, b)\n    if helper_present:\n        assert n_h == len(b_help)\n    else:\n        assert len(b_help) == 0\n    if helper_present and m &gt; 0:\n        assert m_h == m\n    if n == 0:\n        return a, b\n    if n == 1 and not helper_present:\n        return a, b\n\n    i = 0\n    a_temp = np.copy(a)\n    b_temp = np.copy(b)\n    while i &lt; n:\n        objective = a_temp[i, :] * -1\n        b_temp[i] += 1\n        if helper_present:\n            a_opt = np.concatenate((a_temp, a_help), axis=0)\n            b_opt = np.concatenate((b_temp, b_help))\n        else:\n            a_opt = a_temp\n            b_opt = b_temp\n        # Linprog's status values\n        # 0 : Optimization proceeding nominally.\n        # 1 : Iteration limit reached.\n        # 2 : Problem appears to be infeasible.\n        # 3 : Problem appears to be unbounded.\n        # 4 : Numerical difficulties encountered.\n        res = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\n        b_temp[i] -= 1\n        if res[\"status\"] == 3 or (res[\"status\"] == 0 and -res[\"fun\"] &lt;= b_temp[i]):  # noqa: WPS309\n            logging.debug(\"Can remove\")\n            a_temp = np.delete(a_temp, i, 0)\n            b_temp = np.delete(b_temp, i)\n            n -= 1\n        else:\n            i += 1\n        if res[\"status\"] == 2:\n            raise ValueError(\"The constraints are unsatisfiable\")\n\n    return a_temp, b_temp\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.refines","title":"<code>refines(other)</code>","text":"<p>Tells whether the argument is a larger specification.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralTermList</code> <p>TermList against which we are comparing self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>self &lt;= other</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def refines(self, other: PolyhedralTermList) -&gt; bool:\n\"\"\"\n    Tells whether the argument is a larger specification.\n\n    Args:\n        other:\n            TermList against which we are comparing self.\n\n    Returns:\n        self &lt;= other\n    \"\"\"\n    logging.debug(\"Verifying refinement\")\n    logging.debug(\"LH term: %s\", self)\n    logging.debug(\"RH term: %s\", other)\n    if other.lacks_constraints():\n        return True\n    if self.lacks_constraints():\n        return False\n    variables, self_mat, self_cons, ctx_mat, ctx_cons = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\n        self, other\n    )\n    logging.debug(\"Polytope is \\n%s\", self_mat)\n    return PolyhedralTermList.verify_polytope_containment(self_mat, self_cons, ctx_mat, ctx_cons)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.simplify","title":"<code>simplify(context=None)</code>","text":"<p>Remove redundant terms in the PolyhedralTermList using the provided context.</p> Example <p>Suppose the TermList is \\(\\{x - 2y \\le 5, x - y \\le 0\\}\\) and the context is \\(\\{x + y \\le 0\\}\\). Then the TermList could be simplified to \\(\\{x - y \\le 0\\}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Optional[PolyhedralTermList]</code> <p>The TermList providing the context for the simplification.</p> <code>None</code> <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>A new PolyhedralTermList with redundant terms removed using the provided context.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>The intersection of self and context is empty.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def simplify(self, context: Optional[PolyhedralTermList] = None) -&gt; PolyhedralTermList:\n\"\"\"\n    Remove redundant terms in the PolyhedralTermList using the provided context.\n\n    Example:\n        Suppose the TermList is $\\\\{x - 2y \\\\le 5, x - y \\\\le 0\\\\}$ and\n        the context is $\\\\{x + y \\\\le 0\\\\}$. Then the TermList could be\n        simplified to $\\\\{x - y \\\\le 0\\\\}$.\n\n    Args:\n        context:\n            The TermList providing the context for the simplification.\n\n    Returns:\n        A new PolyhedralTermList with redundant terms removed using the provided context.\n\n    Raises:\n        ValueError: The intersection of self and context is empty.\n    \"\"\"\n    logging.debug(\"Starting simplification procedure\")\n    logging.debug(\"Simplifying terms: %s\", self)\n    logging.debug(\"Context: %s\", context)\n    if context:\n        new_self = self - context\n        result = PolyhedralTermList.termlist_to_polytope(new_self, context)\n    else:\n        result = PolyhedralTermList.termlist_to_polytope(self, PolyhedralTermList())\n\n    variables = result[0]\n    self_mat = result[1]\n    self_cons = result[2]\n    ctx_mat = result[3]\n    ctx_cons = result[4]\n    # logging.debug(\"Polytope is \\n%s\", self_mat)\n    try:\n        a_red, b_red = PolyhedralTermList.reduce_polytope(self_mat, self_cons, ctx_mat, ctx_cons)\n    except ValueError as e:\n        raise ValueError(\n            \"The constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n        ) from e\n    logging.debug(\"Reduction: \\n%s\", a_red)\n    simplified = PolyhedralTermList.polytope_to_termlist(a_red, b_red, variables)\n    logging.debug(\"Back to terms: \\n%s\", simplified)\n    return simplified\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.termlist_to_polytope","title":"<code>termlist_to_polytope(terms, context)</code>  <code>staticmethod</code>","text":"<p>Converts a list of terms with its context into matrix-vector pairs.</p> Example <p>Suppose the list of terms is \\(\\{x+y \\le 1, x - y \\le 4\\}\\) and the context is \\(\\{x + 4w \\le 5\\}\\). The routine extracts all variables and generates an order for them, say, \\([x, w, y]\\). Then the routine returns matrix-vector pairs for both the terms TermList and the context. It returns \\(A = \\left( \\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\\\ 1 &amp;0 &amp;-1 \\end{smallmatrix}\\right)\\) and \\(b = \\left( \\begin{smallmatrix} 1 \\\\ 4 \\end{smallmatrix}\\right)\\) for the current TermList and \\(A_{c} = \\left( \\begin{smallmatrix} 1 &amp; 4 &amp; 0 \\end{smallmatrix}\\right)\\) and \\(b_c = \\left( \\begin{smallmatrix} 5 \\end{smallmatrix}\\right)\\) for the context.</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>PolyhedralTermList</code> <p>list of terms to convert to matrix-vector form.</p> required <code>context</code> <code>PolyhedralTermList</code> <p>Context terms to convert to matrix-vector form.</p> required <p>Returns:</p> Type Description <code>List[Var]</code> <p>A tuple <code>variables, A, b, a_h, b_h</code> consisting of the variable</p> <code>np.ndarray</code> <p>order and the matrix-vector pairs for the terms and the context.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef termlist_to_polytope(\n    terms: PolyhedralTermList, context: PolyhedralTermList\n) -&gt; Tuple[List[Var], np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n\"\"\"\n    Converts a list of terms with its context into matrix-vector pairs.\n\n    Example:\n        Suppose the list of terms is $\\\\{x+y \\\\le 1, x - y \\\\le 4\\\\}$\n        and the context is $\\\\{x + 4w \\\\le 5\\\\}$. The routine extracts\n        all variables and generates an order for them, say, $[x, w,\n        y]$. Then the routine returns matrix-vector pairs for both the terms\n        TermList and the context. It returns $A = \\\\left(\n        \\\\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\\\\\\\ 1 &amp;0 &amp;-1\n        \\\\end{smallmatrix}\\\\right)$ and $b = \\\\left(\n        \\\\begin{smallmatrix} 1 \\\\\\\\ 4 \\\\end{smallmatrix}\\\\right)$ for the\n        current TermList and $A_{c} = \\\\left( \\\\begin{smallmatrix} 1 &amp;\n        4 &amp; 0 \\\\end{smallmatrix}\\\\right)$ and $b_c = \\\\left(\n        \\\\begin{smallmatrix} 5 \\\\end{smallmatrix}\\\\right)$ for the context.\n\n    Args:\n        terms:\n            list of terms to convert to matrix-vector form.\n        context:\n            Context terms to convert to matrix-vector form.\n\n    Returns:\n        A tuple `variables, A, b, a_h, b_h` consisting of the variable\n        order and the matrix-vector pairs for the terms and the context.\n    \"\"\"\n    variables = list(list_union(terms.vars, context.vars))\n    a = []\n    b = []\n    for term in terms.terms:\n        pol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\n        a.append(pol)\n        b.append(coeff)\n\n    a_h = []\n    b_h = []\n    for term in context.terms:\n        pol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\n        a_h.append(pol)\n        b_h.append(coeff)\n\n    if len(context.terms) == 0:\n        a_h_ret = np.array([[]])\n    else:\n        a_h_ret = np.array(a_h)\n    # logging.debug(\"a is \\n%s\", a)\n    return variables, np.array(a), np.array(b), a_h_ret, np.array(b_h)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.to_str_list","title":"<code>to_str_list()</code>","text":"<p>Convert termlist into a list of strings.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings corresponding to the terms of the termlist.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def to_str_list(self) -&gt; List[str]:\n\"\"\"\n    Convert termlist into a list of strings.\n\n    Returns:\n        A list of strings corresponding to the terms of the termlist.\n    \"\"\"\n    str_list = []\n    ts = self.terms.copy()\n    while ts:\n        s, rest = serializer.polyhedral_term_list_to_strings(ts)\n        str_list.append(s)\n        ts = rest\n    return str_list\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.verify_polytope_containment","title":"<code>verify_polytope_containment(a_l=None, b_l=None, a_r=None, b_r=None)</code>  <code>staticmethod</code>","text":"<p>Tell whether a polytope is contained in another.</p> <p>Parameters:</p> Name Type Description Default <code>a_l</code> <code>Optional[np.ndarray]</code> <p>Matrix of H-representation of polytope on LHS of inequality.</p> <code>None</code> <code>b_l</code> <code>Optional[np.ndarray]</code> <p>Vector of H-representation of polytope on LHS of inequality.</p> <code>None</code> <code>a_r</code> <code>Optional[np.ndarray]</code> <p>Matrix of H-representation of polytope on RHS of inequality.</p> <code>None</code> <code>b_r</code> <code>Optional[np.ndarray]</code> <p>Vector of H-representation of polytope on RHS of inequality.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if left polytope is contained in right polytope. False otherwise.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef verify_polytope_containment(  # noqa: WPS231\n    a_l: Optional[np.ndarray] = None,\n    b_l: Optional[np.ndarray] = None,\n    a_r: Optional[np.ndarray] = None,\n    b_r: Optional[np.ndarray] = None,\n) -&gt; bool:\n\"\"\"\n    Tell whether a polytope is contained in another.\n\n    Args:\n        a_l:\n            Matrix of H-representation of polytope on LHS of inequality.\n        b_l:\n            Vector of H-representation of polytope on LHS of inequality.\n        a_r:\n            Matrix of H-representation of polytope on RHS of inequality.\n        b_r:\n            Vector of H-representation of polytope on RHS of inequality.\n\n    Returns:\n        True if left polytope is contained in right polytope. False otherwise.\n    \"\"\"\n    if not isinstance(a_l, np.ndarray):\n        a_l = np.array([[]])\n    if not isinstance(a_r, np.ndarray):\n        a_r = np.array([[]])\n    if not isinstance(b_l, np.ndarray):\n        b_l = np.array([])\n    if not isinstance(b_r, np.ndarray):\n        b_r = np.array([])\n    # If the LHS is empty, it is a refinement\n    if PolyhedralTermList.is_polytope_empty(a_l, b_l):\n        return True\n    # If the RHS is empty, but not the LHS, not a refinement\n    if PolyhedralTermList.is_polytope_empty(a_r, b_r):\n        return False\n    # If no side is empty, check whether the RHS terms are included in the\n    # LHS\n    n_l, m_l = a_l.shape\n    n_r, m_r = a_r.shape\n    assert m_l == m_r\n    assert n_l == len(b_l)\n    assert n_r == len(b_r)\n\n    is_refinement = True\n    for i in range(n_r):\n        constraint = a_r[[i], :]\n        objective = constraint * -1\n        b_temp = b_r[i] + 1\n        logging.debug(\"Optimization objective: \\n%s\", objective)\n        logging.debug(\"a_l is \\n%s\", a_l)\n        logging.debug(\"a_r is \\n%s\", a_r)\n        logging.debug(\"b_l is \\n%s\", b_l)\n        logging.debug(\"b_r is \\n%s\", b_r)\n\n        a_opt = np.concatenate((a_l, constraint), axis=0)\n        b_opt = np.concatenate((b_l, np.array([b_temp])))\n\n        res = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\n        b_temp -= 1\n        if res[\"status\"] == 2:\n            is_refinement = False\n            break\n        else:\n            if -res[\"fun\"] &lt;= b_temp:  # noqa: WPS309\n                logging.debug(\"Redundant constraint\")\n            else:\n                is_refinement = False\n                break\n        logging.debug(\"Optimal value: %s\", -res[\"fun\"])\n        logging.debug(\"Results: %s\", res)\n    return is_refinement\n</code></pre>"},{"location":"case_studies/","title":"Overview","text":""},{"location":"case_studies/#case-studies","title":"Case Studies","text":"<p>In the following sections we will present case studies that illustrate the use of Pacti for different applications.</p> <p>  Safety of autonomous vehicles  </p> <p> </p> <p>We present a case study to evaluate the perception system of an autonomous car using the quotient operator.</p> <p></p> <p>  Trajectory planning for multi-agent systems  </p> <p> </p> <p>A case study on multi-agent path finding (MAPF) where multiple agents need to reach their target location on a grid world according to a conflict-free strategy. We treat each time step as our viewpoint to find a solution that satisfies the agents' dynamics and collision constraints using the merge operator.</p> <p></p> <p>  Specification-based synthetic biology  </p> <p> </p> <p>A case study on modeling the specifications of a biological circuit and speed up the experimental design process by finding optimal components to use from a library of parts. In the case study, we first build a characterized library of parts as assume-guarantee contracts using existing experimental data from the literature.With the use of Pacti, we demonstrate how scientists may describe the desired top-level behavior as contracts and then computationally choose from a library of available parts to ensure that the components meet the top-level system specification. For the engineered bacteria case study, we find the specification of the sensors that meet the top-level criteria on fold-change of the circuit response. Finally, we also show how we can find the specifications of missing parts in a system. In synthetic biology, it is common to have parts in the system for which no characterization data is available. Using quotient operation on contracts, we can find the constraints that this missing part must satisfy to meet the desired top-level criteria.</p> <p></p> <p>  Signal processing pipelines in digital ICs  </p> <p> </p> <p>A case study on word length analysis and optimization for digital signal processing circuit design.</p> <p></p> <p>  Generating UAV topologies  </p> <p> </p> <p>We demonstrate the application of Pacti in modeling a context-sensitive grammar for generating three-dimensional topologies for Unmanned Aerial Vehicles (UAVs).</p> <p></p> <p>  Space Mission  </p> <p> </p> <p>A case study on modeling the specifications of autonomous tasks for a planning/scheduling onboard of a space mission system.</p> <p></p> <p>  Mars Entry Descent Landing  </p> <p> </p> <p>A case study on modeling a simplified timeline of the Mars 2020 Entry-Descent-Landing.</p> <p></p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#010-2022-10-04","title":"0.1.0 - 2022-10-04","text":"<p>Compare with first commit</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome and greatly appreciated. If you would like to address a bug or add a feature, please first open an issue. If we decide to move forward with the changes, please fork the repo and open a pull request.</p>"},{"location":"contributing/#installation","title":"Installation","text":"<p>Clone the repo and run</p> <pre><code>pdm install\n</code></pre> <p>Running </p><pre><code>make help\n</code></pre> shows all available tasks."},{"location":"contributing/#development","title":"Development","text":"<p>We use pdm to manage dependencies. Use <code>pdm add</code> to install new packages.</p> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>run <code>make check</code> to check everything (types, docs, quality, and dependencies)</li> <li>make sure that all tests pass and the source code coverage meets our criteria</li> </ol>"},{"location":"contributing/#continuous-integration-and-development","title":"Continuous Integration and Development","text":"<p>Pacti has continuous integration and development setup with Github Actions. Some workflows are automatically run while others are manual. Instructions for all developers:</p> <ol> <li>If you are in the process of developing a feature/fixing a bug in your own development branch: Make sure that the Pacti Development workflow passes. This will automatically be run with every commit, so you should be getting notifications of what Pacti functionality failed (if any).</li> <li>If you are contributing a development feature to any branch (that is, your development has finished): Run the Pacti Development Review workflow. This will test the functionality and also code quality.</li> <li>If you are reviewing a pull-request to the main branch from another developer: Make sure to go to the \"Actions\" tab and run the Pacti Pre-Production workflow manually. This workflow tests the package for functionality and quality on two Python versions.</li> <li>The Pacti Production workflow makes sure that the software works with all OS and all Python versions.</li> </ol>"},{"location":"credits/","title":"Credits","text":"<p>We thank Athreyi Badithela for the wonderful artwork.</p> <p>The following projects were used to build <code>Pacti</code>:</p> <p><code>python</code> | <code>pdm</code> | <code>copier-pdm</code></p>"},{"location":"credits/#exec-0--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>contourpy</code> Python library for calculating contours of 2D quadrilateral grids <code>&gt;=1.0.1</code> <code>1.0.7</code> BSD-3-Clause <code>cycler</code> Composable style cycles <code>&gt;=0.10</code> <code>0.11.0</code> BSD <code>fonttools</code> Tools to manipulate font files <code>&gt;=4.22.0</code> <code>4.39.3</code> MIT <code>importlib-resources</code> Read resources from Python packages <code>&gt;=3.2.0; python_version &lt; \"3.10\"</code> <code>5.12.0</code> ? <code>kiwisolver</code> A fast implementation of the Cassowary constraint solver <code>&gt;=1.0.1</code> <code>1.4.4</code> BSD License <code>matplotlib</code> Python plotting package <code>&gt;=3.6.2</code> <code>3.7.1</code> PSF <code>mpmath</code> Python library for arbitrary-precision floating-point arithmetic <code>&gt;=0.19</code> <code>1.3.0</code> BSD <code>numpy</code> Fundamental package for array computing in Python <code>&gt;=1.24.1</code> <code>1.24.2</code> BSD-3-Clause <code>packaging</code> Core utilities for Python packages <code>&gt;=20.0</code> <code>23.0</code> BSD License <code>pillow</code> Python Imaging Library (Fork) <code>&gt;=6.2.0</code> <code>9.4.0</code> HPND <code>pyparsing</code> pyparsing module - Classes and methods to define and execute parsing grammars <code>&gt;=2.3.1</code> <code>3.0.9</code> MIT License <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.7</code> <code>2.8.2</code> Dual License <code>scipy</code> Fundamental algorithms for scientific computing in Python <code>&gt;=1.10.0</code> <code>1.10.1</code> BSD License <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.16.0</code> MIT <code>sympy</code> Computer algebra system (CAS) in Python <code>&gt;=1.11.1</code> <code>1.11.1</code> BSD <code>typing-extensions</code> Backported and Experimental Type Hints for Python 3.7+ <code>&gt;=4.5.0</code> <code>4.5.0</code> Python Software Foundation License <code>zipp</code> Backport of pathlib-compatible object wrapper for zip files <code>&gt;=3.1.0; python_version &lt; \"3.10\"</code> <code>3.15.0</code> ?"},{"location":"credits/#exec-0--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>ansimarkup</code> Produce colored terminal text with an xml-like markup <code>~=1.4</code> <code>1.5.0</code> Revised BSD License <code>attrs</code> Classes Without Boilerplate <code>&gt;=17.4.0</code> <code>22.2.0</code> MIT <code>autoflake</code> Removes unused imports and unused variables <code>&gt;=1.4</code> <code>2.0.2</code> MIT <code>beautifulsoup4</code> Screen-scraping library <code>4.12.0</code> MIT <code>black</code> The uncompromising code formatter. <code>&gt;=21.10b0</code> <code>23.3.0</code> MIT <code>bleach</code> An easy safelist-based HTML-sanitizing tool. <code>6.0.0</code> Apache Software License <code>certifi</code> Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2022.12.7</code> MPL-2.0 <code>cffi</code> Foreign Function Interface for Python calling C code. <code>; implementation_name == \"pypy\"</code> <code>1.15.1</code> ? <code>charset-normalizer</code> The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&lt;4,&gt;=2</code> <code>3.1.0</code> MIT <code>click</code> Composable command line interface toolkit <code>&gt;=8.0.0</code> <code>8.1.3</code> BSD-3-Clause <code>colorama</code> Cross-platform colored terminal text. <code>; platform_system == \"Windows\"</code> <code>0.4.6</code> BSD License <code>defusedxml</code> XML bomb protection for Python stdlib modules <code>0.7.1</code> PSFL <code>duty</code> A simple task runner. <code>&gt;=0.7</code> <code>0.9.0</code> ISC <code>failprint</code> Run a command, print its output only if it fails. <code>&gt;=0.10</code> <code>0.10.0</code> ISC <code>fastjsonschema</code> Fastest Python implementation of JSON schema <code>2.16.3</code> BSD <code>ghp-import</code> Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License <code>git-changelog</code> Automatic Changelog generator using Jinja2 templates. <code>&gt;=0.4</code> <code>1.0.0</code> ISC <code>griffe</code> Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=0.24</code> <code>0.25.5</code> ISC <code>idna</code> Internationalized Domain Names in Applications (IDNA) <code>&lt;4,&gt;=2.5</code> <code>3.4</code> BSD License <code>importlib-metadata</code> Read metadata from Python packages <code>&gt;=4.3; python_version &lt; \"3.10\"</code> <code>6.1.0</code> ? <code>importlib-resources</code> Read resources from Python packages <code>&gt;=1.4.0; python_version &lt; \"3.9\"</code> <code>5.12.0</code> ? <code>isort</code> A Python utility / library to sort Python imports. <code>&gt;=5.10</code> <code>5.12.0</code> MIT <code>jinja2</code> A very fast and expressive template engine. <code>&lt;4,&gt;=2.11</code> <code>3.1.2</code> BSD-3-Clause <code>jsonschema</code> An implementation of JSON Schema validation for Python <code>&gt;=2.6</code> <code>4.17.3</code> MIT <code>jupyter-client</code> Jupyter protocol implementation and client libraries <code>&gt;=6.1.12</code> <code>8.1.0</code> BSD License <code>jupyter-core</code> Jupyter core package. A base package on which Jupyter projects rely. <code>&gt;=4.7</code> <code>5.3.0</code> BSD License <code>jupyterlab-pygments</code> Pygments theme using JupyterLab CSS variables <code>0.2.2</code> BSD <code>jupytext</code> Jupyter notebooks as Markdown documents, Julia, Python or R scripts <code>&lt;2,&gt;1.13.8</code> <code>1.14.5</code> MIT <code>lxml</code> Powerful and Pythonic XML processing library combining libxml2/libxslt with the ElementTree API. <code>&gt;=4.7.0</code> <code>4.9.2</code> BSD-3-Clause <code>markdown</code> Python implementation of Markdown. <code>&lt;4.0.0,&gt;=3.3.3</code> <code>3.3.7</code> BSD License <code>markdown-callouts</code> Markdown extension: a classier syntax for admonitions <code>&gt;=0.2</code> <code>0.3.0</code> MIT <code>markdown-exec</code> Utilities to execute code blocks in Markdown files. <code>&gt;=0.5</code> <code>1.4.0</code> ISC <code>markdown-it-py</code> Python port of markdown-it. Markdown parsing, done right! <code>&lt;3.0.0,&gt;=1.0.0</code> <code>2.2.0</code> MIT License <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0</code> <code>2.1.2</code> BSD-3-Clause <code>mdit-py-plugins</code> Collection of plugins for markdown-it-py <code>0.3.5</code> MIT License <code>mdurl</code> Markdown URL utilities <code>~=0.1</code> <code>0.1.2</code> MIT License <code>mergedeep</code> A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License <code>mistune</code> A sane Markdown parser with useful plugins and renderers <code>&lt;3,&gt;=2.0.3</code> <code>2.0.5</code> BSD 3-Clause License <code>mkdocs</code> Project documentation with Markdown. <code>&gt;=1.3</code> <code>1.4.2</code> BSD License <code>mkdocs-coverage</code> MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;=0.2</code> <code>0.2.6</code> ISC <code>mkdocs-gen-files</code> MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;=0.3</code> <code>0.4.0</code> MIT <code>mkdocs-jupyter</code> Use Jupyter in mkdocs websites <code>&gt;=0.24,&lt;0.25</code> <code>0.24.1</code> ? <code>mkdocs-literate-nav</code> MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;=0.4</code> <code>0.6.0</code> MIT License <code>mkdocs-material</code> Documentation that simply works <code>&gt;=9.1</code> <code>9.1.5</code> MIT License <code>mkdocs-material-extensions</code> Extension pack for Python Markdown and MkDocs Material. <code>&gt;=1.1</code> <code>1.1.1</code> MIT License <code>mkdocs-section-index</code> MkDocs plugin to allow clickable sections that lead to an index page <code>&gt;=0.3</code> <code>0.3.5</code> MIT License <code>mkdocs-video</code> <code>&gt;=1.3.0</code> <code>1.5.0</code> MIT <code>mkdocstrings</code> Automatic documentation from sources, for MkDocs. <code>[python]&gt;=0.18</code> <code>0.20.0</code> ISC <code>mkdocstrings-python</code> A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>0.8.3</code> ISC <code>mypy-extensions</code> Type system extensions for programs checked with the mypy type checker. <code>&gt;=0.4.3</code> <code>1.0.0</code> MIT License <code>nbclient</code> A client library for executing notebooks. Formerly nbconvert's ExecutePreprocessor. <code>&gt;=0.5.0</code> <code>0.7.2</code> BSD License <code>nbconvert</code> Converting Jupyter Notebooks <code>&lt;8,&gt;=7.2.9</code> <code>7.2.10</code> BSD License <code>nbformat</code> The Jupyter Notebook format <code>&gt;=5.1</code> <code>5.8.0</code> BSD License <code>packaging</code> Core utilities for Python packages <code>&gt;=22.0</code> <code>23.0</code> BSD License <code>pandocfilters</code> Utilities for writing pandoc filters in python <code>&gt;=1.4.1</code> <code>1.5.0</code> BSD-3-Clause <code>pathspec</code> Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.9.0</code> <code>0.11.1</code> Mozilla Public License 2.0 (MPL 2.0) <code>pkgutil-resolve-name</code> Resolve a name to an object. <code>&gt;=1.3.10; python_version &lt; \"3.9\"</code> <code>1.3.10</code> ? <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=2</code> <code>3.2.0</code> MIT License <code>ptyprocess</code> Run a subprocess in a pseudo terminal <code>~=0.6; sys_platform != \"win32\"</code> <code>0.7.0</code> ? <code>pycparser</code> C parser in Python <code>2.21</code> ? <code>pyflakes</code> passive checker of Python programs <code>&gt;=3.0.0</code> <code>3.0.1</code> MIT <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>&gt;2.12.0</code> <code>2.14.0</code> BSD-2-Clause <code>pymdown-extensions</code> Extension pack for Python Markdown. <code>&gt;=9</code> <code>9.10</code> MIT License <code>pyrsistent</code> Persistent/Functional/Immutable data structures <code>!=0.17.0,!=0.17.1,!=0.17.2,&gt;=0.14.0</code> <code>0.19.3</code> MIT <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.8.2</code> Dual License <code>pywin32</code> Python for Window Extensions <code>&gt;=300; sys_platform == \"win32\" and platform_python_implementation != \"PyPy\"</code> <code>306</code> PSF <code>pyyaml</code> YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0</code> MIT <code>pyyaml-env-tag</code> A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License <code>pyzmq</code> Python bindings for 0MQ <code>&gt;=23.0</code> <code>25.0.2</code> LGPL+BSD <code>regex</code> Alternative regular expression module, to replace re. <code>&gt;=2022.4.24</code> <code>2023.3.23</code> Apache Software License <code>requests</code> Python HTTP for Humans. <code>&gt;=2.26</code> <code>2.28.2</code> Apache 2.0 <code>semver</code> Python helper for Semantic Versioning (http://semver.org/) <code>~=2.13</code> <code>2.13.0</code> BSD <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.9.0</code> <code>1.16.0</code> MIT <code>soupsieve</code> A modern CSS selector implementation for Beautiful Soup. <code>&gt;1.2</code> <code>2.4</code> MIT License <code>tinycss2</code> A tiny CSS parser <code>1.2.1</code> BSD License <code>toml</code> Python Library for Tom's Obvious, Minimal Language <code>&gt;=0.10</code> <code>0.10.2</code> MIT <code>tomli</code> A lil' TOML parser <code>&gt;=2.0.1; python_version &lt; \"3.11\"</code> <code>2.0.1</code> ? <code>tornado</code> Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed. <code>&gt;=6.2</code> <code>6.2</code> http://www.apache.org/licenses/LICENSE-2.0 <code>traitlets</code> Traitlets Python configuration system <code>&gt;=5.0</code> <code>5.9.0</code> BSD License <code>typing-extensions</code> Backported and Experimental Type Hints for Python 3.7+ <code>&gt;=3.10.0.0; python_version &lt; \"3.10\"</code> <code>4.5.0</code> Python Software Foundation License <code>urllib3</code> HTTP library with thread-safe connection pooling, file post, and more. <code>&lt;1.27,&gt;=1.21.1</code> <code>1.26.15</code> MIT <code>urlopen</code> A simple printer of automated lists <code>&gt;=1.0.0</code> <code>1.0.0</code> ? <code>watchdog</code> Filesystem events monitoring <code>&gt;=2.0</code> <code>3.0.0</code> Apache License 2.0 <code>webencodings</code> Character encoding aliases for legacy web content <code>&gt;=0.4</code> <code>0.5.1</code> BSD <code>zipp</code> Backport of pathlib-compatible object wrapper for zip files <code>&gt;=0.5</code> <code>3.15.0</code> ?"},{"location":"gen_credits/","title":"Gen credits","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nISC License\n\nCopyright (c) 2019, Timoth\u00e9e Mazzucotelli\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\"\"\"\n</pre> \"\"\" ISC License  Copyright (c) 2019, Timoth\u00e9e Mazzucotelli  Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. \"\"\" In\u00a0[\u00a0]: Copied! <pre>import re\nfrom importlib.metadata import PackageNotFoundError, metadata\nfrom itertools import chain\nfrom pathlib import Path\nfrom textwrap import dedent\n</pre> import re from importlib.metadata import PackageNotFoundError, metadata from itertools import chain from pathlib import Path from textwrap import dedent In\u00a0[\u00a0]: Copied! <pre>import toml\nfrom jinja2 import StrictUndefined\nfrom jinja2.sandbox import SandboxedEnvironment\n</pre> import toml from jinja2 import StrictUndefined from jinja2.sandbox import SandboxedEnvironment In\u00a0[\u00a0]: Copied! <pre>project_dir = Path(\".\")\npyproject = toml.load(project_dir / \"pyproject.toml\")\nproject = pyproject[\"project\"]\npdm = pyproject[\"tool\"][\"pdm\"]\nlock_data = toml.load(project_dir / \"pdm.lock\")\nlock_pkgs = {pkg[\"name\"].lower(): pkg for pkg in lock_data[\"package\"]}\nproject_name = project[\"name\"]\nregex = re.compile(r\"(?P&lt;dist&gt;[\\w.-]+)(?P&lt;spec&gt;.*)$\")\n</pre> project_dir = Path(\".\") pyproject = toml.load(project_dir / \"pyproject.toml\") project = pyproject[\"project\"] pdm = pyproject[\"tool\"][\"pdm\"] lock_data = toml.load(project_dir / \"pdm.lock\") lock_pkgs = {pkg[\"name\"].lower(): pkg for pkg in lock_data[\"package\"]} project_name = project[\"name\"] regex = re.compile(r\"(?P[\\w.-]+)(?P.*)$\") In\u00a0[\u00a0]: Copied! <pre>def get_license(pkg_name):\n    try:\n        data = metadata(pkg_name)\n    except PackageNotFoundError:\n        return \"?\"\n    license = data.get(\"License\", \"\").strip()\n    multiple_lines = bool(license.count(\"\\n\"))\n    if multiple_lines or not license or license == \"UNKNOWN\":\n        for header, value in data.items():\n            if header == \"Classifier\" and value.startswith(\"License ::\"):\n                license = value.rsplit(\"::\", 1)[1].strip()\n    return license or \"?\"\n</pre> def get_license(pkg_name):     try:         data = metadata(pkg_name)     except PackageNotFoundError:         return \"?\"     license = data.get(\"License\", \"\").strip()     multiple_lines = bool(license.count(\"\\n\"))     if multiple_lines or not license or license == \"UNKNOWN\":         for header, value in data.items():             if header == \"Classifier\" and value.startswith(\"License ::\"):                 license = value.rsplit(\"::\", 1)[1].strip()     return license or \"?\" In\u00a0[\u00a0]: Copied! <pre>def get_deps(base_deps):\n    deps = {}\n    for dep in base_deps:\n        parsed = regex.match(dep).groupdict()\n        dep_name = parsed[\"dist\"].lower()\n        deps[dep_name] = {\"license\": get_license(dep_name), **parsed, **lock_pkgs[dep_name]}\n\n    again = True\n    while again:\n        again = False\n        for pkg_name in lock_pkgs:\n            if pkg_name in deps:\n                for pkg_dependency in lock_pkgs[pkg_name].get(\"dependencies\", []):\n                    parsed = regex.match(pkg_dependency).groupdict()\n                    dep_name = parsed[\"dist\"].lower()\n                    if dep_name not in deps:\n                        deps[dep_name] = {\"license\": get_license(dep_name), **parsed, **lock_pkgs[dep_name]}\n                        again = True\n\n    return deps\n</pre> def get_deps(base_deps):     deps = {}     for dep in base_deps:         parsed = regex.match(dep).groupdict()         dep_name = parsed[\"dist\"].lower()         deps[dep_name] = {\"license\": get_license(dep_name), **parsed, **lock_pkgs[dep_name]}      again = True     while again:         again = False         for pkg_name in lock_pkgs:             if pkg_name in deps:                 for pkg_dependency in lock_pkgs[pkg_name].get(\"dependencies\", []):                     parsed = regex.match(pkg_dependency).groupdict()                     dep_name = parsed[\"dist\"].lower()                     if dep_name not in deps:                         deps[dep_name] = {\"license\": get_license(dep_name), **parsed, **lock_pkgs[dep_name]}                         again = True      return deps In\u00a0[\u00a0]: Copied! <pre>dev_dependencies = get_deps(chain(*pdm.get(\"dev-dependencies\", {}).values()))\nprod_dependencies = get_deps(\n    chain(\n        project.get(\"dependencies\", []),\n        chain(*project.get(\"optional-dependencies\", {}).values()),\n    )\n)\n</pre> dev_dependencies = get_deps(chain(*pdm.get(\"dev-dependencies\", {}).values())) prod_dependencies = get_deps(     chain(         project.get(\"dependencies\", []),         chain(*project.get(\"optional-dependencies\", {}).values()),     ) ) In\u00a0[\u00a0]: Copied! <pre>template_data = {\n    \"project_name\": project_name,\n    \"prod_dependencies\": sorted(prod_dependencies.values(), key=lambda dep: dep[\"name\"]),\n    \"dev_dependencies\": sorted(dev_dependencies.values(), key=lambda dep: dep[\"name\"]),\n    \"more_credits\": \"\",\n}\ntemplate_text = dedent(\n\"\"\"\n    We thank Athreyi Badithela for the wonderful artwork.\n\n    The following projects were used to build `{{ project_name }}`:\n\n    [`python`](https://www.python.org/) |\n    [`pdm`](https://pdm.fming.dev/) |\n    [`copier-pdm`](https://github.com/pawamoy/copier-pdm)\n\n    {% macro dep_line(dep) -%}\n    [`{{ dep.name }}`](https://pypi.org/project/{{ dep.name }}/) | {{ dep.summary }} | {{ (\"`\" ~ dep.spec ~ \"`\") if dep.spec else \"\" }} | `{{ dep.version }}` | {{ dep.license }}\n    {%- endmacro %}\n\n    ### Runtime dependencies\n\n    Project | Summary | Version (accepted) | Version (last resolved) | License\n    ------- | ------- | ------------------ | ----------------------- | -------\n    {% for dep in prod_dependencies -%}\n    {{ dep_line(dep) }}\n    {% endfor %}\n\n    ### Development dependencies\n\n    Project | Summary | Version (accepted) | Version (last resolved) | License\n    ------- | ------- | ------------------ | ----------------------- | -------\n    {% for dep in dev_dependencies -%}\n    {{ dep_line(dep) }}\n    {% endfor %}\n\n    {% if more_credits %}**[More credits from the author]({{ more_credits }})**{% endif %}\n    \"\"\"\n)\njinja_env = SandboxedEnvironment(undefined=StrictUndefined)\nprint(jinja_env.from_string(template_text).render(**template_data))\n</pre> template_data = {     \"project_name\": project_name,     \"prod_dependencies\": sorted(prod_dependencies.values(), key=lambda dep: dep[\"name\"]),     \"dev_dependencies\": sorted(dev_dependencies.values(), key=lambda dep: dep[\"name\"]),     \"more_credits\": \"\", } template_text = dedent(     \"\"\"     We thank Athreyi Badithela for the wonderful artwork.      The following projects were used to build `{{ project_name }}`:      [`python`](https://www.python.org/) |     [`pdm`](https://pdm.fming.dev/) |     [`copier-pdm`](https://github.com/pawamoy/copier-pdm)      {% macro dep_line(dep) -%}     [`{{ dep.name }}`](https://pypi.org/project/{{ dep.name }}/) | {{ dep.summary }} | {{ (\"`\" ~ dep.spec ~ \"`\") if dep.spec else \"\" }} | `{{ dep.version }}` | {{ dep.license }}     {%- endmacro %}      ### Runtime dependencies      Project | Summary | Version (accepted) | Version (last resolved) | License     ------- | ------- | ------------------ | ----------------------- | -------     {% for dep in prod_dependencies -%}     {{ dep_line(dep) }}     {% endfor %}      ### Development dependencies      Project | Summary | Version (accepted) | Version (last resolved) | License     ------- | ------- | ------------------ | ----------------------- | -------     {% for dep in dev_dependencies -%}     {{ dep_line(dep) }}     {% endfor %}      {% if more_credits %}**[More credits from the author]({{ more_credits }})**{% endif %}     \"\"\" ) jinja_env = SandboxedEnvironment(undefined=StrictUndefined) print(jinja_env.from_string(template_text).render(**template_data))"},{"location":"gen_ref_nav/","title":"Gen ref nav","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nISC License\n\nCopyright (c) 2019, Timoth\u00e9e Mazzucotelli\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\"\"\"\n</pre> \"\"\" ISC License  Copyright (c) 2019, Timoth\u00e9e Mazzucotelli  Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. \"\"\" In\u00a0[\u00a0]: Copied! <pre>\"\"\"Generate the code reference pages and navigation.\"\"\"\n</pre> \"\"\"Generate the code reference pages and navigation.\"\"\" In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\n</pre> nav = mkdocs_gen_files.Nav() In\u00a0[\u00a0]: Copied! <pre>for path in sorted(Path(\"src\").rglob(\"*.py\")):\n    module_path = path.relative_to(\"src\").with_suffix(\"\")\n    doc_path = path.relative_to(\"src\").with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    parts = tuple(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n    elif parts[-1] == \"__main__\":\n        continue\n    elif parts[-1] == \"utils\":\n        continue\n    elif parts[-1] == \"cli\":\n        continue\n\n    nav[parts] = doc_path.as_posix()\n\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        ident = \".\".join(parts)\n        fd.write(f\"::: {ident}\")\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, path)\n</pre> for path in sorted(Path(\"src\").rglob(\"*.py\")):     module_path = path.relative_to(\"src\").with_suffix(\"\")     doc_path = path.relative_to(\"src\").with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      parts = tuple(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")     elif parts[-1] == \"__main__\":         continue     elif parts[-1] == \"utils\":         continue     elif parts[-1] == \"cli\":         continue      nav[parts] = doc_path.as_posix()      with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         ident = \".\".join(parts)         fd.write(f\"::: {ident}\")      mkdocs_gen_files.set_edit_path(full_doc_path, path) <p>add pages manually: nav[\"package\", \"module\"] = \"path/to/file.md\"</p> In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"},{"location":"installing/","title":"Installing","text":"<p>Pacti runs on <code>Python &gt;= 3.8</code>. You can verify your Python version by running the command </p><pre><code>python --version\n</code></pre> Pacti is installed as a standard Python package using pip: <pre><code>pip install pacti\n</code></pre>"},{"location":"iocontract/","title":"IoContract","text":"<p>IoContracts definitions.</p> <p>IoContracts contains Pacti's basic definitions: Var, Term, TemList, and IoContract. Var creates variables; Term is an abstract class representing constraints; a TermList (also an abstract class) is a collection of terms semantically equivalent to the term which is the conjunction of all terms contained in the TermList; IoContract is an assume-guarantee specification consisting of assumptions, guarantees, and input and output variables. The assumptions and guarantees are given by TermLists. Assumptions make predicates only on inputs, and guarantees on both input and outputs (and no other variable).</p> <p>This module implements all supported contract operations and relations. In order to instantiate contracts and perform this operations, it is necessary to extend Term and TermList with specific constraint formalisms.</p>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract","title":"<code>IoContract</code>","text":"<p>         Bases: <code>Generic[TermList_t]</code></p> <p>Basic type for an IO contract.</p> <p>Attributes:</p> Name Type Description <code>inputvars</code> <p>Variables which are inputs of the implementations of the contract.</p> <code>outputvars</code> <p>Variables which are outputs of the implementations of the contract.</p> <code>a(TermList)</code> <p>Contract assumptions.</p> <code>g(TermList)</code> <p>Contract guarantees.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>class IoContract(Generic[TermList_t]):\n\"\"\"\n    Basic type for an IO contract.\n\n    Attributes:\n        inputvars:\n            Variables which are inputs of the implementations of the contract.\n\n        outputvars:\n            Variables which are outputs of the implementations of the contract.\n\n        a(TermList): Contract assumptions.\n\n        g(TermList): Contract guarantees.\n    \"\"\"\n\n    def __init__(\n        self, assumptions: TermList_t, guarantees: TermList_t, input_vars: List[Var], output_vars: List[Var]\n    ) -&gt; None:\n\"\"\"\n        Class constructor.\n\n        Args:\n            assumptions: The assumptions of the contract.\n            guarantees: The guarantees of the contract.\n            input_vars: The input variables of the contract.\n            output_vars: The output variables of the contract.\n\n        Raises:\n            IncompatibleArgsError: Arguments provided does not produce a valid IO contract.\n        \"\"\"\n        # make sure the input and output variables have no repeated entries\n        if len(input_vars) != len(set(input_vars)):\n            raise IncompatibleArgsError(\n                \"The following input variables appear multiple times in argument %s\"\n                % (set(list_diff(input_vars, list(set(input_vars)))))\n            )\n        if len(output_vars) != len(set(output_vars)):\n            raise IncompatibleArgsError(\n                \"The following output variables appear multiple times in argument %s\"\n                % (set(list_diff(output_vars, list(set(output_vars)))))\n            )\n        # make sure the input &amp; output variables are disjoint\n        if list_intersection(input_vars, output_vars):\n            raise IncompatibleArgsError(\n                \"The following variables appear in inputs and outputs: %s\"\n                % (list_intersection(input_vars, output_vars))\n            )\n        # make sure the assumptions only contain input variables\n        if list_diff(assumptions.vars, input_vars):\n            raise IncompatibleArgsError(\n                \"The following variables appear in the assumptions but are not inputs: %s\"\n                % (list_diff(assumptions.vars, input_vars))\n            )\n        # make sure the guarantees only contain input or output variables\n        if list_diff(guarantees.vars, list_union(input_vars, output_vars)):\n            raise IncompatibleArgsError(\n                \"The guarantees contain the following variables which are neither\"\n                \"inputs nor outputs: %s. Inputs: %s. Outputs: %s. Guarantees: %s\"\n                % (list_diff(guarantees.vars, list_union(input_vars, output_vars)), input_vars, output_vars, guarantees)\n            )\n\n        self.a: TermList_t = assumptions.copy()\n        self.inputvars = input_vars.copy()\n        self.outputvars = output_vars.copy()\n        # simplify the guarantees with the assumptions\n        self.g = guarantees.simplify(self.a)\n\n    @property\n    def vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"\n        The list of variables in the interface of the contract.\n\n        Returns:\n            Input and output variables of the contract.\n        \"\"\"\n        return list_union(self.inputvars, self.outputvars)\n\n    def __str__(self) -&gt; str:\n        return (\n            \"InVars: \"\n            + \"[\"\n            + \", \".join([v.name for v in self.inputvars])\n            + \"]\"\n            + \"\\nOutVars:\"\n            + \"[\"\n            + \", \".join([v.name for v in self.outputvars])\n            + \"]\"\n            + \"\\nA: \"\n            + str(self.a)\n            + \"\\n\"\n            + \"G: \"\n            + str(self.g)\n        )\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            raise ValueError\n        return (\n            self.inputvars == other.inputvars\n            and self.outputvars == self.outputvars\n            and self.a == other.a\n            and self.g == other.g\n        )\n\n    def __hash__(self) -&gt; int:\n        return hash((tuple(self.inputvars), tuple(self.outputvars), self.a, self.g))\n\n    def rename_variable(  # noqa: WPS231 too much cognitive complexity\n        self: IoContract_t, source_var: Var, target_var: Var\n    ) -&gt; IoContract_t:\n\"\"\"\n        Rename a variable in a contract.\n\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n\n        Returns:\n            A contract with `source_var` replaced by `target_var`.\n\n        Raises:\n            IncompatibleArgsError: The new variable is both an input and output of the resulting contract.\n        \"\"\"\n        inputvars = self.inputvars.copy()\n        outputvars = self.outputvars.copy()\n        assumptions = self.a.copy()\n        guarantees = self.g.copy()\n        if source_var != target_var:\n            if source_var in inputvars:\n                if target_var in outputvars:\n                    raise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\n                elif target_var not in inputvars:\n                    inputvars.append(target_var)\n                inputvars.remove(source_var)\n                assumptions = assumptions.rename_variable(source_var, target_var)\n                guarantees = guarantees.rename_variable(source_var, target_var)\n            elif source_var in outputvars:\n                if target_var in inputvars:\n                    raise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\n                elif target_var not in outputvars:\n                    outputvars.append(target_var)\n                outputvars.remove(source_var)\n                assumptions = assumptions.rename_variable(source_var, target_var)\n                guarantees = guarantees.rename_variable(source_var, target_var)\n        return type(self)(assumptions, guarantees, inputvars, outputvars)\n\n    def copy(self: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n        Makes copy of contract.\n\n        Returns:\n            Copy of contract.\n        \"\"\"\n        inputvars = self.inputvars.copy()\n        outputvars = self.outputvars.copy()\n        assumptions = self.a.copy()\n        guarantees = self.g.copy()\n        return type(self)(assumptions, guarantees, inputvars, outputvars)\n\n    def __le__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            raise ValueError()\n        return self.refines(other)\n\n    def __repr__(self) -&gt; str:\n        return \"&lt;Var {0}&gt;\".format(self)\n\n    def can_compose_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether the contract can be composed with another contract.\n\n        Args:\n            other:\n                Contract whose possibility to compose with self we are\n                verifying.\n\n        Returns:\n            True if the contracts can be composed. False otherwise.\n        \"\"\"\n        # make sure lists of output variables don't intersect\n        return len(list_intersection(self.outputvars, other.outputvars)) == 0\n\n    def can_quotient_by(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether the contract can quotiented by another contract.\n\n        Args:\n            other: potential quotient by which self would be quotiented.\n\n        Returns:\n            True if the IO profiles of the contracts allow the quotient to\n            exist. False otherwise.\n        \"\"\"\n        # make sure the top level outputs not contained in outputs of the\n        # existing component do not intersect with the inputs of the existing\n        # component\n        return len(list_intersection(list_diff(self.outputvars, other.outputvars), other.inputvars)) == 0\n\n    def shares_io_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether two contracts have the same IO signature.\n\n        Args:\n            other: contract whose IO signature is compared with self.\n\n        Returns:\n            True if the contracts have the same IO profile.\n        \"\"\"\n        return lists_equal(self.inputvars, other.inputvars) &amp; lists_equal(self.outputvars, other.outputvars)\n\n    def refines(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether the given contract is a refinement of another.\n\n        Return self &lt;= other.\n\n        Args:\n            other: contract being compared with self.\n\n        Returns:\n            True if the calling contract refines the argument.\n\n        Raises:\n            IncompatibleArgsError: Refinement cannot be computed.\n        \"\"\"\n        if not self.shares_io_with(other):\n            raise IncompatibleArgsError(\"Contracts do not share IO\")\n        assumptions_check: bool = other.a &lt;= self.a\n        guarantees_check: bool = (self.g | other.a) &lt;= (other.g | other.a)\n        return assumptions_check and guarantees_check\n\n    def compose(self: IoContract_t, other: IoContract_t, vars_to_keep: Any = None) -&gt; IoContract_t:  # noqa: WPS231\n\"\"\"Compose IO contracts.\n\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n\n        Returns:\n            The abstracted composition of the two contracts.\n\n        Raises:\n            IncompatibleArgsError: An error occurred during composition.\n        \"\"\"\n        if vars_to_keep is None:\n            vars_to_keep = []\n        conflict_vars = list_diff(vars_to_keep, list_union(self.outputvars, other.outputvars))\n        if conflict_vars:\n            raise IncompatibleArgsError(\"Asked to keep variables %s, which are not outputs\" % (conflict_vars))\n\n        logging.debug(\"Composing contracts \\n%s and \\n%s\", self, other)\n        intvars = list_union(\n            list_intersection(self.outputvars, other.inputvars), list_intersection(self.inputvars, other.outputvars)\n        )\n        inputvars = list_diff(list_union(self.inputvars, other.inputvars), intvars)\n        outputvars = list_diff(list_union(self.outputvars, other.outputvars), intvars)\n        # remove requested variables\n        intvars = list_diff(intvars, vars_to_keep)\n        outputvars = list_union(outputvars, vars_to_keep)\n\n        selfinputconst = self.a.vars\n        otherinputconst = other.a.vars\n        cycle_present = (\n            len(list_intersection(self.inputvars, other.outputvars)) &gt; 0\n            and len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\n        )\n\n        assumptions_forbidden_vars = list_union(intvars, outputvars)\n        if not self.can_compose_with(other):\n            raise IncompatibleArgsError(\n                \"Cannot compose the following contracts due to incompatible IO profiles:\\n %s \\n %s\" % (self, other)\n            )\n        other_helps_self = len(list_intersection(other.outputvars, self.inputvars)) &gt; 0\n        self_helps_other = len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\n        other_drives_const_inputs = len(list_intersection(other.outputvars, selfinputconst)) &gt; 0\n        self_drives_const_inputs = len(list_intersection(self.outputvars, otherinputconst)) &gt; 0\n        # process assumptions\n        if cycle_present and (other_drives_const_inputs or self_drives_const_inputs):\n            raise IncompatibleArgsError(\"Cannot compose contracts due to feedback\")\n        elif self_helps_other and not other_helps_self:\n            logging.debug(\"Assumption computation: self provides context for other\")\n            new_a: TermList_t = other.a.elim_vars_by_refining(self.a | self.g, assumptions_forbidden_vars)\n            conflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\n            if conflict_variables:\n                raise IncompatibleArgsError(\n                    \"Could not eliminate variables {}\\n\".format([str(x) for x in assumptions_forbidden_vars])\n                    + \"by refining the assumptions \\n{}\\n\".format(new_a.get_terms_with_vars(assumptions_forbidden_vars))\n                    + \"using guarantees \\n{}\\n\".format(self.a | self.g)\n                )\n            assumptions = new_a | self.a\n        elif other_helps_self and not self_helps_other:\n            logging.debug(\"****** Assumption computation: other provides context for self\")\n            new_a = self.a.elim_vars_by_refining(other.a | other.g, assumptions_forbidden_vars)\n            conflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\n            if conflict_variables:\n                raise IncompatibleArgsError(\n                    \"Could not eliminate variables {}\".format([str(x) for x in assumptions_forbidden_vars])\n                    + \" by refining the assumptions \\n{}\\n\".format(\n                        new_a.get_terms_with_vars(assumptions_forbidden_vars)\n                    )\n                    + \"using guarantees \\n{}\\n\".format(other.a | other.g)\n                )\n            assumptions = new_a | other.a\n        # contracts can't help each other\n        else:\n            logging.debug(\"****** Assumption computation: other provides context for self\")\n            assumptions = self.a | other.a\n        logging.debug(\"Assumption computation: computed assumptions:\\n%s\", assumptions)\n        assumptions = assumptions.simplify()\n\n        # process guarantees\n        logging.debug(\"****** Computing guarantees\")\n        g1_t = self.g.copy()\n        g2_t = other.g.copy()\n        g1 = g1_t.elim_vars_by_relaxing(g2_t, intvars)\n        g2 = g2_t.elim_vars_by_relaxing(g1_t, intvars)\n        allguarantees = g1 | g2\n        allguarantees = allguarantees.elim_vars_by_relaxing(assumptions, intvars)\n\n        # eliminate terms with forbidden vars\n        terms_to_elim = allguarantees.get_terms_with_vars(intvars)\n        allguarantees -= terms_to_elim\n\n        return type(self)(assumptions, allguarantees, inputvars, outputvars)\n\n    def quotient(\n        self: IoContract_t, other: IoContract_t, additional_inputs: Optional[List[Var]] = None\n    ) -&gt; IoContract_t:\n\"\"\"Compute the contract quotient.\n\n        Compute the quotient self/other of the two given contracts and refine\n        the result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n\n        Returns:\n            The refined quotient self/other.\n\n        Raises:\n            IncompatibleArgsError: Arguments provided are incompatible with computation of the quotient.\n        \"\"\"\n        if not additional_inputs:\n            additional_inputs = []\n        if not self.can_quotient_by(other):\n            raise IncompatibleArgsError(\"Contracts cannot be quotiented due to incompatible IO\")\n        if list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)):\n            raise IncompatibleArgsError(\n                \"The additional inputs %s are neither top level inputs nor existing component outputs\"\n                % (list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)))\n            )\n        outputvars = list_union(\n            list_diff(self.outputvars, other.outputvars), list_diff(other.inputvars, self.inputvars)\n        )\n        inputvars = list_union(list_diff(self.inputvars, other.inputvars), list_diff(other.outputvars, self.outputvars))\n        inputvars = list_union(inputvars, additional_inputs)\n        intvars = list_union(\n            list_intersection(self.outputvars, other.outputvars), list_intersection(self.inputvars, other.inputvars)\n        )\n        intvars = list_diff(intvars, additional_inputs)\n\n        # get assumptions\n        logging.debug(\"Computing quotient assumptions\")\n        assumptions = copy.deepcopy(self.a)\n        empty_context = type(assumptions)([])\n        if assumptions.refines(other.a):\n            logging.debug(\"Extending top-level assumptions with divisor's guarantees\")\n            assumptions = assumptions | other.g\n        assumptions = assumptions.elim_vars_by_relaxing(empty_context, list_union(intvars, outputvars))\n        logging.debug(\"Assumptions after processing: %s\", assumptions)\n\n        # get guarantees\n        logging.debug(\"Computing quotient guarantees\")\n        guarantees: TermList_t = self.g\n        logging.debug(\"Using existing guarantees to aid system-level guarantees\")\n        try:\n            guarantees = guarantees.elim_vars_by_refining(other.g | other.a, intvars)\n        except ValueError:\n            guarantees = self.g\n        logging.debug(\"Guarantees are %s\" % (guarantees))\n        logging.debug(\"Using system-level assumptions to aid quotient guarantees\")\n        guarantees = guarantees | other.a\n        try:\n            guarantees = guarantees.elim_vars_by_refining(self.a, intvars)\n        except ValueError:\n            ...\n        logging.debug(\"Guarantees after processing: %s\", guarantees)\n        conflict_variables = list_intersection(guarantees.vars, intvars)\n        if conflict_variables:\n            raise IncompatibleArgsError(\n                \"Could not eliminate variables \\n{}\".format([str(x) for x in conflict_variables])\n                + \"by refining the guarantees \\n{}\\n\".format(guarantees.get_terms_with_vars(intvars))\n            )\n\n        return type(self)(assumptions, guarantees, inputvars, outputvars)\n\n    def merge(self: IoContract_t, other: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n        Compute the merging operation for two contracts.\n\n        Compute the merging operation of the two given contracts. No\n        abstraction/refinement is applied.\n\n        Args:\n            other: The contract with which we are merging self.\n\n        Returns:\n            The result of merging.\n\n        Raises:\n            IncompatibleArgsError: trying to merge different contract types.\n        \"\"\"\n        if not isinstance(self, type(other)):\n            raise IncompatibleArgsError(\"Asked to merge incompatible contracts\")\n        input_vars = list_union(self.inputvars, other.inputvars)\n        output_vars = list_union(self.outputvars, other.outputvars)\n        assumptions = self.a | other.a\n        guarantees = self.g | other.g\n        return type(self)(assumptions, guarantees, input_vars, output_vars)\n\n    def contains_environment(self, component: TermList) -&gt; bool:\n\"\"\"\n        Tell whether a component is a valid environment for the contract.\n\n        Args:\n            component: The component in question.\n\n        Returns:\n            True if the component is a valid environment; false otherwise.\n        \"\"\"\n        return component &lt;= self.a\n\n    def contains_implementation(self, component: TermList) -&gt; bool:\n\"\"\"\n        Tell whether a component is a valid implementation for the contract.\n\n        Args:\n            component:\n                The component in question.\n\n        Returns:\n            True if the component is a valid implementation; false otherwise.\n        \"\"\"\n        return (component | self.a) &lt;= (self.g | self.a)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.vars","title":"<code>vars: List[Var]</code>  <code>property</code>","text":"<p>The list of variables in the interface of the contract.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>Input and output variables of the contract.</p>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.__init__","title":"<code>__init__(assumptions, guarantees, input_vars, output_vars)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>TermList_t</code> <p>The assumptions of the contract.</p> required <code>guarantees</code> <code>TermList_t</code> <p>The guarantees of the contract.</p> required <code>input_vars</code> <code>List[Var]</code> <p>The input variables of the contract.</p> required <code>output_vars</code> <code>List[Var]</code> <p>The output variables of the contract.</p> required <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>Arguments provided does not produce a valid IO contract.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def __init__(\n    self, assumptions: TermList_t, guarantees: TermList_t, input_vars: List[Var], output_vars: List[Var]\n) -&gt; None:\n\"\"\"\n    Class constructor.\n\n    Args:\n        assumptions: The assumptions of the contract.\n        guarantees: The guarantees of the contract.\n        input_vars: The input variables of the contract.\n        output_vars: The output variables of the contract.\n\n    Raises:\n        IncompatibleArgsError: Arguments provided does not produce a valid IO contract.\n    \"\"\"\n    # make sure the input and output variables have no repeated entries\n    if len(input_vars) != len(set(input_vars)):\n        raise IncompatibleArgsError(\n            \"The following input variables appear multiple times in argument %s\"\n            % (set(list_diff(input_vars, list(set(input_vars)))))\n        )\n    if len(output_vars) != len(set(output_vars)):\n        raise IncompatibleArgsError(\n            \"The following output variables appear multiple times in argument %s\"\n            % (set(list_diff(output_vars, list(set(output_vars)))))\n        )\n    # make sure the input &amp; output variables are disjoint\n    if list_intersection(input_vars, output_vars):\n        raise IncompatibleArgsError(\n            \"The following variables appear in inputs and outputs: %s\"\n            % (list_intersection(input_vars, output_vars))\n        )\n    # make sure the assumptions only contain input variables\n    if list_diff(assumptions.vars, input_vars):\n        raise IncompatibleArgsError(\n            \"The following variables appear in the assumptions but are not inputs: %s\"\n            % (list_diff(assumptions.vars, input_vars))\n        )\n    # make sure the guarantees only contain input or output variables\n    if list_diff(guarantees.vars, list_union(input_vars, output_vars)):\n        raise IncompatibleArgsError(\n            \"The guarantees contain the following variables which are neither\"\n            \"inputs nor outputs: %s. Inputs: %s. Outputs: %s. Guarantees: %s\"\n            % (list_diff(guarantees.vars, list_union(input_vars, output_vars)), input_vars, output_vars, guarantees)\n        )\n\n    self.a: TermList_t = assumptions.copy()\n    self.inputvars = input_vars.copy()\n    self.outputvars = output_vars.copy()\n    # simplify the guarantees with the assumptions\n    self.g = guarantees.simplify(self.a)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.can_compose_with","title":"<code>can_compose_with(other)</code>","text":"<p>Tell whether the contract can be composed with another contract.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>Contract whose possibility to compose with self we are verifying.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the contracts can be composed. False otherwise.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def can_compose_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether the contract can be composed with another contract.\n\n    Args:\n        other:\n            Contract whose possibility to compose with self we are\n            verifying.\n\n    Returns:\n        True if the contracts can be composed. False otherwise.\n    \"\"\"\n    # make sure lists of output variables don't intersect\n    return len(list_intersection(self.outputvars, other.outputvars)) == 0\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.can_quotient_by","title":"<code>can_quotient_by(other)</code>","text":"<p>Tell whether the contract can quotiented by another contract.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>potential quotient by which self would be quotiented.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the IO profiles of the contracts allow the quotient to</p> <code>bool</code> <p>exist. False otherwise.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def can_quotient_by(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether the contract can quotiented by another contract.\n\n    Args:\n        other: potential quotient by which self would be quotiented.\n\n    Returns:\n        True if the IO profiles of the contracts allow the quotient to\n        exist. False otherwise.\n    \"\"\"\n    # make sure the top level outputs not contained in outputs of the\n    # existing component do not intersect with the inputs of the existing\n    # component\n    return len(list_intersection(list_diff(self.outputvars, other.outputvars), other.inputvars)) == 0\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.compose","title":"<code>compose(other, vars_to_keep=None)</code>","text":"<p>Compose IO contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Any</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <p>Returns:</p> Type Description <code>IoContract_t</code> <p>The abstracted composition of the two contracts.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>An error occurred during composition.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def compose(self: IoContract_t, other: IoContract_t, vars_to_keep: Any = None) -&gt; IoContract_t:  # noqa: WPS231\n\"\"\"Compose IO contracts.\n\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n\n    Returns:\n        The abstracted composition of the two contracts.\n\n    Raises:\n        IncompatibleArgsError: An error occurred during composition.\n    \"\"\"\n    if vars_to_keep is None:\n        vars_to_keep = []\n    conflict_vars = list_diff(vars_to_keep, list_union(self.outputvars, other.outputvars))\n    if conflict_vars:\n        raise IncompatibleArgsError(\"Asked to keep variables %s, which are not outputs\" % (conflict_vars))\n\n    logging.debug(\"Composing contracts \\n%s and \\n%s\", self, other)\n    intvars = list_union(\n        list_intersection(self.outputvars, other.inputvars), list_intersection(self.inputvars, other.outputvars)\n    )\n    inputvars = list_diff(list_union(self.inputvars, other.inputvars), intvars)\n    outputvars = list_diff(list_union(self.outputvars, other.outputvars), intvars)\n    # remove requested variables\n    intvars = list_diff(intvars, vars_to_keep)\n    outputvars = list_union(outputvars, vars_to_keep)\n\n    selfinputconst = self.a.vars\n    otherinputconst = other.a.vars\n    cycle_present = (\n        len(list_intersection(self.inputvars, other.outputvars)) &gt; 0\n        and len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\n    )\n\n    assumptions_forbidden_vars = list_union(intvars, outputvars)\n    if not self.can_compose_with(other):\n        raise IncompatibleArgsError(\n            \"Cannot compose the following contracts due to incompatible IO profiles:\\n %s \\n %s\" % (self, other)\n        )\n    other_helps_self = len(list_intersection(other.outputvars, self.inputvars)) &gt; 0\n    self_helps_other = len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\n    other_drives_const_inputs = len(list_intersection(other.outputvars, selfinputconst)) &gt; 0\n    self_drives_const_inputs = len(list_intersection(self.outputvars, otherinputconst)) &gt; 0\n    # process assumptions\n    if cycle_present and (other_drives_const_inputs or self_drives_const_inputs):\n        raise IncompatibleArgsError(\"Cannot compose contracts due to feedback\")\n    elif self_helps_other and not other_helps_self:\n        logging.debug(\"Assumption computation: self provides context for other\")\n        new_a: TermList_t = other.a.elim_vars_by_refining(self.a | self.g, assumptions_forbidden_vars)\n        conflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\n        if conflict_variables:\n            raise IncompatibleArgsError(\n                \"Could not eliminate variables {}\\n\".format([str(x) for x in assumptions_forbidden_vars])\n                + \"by refining the assumptions \\n{}\\n\".format(new_a.get_terms_with_vars(assumptions_forbidden_vars))\n                + \"using guarantees \\n{}\\n\".format(self.a | self.g)\n            )\n        assumptions = new_a | self.a\n    elif other_helps_self and not self_helps_other:\n        logging.debug(\"****** Assumption computation: other provides context for self\")\n        new_a = self.a.elim_vars_by_refining(other.a | other.g, assumptions_forbidden_vars)\n        conflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\n        if conflict_variables:\n            raise IncompatibleArgsError(\n                \"Could not eliminate variables {}\".format([str(x) for x in assumptions_forbidden_vars])\n                + \" by refining the assumptions \\n{}\\n\".format(\n                    new_a.get_terms_with_vars(assumptions_forbidden_vars)\n                )\n                + \"using guarantees \\n{}\\n\".format(other.a | other.g)\n            )\n        assumptions = new_a | other.a\n    # contracts can't help each other\n    else:\n        logging.debug(\"****** Assumption computation: other provides context for self\")\n        assumptions = self.a | other.a\n    logging.debug(\"Assumption computation: computed assumptions:\\n%s\", assumptions)\n    assumptions = assumptions.simplify()\n\n    # process guarantees\n    logging.debug(\"****** Computing guarantees\")\n    g1_t = self.g.copy()\n    g2_t = other.g.copy()\n    g1 = g1_t.elim_vars_by_relaxing(g2_t, intvars)\n    g2 = g2_t.elim_vars_by_relaxing(g1_t, intvars)\n    allguarantees = g1 | g2\n    allguarantees = allguarantees.elim_vars_by_relaxing(assumptions, intvars)\n\n    # eliminate terms with forbidden vars\n    terms_to_elim = allguarantees.get_terms_with_vars(intvars)\n    allguarantees -= terms_to_elim\n\n    return type(self)(assumptions, allguarantees, inputvars, outputvars)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.contains_environment","title":"<code>contains_environment(component)</code>","text":"<p>Tell whether a component is a valid environment for the contract.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>TermList</code> <p>The component in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the component is a valid environment; false otherwise.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def contains_environment(self, component: TermList) -&gt; bool:\n\"\"\"\n    Tell whether a component is a valid environment for the contract.\n\n    Args:\n        component: The component in question.\n\n    Returns:\n        True if the component is a valid environment; false otherwise.\n    \"\"\"\n    return component &lt;= self.a\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.contains_implementation","title":"<code>contains_implementation(component)</code>","text":"<p>Tell whether a component is a valid implementation for the contract.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>TermList</code> <p>The component in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the component is a valid implementation; false otherwise.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def contains_implementation(self, component: TermList) -&gt; bool:\n\"\"\"\n    Tell whether a component is a valid implementation for the contract.\n\n    Args:\n        component:\n            The component in question.\n\n    Returns:\n        True if the component is a valid implementation; false otherwise.\n    \"\"\"\n    return (component | self.a) &lt;= (self.g | self.a)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.copy","title":"<code>copy()</code>","text":"<p>Makes copy of contract.</p> <p>Returns:</p> Type Description <code>IoContract_t</code> <p>Copy of contract.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def copy(self: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n    Makes copy of contract.\n\n    Returns:\n        Copy of contract.\n    \"\"\"\n    inputvars = self.inputvars.copy()\n    outputvars = self.outputvars.copy()\n    assumptions = self.a.copy()\n    guarantees = self.g.copy()\n    return type(self)(assumptions, guarantees, inputvars, outputvars)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.merge","title":"<code>merge(other)</code>","text":"<p>Compute the merging operation for two contracts.</p> <p>Compute the merging operation of the two given contracts. No abstraction/refinement is applied.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The contract with which we are merging self.</p> required <p>Returns:</p> Type Description <code>IoContract_t</code> <p>The result of merging.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>trying to merge different contract types.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def merge(self: IoContract_t, other: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n    Compute the merging operation for two contracts.\n\n    Compute the merging operation of the two given contracts. No\n    abstraction/refinement is applied.\n\n    Args:\n        other: The contract with which we are merging self.\n\n    Returns:\n        The result of merging.\n\n    Raises:\n        IncompatibleArgsError: trying to merge different contract types.\n    \"\"\"\n    if not isinstance(self, type(other)):\n        raise IncompatibleArgsError(\"Asked to merge incompatible contracts\")\n    input_vars = list_union(self.inputvars, other.inputvars)\n    output_vars = list_union(self.outputvars, other.outputvars)\n    assumptions = self.a | other.a\n    guarantees = self.g | other.g\n    return type(self)(assumptions, guarantees, input_vars, output_vars)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.quotient","title":"<code>quotient(other, additional_inputs=None)</code>","text":"<p>Compute the contract quotient.</p> <p>Compute the quotient self/other of the two given contracts and refine the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <p>Returns:</p> Type Description <code>IoContract_t</code> <p>The refined quotient self/other.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>Arguments provided are incompatible with computation of the quotient.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def quotient(\n    self: IoContract_t, other: IoContract_t, additional_inputs: Optional[List[Var]] = None\n) -&gt; IoContract_t:\n\"\"\"Compute the contract quotient.\n\n    Compute the quotient self/other of the two given contracts and refine\n    the result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n\n    Returns:\n        The refined quotient self/other.\n\n    Raises:\n        IncompatibleArgsError: Arguments provided are incompatible with computation of the quotient.\n    \"\"\"\n    if not additional_inputs:\n        additional_inputs = []\n    if not self.can_quotient_by(other):\n        raise IncompatibleArgsError(\"Contracts cannot be quotiented due to incompatible IO\")\n    if list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)):\n        raise IncompatibleArgsError(\n            \"The additional inputs %s are neither top level inputs nor existing component outputs\"\n            % (list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)))\n        )\n    outputvars = list_union(\n        list_diff(self.outputvars, other.outputvars), list_diff(other.inputvars, self.inputvars)\n    )\n    inputvars = list_union(list_diff(self.inputvars, other.inputvars), list_diff(other.outputvars, self.outputvars))\n    inputvars = list_union(inputvars, additional_inputs)\n    intvars = list_union(\n        list_intersection(self.outputvars, other.outputvars), list_intersection(self.inputvars, other.inputvars)\n    )\n    intvars = list_diff(intvars, additional_inputs)\n\n    # get assumptions\n    logging.debug(\"Computing quotient assumptions\")\n    assumptions = copy.deepcopy(self.a)\n    empty_context = type(assumptions)([])\n    if assumptions.refines(other.a):\n        logging.debug(\"Extending top-level assumptions with divisor's guarantees\")\n        assumptions = assumptions | other.g\n    assumptions = assumptions.elim_vars_by_relaxing(empty_context, list_union(intvars, outputvars))\n    logging.debug(\"Assumptions after processing: %s\", assumptions)\n\n    # get guarantees\n    logging.debug(\"Computing quotient guarantees\")\n    guarantees: TermList_t = self.g\n    logging.debug(\"Using existing guarantees to aid system-level guarantees\")\n    try:\n        guarantees = guarantees.elim_vars_by_refining(other.g | other.a, intvars)\n    except ValueError:\n        guarantees = self.g\n    logging.debug(\"Guarantees are %s\" % (guarantees))\n    logging.debug(\"Using system-level assumptions to aid quotient guarantees\")\n    guarantees = guarantees | other.a\n    try:\n        guarantees = guarantees.elim_vars_by_refining(self.a, intvars)\n    except ValueError:\n        ...\n    logging.debug(\"Guarantees after processing: %s\", guarantees)\n    conflict_variables = list_intersection(guarantees.vars, intvars)\n    if conflict_variables:\n        raise IncompatibleArgsError(\n            \"Could not eliminate variables \\n{}\".format([str(x) for x in conflict_variables])\n            + \"by refining the guarantees \\n{}\\n\".format(guarantees.get_terms_with_vars(intvars))\n        )\n\n    return type(self)(assumptions, guarantees, inputvars, outputvars)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.refines","title":"<code>refines(other)</code>","text":"<p>Tell whether the given contract is a refinement of another.</p> <p>Return self &lt;= other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>contract being compared with self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the calling contract refines the argument.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>Refinement cannot be computed.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def refines(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether the given contract is a refinement of another.\n\n    Return self &lt;= other.\n\n    Args:\n        other: contract being compared with self.\n\n    Returns:\n        True if the calling contract refines the argument.\n\n    Raises:\n        IncompatibleArgsError: Refinement cannot be computed.\n    \"\"\"\n    if not self.shares_io_with(other):\n        raise IncompatibleArgsError(\"Contracts do not share IO\")\n    assumptions_check: bool = other.a &lt;= self.a\n    guarantees_check: bool = (self.g | other.a) &lt;= (other.g | other.a)\n    return assumptions_check and guarantees_check\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a contract.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>IoContract_t</code> <p>A contract with <code>source_var</code> replaced by <code>target_var</code>.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>The new variable is both an input and output of the resulting contract.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def rename_variable(  # noqa: WPS231 too much cognitive complexity\n    self: IoContract_t, source_var: Var, target_var: Var\n) -&gt; IoContract_t:\n\"\"\"\n    Rename a variable in a contract.\n\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n\n    Returns:\n        A contract with `source_var` replaced by `target_var`.\n\n    Raises:\n        IncompatibleArgsError: The new variable is both an input and output of the resulting contract.\n    \"\"\"\n    inputvars = self.inputvars.copy()\n    outputvars = self.outputvars.copy()\n    assumptions = self.a.copy()\n    guarantees = self.g.copy()\n    if source_var != target_var:\n        if source_var in inputvars:\n            if target_var in outputvars:\n                raise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\n            elif target_var not in inputvars:\n                inputvars.append(target_var)\n            inputvars.remove(source_var)\n            assumptions = assumptions.rename_variable(source_var, target_var)\n            guarantees = guarantees.rename_variable(source_var, target_var)\n        elif source_var in outputvars:\n            if target_var in inputvars:\n                raise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\n            elif target_var not in outputvars:\n                outputvars.append(target_var)\n            outputvars.remove(source_var)\n            assumptions = assumptions.rename_variable(source_var, target_var)\n            guarantees = guarantees.rename_variable(source_var, target_var)\n    return type(self)(assumptions, guarantees, inputvars, outputvars)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.shares_io_with","title":"<code>shares_io_with(other)</code>","text":"<p>Tell whether two contracts have the same IO signature.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>contract whose IO signature is compared with self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the contracts have the same IO profile.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def shares_io_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether two contracts have the same IO signature.\n\n    Args:\n        other: contract whose IO signature is compared with self.\n\n    Returns:\n        True if the contracts have the same IO profile.\n    \"\"\"\n    return lists_equal(self.inputvars, other.inputvars) &amp; lists_equal(self.outputvars, other.outputvars)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term","title":"<code>Term</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Terms, or constraints, to be imposed on the system or components.</p> <p>Term is an abstract class that must be extended in order to support specific constraint languages.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>class Term(ABC):\n\"\"\"\n    Terms, or constraints, to be imposed on the system or components.\n\n    Term is an abstract class that must be extended in order to support specific\n    constraint languages.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"Variables contained in the syntax of the term.\"\"\"\n\n    @abstractmethod\n    def contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n        Tell whether term contains a given variable.\n\n        Args:\n            var_to_seek: The variable that we are seeking in the current term.\n        \"\"\"\n\n    @abstractmethod\n    def __eq__(self, other: object) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def __str__(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def __hash__(self) -&gt; int:\n        pass\n\n    @abstractmethod\n    def __repr__(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def copy(self: Term_t) -&gt; Term_t:\n\"\"\"Returns a copy of term.\"\"\"\n\n    @abstractmethod\n    def rename_variable(self: Term_t, source_var: Var, target_var: Var) -&gt; Term_t:\n\"\"\"\n        Rename a variable in a term.\n\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n\n        Returns:\n            A term with `source_var` replaced by `target_var`.\n        \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term.vars","title":"<code>vars: List[Var]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Variables contained in the syntax of the term.</p>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term.contains_var","title":"<code>contains_var(var_to_seek)</code>  <code>abstractmethod</code>","text":"<p>Tell whether term contains a given variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_to_seek</code> <code>Var</code> <p>The variable that we are seeking in the current term.</p> required Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n    Tell whether term contains a given variable.\n\n    Args:\n        var_to_seek: The variable that we are seeking in the current term.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term.copy","title":"<code>copy()</code>  <code>abstractmethod</code>","text":"<p>Returns a copy of term.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef copy(self: Term_t) -&gt; Term_t:\n\"\"\"Returns a copy of term.\"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>  <code>abstractmethod</code>","text":"<p>Rename a variable in a term.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>Term_t</code> <p>A term with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef rename_variable(self: Term_t, source_var: Var, target_var: Var) -&gt; Term_t:\n\"\"\"\n    Rename a variable in a term.\n\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n\n    Returns:\n        A term with `source_var` replaced by `target_var`.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList","title":"<code>TermList</code>","text":"<p>         Bases: <code>ABC</code></p> <p>A collection of terms, or constraints.</p> <p>A TermList is semantically equivalent to a single term which is the conjunction of all terms contained in the TermList. TermList is an abstract class that must be extended to support a specific constraint formalism.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>class TermList(ABC):\n\"\"\"\n    A collection of terms, or constraints.\n\n    A TermList is semantically equivalent to a single term which is the\n    conjunction of all terms contained in the TermList. TermList is an abstract\n    class that must be extended to support a specific constraint formalism.\n    \"\"\"\n\n    def __init__(self, term_list: Optional[List] = None):\n\"\"\"\n        Class constructor.\n\n        Args:\n            term_list: A list of terms contained by TermList.\n        \"\"\"\n        if term_list:\n            self.terms = term_list.copy()\n        else:\n            self.terms = []\n\n    @property\n    def vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"The list of variables contained in this list of terms.\n\n        Returns:\n            List of variables referenced in the term.\n        \"\"\"\n        varlist: List[Var] = []\n        for t in self.terms:\n            varlist = list_union(varlist, t.vars)\n        return varlist\n\n    def __str__(self) -&gt; str:\n        if self.terms:\n            res = [str(el) for el in self.terms]\n            return \", \".join(res)\n        return \"true\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            raise ValueError()\n        return self.terms == other.terms\n\n    def get_terms_with_vars(self: TermList_t, variable_list: List[Var]) -&gt; TermList_t:\n\"\"\"\n        Returns the list of terms which contain any of the variables indicated.\n\n        Args:\n            variable_list: a list of variables being sought in current TermList.\n\n        Returns:\n            The list of terms which contain any of the variables indicated.\n        \"\"\"\n        terms = []\n        for t in self.terms:\n            if list_intersection(t.vars, variable_list):\n                terms.append(t)\n        return type(self)(terms)\n\n    def __and__(self: TermList_t, other: TermList_t) -&gt; TermList_t:\n        return type(self)(list_intersection(self.copy().terms, other.copy().terms))\n\n    def __or__(self: TermList_t, other: TermList_t) -&gt; TermList_t:\n        return type(self)(list_union(self.copy().terms, other.copy().terms))\n\n    def __sub__(self: TermList_t, other: TermList_t) -&gt; TermList_t:\n        return type(self)(list_diff(self.copy().terms, other.copy().terms))\n\n    def __le__(self: TermList_t, other: TermList_t) -&gt; bool:\n        return self.refines(other)\n\n    @abstractmethod\n    def __hash__(self) -&gt; int:\n        ...\n\n    def copy(self: TermList_t) -&gt; TermList_t:\n\"\"\"\n        Makes copy of termlist.\n\n        Returns:\n            Copy of termlist.\n        \"\"\"\n        return type(self)([term.copy() for term in self.terms])\n\n    def rename_variable(self: TermList_t, source_var: Var, target_var: Var) -&gt; TermList_t:\n\"\"\"\n        Rename a variable in a termlist.\n\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n\n        Returns:\n            A termlist with `source_var` replaced by `target_var`.\n        \"\"\"\n        return type(self)([term.rename_variable(source_var, target_var) for term in self.terms])\n\n    @abstractmethod\n    def contains_behavior(self, behavior: Any) -&gt; bool:\n\"\"\"\n        Tell whether TermList contains the given behavior.\n\n        Args:\n            behavior:\n                The behavior in question.\n\n        Returns:\n            True if the behavior satisfies the constraints; false otherwise.\n\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\n\n    @abstractmethod\n    def elim_vars_by_refining(self: TermList_t, context: TermList_t, vars_to_elim: List[Var]) -&gt; TermList_t:\n\"\"\"\n        Eliminate variables from termlist by refining it in a context.\n\n        Given a context $\\\\Gamma$, and the list of terms contained in self,\n        $s$, this routine identifies a TermList $x$ lacking variables\n        vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; x}{\\\\Gamma: \\\\;\n        s}$.\n\n        Args:\n            context:\n                List of context terms that will be used to refine the TermList.\n            vars_to_elim:\n                Variables to be eliminated.\n\n        Returns:\n            A list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, imply the terms contained in the\n            calling termlist.\n        \"\"\"\n\n    @abstractmethod\n    def elim_vars_by_relaxing(self: TermList_t, context: TermList_t, vars_to_elim: List[Var]) -&gt; TermList_t:\n\"\"\"\n        Eliminate variables from termlist by relaxing it in a context\n\n        Given a context $\\\\Gamma$, and the list of terms contained in self,\n        $s$, this routine identifies a formula $x$ lacking variables\n        vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; s}{\\\\Gamma: \\\\;\n        x}$.\n\n        Args:\n            context:\n                List of context terms that will be used to abstract the TermList.\n            vars_to_elim:\n                Variables that cannot be present in TermList after relaxation.\n\n        Returns:\n            A list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, are implied by the terms\n            contained in the calling termlist.\n        \"\"\"\n\n    @abstractmethod\n    def simplify(self: TermList_t, context: Optional[TermList_t] = None) -&gt; TermList_t:\n\"\"\"Remove redundant terms in TermList.\n\n        Args:\n            context:\n                List of context terms that will be used to remove redundancies in\n                the TermList.\n\n        Returns:\n            Let $S$ be this TermList. Simplify will return $S_T = S \\\\setminus T$\n            where $T \\\\subseteq S$ is a maximal subset such that $\\\\frac{\\\\Gamma, S_T\\\\colon \\\\;\n            \\\\top}{\\\\Gamma, S_T\\\\colon \\\\; \\\\wedge_{t \\\\in T} t}$.\n        \"\"\"\n\n    @abstractmethod\n    def refines(self: TermList_t, other: TermList_t) -&gt; bool:\n\"\"\"\n        Tell whether the argument is a larger specification.\n\n        Args:\n            other:\n                TermList against which we are comparing self.\n\n        Returns:\n            self &lt;= other.\n        \"\"\"\n\n    @abstractmethod\n    def is_empty(self) -&gt; bool:\n\"\"\"\n        Tell whether the termlist has no satisfying assignments.\n\n        Returns:\n            True if termlist constraints cannot be satisfied.\n        \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.vars","title":"<code>vars: List[Var]</code>  <code>property</code>","text":"<p>The list of variables contained in this list of terms.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>List of variables referenced in the term.</p>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.__init__","title":"<code>__init__(term_list=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>term_list</code> <code>Optional[List]</code> <p>A list of terms contained by TermList.</p> <code>None</code> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def __init__(self, term_list: Optional[List] = None):\n\"\"\"\n    Class constructor.\n\n    Args:\n        term_list: A list of terms contained by TermList.\n    \"\"\"\n    if term_list:\n        self.terms = term_list.copy()\n    else:\n        self.terms = []\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.contains_behavior","title":"<code>contains_behavior(behavior)</code>  <code>abstractmethod</code>","text":"<p>Tell whether TermList contains the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Any</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraints; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef contains_behavior(self, behavior: Any) -&gt; bool:\n\"\"\"\n    Tell whether TermList contains the given behavior.\n\n    Args:\n        behavior:\n            The behavior in question.\n\n    Returns:\n        True if the behavior satisfies the constraints; false otherwise.\n\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.copy","title":"<code>copy()</code>","text":"<p>Makes copy of termlist.</p> <p>Returns:</p> Type Description <code>TermList_t</code> <p>Copy of termlist.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def copy(self: TermList_t) -&gt; TermList_t:\n\"\"\"\n    Makes copy of termlist.\n\n    Returns:\n        Copy of termlist.\n    \"\"\"\n    return type(self)([term.copy() for term in self.terms])\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.elim_vars_by_refining","title":"<code>elim_vars_by_refining(context, vars_to_elim)</code>  <code>abstractmethod</code>","text":"<p>Eliminate variables from termlist by refining it in a context.</p> <p>Given a context \\(\\Gamma\\), and the list of terms contained in self, \\(s\\), this routine identifies a TermList \\(x\\) lacking variables vars_to_elim such that \\(\\frac{\\Gamma\\colon \\; x}{\\Gamma: \\; s}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>TermList_t</code> <p>List of context terms that will be used to refine the TermList.</p> required <code>vars_to_elim</code> <code>List[Var]</code> <p>Variables to be eliminated.</p> required <p>Returns:</p> Type Description <code>TermList_t</code> <p>A list of terms not containing any variables in <code>vars_to_elim</code></p> <code>TermList_t</code> <p>and which, in the context provided, imply the terms contained in the</p> <code>TermList_t</code> <p>calling termlist.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef elim_vars_by_refining(self: TermList_t, context: TermList_t, vars_to_elim: List[Var]) -&gt; TermList_t:\n\"\"\"\n    Eliminate variables from termlist by refining it in a context.\n\n    Given a context $\\\\Gamma$, and the list of terms contained in self,\n    $s$, this routine identifies a TermList $x$ lacking variables\n    vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; x}{\\\\Gamma: \\\\;\n    s}$.\n\n    Args:\n        context:\n            List of context terms that will be used to refine the TermList.\n        vars_to_elim:\n            Variables to be eliminated.\n\n    Returns:\n        A list of terms not containing any variables in `vars_to_elim`\n        and which, in the context provided, imply the terms contained in the\n        calling termlist.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.elim_vars_by_relaxing","title":"<code>elim_vars_by_relaxing(context, vars_to_elim)</code>  <code>abstractmethod</code>","text":"<p>Eliminate variables from termlist by relaxing it in a context</p> <p>Given a context \\(\\Gamma\\), and the list of terms contained in self, \\(s\\), this routine identifies a formula \\(x\\) lacking variables vars_to_elim such that \\(\\frac{\\Gamma\\colon \\; s}{\\Gamma: \\; x}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>TermList_t</code> <p>List of context terms that will be used to abstract the TermList.</p> required <code>vars_to_elim</code> <code>List[Var]</code> <p>Variables that cannot be present in TermList after relaxation.</p> required <p>Returns:</p> Type Description <code>TermList_t</code> <p>A list of terms not containing any variables in <code>vars_to_elim</code></p> <code>TermList_t</code> <p>and which, in the context provided, are implied by the terms</p> <code>TermList_t</code> <p>contained in the calling termlist.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef elim_vars_by_relaxing(self: TermList_t, context: TermList_t, vars_to_elim: List[Var]) -&gt; TermList_t:\n\"\"\"\n    Eliminate variables from termlist by relaxing it in a context\n\n    Given a context $\\\\Gamma$, and the list of terms contained in self,\n    $s$, this routine identifies a formula $x$ lacking variables\n    vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; s}{\\\\Gamma: \\\\;\n    x}$.\n\n    Args:\n        context:\n            List of context terms that will be used to abstract the TermList.\n        vars_to_elim:\n            Variables that cannot be present in TermList after relaxation.\n\n    Returns:\n        A list of terms not containing any variables in `vars_to_elim`\n        and which, in the context provided, are implied by the terms\n        contained in the calling termlist.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.get_terms_with_vars","title":"<code>get_terms_with_vars(variable_list)</code>","text":"<p>Returns the list of terms which contain any of the variables indicated.</p> <p>Parameters:</p> Name Type Description Default <code>variable_list</code> <code>List[Var]</code> <p>a list of variables being sought in current TermList.</p> required <p>Returns:</p> Type Description <code>TermList_t</code> <p>The list of terms which contain any of the variables indicated.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def get_terms_with_vars(self: TermList_t, variable_list: List[Var]) -&gt; TermList_t:\n\"\"\"\n    Returns the list of terms which contain any of the variables indicated.\n\n    Args:\n        variable_list: a list of variables being sought in current TermList.\n\n    Returns:\n        The list of terms which contain any of the variables indicated.\n    \"\"\"\n    terms = []\n    for t in self.terms:\n        if list_intersection(t.vars, variable_list):\n            terms.append(t)\n    return type(self)(terms)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.is_empty","title":"<code>is_empty()</code>  <code>abstractmethod</code>","text":"<p>Tell whether the termlist has no satisfying assignments.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if termlist constraints cannot be satisfied.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef is_empty(self) -&gt; bool:\n\"\"\"\n    Tell whether the termlist has no satisfying assignments.\n\n    Returns:\n        True if termlist constraints cannot be satisfied.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.refines","title":"<code>refines(other)</code>  <code>abstractmethod</code>","text":"<p>Tell whether the argument is a larger specification.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>TermList_t</code> <p>TermList against which we are comparing self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>self &lt;= other.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef refines(self: TermList_t, other: TermList_t) -&gt; bool:\n\"\"\"\n    Tell whether the argument is a larger specification.\n\n    Args:\n        other:\n            TermList against which we are comparing self.\n\n    Returns:\n        self &lt;= other.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a termlist.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>TermList_t</code> <p>A termlist with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def rename_variable(self: TermList_t, source_var: Var, target_var: Var) -&gt; TermList_t:\n\"\"\"\n    Rename a variable in a termlist.\n\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n\n    Returns:\n        A termlist with `source_var` replaced by `target_var`.\n    \"\"\"\n    return type(self)([term.rename_variable(source_var, target_var) for term in self.terms])\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.simplify","title":"<code>simplify(context=None)</code>  <code>abstractmethod</code>","text":"<p>Remove redundant terms in TermList.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Optional[TermList_t]</code> <p>List of context terms that will be used to remove redundancies in the TermList.</p> <code>None</code> <p>Returns:</p> Type Description <code>TermList_t</code> <p>Let \\(S\\) be this TermList. Simplify will return \\(S_T = S \\setminus T\\)</p> <code>TermList_t</code> <p>where \\(T \\subseteq S\\) is a maximal subset such that $\\frac{\\Gamma, S_T\\colon \\;</p> <code>TermList_t</code> <p>\\top}{\\Gamma, S_T\\colon \\; \\wedge_{t \\in T} t}$.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef simplify(self: TermList_t, context: Optional[TermList_t] = None) -&gt; TermList_t:\n\"\"\"Remove redundant terms in TermList.\n\n    Args:\n        context:\n            List of context terms that will be used to remove redundancies in\n            the TermList.\n\n    Returns:\n        Let $S$ be this TermList. Simplify will return $S_T = S \\\\setminus T$\n        where $T \\\\subseteq S$ is a maximal subset such that $\\\\frac{\\\\Gamma, S_T\\\\colon \\\\;\n        \\\\top}{\\\\Gamma, S_T\\\\colon \\\\; \\\\wedge_{t \\\\in T} t}$.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Var","title":"<code>Var</code>","text":"<p>Variables used in system modeling.</p> <p>Variables allow us to name an entity for which we want to write constraints.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>class Var:\n\"\"\"\n    Variables used in system modeling.\n\n    Variables allow us to name an entity for which we want to write constraints.\n    \"\"\"\n\n    def __init__(self, varname: str):\n\"\"\"\n        Constructor for Var.\n\n        Args:\n            varname: The name of the variable.\n        \"\"\"\n        self._name = str(varname)\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"The name of the variable.\n\n        Returns:\n            The name of the variable.\n        \"\"\"\n        return self._name\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            raise ValueError()\n        return self.name == other.name\n\n    def __str__(self) -&gt; str:\n        return self.name\n\n    def __hash__(self) -&gt; int:\n        return hash(self.name)\n\n    def __repr__(self) -&gt; str:\n        return \"&lt;Var {0}&gt;\".format(self.name)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Var.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The name of the variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the variable.</p>"},{"location":"iocontract/#pacti.iocontract.iocontract.Var.__init__","title":"<code>__init__(varname)</code>","text":"<p>Constructor for Var.</p> <p>Parameters:</p> Name Type Description Default <code>varname</code> <code>str</code> <p>The name of the variable.</p> required Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def __init__(self, varname: str):\n\"\"\"\n    Constructor for Var.\n\n    Args:\n        varname: The name of the variable.\n    \"\"\"\n    self._name = str(varname)\n</code></pre>"},{"location":"license/","title":"License","text":"<pre><code>BSD 3-Clause License\n\nCopyright (c) 2023, California Institute of Technology\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</code></pre>"},{"location":"team/","title":"Team","text":"<p>The Pacti development team is led by Inigo Incer and consists of Apurva Badithela, Josefine Graebener, Piergiuseppe Mallozzi, Ayush Pandey, Nicolas Rouquette, and Sheng-Jung Yu.</p> <p>The Pacti project is advised by  Albert Benveniste, Benoit Caillaud, Richard M. Murray, Alberto Sangiovanni-Vincentelli, and Sanjit A. Seshia.</p>"},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/","title":"Synthetic Biology","text":"<p>Research in synthetic biology has accelerated in the past decade due to its enormous promise in engineering biological systems for desired behavior (here's a review article on synthetic biology, and here's another). Applications range from biomedicine to engineered living materials and environmental remediation. From a design standpoint, mathematical models have been used to study the behavior of biological systems and analyze various properties (see for example this modeling paper). However, current experimental design approaches in synthetic biology are largely heuristics and trial-and-error based, hence, difficult to scale. To alleviate this, various modeling and analysis and logic gate design tools (like Cello) have been proposed but none have yet been used to successfully design large biological circuits. We believe that the Pacti framework holds the potential to address this issue of scale due to its generality in writing system specifications and in decoupling the modeling details of each component from their specification.</p> <p></p> <p>Some notes on the biological jargon in this notebook: 0. Genetic circuit: A biological system (DNA/group of DNA/DNA and other enzymes, or any other engineered biological system)</p> <ol> <li>Protein Expression: This simply means the process of production of a protein, often used when talking about the quantitiy of the protein that is produced.</li> <li>Inducer: A chemical that is used as an input to \"induce\" a system, that is, a chemical that switched something ON.</li> <li>Plasmid: A plasmid is a small DNA molecule within a cell. Often used interchangeably in this notebook with a \"gene\".</li> <li>Regulator: A system or a molecule that controls (regulates) something else (expression of a protein or a chemical or enzyme).</li> <li>RPU: This stands for relative promoter units, this is a commonly used unit to measure the quantity of a protein output. You can think of RPU as an analogoue of concentration of a protein.</li> <li>Fold-change: The ratio between the ON and the OFF level of something. You can think of fold-change as \"SNR\" - the ratio between the output of the system when it is ON (there is a signal that we measure, in this case, RFP) and when it is OFF (so there is only some noisy output, which we refer to as the \"leak value of RFP\").</li> </ol> <p>This case study shows the use of Pacti to aid the design of engineered biological circuits for altering and observing the dynamics of bacterial gene transfer in soil and its effects on protein expression in plants (schematic shown in Figure A above). As the full system design is large, we focus on the design of a biological NAND gate system. This system has three subsystems, as shown in Figure B. We will use contract composition as part of an optimization strategy to maximize the system fold-change, defined as the ratio between the on and off levels of the system's output. The quotient will be used to infer a specification of a missing subsystem that needs to be designed in our system. We say that an input or an output is \"ON\" when its level is higher than a minimum  threshold, and is \"OFF\" when its level is lower than a maximum threshold. We formalize these notions with polyhedral constraints in the contract descriptions.</p> <p>The biological NAND gate consists of the three subsystems:</p> <ol> <li><p>a sensor with tetracycline (aTc) input that outputs a dCas9 protein,</p> </li> <li><p>another sensor (to be chosen) that outputs the xRFP-gRNA protein, and</p> </li> <li><p>a dCas9 repressor subsystem, which takes as inputs the xRFP-gRNA and the dCas9 proteins.</p> </li> </ol> <p>When both inputs to this repressor subsystem are ON, it suppresses the output, RFP, a red fluorescent protein. RFP is also the output of the top-level system. RFP is ON only when either of the sensors inputs are OFF. In this way, the system behavior is that of a NAND logic gate. We will denote the contract for the tetracycline sensor as $C_{\\text{aTc}}$, and the contract for dCas9 repression mechanism as $C_{\\text{dCas9}}$. Our first task will be to find the second sensor (choose spec for subsystem 2) that maximizes the top-level system fold-change. Then we will consider the task of finding a specification for the repression component (subsystem 3) assuming that the contracts for both sensors and the top-level system are available.</p> <p>Biological motivation:</p> <p>The input in this system design is a target gene of interest introduced in the soil through bacteria. The goal is to measure the protein expression of the plant in response to the target gene input. The way we detect whether this gene is present is with many different complex biological processes and the output of whether we detect the gene, is \"read out\" from the plant leaf. So, the input is the gene of interest that we want to detect and the output is the protein production out of the plants (measured as protein fluorescence). Designing such a biological system is difficult due to the lack of information about key biological mechanisms, absence of characterization data for system parts, unknown effects of the soil context, etc. There are many biological processes that would need to be engineered to build a system like this but we focus on a small part of it =&gt; the engineered bacteria (see Figure). We assume that the top-level designer has asked us to design this functionally complete bacteria as a NAND gate to serve the overall purpose. To optimize the design, we would like the bacterial system to maximize its fold-change, that is, maximize the ratio of its output in the on and the off levels (fold-change = output on / output off).</p> <p>To summarize, we address the following three tasks in this notebook:</p> <ol> <li>Characterized library of parts as assume-guarantee contracts: Using existing experimental data from literature, we present a library of sensors as assume-guarantee contracts that can be used to reason about specifications of diverse biological circuits. For the engineered bacteria case study, we use previously published data (for the Marionette cell lines) to construct a library of 14 sensors.</li> <li>Speeding up the experimental design: Current experimental design approaches in synthetic biology are heavily reliant on screening experiments where all possible choices are explored experimentally to choose the one that works. This is not only time consuming and expensive but also does not scale beyond three or four independent choices. With the use of Pacti , we demonstrate how scientists may describe the desired top-level behavior as contracts and then computationally choose from a library of available parts to ensure that the components meet the top-level system specification. For the engineered bacteria case study, we find the specification of the sensors that meet the top-level criteria on fold-change of the circuit response.</li> <li>Finding specifications of missing parts: In synthetic biology, it is common to have parts in the system for which no characterization data is available. Using quotient operation on contracts, we can find the constraints that this missing part must satisfy to meet the desired top-level criteria. For the bacterial case study, we find the missing contract of the dCas9-mediated repression mechanism (as shown in the B panel of the Figure above) for which characterization data is not available in the literature.</li> </ol> In\u00a0[2]: Copied! <pre># Load the Pandas library to read experimental data from the Marionette paper [1]\nimport pandas as pd\n# Import pacti PolyhedralContract class to read contracts\nfrom pacti.terms.polyhedra import PolyhedralContract\n# Import utility functions for this case study\nfrom utils.synbio_utils import display_sensor_contracts, remove_quantization_errors\n# Import pacti PolyhedralContract parent for operations on guarantees\nimport pacti.terms.polyhedra as gtp\n# Import pacti function to write contracts to a file\nfrom pacti import write_contracts_to_file\n# Import matplotlib for plotting\nimport matplotlib.pyplot as plt\n# Import Python symbolic computation library: sympy\nimport sympy\n# Import Python numpy\nimport numpy as np\n</pre> # Load the Pandas library to read experimental data from the Marionette paper [1] import pandas as pd # Import pacti PolyhedralContract class to read contracts from pacti.terms.polyhedra import PolyhedralContract # Import utility functions for this case study from utils.synbio_utils import display_sensor_contracts, remove_quantization_errors # Import pacti PolyhedralContract parent for operations on guarantees import pacti.terms.polyhedra as gtp # Import pacti function to write contracts to a file from pacti import write_contracts_to_file # Import matplotlib for plotting import matplotlib.pyplot as plt # Import Python symbolic computation library: sympy import sympy # Import Python numpy import numpy as np In\u00a0[3]: Copied! <pre># Read the data from the paper using the CSV file \"marionette_data.csv\"\ndf = pd.read_csv(\"data/marionette_data.csv\", delimiter=\",\", engine=\"python\")\n\ndf\n</pre> # Read the data from the paper using the CSV file \"marionette_data.csv\" df = pd.read_csv(\"data/marionette_data.csv\", delimiter=\",\", engine=\"python\")  df Out[3]: Inducer Plasmid Regulator Promoter ymax (RPU) ymin (RPUx10-3) K (\u00b5M) n Dynamic range start ymax Linear 0 DAPG pAJM.847 PhlFAM PPhlF 2.50 2.5 1.700 2.1 1000 0.0300 2.00 1 Cuma pAJM.657 CymRAM PCymRC 3.70 4.3 8.900 2.4 870 0.3000 2.00 2 OC6 pAJM.474 LuxR PLuxB 1.30 2.4 0.120 1.8 540 0.0020 0.50 3 Van pAJM.773 VanRAM PVanCC 3.00 2.4 26.000 2.3 1200 1.0000 1.80 4 IPTG pAJM.336 LacIAM PTac 3.30 4.8 140.000 1.8 690 2.0000 1.50 5 aTc pAJM.011 TetR PTet* 2.40 4.9 0.013 3.8 500 0.0018 1.00 6 Ara pAJM.677 AraCAM PBAD 1.20 2.4 37.000 1.5 500 0.2000 0.70 7 Cho pAJM.683 BetIAM PBetI 2.60 8.5 4100.000 2.7 310 300.0000 0.90 8 Nar pAJM.661 TtgRAM PTtg 0.46 3.4 95.000 1.9 140 2.0000 0.20 9 DHBA pAJM.690 PcaUAM P3B5B 1.60 4.5 370.000 1.8 360 9.0000 1.00 10 Sal pAJM.771 NahRAM PSalTTC 2.80 4.7 43.000 1.8 600 0.9000 1.30 11 OHC14 pAJM.1642 CinRAM PCin 1.50 3.0 0.430 2.3 490 0.0160 0.70 12 Acr pAJM.884 AcuRAM PAcu 3.10 37.0 130.000 2.5 83 10.0000 1.70 13 Ery pAJM.969 MphRAM PMph 0.29 8.0 65.000 1.5 36 2.0000 0.18 <p>Create contracts for the sensor using this experimental data:</p> In\u00a0[4]: Copied! <pre>def create_sensor_contracts(sensor_input=\"AHL\", output=\"FP\", K=0.0, yleak=0.0,\n                            start=0.0, ymax_lin=0.0):\n\"\"\"\n    Creates the contracts for a Marionette sensing subsystem\n    params:\n        * input (str): The inducer input to the sensor\n        * output (str): The output of the genetic construct.\n                        Inducer activates the production of this output\n        * K (float): The value of the Hill activation parameter K\n        * yleak (float): The minimum expression of output even\n                         in absence of inducer\n        * start (float): The value of inducer at which the induction starts\n        * ymax_lin (float): The maximum expression of output by the inducer\n                            before saturating (the end of linear regime)\n    \"\"\"\n    slope = (ymax_lin - yleak) / (K - start)\n    intercept = yleak - slope * start\n    contract_0 = PolyhedralContract.from_string(\n        input_vars=[sensor_input],\n        output_vars=[output],\n        assumptions=[f\"{sensor_input} &lt;= {start}\"],\n        guarantees=[f\"{output} &lt;= {yleak}\"]\n    )\n    contract_lin = PolyhedralContract.from_string(\n        input_vars=[sensor_input],\n        output_vars=[output],\n        assumptions=[\n            f\"{sensor_input} &lt;= {K}\",\n            f\"-{sensor_input} &lt;= {-1 * start}\"\n        ],\n        guarantees=[\n            f\"-{output} + {slope}{sensor_input} &lt;= {intercept}\",\n            f\"{output} - {slope}{sensor_input} &lt;= {-1*intercept}\"\n        ]\n    )\n    contract_max = PolyhedralContract.from_string(\n        input_vars=[sensor_input],\n        output_vars=[output],\n        assumptions=[\n            f\"-{sensor_input} &lt;= {-1 * K}\"\n        ],\n        guarantees=[\n            f\"-{output} &lt;= {-1 * ymax_lin}\"\n        ]\n    )\n    return contract_0, contract_lin, contract_max\n</pre> def create_sensor_contracts(sensor_input=\"AHL\", output=\"FP\", K=0.0, yleak=0.0,                             start=0.0, ymax_lin=0.0):     \"\"\"     Creates the contracts for a Marionette sensing subsystem     params:         * input (str): The inducer input to the sensor         * output (str): The output of the genetic construct.                         Inducer activates the production of this output         * K (float): The value of the Hill activation parameter K         * yleak (float): The minimum expression of output even                          in absence of inducer         * start (float): The value of inducer at which the induction starts         * ymax_lin (float): The maximum expression of output by the inducer                             before saturating (the end of linear regime)     \"\"\"     slope = (ymax_lin - yleak) / (K - start)     intercept = yleak - slope * start     contract_0 = PolyhedralContract.from_string(         input_vars=[sensor_input],         output_vars=[output],         assumptions=[f\"{sensor_input} &lt;= {start}\"],         guarantees=[f\"{output} &lt;= {yleak}\"]     )     contract_lin = PolyhedralContract.from_string(         input_vars=[sensor_input],         output_vars=[output],         assumptions=[             f\"{sensor_input} &lt;= {K}\",             f\"-{sensor_input} &lt;= {-1 * start}\"         ],         guarantees=[             f\"-{output} + {slope}{sensor_input} &lt;= {intercept}\",             f\"{output} - {slope}{sensor_input} &lt;= {-1*intercept}\"         ]     )     contract_max = PolyhedralContract.from_string(         input_vars=[sensor_input],         output_vars=[output],         assumptions=[             f\"-{sensor_input} &lt;= {-1 * K}\"         ],         guarantees=[             f\"-{output} &lt;= {-1 * ymax_lin}\"         ]     )     return contract_0, contract_lin, contract_max In\u00a0[5]: Copied! <pre># Create all sensor contracts:\nsensor_names = [str(i) for i in df[\"Inducer\"]]\nsensor_library = {}\nsensor_library_params = {}\nfor sensor in sensor_names:\n    sensor_params = {}\n    yleak_s = df.loc[df[\"Inducer\"] == sensor][\"ymin (RPUx10-3)\"].values[0]\n    yleak_s = yleak_s * 1e-3\n    s_start = df.loc[df[\"Inducer\"] == sensor][\"start\"].values[0]\n    s_K = df.loc[df[\"Inducer\"] == sensor][\"K (\u00b5M)\"].values[0]\n    ymax_s = df.loc[df[\"Inducer\"] == sensor][\"ymax Linear\"].values[0]\n    sensor_params = {\"leak\": yleak_s, \"start\": s_start,\n                     \"K\": s_K, \"ymax\": ymax_s}\n    s_output = \"dCas9\"\n    contract_s_0, contract_s_lin, contract_s_max = create_sensor_contracts(\n        sensor_input=sensor, output=\"xRFP\", start=s_start, K=s_K,\n        ymax_lin=ymax_s, yleak=yleak_s\n    )\n    sensor_library[sensor] = [contract_s_0, contract_s_lin, contract_s_max]\n    sensor_library_params[sensor] = sensor_params\n</pre> # Create all sensor contracts: sensor_names = [str(i) for i in df[\"Inducer\"]] sensor_library = {} sensor_library_params = {} for sensor in sensor_names:     sensor_params = {}     yleak_s = df.loc[df[\"Inducer\"] == sensor][\"ymin (RPUx10-3)\"].values[0]     yleak_s = yleak_s * 1e-3     s_start = df.loc[df[\"Inducer\"] == sensor][\"start\"].values[0]     s_K = df.loc[df[\"Inducer\"] == sensor][\"K (\u00b5M)\"].values[0]     ymax_s = df.loc[df[\"Inducer\"] == sensor][\"ymax Linear\"].values[0]     sensor_params = {\"leak\": yleak_s, \"start\": s_start,                      \"K\": s_K, \"ymax\": ymax_s}     s_output = \"dCas9\"     contract_s_0, contract_s_lin, contract_s_max = create_sensor_contracts(         sensor_input=sensor, output=\"xRFP\", start=s_start, K=s_K,         ymax_lin=ymax_s, yleak=yleak_s     )     sensor_library[sensor] = [contract_s_0, contract_s_lin, contract_s_max]     sensor_library_params[sensor] = sensor_params In\u00a0[6]: Copied! <pre>fig, all_ax = plt.subplots(nrows=3, ncols=5, figsize=(32, 20))\nindex = 0\nfor sensor in sensor_names:\n    ax = all_ax[index // 5][index % 5]\n    index += 1\n    yleak_s = df.loc[df[\"Inducer\"] == sensor][\"ymin (RPUx10-3)\"].values[0]\n    yleak_s = yleak_s * 1e-3\n    s_start = df.loc[df[\"Inducer\"] == sensor][\"start\"].values[0]\n    s_K = df.loc[df[\"Inducer\"] == sensor][\"K (\u00b5M)\"].values[0]\n    ymax_s = df.loc[df[\"Inducer\"] == sensor][\"ymax Linear\"].values[0]\n    ax = display_sensor_contracts(\n        sensor_input=sensor,\n        output=\"\",\n        leak=yleak_s,\n        start=s_start,\n        K=s_K,\n        ymax_lin=ymax_s,\n        xlim_min=10**-3,\n        xlim_max=10**4,\n        ylim_min=10**-3,\n        ylim_max=10**2,\n        ax=ax,\n        show=False,\n    )\n    ax.set_xlabel(sensor, fontsize=16)\n    ax.tick_params(axis=\"both\", which=\"major\", labelsize=16)\n    ax.set_ylabel(\"Output\", fontsize=16)\n    ax.legend(fontsize=16)\nall_ax[2][4].set_axis_off()\n# plt.savefig('all_sensors.svg')\nplt.show()\n</pre> fig, all_ax = plt.subplots(nrows=3, ncols=5, figsize=(32, 20)) index = 0 for sensor in sensor_names:     ax = all_ax[index // 5][index % 5]     index += 1     yleak_s = df.loc[df[\"Inducer\"] == sensor][\"ymin (RPUx10-3)\"].values[0]     yleak_s = yleak_s * 1e-3     s_start = df.loc[df[\"Inducer\"] == sensor][\"start\"].values[0]     s_K = df.loc[df[\"Inducer\"] == sensor][\"K (\u00b5M)\"].values[0]     ymax_s = df.loc[df[\"Inducer\"] == sensor][\"ymax Linear\"].values[0]     ax = display_sensor_contracts(         sensor_input=sensor,         output=\"\",         leak=yleak_s,         start=s_start,         K=s_K,         ymax_lin=ymax_s,         xlim_min=10**-3,         xlim_max=10**4,         ylim_min=10**-3,         ylim_max=10**2,         ax=ax,         show=False,     )     ax.set_xlabel(sensor, fontsize=16)     ax.tick_params(axis=\"both\", which=\"major\", labelsize=16)     ax.set_ylabel(\"Output\", fontsize=16)     ax.legend(fontsize=16) all_ax[2][4].set_axis_off() # plt.savefig('all_sensors.svg') plt.show() <p>Write the contract for the dCas9 repression mechanism</p> In\u00a0[7]: Copied! <pre>dCas9_contract_off = PolyhedralContract.from_string(\n    # \"xRFP:OFF, dCas9:OFF, RFP:ON\",\n    input_vars=[\"xRFP\", \"dCas9\"],\n    output_vars=[\"RFP\"],\n    assumptions=[\n        \"xRFP &lt;= 0.2\",\n        \"dCas9 &lt;= 0.1\"\n    ],\n    guarantees=[\n        \"-RFP &lt;= -10\"\n    ]\n)\n\ndCas9_contract_on = PolyhedralContract.from_string(\n    # \"The dCas9 repression: xRFP:ON, dCas9:ON, RFP:OFF\",\n    input_vars=[\"xRFP\", \"dCas9\"],\n    output_vars=[\"RFP\"],\n    assumptions=[\n        \"-xRFP &lt;= -0.3\",\n        \"xRFP &lt;= 1\",\n        \"-dCas9 &lt;= -0.1\",\n        \"dCas9 &lt;= 0.8\"\n    ],\n    guarantees=[\n        \"RFP + 2xRFP + 0.1dCas9 &lt;= 5\"\n    ]\n)\n</pre> dCas9_contract_off = PolyhedralContract.from_string(     # \"xRFP:OFF, dCas9:OFF, RFP:ON\",     input_vars=[\"xRFP\", \"dCas9\"],     output_vars=[\"RFP\"],     assumptions=[         \"xRFP &lt;= 0.2\",         \"dCas9 &lt;= 0.1\"     ],     guarantees=[         \"-RFP &lt;= -10\"     ] )  dCas9_contract_on = PolyhedralContract.from_string(     # \"The dCas9 repression: xRFP:ON, dCas9:ON, RFP:OFF\",     input_vars=[\"xRFP\", \"dCas9\"],     output_vars=[\"RFP\"],     assumptions=[         \"-xRFP &lt;= -0.3\",         \"xRFP &lt;= 1\",         \"-dCas9 &lt;= -0.1\",         \"dCas9 &lt;= 0.8\"     ],     guarantees=[         \"RFP + 2xRFP + 0.1dCas9 &lt;= 5\"     ] ) In\u00a0[8]: Copied! <pre># Our 2nd input is aTc that outputs \"dCas9\"\n# Create the contracts for this sensor\n# using our `create_sensor_contracts` function\ninput2 = \"aTc\"\nin2_params = sensor_library_params[input2]\nc_atc_off, c_atc_on, c_atc_sat = create_sensor_contracts(sensor_input=\"aTc\",\n                                                         output=\"dCas9\",\n                                                         start=in2_params\n                                                         [\"start\"],\n                                                         K=in2_params[\"K\"],\n                                                         ymax_lin=in2_params\n                                                         [\"ymax\"],\n                                                         yleak=in2_params\n                                                         [\"leak\"])\n# Now we will go through all other sensors and\n# find out which are OK to use given the context\nsensor_ok = {}\n# We will store all sensor names that are not compatible in a dictionary:\ndesign_error = {}\n# We will store the fold-change for all the\n# sensors that are OK in this dictionary:\nfold_change = {}\n# Desired fold change: RFP_on/RFP_off\ndesired_fold_change = 4\n# Go through all sensors in the library except aTc,\n# since that has been chosen for the 2nd subsystem\nfor sensor in sensor_library:\n    if sensor == \"aTc\":\n        continue\n    in1_params = sensor_library_params[sensor]\n    # OFF condition\n    # (note that RFP will be ON for this, so we will calculate \"rfp_vals_on\")\n    c_sensor1 = sensor_library[sensor][0]\n    c_sensor2 = c_atc_off\n    # Compose the sensors together\n    # (if allowed! =&gt; Handle exceptions of the Pacti\n    # design error if composition is not allowed)\n    try:\n        sensor_comp = c_sensor2.compose(c_sensor1)\n        top_level_off = sensor_comp.compose(dCas9_contract_off)\n    except ValueError as e:\n        # If Pacti raises a ValueError saying that the composition was\n        # \"unsatisfiable in context\", then that\n        # means that this sensor will not work!\n        if \"unsatisfiable in context\" in str(e):\n            sensor_ok[sensor] = False\n    else:\n        sensor_ok[sensor] = True\n        # If the try block succeeds, this block runs\n        # Remove quantization errors that are introduced in solving equations\n        top_level_off = remove_quantization_errors(top_level_off)\n        # Get the guarantee term and evaluate it\n        sym_expr = gtp.PolyhedralTerm.to_symbolic(top_level_off.g.terms[0])\n        rfp_vals_on = {}\n        updated_sym = sym_expr.subs(sensor, 0.9 * in1_params[\"start\"])\n        updated_sym = updated_sym.subs(input2, 0.9 * in2_params[\"start\"])\n        subs_val = sympy.solve(updated_sym, \"RFP\")\n        rfp_vals_on[in1_params[\"start\"], in2_params[\"start\"]] = subs_val[0]\n\n    # ON condition\n    # (note that RFP will be OFF for this, so we will calculate \"rfp_vals_off\")\n    c_sensor1 = sensor_library[sensor][1]\n    c_sensor2 = c_atc_on\n    # Compose the sensors together\n    # (if allowed! =&gt; Handle exceptions of the Pacti\n    # design error if composition is not allowed)\n    try:\n        sensor_comp = c_sensor2.compose(c_sensor1)\n        top_level_on = sensor_comp.compose(dCas9_contract_on)\n    except ValueError as e:\n        # If Pacti raises a ValueError saying that the composition was\n        # \"unsatisfiable in context\", then that means\n        # that this sensor will not work!\n        if \"unsatisfiable in context\" in str(e):\n            design_error[sensor] = False\n    else:\n        design_error[sensor] = True\n        # If the try block succeeds, this block runs\n        # Remove quantization errors that are introduced in solving equations\n        top_level_on = remove_quantization_errors(top_level_on)\n        # Get the guarantee term and evaluate it\n        sym_expr = gtp.PolyhedralTerm.to_symbolic(top_level_on.g.terms[0])\n        rfp_vals_off = {}\n        updated_sym = sym_expr.subs(sensor, 0.9 * in1_params[\"K\"])\n        updated_sym = updated_sym.subs(input2, 0.9 * in2_params[\"K\"])\n        subs_val = sympy.solve(updated_sym, \"RFP\")\n        rfp_vals_off[in1_params[\"K\"], in2_params[\"K\"]] = subs_val[0]\n    # Now that we have rfp_vals_on and rfp_vals_off,\n    # we can compute the fold change:\n    if design_error[sensor]:\n        RFP_on = list(rfp_vals_on.values())[0]\n        RFP_off = list(rfp_vals_off.values())[0]\n        fold_change[sensor] = RFP_on / RFP_off\n        if fold_change[sensor] &gt; desired_fold_change:\n            sensor_ok[sensor] = True\n        else:\n            sensor_ok[sensor] = False\n</pre> # Our 2nd input is aTc that outputs \"dCas9\" # Create the contracts for this sensor # using our `create_sensor_contracts` function input2 = \"aTc\" in2_params = sensor_library_params[input2] c_atc_off, c_atc_on, c_atc_sat = create_sensor_contracts(sensor_input=\"aTc\",                                                          output=\"dCas9\",                                                          start=in2_params                                                          [\"start\"],                                                          K=in2_params[\"K\"],                                                          ymax_lin=in2_params                                                          [\"ymax\"],                                                          yleak=in2_params                                                          [\"leak\"]) # Now we will go through all other sensors and # find out which are OK to use given the context sensor_ok = {} # We will store all sensor names that are not compatible in a dictionary: design_error = {} # We will store the fold-change for all the # sensors that are OK in this dictionary: fold_change = {} # Desired fold change: RFP_on/RFP_off desired_fold_change = 4 # Go through all sensors in the library except aTc, # since that has been chosen for the 2nd subsystem for sensor in sensor_library:     if sensor == \"aTc\":         continue     in1_params = sensor_library_params[sensor]     # OFF condition     # (note that RFP will be ON for this, so we will calculate \"rfp_vals_on\")     c_sensor1 = sensor_library[sensor][0]     c_sensor2 = c_atc_off     # Compose the sensors together     # (if allowed! =&gt; Handle exceptions of the Pacti     # design error if composition is not allowed)     try:         sensor_comp = c_sensor2.compose(c_sensor1)         top_level_off = sensor_comp.compose(dCas9_contract_off)     except ValueError as e:         # If Pacti raises a ValueError saying that the composition was         # \"unsatisfiable in context\", then that         # means that this sensor will not work!         if \"unsatisfiable in context\" in str(e):             sensor_ok[sensor] = False     else:         sensor_ok[sensor] = True         # If the try block succeeds, this block runs         # Remove quantization errors that are introduced in solving equations         top_level_off = remove_quantization_errors(top_level_off)         # Get the guarantee term and evaluate it         sym_expr = gtp.PolyhedralTerm.to_symbolic(top_level_off.g.terms[0])         rfp_vals_on = {}         updated_sym = sym_expr.subs(sensor, 0.9 * in1_params[\"start\"])         updated_sym = updated_sym.subs(input2, 0.9 * in2_params[\"start\"])         subs_val = sympy.solve(updated_sym, \"RFP\")         rfp_vals_on[in1_params[\"start\"], in2_params[\"start\"]] = subs_val[0]      # ON condition     # (note that RFP will be OFF for this, so we will calculate \"rfp_vals_off\")     c_sensor1 = sensor_library[sensor][1]     c_sensor2 = c_atc_on     # Compose the sensors together     # (if allowed! =&gt; Handle exceptions of the Pacti     # design error if composition is not allowed)     try:         sensor_comp = c_sensor2.compose(c_sensor1)         top_level_on = sensor_comp.compose(dCas9_contract_on)     except ValueError as e:         # If Pacti raises a ValueError saying that the composition was         # \"unsatisfiable in context\", then that means         # that this sensor will not work!         if \"unsatisfiable in context\" in str(e):             design_error[sensor] = False     else:         design_error[sensor] = True         # If the try block succeeds, this block runs         # Remove quantization errors that are introduced in solving equations         top_level_on = remove_quantization_errors(top_level_on)         # Get the guarantee term and evaluate it         sym_expr = gtp.PolyhedralTerm.to_symbolic(top_level_on.g.terms[0])         rfp_vals_off = {}         updated_sym = sym_expr.subs(sensor, 0.9 * in1_params[\"K\"])         updated_sym = updated_sym.subs(input2, 0.9 * in2_params[\"K\"])         subs_val = sympy.solve(updated_sym, \"RFP\")         rfp_vals_off[in1_params[\"K\"], in2_params[\"K\"]] = subs_val[0]     # Now that we have rfp_vals_on and rfp_vals_off,     # we can compute the fold change:     if design_error[sensor]:         RFP_on = list(rfp_vals_on.values())[0]         RFP_off = list(rfp_vals_off.values())[0]         fold_change[sensor] = RFP_on / RFP_off         if fold_change[sensor] &gt; desired_fold_change:             sensor_ok[sensor] = True         else:             sensor_ok[sensor] = False In\u00a0[9]: Copied! <pre>fig, ax = plt.subplots()\nax.bar(fold_change.keys(), fold_change.values(), color=\"C1\", alpha=0.5)\nax.set_xlabel(\"Sensor\", fontsize=14)\nax.set_ylabel(\"Top-level fold-change\", fontsize=14)\nplt.xticks(rotation=45, fontsize=14)\nplt.yticks(fontsize=14)\nplt.show()\n</pre> fig, ax = plt.subplots() ax.bar(fold_change.keys(), fold_change.values(), color=\"C1\", alpha=0.5) ax.set_xlabel(\"Sensor\", fontsize=14) ax.set_ylabel(\"Top-level fold-change\", fontsize=14) plt.xticks(rotation=45, fontsize=14) plt.yticks(fontsize=14) plt.show() <p>Choose subsystem 1 using the above exploration chart as the sensor that gives the highest-fold change:</p> <p>We choose \"Cuma\" with the contract:</p> In\u00a0[10]: Copied! <pre>for contract in sensor_library[\"Cuma\"]:\n    print(contract)\n</pre> for contract in sensor_library[\"Cuma\"]:     print(contract) <pre>InVars: [Cuma]\nOutVars:[xRFP]\nA: [\n  Cuma &lt;= 0.3\n]\nG: [\n  xRFP &lt;= 0.0042999999999999705\n]\nInVars: [Cuma]\nOutVars:[xRFP]\nA: [\n  Cuma &lt;= 8.9\n  -Cuma &lt;= -0.3\n]\nG: [\n  0.23205813953488375 Cuma - xRFP = -0.06531744186046518\n]\nInVars: [Cuma]\nOutVars:[xRFP]\nA: [\n  -Cuma &lt;= -8.9\n]\nG: [\n  -xRFP &lt;= -2.0\n]\n</pre> <p>Note that not all sensors were compatible. Some of the sensor choices led to errors in design automatically caught by Pacti :</p> In\u00a0[11]: Copied! <pre>fold_change\n</pre> fold_change Out[11]: <pre>{'DAPG': 8.66785005774809,\n 'Cuma': 9.68674395539190,\n 'OC6': 2.52677363203287,\n 'Van': 7.26517302130202,\n 'IPTG': 4.72491416737617,\n 'Ara': 2.76605435260938,\n 'Cho': 3.30535361336978,\n 'DHBA': 3.32963257502971,\n 'Sal': 4.07634004092162,\n 'OHC14': 2.83319542816097,\n 'Acr': 6.97093280769728}</pre> In\u00a0[12]: Copied! <pre>sensor_ok\n</pre> sensor_ok Out[12]: <pre>{'DAPG': True,\n 'Cuma': True,\n 'OC6': False,\n 'Van': True,\n 'IPTG': True,\n 'Ara': False,\n 'Cho': False,\n 'Nar': True,\n 'DHBA': False,\n 'Sal': True,\n 'OHC14': False,\n 'Acr': True,\n 'Ery': True}</pre> In\u00a0[13]: Copied! <pre>yleak_sal = df.loc[df[\"Inducer\"] == \"Sal\"][\"ymin (RPUx10-3)\"].values[0] * 1e-3\nsal_start = df.loc[df[\"Inducer\"] == \"Sal\"][\"start\"].values[0]\nsal_K = df.loc[df[\"Inducer\"] == \"Sal\"][\"K (\u00b5M)\"].values[0]\nymax_sal = df.loc[df[\"Inducer\"] == \"Sal\"][\"ymax Linear\"].values[0]\n\nsal_output = \"xRFP\"\ncontract_sal_min, contract_sal_lin, contract_sal_max = create_sensor_contracts(\n    sensor_input=\"Sal\", output=sal_output, start=sal_start, K=sal_K,\n    ymax_lin=ymax_sal, yleak=yleak_sal\n)\n</pre> yleak_sal = df.loc[df[\"Inducer\"] == \"Sal\"][\"ymin (RPUx10-3)\"].values[0] * 1e-3 sal_start = df.loc[df[\"Inducer\"] == \"Sal\"][\"start\"].values[0] sal_K = df.loc[df[\"Inducer\"] == \"Sal\"][\"K (\u00b5M)\"].values[0] ymax_sal = df.loc[df[\"Inducer\"] == \"Sal\"][\"ymax Linear\"].values[0]  sal_output = \"xRFP\" contract_sal_min, contract_sal_lin, contract_sal_max = create_sensor_contracts(     sensor_input=\"Sal\", output=sal_output, start=sal_start, K=sal_K,     ymax_lin=ymax_sal, yleak=yleak_sal ) In\u00a0[14]: Copied! <pre>display_sensor_contracts(sensor_input=\"Input 1\", output=\"xRFP\", leak=yleak_sal,\n                         start=sal_start, K=sal_K, ymax_lin=ymax_sal, xlim_min=10**-3,\n                         xlim_max=10**3, ylim_min=10**-3, ylim_max=10**1)\n</pre> display_sensor_contracts(sensor_input=\"Input 1\", output=\"xRFP\", leak=yleak_sal,                          start=sal_start, K=sal_K, ymax_lin=ymax_sal, xlim_min=10**-3,                          xlim_max=10**3, ylim_min=10**-3, ylim_max=10**1) Out[14]: <pre>&lt;AxesSubplot: xlabel='Input 1', ylabel='xRFP'&gt;</pre> In\u00a0[15]: Copied! <pre>yleak_atc = df.loc[df[\"Inducer\"] == \"aTc\"][\"ymin (RPUx10-3)\"].values[0] * 1e-3\natc_start = df.loc[df[\"Inducer\"] == \"aTc\"][\"start\"].values[0]\natc_K = df.loc[df[\"Inducer\"] == \"aTc\"][\"K (\u00b5M)\"].values[0]\nymax_atc = df.loc[df[\"Inducer\"] == \"aTc\"][\"ymax Linear\"].values[0]\natc_output = \"dCas9\"\ncontract_atc_min, contract_atc_lin, contract_atc_max = create_sensor_contracts(\n    sensor_input=\"aTc\", output=atc_output, start=atc_start, K=atc_K,\n    ymax_lin=ymax_atc, yleak=yleak_atc\n)\n</pre> yleak_atc = df.loc[df[\"Inducer\"] == \"aTc\"][\"ymin (RPUx10-3)\"].values[0] * 1e-3 atc_start = df.loc[df[\"Inducer\"] == \"aTc\"][\"start\"].values[0] atc_K = df.loc[df[\"Inducer\"] == \"aTc\"][\"K (\u00b5M)\"].values[0] ymax_atc = df.loc[df[\"Inducer\"] == \"aTc\"][\"ymax Linear\"].values[0] atc_output = \"dCas9\" contract_atc_min, contract_atc_lin, contract_atc_max = create_sensor_contracts(     sensor_input=\"aTc\", output=atc_output, start=atc_start, K=atc_K,     ymax_lin=ymax_atc, yleak=yleak_atc ) In\u00a0[16]: Copied! <pre>display_sensor_contracts(\n    sensor_input=\"aTc\",\n    output=\"dCas9\",\n    leak=yleak_atc,\n    start=atc_start,\n    K=atc_K,\n    ymax_lin=ymax_atc,\n    xlim_min=10**-3,\n    xlim_max=10**0,\n    ylim_min=10**-3,\n    ylim_max=10**1,\n);\n</pre> display_sensor_contracts(     sensor_input=\"aTc\",     output=\"dCas9\",     leak=yleak_atc,     start=atc_start,     K=atc_K,     ymax_lin=ymax_atc,     xlim_min=10**-3,     xlim_max=10**0,     ylim_min=10**-3,     ylim_max=10**1, ); In\u00a0[17]: Copied! <pre>leak_RFP = np.max([yleak_atc, yleak_sal])\nmax_RFP = np.max([ymax_atc, ymax_sal])\n\n\ndef create_top_level_contracts(input1=\"u1\", input2=\"u2\", output=\"y\",\n                               input1_params=None, input2_params=None,\n                               output_params=None):\n\"\"\"\n    Creates the top level system contracts\n    \"\"\"\n    u1_start = input1_params[\"start\"]\n    u1_K = input1_params[\"K\"]\n\n    u2_start = input2_params[\"start\"]\n    u2_K = input2_params[\"K\"]\n\n    y_max = output_params[\"max\"]\n    y_leak = output_params[\"leak\"]\n    all_contracts = []\n    contract_top_level_on1 = PolyhedralContract.from_string(\n        # \"u1:OFF, u2:OFF, y:ON\",\n        input_vars=[\n            input1, input2\n        ],\n        output_vars=[\n            output\n        ],\n        assumptions=[\n            f\"{input1} &lt;= {u1_start - u1_start*0.01}\",\n            f\"{input1} &lt;= {u2_start - u2_start*0.01}\"\n        ],\n        guarantees=[\n            f\"-{output}&lt;={-1*y_max}\",\n        ]\n    )\n    all_contracts.append(contract_top_level_on1)\n    contract_top_level_on2 = PolyhedralContract.from_string(\n        # \"u1:ON, u2:OFF, y:ON\",\n        input_vars=[\n            input1, input2\n        ],\n        output_vars=[\n            output\n        ],\n        assumptions=[\n            f\"-{input1} &lt;= {-1*(u1_start + u2_start*0.01)}\",\n            f\"{input1} &lt;= {u1_K - u1_K*0.01}\",\n            f\"{input2} &lt;= {u2_start - u2_start*0.01}\"\n        ],\n        guarantees=[\n            f\"-{output} &lt;= {-1*y_max}\"\n        ]\n    )\n    all_contracts.append(contract_top_level_on2)\n    contract_top_level_on3 = PolyhedralContract.from_string(\n        # \"u1:OFF, u2:ON, y:ON\",\n        input_vars=[\n            input1, input2\n        ],\n        output_vars=[\n            output\n        ],\n        assumptions=[\n            f\"{input1} &lt;= {u1_start - u1_start*0.01}\",\n            f\"-{input2} &lt;= {-1*(u2_start + u2_start*0.01)}\",\n            f\"{input2} &lt;= {u2_K - u2_K*0.01}\",\n        ],\n        guarantees=[\n            f\"-{output}&lt;={-1*y_max}\",\n        ]\n    )\n    all_contracts.append(contract_top_level_on3)\n    contract_top_level_off = PolyhedralContract.from_string(\n        # \"u1:ON, u2:ON, y:OFF\",\n        input_vars=[\n            input1, input2\n        ],\n        output_vars=[\n            output\n        ],\n        assumptions=[\n            f\"-{input1} &lt;= {-1*(u1_start + u1_start*0.01)}\",\n            f\"{input1} &lt;= {u1_K - u1_K*0.01}\",\n            f\"-{input2} &lt;= {-1*(u2_start + u2_start*0.01)}\",\n            f\"{input2} &lt;= {u2_K - u2_K*0.01}\",\n        ],\n        guarantees=[\n            f\"{output} &lt;= {y_leak}\"\n        ]\n    )\n    all_contracts.append(contract_top_level_off)\n    return all_contracts\n</pre> leak_RFP = np.max([yleak_atc, yleak_sal]) max_RFP = np.max([ymax_atc, ymax_sal])   def create_top_level_contracts(input1=\"u1\", input2=\"u2\", output=\"y\",                                input1_params=None, input2_params=None,                                output_params=None):     \"\"\"     Creates the top level system contracts     \"\"\"     u1_start = input1_params[\"start\"]     u1_K = input1_params[\"K\"]      u2_start = input2_params[\"start\"]     u2_K = input2_params[\"K\"]      y_max = output_params[\"max\"]     y_leak = output_params[\"leak\"]     all_contracts = []     contract_top_level_on1 = PolyhedralContract.from_string(         # \"u1:OFF, u2:OFF, y:ON\",         input_vars=[             input1, input2         ],         output_vars=[             output         ],         assumptions=[             f\"{input1} &lt;= {u1_start - u1_start*0.01}\",             f\"{input1} &lt;= {u2_start - u2_start*0.01}\"         ],         guarantees=[             f\"-{output}&lt;={-1*y_max}\",         ]     )     all_contracts.append(contract_top_level_on1)     contract_top_level_on2 = PolyhedralContract.from_string(         # \"u1:ON, u2:OFF, y:ON\",         input_vars=[             input1, input2         ],         output_vars=[             output         ],         assumptions=[             f\"-{input1} &lt;= {-1*(u1_start + u2_start*0.01)}\",             f\"{input1} &lt;= {u1_K - u1_K*0.01}\",             f\"{input2} &lt;= {u2_start - u2_start*0.01}\"         ],         guarantees=[             f\"-{output} &lt;= {-1*y_max}\"         ]     )     all_contracts.append(contract_top_level_on2)     contract_top_level_on3 = PolyhedralContract.from_string(         # \"u1:OFF, u2:ON, y:ON\",         input_vars=[             input1, input2         ],         output_vars=[             output         ],         assumptions=[             f\"{input1} &lt;= {u1_start - u1_start*0.01}\",             f\"-{input2} &lt;= {-1*(u2_start + u2_start*0.01)}\",             f\"{input2} &lt;= {u2_K - u2_K*0.01}\",         ],         guarantees=[             f\"-{output}&lt;={-1*y_max}\",         ]     )     all_contracts.append(contract_top_level_on3)     contract_top_level_off = PolyhedralContract.from_string(         # \"u1:ON, u2:ON, y:OFF\",         input_vars=[             input1, input2         ],         output_vars=[             output         ],         assumptions=[             f\"-{input1} &lt;= {-1*(u1_start + u1_start*0.01)}\",             f\"{input1} &lt;= {u1_K - u1_K*0.01}\",             f\"-{input2} &lt;= {-1*(u2_start + u2_start*0.01)}\",             f\"{input2} &lt;= {u2_K - u2_K*0.01}\",         ],         guarantees=[             f\"{output} &lt;= {y_leak}\"         ]     )     all_contracts.append(contract_top_level_off)     return all_contracts In\u00a0[18]: Copied! <pre>sal_params = {\"start\": sal_start, \"K\": sal_K}\natc_params = {\"start\": atc_start, \"K\": atc_K}\nRFP_params = {\"max\": max_RFP, \"leak\": leak_RFP}\nctop_off_off, ctop_on_off, ctop_off_on, ctop_on_on = create_top_level_contracts(\n    input1=\"Sal\", input2=\"aTc\", output=\"RFP\",\n    input1_params=sal_params, input2_params=atc_params, output_params=RFP_params\n)\n</pre> sal_params = {\"start\": sal_start, \"K\": sal_K} atc_params = {\"start\": atc_start, \"K\": atc_K} RFP_params = {\"max\": max_RFP, \"leak\": leak_RFP} ctop_off_off, ctop_on_off, ctop_off_on, ctop_on_on = create_top_level_contracts(     input1=\"Sal\", input2=\"aTc\", output=\"RFP\",     input1_params=sal_params, input2_params=atc_params, output_params=RFP_params ) In\u00a0[19]: Copied! <pre>print(contract_atc_lin)\n</pre> print(contract_atc_lin) <pre>InVars: [aTc]\nOutVars:[dCas9]\nA: [\n  aTc &lt;= 0.013\n  -aTc &lt;= -0.0018\n]\nG: [\n  88.84821428571429 aTc - dCas9 = -0.15502678571428574\n]\n</pre> In\u00a0[20]: Copied! <pre>print(contract_sal_lin)\n</pre> print(contract_sal_lin) <pre>InVars: [Sal]\nOutVars:[xRFP]\nA: [\n  Sal &lt;= 43.0\n  -Sal &lt;= -0.9\n]\nG: [\n  0.03076722090261283 Sal - xRFP = -0.0229904988123516\n]\n</pre> In\u00a0[21]: Copied! <pre>print(contract_sal_lin.compose(contract_atc_lin))\n</pre> print(contract_sal_lin.compose(contract_atc_lin)) <pre>InVars: [Sal, aTc]\nOutVars:[xRFP, dCas9]\nA: [\n  Sal &lt;= 43.0\n  -Sal &lt;= -0.9\n  aTc &lt;= 0.0129999999999999\n  -aTc &lt;= -0.0018000000000000238\n]\nG: [\n  0.03076722090261283 Sal - xRFP = -0.0229904988123516\n  88.84821428571429 aTc - dCas9 = -0.15502678571428574\n]\n</pre> In\u00a0[22]: Copied! <pre>print(ctop_on_on)\n</pre> print(ctop_on_on) <pre>InVars: [Sal, aTc]\nOutVars:[RFP]\nA: [\n  -Sal &lt;= -0.909\n  Sal &lt;= 42.57\n  -aTc &lt;= -0.001818\n  aTc &lt;= 0.01287\n]\nG: [\n  RFP &lt;= 0.004899999999999904\n]\n</pre> In\u00a0[23]: Copied! <pre>csal_atc = contract_sal_lin.compose(contract_atc_lin)\ndCas_repression_lin = ctop_on_on.quotient(csal_atc)\n</pre> csal_atc = contract_sal_lin.compose(contract_atc_lin) dCas_repression_lin = ctop_on_on.quotient(csal_atc) In\u00a0[24]: Copied! <pre>print(dCas_repression_lin)\n</pre> print(dCas_repression_lin) <pre>InVars: [xRFP, dCas9]\nOutVars:[RFP]\nA: [\n  -xRFP &lt;= -0.05095790261282662\n  xRFP &lt;= 1.3327510926365798\n  -dCas9 &lt;= -0.3165528392857134\n  dCas9 &lt;= 1.2985033035714197\n]\nG: [\n  RFP &lt;= 0.004899999999999904\n]\n</pre> In\u00a0[25]: Copied! <pre>print(contract_sal_min)\n</pre> print(contract_sal_min) <pre>InVars: [Sal]\nOutVars:[xRFP]\nA: [\n  Sal &lt;= 0.9\n]\nG: [\n  xRFP &lt;= 0.0046999999999999265\n]\n</pre> In\u00a0[26]: Copied! <pre>print(contract_atc_lin)\n</pre> print(contract_atc_lin) <pre>InVars: [aTc]\nOutVars:[dCas9]\nA: [\n  aTc &lt;= 0.013\n  -aTc &lt;= -0.0018\n]\nG: [\n  88.84821428571429 aTc - dCas9 = -0.15502678571428574\n]\n</pre> In\u00a0[27]: Copied! <pre>print(contract_sal_min.compose(contract_atc_lin))\n</pre> print(contract_sal_min.compose(contract_atc_lin)) <pre>InVars: [Sal, aTc]\nOutVars:[xRFP, dCas9]\nA: [\n  Sal &lt;= 0.8999999999999999\n  aTc &lt;= 0.0129999999999999\n  -aTc &lt;= -0.0018000000000000238\n]\nG: [\n  xRFP &lt;= 0.0046999999999999265\n  88.84821428571429 aTc - dCas9 = -0.15502678571428574\n]\n</pre> In\u00a0[28]: Copied! <pre>print(ctop_off_on)\n</pre> print(ctop_off_on) <pre>InVars: [Sal, aTc]\nOutVars:[RFP]\nA: [\n  Sal &lt;= 0.891\n  -aTc &lt;= -0.001818\n  aTc &lt;= 0.01287\n]\nG: [\n  -RFP &lt;= -1.3\n]\n</pre> In\u00a0[29]: Copied! <pre>csal_atc = contract_sal_min.compose(contract_atc_lin)\ndCas_repression_off_on = ctop_off_on.quotient(csal_atc)\n</pre> csal_atc = contract_sal_min.compose(contract_atc_lin) dCas_repression_off_on = ctop_off_on.quotient(csal_atc) In\u00a0[30]: Copied! <pre>print(dCas_repression_off_on)\n</pre> print(dCas_repression_off_on) <pre>InVars: [xRFP, dCas9]\nOutVars:[RFP]\nA: [\n  xRFP &lt;= 0.0046999999999999265\n  -dCas9 &lt;= -0.3165528392857134\n  dCas9 &lt;= 1.2985033035714197\n]\nG: [\n  -RFP &lt;= -1.3\n]\n</pre> In\u00a0[31]: Copied! <pre>system_json_contracts = write_contracts_to_file([dCas_repression_lin, dCas_repression_off_on],\n                                                names=[\"dCas_Linear\", \"dCas_off_on\"],\n                                                file_name=\"data/dCas9_repression.json\")\n</pre> system_json_contracts = write_contracts_to_file([dCas_repression_lin, dCas_repression_off_on],                                                 names=[\"dCas_Linear\", \"dCas_off_on\"],                                                 file_name=\"data/dCas9_repression.json\")"},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#scaling-up-designs-in-synthetic-biology-using-pacti","title":"Scaling up designs in synthetic biology using Pacti\u00b6","text":""},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#modeling-the-specifications-to-construct-a-library-of-parts","title":"Modeling the specifications to construct a library of parts\u00b6","text":"<p>Using the experimental characterization data for the sensors in the Marionette bacterial cell strain [1], we model the sensor behavior as assume-guarantee contracts. We observe that each sensor has three characteristic behaviors: (1) the off state, where the output of the sensor stays close to zero (the non-zero expression in this state is termed as \"leaky response\"), (2) the linear rate of output , where the sensor output responds linearly to the input (in log scale), (3) the saturation state, where the sensor output saturates to a maximum constant v</p> <p>[1] Meyer, Adam J., et al. \"Escherichia coli \u201cMarionette\u201d strains with 12 highly optimized small-molecule sensors.\" Nature chemical biology 15.2 (2019): 196-204.</p>"},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#composition-to-find-optimal-sensor-choices","title":"Composition to find optimal sensor choices\u00b6","text":"<p>To speed up the experimental screening, we use Pacti to choose a sensor from the library that meets the desired top-level behavior. Here, we have a tetracycline (aTc) sensor that expresses a dCas9 protein and the other sensor (the one we want to choose) that expresses the xRFP guide RNA. The xRFP guide RNA binds to dCas9 to repress the expression of red fluorescent protein (RFP), the output of the system. When either of the sensors are OFF, the output (RFP) is constitutively expressed (that is, output is ON). In this way, the system behavior is that of a NAND logic gate. We denote the contract for the tetracycline sensor as $C_{\\text{atc}}$ and the contract for dCas9 repression mechanism as $C_{\\text{dCas9}}$. For the top-level specification, we define the fold-change of the system as $F = \\frac{\\text{RFP}_{\\text{on}}}{\\text{RFP}_{\\text{off}}}.$</p> <p>To choose the sensor that achieves the highest fold-change for the system, we compose the contract for each of the available 13 sensors in the library with the tetracycline contract and the dCas9 repression contract to obtain the top-level system contract. The composition operation in Pacti reports a design error for any sensor that is \"unsatisfiable in the given context\" to reject some of the choices while some other choices are rejected if they do not meet the set top-level system criteria.</p>"},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#result","title":"Result\u00b6","text":""},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#finding-specifications-of-missing-parts","title":"Finding specifications of missing parts\u00b6","text":"<p>For the NAND gate described above, if we write a desired top-level contract $C_{\\text{sys}}$ and assume that both sensors have been chosen (here we choose Sal and aTc) so that we have the contracts for both sensors. Then, we may use quotient operation in Pacti to find the ideal specifications of the dCas9 mechanism. This can guide the design of the repression mechanism.</p>"},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#contract-for-sal-sensor","title":"Contract for Sal sensor:\u00b6","text":""},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#contracts-for-atc-sensor","title":"Contracts for aTc sensor\u00b6","text":""},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#top-level-system-contract","title":"Top-level system contract\u00b6","text":""},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#print-the-contracts","title":"Print the contracts\u00b6","text":""},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#available-composition","title":"Available composition\u00b6","text":"<p>(in the NAND gate ON condition =&gt; output is OFF)</p>"},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#take-the-quotient-of-the-top-level-contract-in-the-on-condition-from-the-available-composition","title":"Take the quotient of the top-level contract in the ON condition from the available composition\u00b6","text":""},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#result-we-find-the-missing-contract","title":"Result: We find the missing contract:\u00b6","text":""},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#find-contract-for-the-missing-subsystem-for-other-conditions-of-the-nand-gate-circuit","title":"Find contract for the missing subsystem for other conditions of the NAND gate circuit:\u00b6","text":""},{"location":"_case_studies/cs-biocircuits/specification_based_synthetic_biology/#write-results-to-a-json-file","title":"Write results to a JSON file!\u00b6","text":""},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/","title":"Signal Processing in Digital ICs","text":"<p>First, we import some data structure for holding the wordlength, and the APIs of Pacti.</p> In\u00a0[1]: Copied! <pre>\"\"\"DSP Case Study Code\"\"\"\nimport itertools\n\nfrom tool import PortWordLength, float_to_bin, port_add, port_mult\n\nfrom pacti.terms.polyhedra import PolyhedralContract\n</pre> \"\"\"DSP Case Study Code\"\"\" import itertools  from tool import PortWordLength, float_to_bin, port_add, port_mult  from pacti.terms.polyhedra import PolyhedralContract In\u00a0[2]: Copied! <pre># Definition of value_num method in PortWordLength class\n#    def value_num(self):\n#        return int(self.value, base=2) * 2 ** (- (self.n - self.p))\ndef show_wordlength() -&gt; None:\n\"\"\"Show the wordlength structure\"\"\"\n    port = PortWordLength(n=5, p=2, value=\"11011\")\n    print(f'The word length (n = {port.n}, p = {port.p}) of the bits \"{port.value}\" is: ')\n    print(port.value_num())\n\n\nshow_wordlength()\n</pre> # Definition of value_num method in PortWordLength class #    def value_num(self): #        return int(self.value, base=2) * 2 ** (- (self.n - self.p)) def show_wordlength() -&gt; None:     \"\"\"Show the wordlength structure\"\"\"     port = PortWordLength(n=5, p=2, value=\"11011\")     print(f'The word length (n = {port.n}, p = {port.p}) of the bits \"{port.value}\" is: ')     print(port.value_num())   show_wordlength() <pre>The word length (n = 5, p = 2) of the bits \"11011\" is: \n3.375\n</pre> <p>The following example shows how the error is bounded:</p> In\u00a0[3]: Copied! <pre>def truncation_error_same_position(pi: PortWordLength, po: PortWordLength) -&gt; float:\n\"\"\"\n    Truncation error for the case where input ports and output ports have the same number of integer bits.\n\n    Args:\n        pi: PortWordLength: input port word length\n        po: PortWordLength: input port word length\n\n    Returns:\n        The maximum truncation error if a number is truncated from wordlength pi to wordlength po\n    \"\"\"\n    assert pi.p == po.p\n    if pi.n &gt; po.n:\n        return float(2**po.p * (2 ** (-po.n) - 2 ** (-pi.n)))\n    return 0\n\n\ndef truncate(pi: PortWordLength, po: PortWordLength) -&gt; None:\n\"\"\"\n    Truncate the value in pi into po.\n\n    Args:\n        pi: PortWordLength: input port word length\n        po: PortWordLength: input port word length\n    \"\"\"\n    # separate the bits into two parts, before binary point and after binary point\n    bits_str: str = str(pi.value)\n    bits_before_point = bits_str[: pi.p]\n    bits_after_point = bits_str[pi.p :]\n\n    # truncate or appending 0\n    if po.p &gt;= pi.p:\n        bits_before_point = (\"0\" * (po.p - pi.p)) + bits_before_point\n    else:\n        bits_before_point = bits_before_point[pi.p - po.p :]\n\n    if po.n - po.p &gt;= pi.n - pi.p:\n        bits_after_point = bits_after_point + \"0\" * (po.n - po.p - pi.n + pi.p)\n    else:\n        bits_after_point = bits_after_point[: (po.n - po.p)]\n\n    # combine the both parts\n    ret = bits_before_point + bits_after_point\n    po.value = ret\n</pre> def truncation_error_same_position(pi: PortWordLength, po: PortWordLength) -&gt; float:     \"\"\"     Truncation error for the case where input ports and output ports have the same number of integer bits.      Args:         pi: PortWordLength: input port word length         po: PortWordLength: input port word length      Returns:         The maximum truncation error if a number is truncated from wordlength pi to wordlength po     \"\"\"     assert pi.p == po.p     if pi.n &gt; po.n:         return float(2**po.p * (2 ** (-po.n) - 2 ** (-pi.n)))     return 0   def truncate(pi: PortWordLength, po: PortWordLength) -&gt; None:     \"\"\"     Truncate the value in pi into po.      Args:         pi: PortWordLength: input port word length         po: PortWordLength: input port word length     \"\"\"     # separate the bits into two parts, before binary point and after binary point     bits_str: str = str(pi.value)     bits_before_point = bits_str[: pi.p]     bits_after_point = bits_str[pi.p :]      # truncate or appending 0     if po.p &gt;= pi.p:         bits_before_point = (\"0\" * (po.p - pi.p)) + bits_before_point     else:         bits_before_point = bits_before_point[pi.p - po.p :]      if po.n - po.p &gt;= pi.n - pi.p:         bits_after_point = bits_after_point + \"0\" * (po.n - po.p - pi.n + pi.p)     else:         bits_after_point = bits_after_point[: (po.n - po.p)]      # combine the both parts     ret = bits_before_point + bits_after_point     po.value = ret In\u00a0[4]: Copied! <pre>def example_truncation_error_same_position() -&gt; None:\n\"\"\"The example showing truncation error for same number of integer bits\"\"\"\n    p1 = PortWordLength(n=7, p=2, name=\"p1\", value=\"1111111\")\n    p2 = PortWordLength(n=5, p=2, name=\"p2\")\n\n    print(\"Truncation Error: \")\n    print(truncation_error_same_position(p1, p2))\n    print(\"Example Value to produce the error\")\n\n    truncate(p1, p2)\n    print(f\"p1 = {p1.value_num()}, bits: {p1.value}\")\n    print(f\"p2 = {p2.value_num()}, bits: {p2.value}\")\n    print(\"p1 - p2 = \", p1.value_num() - p2.value_num())\n\n\nexample_truncation_error_same_position()\n</pre> def example_truncation_error_same_position() -&gt; None:     \"\"\"The example showing truncation error for same number of integer bits\"\"\"     p1 = PortWordLength(n=7, p=2, name=\"p1\", value=\"1111111\")     p2 = PortWordLength(n=5, p=2, name=\"p2\")      print(\"Truncation Error: \")     print(truncation_error_same_position(p1, p2))     print(\"Example Value to produce the error\")      truncate(p1, p2)     print(f\"p1 = {p1.value_num()}, bits: {p1.value}\")     print(f\"p2 = {p2.value_num()}, bits: {p2.value}\")     print(\"p1 - p2 = \", p1.value_num() - p2.value_num())   example_truncation_error_same_position() <pre>Truncation Error: \n0.09375\nExample Value to produce the error\np1 = 3.96875, bits: 1111111\np2 = 3.875, bits: 11111\np1 - p2 =  0.09375\n</pre> <p>Then let's see what happens if the integer parts have different numbers of bits.</p> <p>The following example shows how the error can be calculated.</p> In\u00a0[5]: Copied! <pre>def truncation_error(pi: PortWordLength, po: PortWordLength) -&gt; float:\n\"\"\"\n    Truncation error for the case where input ports and output ports have different number of integer bits.\n\n    Args:\n        pi: PortWordLength: input port word length\n        po: PortWordLength: input port word length\n\n    Returns:\n        The maximum truncation error if a number is truncated from wordlength pi to wordlength po\n    \"\"\"\n    # remove uneccesary most significant bits\n    # Remider: The assumption must hold!!\n    pi_adjusted = PortWordLength(n=pi.n - pi.p + po.p, p=po.p)\n    # return the truncation error as in case 1\n    return truncation_error_same_position(pi=pi_adjusted, po=po)\n\n\ndef get_assumption_value(pi: PortWordLength, po: PortWordLength) -&gt; float:\n\"\"\"\n    Compute the assumption required for truncation to ensure no loss of integer values.\n\n    Args:\n        pi: PortWordLength: input port word length\n        po: PortWordLength: input port word length\n\n    Returns:\n        The maximum bound pi such that it won't loss integer bits after truncation\n    \"\"\"\n    if pi.p &gt; po.p:\n        return float(2**po.p)\n    return float(\"inf\")  # no additional assumption needed\n\n\ndef check_assumption_value(pi: PortWordLength, po: PortWordLength) -&gt; bool:\n\"\"\"\n    Check if the value of the input port satisfy the assumption for truncation.\n\n    Args:\n        pi: PortWordLength: input port word length\n        po: PortWordLength: input port word length\n\n    Returns:\n        If the assumption to prevent integer bit loss is satisfied\n    \"\"\"\n    assumption_value = get_assumption_value(pi, po)\n    print(f\"Assumption: {pi.name} &lt; {assumption_value}\")\n    if pi.value_num() &gt;= assumption_value:\n        print(\"Assumption failed, truncation of MSB occurs\")\n        return False\n\n    print(f\"Assumption Satisfied ({pi.name} = {pi.value_num()} &lt; {assumption_value})\")\n    return True\n</pre> def truncation_error(pi: PortWordLength, po: PortWordLength) -&gt; float:     \"\"\"     Truncation error for the case where input ports and output ports have different number of integer bits.      Args:         pi: PortWordLength: input port word length         po: PortWordLength: input port word length      Returns:         The maximum truncation error if a number is truncated from wordlength pi to wordlength po     \"\"\"     # remove uneccesary most significant bits     # Remider: The assumption must hold!!     pi_adjusted = PortWordLength(n=pi.n - pi.p + po.p, p=po.p)     # return the truncation error as in case 1     return truncation_error_same_position(pi=pi_adjusted, po=po)   def get_assumption_value(pi: PortWordLength, po: PortWordLength) -&gt; float:     \"\"\"     Compute the assumption required for truncation to ensure no loss of integer values.      Args:         pi: PortWordLength: input port word length         po: PortWordLength: input port word length      Returns:         The maximum bound pi such that it won't loss integer bits after truncation     \"\"\"     if pi.p &gt; po.p:         return float(2**po.p)     return float(\"inf\")  # no additional assumption needed   def check_assumption_value(pi: PortWordLength, po: PortWordLength) -&gt; bool:     \"\"\"     Check if the value of the input port satisfy the assumption for truncation.      Args:         pi: PortWordLength: input port word length         po: PortWordLength: input port word length      Returns:         If the assumption to prevent integer bit loss is satisfied     \"\"\"     assumption_value = get_assumption_value(pi, po)     print(f\"Assumption: {pi.name} &lt; {assumption_value}\")     if pi.value_num() &gt;= assumption_value:         print(\"Assumption failed, truncation of MSB occurs\")         return False      print(f\"Assumption Satisfied ({pi.name} = {pi.value_num()} &lt; {assumption_value})\")     return True In\u00a0[6]: Copied! <pre>def example_truncation_error() -&gt; None:\n\"\"\"Example showing the truncation error\"\"\"\n    p1 = PortWordLength(n=7, p=3, name=\"p1\", value=\"0100111\")\n    p2 = PortWordLength(n=5, p=2, name=\"p2\")\n\n    assert check_assumption_value(pi=p1, po=p2)\n\n    print(\"Truncation Error: \")\n    print(truncation_error(p1, p2))\n    print(\"Example Value to produce the error\")\n\n    truncate(p1, p2)\n    print(f\"p1 = {p1.value_num()}, bits: {p1.value}\")\n    print(f\"p2 = {p2.value_num()}, bits: {p2.value}\")\n    print(\"p1 - p2 = \", p1.value_num() - p2.value_num())\n\n\nexample_truncation_error()\n</pre> def example_truncation_error() -&gt; None:     \"\"\"Example showing the truncation error\"\"\"     p1 = PortWordLength(n=7, p=3, name=\"p1\", value=\"0100111\")     p2 = PortWordLength(n=5, p=2, name=\"p2\")      assert check_assumption_value(pi=p1, po=p2)      print(\"Truncation Error: \")     print(truncation_error(p1, p2))     print(\"Example Value to produce the error\")      truncate(p1, p2)     print(f\"p1 = {p1.value_num()}, bits: {p1.value}\")     print(f\"p2 = {p2.value_num()}, bits: {p2.value}\")     print(\"p1 - p2 = \", p1.value_num() - p2.value_num())   example_truncation_error() <pre>Assumption: p1 &lt; 4.0\nAssumption Satisfied (p1 = 2.4375 &lt; 4.0)\nTruncation Error: \n0.0625\nExample Value to produce the error\np1 = 2.4375, bits: 0100111\np2 = 2.375, bits: 10011\np1 - p2 =  0.0625\n</pre> In\u00a0[7]: Copied! <pre>def compute_required_word_length_add(in1: PortWordLength, in2: PortWordLength) -&gt; PortWordLength:\n\"\"\"\n    Compute the minimum word length to hold all values after addition operation on the inputs without lossing any information.\n\n    Args:\n        in1: PortWordLength: input port word length\n        in2: PortWordLength: input port word length\n\n    Returns:\n        The minimum word length to hold all values after addition operation on the inputs without lossing any information.\n    \"\"\"\n    new_n = max(in1.n, in2.n - in2.p + in1.p) - min(0, in1.p - in2.p) + 1\n    new_p = max(in1.p, in2.p) + 1\n    return PortWordLength(n=new_n, p=new_p)\n\n\ndef error_truncation_add(in1: PortWordLength, in2: PortWordLength, out: PortWordLength) -&gt; float:\n\"\"\"\n    Compute the maximum error of truncation caused by the addition operation.\n\n    The addition operation is perform for ports out = in1 + in2.\n    The value of in1 + in2 is truncated to fit in out\n\n    Args:\n        in1: PortWordLength: input port word length\n        in2: PortWordLength: input port word length\n        out: PortWordLength: output port word length\n\n    Returns:\n        The maximum error of truncation caused by the addition operation\n    \"\"\"\n    print(f\"Input {in1.name}: (n={in1.n}, p={in1.p})\")\n    print(f\"Input {in2.name}: (n={in2.n}, p={in2.p})\")\n    p_ideal = compute_required_word_length_add(in1=in1, in2=in2)\n    print(f\"Ideal Output: (n={p_ideal.n}, p={p_ideal.p})\")\n    print(f\"Actual Output ({out.name}): (n={out.n}, p={out.p})\")\n\n    assumption_value = get_assumption_value(pi=p_ideal, po=out)\n    print(f\"Assumption: {in1.name} + {in2.name} &lt; {assumption_value}\")\n    return truncation_error(pi=p_ideal, po=out)\n</pre> def compute_required_word_length_add(in1: PortWordLength, in2: PortWordLength) -&gt; PortWordLength:     \"\"\"     Compute the minimum word length to hold all values after addition operation on the inputs without lossing any information.      Args:         in1: PortWordLength: input port word length         in2: PortWordLength: input port word length      Returns:         The minimum word length to hold all values after addition operation on the inputs without lossing any information.     \"\"\"     new_n = max(in1.n, in2.n - in2.p + in1.p) - min(0, in1.p - in2.p) + 1     new_p = max(in1.p, in2.p) + 1     return PortWordLength(n=new_n, p=new_p)   def error_truncation_add(in1: PortWordLength, in2: PortWordLength, out: PortWordLength) -&gt; float:     \"\"\"     Compute the maximum error of truncation caused by the addition operation.      The addition operation is perform for ports out = in1 + in2.     The value of in1 + in2 is truncated to fit in out      Args:         in1: PortWordLength: input port word length         in2: PortWordLength: input port word length         out: PortWordLength: output port word length      Returns:         The maximum error of truncation caused by the addition operation     \"\"\"     print(f\"Input {in1.name}: (n={in1.n}, p={in1.p})\")     print(f\"Input {in2.name}: (n={in2.n}, p={in2.p})\")     p_ideal = compute_required_word_length_add(in1=in1, in2=in2)     print(f\"Ideal Output: (n={p_ideal.n}, p={p_ideal.p})\")     print(f\"Actual Output ({out.name}): (n={out.n}, p={out.p})\")      assumption_value = get_assumption_value(pi=p_ideal, po=out)     print(f\"Assumption: {in1.name} + {in2.name} &lt; {assumption_value}\")     return truncation_error(pi=p_ideal, po=out) In\u00a0[8]: Copied! <pre>def example_truncation_error_add() -&gt; None:\n\"\"\"Example showing truncation error of addition operation\"\"\"\n    p1 = PortWordLength(n=7, p=3, name=\"p1\", value=\"0100111\")\n    p2 = PortWordLength(n=5, p=2, name=\"p2\")\n    p3 = PortWordLength(n=5, p=3, name=\"p3\")\n\n    err = error_truncation_add(in1=p1, in2=p2, out=p3)\n\n    print(f\"Error of the addition calculation: {err}\")\n\n\nexample_truncation_error_add()\n</pre> def example_truncation_error_add() -&gt; None:     \"\"\"Example showing truncation error of addition operation\"\"\"     p1 = PortWordLength(n=7, p=3, name=\"p1\", value=\"0100111\")     p2 = PortWordLength(n=5, p=2, name=\"p2\")     p3 = PortWordLength(n=5, p=3, name=\"p3\")      err = error_truncation_add(in1=p1, in2=p2, out=p3)      print(f\"Error of the addition calculation: {err}\")   example_truncation_error_add() <pre>Input p1: (n=7, p=3)\nInput p2: (n=5, p=2)\nIdeal Output: (n=8, p=4)\nActual Output (p3): (n=5, p=3)\nAssumption: p1 + p2 &lt; 8.0\nError of the addition calculation: 0.1875\n</pre> In\u00a0[9]: Copied! <pre>def compute_required_word_length_mult(in1: PortWordLength, in2: PortWordLength) -&gt; PortWordLength:\n\"\"\"\n    Compute the minimum word length to hold all values after multiplication operation on the inputs without lossing any information.\n\n    Args:\n        in1: PortWordLength: input port word length\n        in2: PortWordLength: input port word length\n\n    Returns:\n        The minimum word length to hold all values after multiplication operation on the inputs without lossing any information.\n    \"\"\"\n    new_n = in1.n + in2.n\n    new_p = in1.p + in2.p\n    return PortWordLength(n=new_n, p=new_p)\n\n\ndef error_truncation_mult(in1: PortWordLength, in2: PortWordLength, out: PortWordLength) -&gt; float:\n\"\"\"\n    Compute the maximum error of truncation caused by the multiplication operation.\n\n    The multiplication operation is perform for ports out = in1 * in2.\n    The value of in1 * in2 is truncated to fit in out\n\n    Args:\n        in1: PortWordLength: input port word length\n        in2: PortWordLength: input port word length\n        out: PortWordLength: output port word length\n\n    Returns:\n        The maximum error of truncation caused by the multiplication operation\n    \"\"\"\n    print(f\"Input {in1.name}: (n={in1.n}, p={in1.p})\")\n    print(f\"Input {in2.name}: (n={in2.n}, p={in2.p})\")\n    p_ideal = compute_required_word_length_mult(in1=in1, in2=in2)\n    print(f\"Ideal Output: (n={p_ideal.n}, p={p_ideal.p})\")\n    print(f\"Actual Output ({out.name}): (n={out.n}, p={out.p})\")\n\n    assumption_value = get_assumption_value(pi=p_ideal, po=out)\n    print(f\"Assumption: {in1.name} * {in2.name} &lt; {assumption_value}\")\n    return truncation_error(pi=p_ideal, po=out)\n</pre> def compute_required_word_length_mult(in1: PortWordLength, in2: PortWordLength) -&gt; PortWordLength:     \"\"\"     Compute the minimum word length to hold all values after multiplication operation on the inputs without lossing any information.      Args:         in1: PortWordLength: input port word length         in2: PortWordLength: input port word length      Returns:         The minimum word length to hold all values after multiplication operation on the inputs without lossing any information.     \"\"\"     new_n = in1.n + in2.n     new_p = in1.p + in2.p     return PortWordLength(n=new_n, p=new_p)   def error_truncation_mult(in1: PortWordLength, in2: PortWordLength, out: PortWordLength) -&gt; float:     \"\"\"     Compute the maximum error of truncation caused by the multiplication operation.      The multiplication operation is perform for ports out = in1 * in2.     The value of in1 * in2 is truncated to fit in out      Args:         in1: PortWordLength: input port word length         in2: PortWordLength: input port word length         out: PortWordLength: output port word length      Returns:         The maximum error of truncation caused by the multiplication operation     \"\"\"     print(f\"Input {in1.name}: (n={in1.n}, p={in1.p})\")     print(f\"Input {in2.name}: (n={in2.n}, p={in2.p})\")     p_ideal = compute_required_word_length_mult(in1=in1, in2=in2)     print(f\"Ideal Output: (n={p_ideal.n}, p={p_ideal.p})\")     print(f\"Actual Output ({out.name}): (n={out.n}, p={out.p})\")      assumption_value = get_assumption_value(pi=p_ideal, po=out)     print(f\"Assumption: {in1.name} * {in2.name} &lt; {assumption_value}\")     return truncation_error(pi=p_ideal, po=out) In\u00a0[10]: Copied! <pre>def example_truncation_error_mult() -&gt; None:\n\"\"\"Example showing truncation error of multiplication operation\"\"\"\n    p1 = PortWordLength(n=7, p=3, name=\"p1\", value=\"0100111\")\n    p2 = PortWordLength(n=5, p=2, name=\"p2\")\n    p3 = PortWordLength(n=5, p=3, name=\"p3\")\n\n    err = error_truncation_mult(in1=p1, in2=p2, out=p3)\n\n    print(f\"Error of the multiplication calculation: {err}\")\n\n\nexample_truncation_error_mult()\n</pre> def example_truncation_error_mult() -&gt; None:     \"\"\"Example showing truncation error of multiplication operation\"\"\"     p1 = PortWordLength(n=7, p=3, name=\"p1\", value=\"0100111\")     p2 = PortWordLength(n=5, p=2, name=\"p2\")     p3 = PortWordLength(n=5, p=3, name=\"p3\")      err = error_truncation_mult(in1=p1, in2=p2, out=p3)      print(f\"Error of the multiplication calculation: {err}\")   example_truncation_error_mult() <pre>Input p1: (n=7, p=3)\nInput p2: (n=5, p=2)\nIdeal Output: (n=12, p=5)\nActual Output (p3): (n=5, p=3)\nAssumption: p1 * p2 &lt; 8.0\nError of the multiplication calculation: 0.2421875\n</pre> In\u00a0[11]: Copied! <pre>def error_propagation_add(in1: PortWordLength, in2: PortWordLength, out: PortWordLength) -&gt; float:\n\"\"\"\n    Compute the propagation error caused by addtion operation.\n\n    Args:\n        in1: PortWordLength: input port word length\n        in2: PortWordLength: input port word length\n        out: PortWordLength: output port word length\n\n    Returns:\n        The propagation error caused by addtion operation given the known error in the inputs.\n    \"\"\"\n    return float(in1.e + in2.e)\n</pre> def error_propagation_add(in1: PortWordLength, in2: PortWordLength, out: PortWordLength) -&gt; float:     \"\"\"     Compute the propagation error caused by addtion operation.      Args:         in1: PortWordLength: input port word length         in2: PortWordLength: input port word length         out: PortWordLength: output port word length      Returns:         The propagation error caused by addtion operation given the known error in the inputs.     \"\"\"     return float(in1.e + in2.e) In\u00a0[12]: Copied! <pre>def example_propagation_error_add() -&gt; None:\n\"\"\"Example showing propagation error of addition operation\"\"\"\n    e1 = 0.5\n    e2 = 0.2\n    p1 = PortWordLength(n=7, p=3, e=e1, name=\"p1\", value=\"0100111\")\n    p2 = PortWordLength(n=5, p=2, e=e2, name=\"p2\")\n    p3 = PortWordLength(n=5, p=3, name=\"p3\")\n\n    e_p = error_propagation_add(in1=p1, in2=p2, out=p3)\n    e_t = error_truncation_add(in1=p1, in2=p2, out=p3)\n\n    err = e_p + e_t\n    print(f\"Propagation error: {e_p}\")\n    print(f\"Truncation error: {e_t}\")\n    print(f\"Error bound of the addition calculation: {err}\")\n\n\nexample_propagation_error_add()\n</pre> def example_propagation_error_add() -&gt; None:     \"\"\"Example showing propagation error of addition operation\"\"\"     e1 = 0.5     e2 = 0.2     p1 = PortWordLength(n=7, p=3, e=e1, name=\"p1\", value=\"0100111\")     p2 = PortWordLength(n=5, p=2, e=e2, name=\"p2\")     p3 = PortWordLength(n=5, p=3, name=\"p3\")      e_p = error_propagation_add(in1=p1, in2=p2, out=p3)     e_t = error_truncation_add(in1=p1, in2=p2, out=p3)      err = e_p + e_t     print(f\"Propagation error: {e_p}\")     print(f\"Truncation error: {e_t}\")     print(f\"Error bound of the addition calculation: {err}\")   example_propagation_error_add() <pre>Input p1: (n=7, p=3)\nInput p2: (n=5, p=2)\nIdeal Output: (n=8, p=4)\nActual Output (p3): (n=5, p=3)\nAssumption: p1 + p2 &lt; 8.0\nPropagation error: 0.7\nTruncation error: 0.1875\nError bound of the addition calculation: 0.8875\n</pre> In\u00a0[13]: Copied! <pre>def error_propagation_mult(in1: PortWordLength, in2: PortWordLength, out: PortWordLength) -&gt; float:\n\"\"\"\n    Compute the propagation error caused by multiplication operation.\n\n    Args:\n        in1: PortWordLength: input port word length\n        in2: PortWordLength: input port word length\n        out: PortWordLength: output port word length\n\n    Returns:\n        The propagation error caused by multiplication operation given the known error in the inputs.\n    \"\"\"\n    return float(in1.a * in2.e + in2.a * in1.e + in1.e * in2.e)\n</pre> def error_propagation_mult(in1: PortWordLength, in2: PortWordLength, out: PortWordLength) -&gt; float:     \"\"\"     Compute the propagation error caused by multiplication operation.      Args:         in1: PortWordLength: input port word length         in2: PortWordLength: input port word length         out: PortWordLength: output port word length      Returns:         The propagation error caused by multiplication operation given the known error in the inputs.     \"\"\"     return float(in1.a * in2.e + in2.a * in1.e + in1.e * in2.e) In\u00a0[14]: Copied! <pre>def example_propagation_error_mult() -&gt; None:\n\"\"\"Example showing propagation error of multiplication operation\"\"\"\n    e1 = 0.5\n    e2 = 0.3\n    p1 = PortWordLength(n=7, p=3, e=e1, name=\"p1\", value=\"0100111\")\n    p2 = PortWordLength(n=5, p=2, e=e2, name=\"p2\")\n    p3 = PortWordLength(n=5, p=3, name=\"p3\")\n\n    e_p = error_propagation_mult(in1=p1, in2=p2, out=p3)\n    e_t = error_truncation_mult(in1=p1, in2=p2, out=p3)\n\n    err = e_p + e_t\n    print(f\"Propagation error: {e_p}\")\n    print(f\"Truncation error: {e_t}\")\n    print(f\"Error bound of the multiplication calculation: {err}\")\n\n\nexample_propagation_error_mult()\n</pre> def example_propagation_error_mult() -&gt; None:     \"\"\"Example showing propagation error of multiplication operation\"\"\"     e1 = 0.5     e2 = 0.3     p1 = PortWordLength(n=7, p=3, e=e1, name=\"p1\", value=\"0100111\")     p2 = PortWordLength(n=5, p=2, e=e2, name=\"p2\")     p3 = PortWordLength(n=5, p=3, name=\"p3\")      e_p = error_propagation_mult(in1=p1, in2=p2, out=p3)     e_t = error_truncation_mult(in1=p1, in2=p2, out=p3)      err = e_p + e_t     print(f\"Propagation error: {e_p}\")     print(f\"Truncation error: {e_t}\")     print(f\"Error bound of the multiplication calculation: {err}\")   example_propagation_error_mult() <pre>Input p1: (n=7, p=3)\nInput p2: (n=5, p=2)\nIdeal Output: (n=12, p=5)\nActual Output (p3): (n=5, p=3)\nAssumption: p1 * p2 &lt; 8.0\nPropagation error: 2.81875\nTruncation error: 0.2421875\nError bound of the multiplication calculation: 3.0609375\n</pre> <p>The following functions show how we form contract for arbitrary length of input ports and output ports. The \"_a\" variables are used as the variable for the actual value going through the port.</p> In\u00a0[15]: Copied! <pre>def form_contract_add(\n    in_port1: PortWordLength, in_port2: PortWordLength, out_port: PortWordLength\n) -&gt; dict[str, object]:\n\"\"\"\n    Create contract in dictionary form for an addition operation.\n\n    The contract includes information about the bound for its output value and the bound for its maximum error\n\n    Args:\n        in_port1: PortWordLength: input port word length\n        in_port2: PortWordLength: input port word length\n        out_port: PortWordLength: output port word length\n\n    Returns:\n        The contract in dictionary form for an addition operation.\n    \"\"\"\n    ret_contract: dict[str, object] = {}\n    # define input/output vars\n    ret_contract[\"input_vars\"] = [\n        f\"{in_port1.name}_a\",\n        f\"{in_port1.name}_e\",\n        f\"{in_port2.name}_a\",\n        f\"{in_port2.name}_e\",\n    ]\n    ret_contract[\"output_vars\"] = [f\"{out_port.name}_a\", f\"{out_port.name}_e\"]\n    # get assumption\n    ideal_out_port = compute_required_word_length_add(in1=in_port1, in2=in_port2)\n    assumption_value = get_assumption_value(pi=ideal_out_port, po=out_port)\n    # write assumption in the contract\n    if assumption_value == float(\"inf\"):\n        ret_contract[\"assumptions\"] = []\n    else:\n        ret_contract[\"assumptions\"] = [\n            {\"coefficients\": {f\"{in_port1.name}_a\": 1, f\"{in_port2.name}_a\": 1}, \"constant\": assumption_value}\n        ]\n    # get guarantee\n    e_trunc = truncation_error(pi=ideal_out_port, po=out_port)\n\n    # write guarantee in the contract, note the propagation is encoded in the polyhedral constraints\n    ret_contract[\"guarantees\"] = [\n        {\n            \"coefficients\": {f\"{in_port1.name}_e\": -1, f\"{in_port2.name}_e\": -1, f\"{out_port.name}_e\": 1},\n            \"constant\": e_trunc,\n        },\n        {\"coefficients\": {f\"{out_port.name}_a\": 1}, \"constant\": out_port.a},\n        # {\"coefficients\":{f\"{out_port.name}_a\": 1}, \"constant\":in_port1.a + in_port2.a},\n        {\"coefficients\": {f\"{out_port.name}_a\": 1, f\"{in_port1.name}_a\": -1, f\"{in_port2.name}_a\": -1}, \"constant\": 0},\n    ]\n    return ret_contract\n\n\ndef form_contract_mult_const(\n    in_port: PortWordLength, in_port_const: PortWordLength, out_port: PortWordLength\n) -&gt; dict[str, object]:\n\"\"\"\n    Create contract in dictionary form for a constant coefficient multiplication operation.\n\n    The contract includes information about the bound for its output value and the bound for its maximum error\n\n    Args:\n        in_port: PortWordLength: input port word length\n        in_port_const: PortWordLength: constant input port word length\n        out_port: PortWordLength: output port word length\n\n    Returns:\n        The contract in dictionary form for a constant coefficient multiplication operation.\n    \"\"\"\n    ret_contract: dict[str, object] = {}\n    # define input/output vars\n    ret_contract[\"input_vars\"] = [f\"{in_port.name}_a\", f\"{in_port.name}_e\"]\n    ret_contract[\"output_vars\"] = [f\"{out_port.name}_a\", f\"{out_port.name}_e\"]\n    # get assumption\n    ideal_out_port = compute_required_word_length_mult(in1=in_port, in2=in_port_const)\n    assumption_value = get_assumption_value(pi=ideal_out_port, po=out_port)\n    # write assumption in the contract\n    if assumption_value == float(\"inf\"):\n        ret_contract[\"assumptions\"] = []\n    else:\n        print(assumption_value)\n        ret_contract[\"assumptions\"] = [\n            {\"coefficients\": {f\"{in_port.name}_a\": in_port_const.a}, \"constant\": assumption_value}\n        ]\n    # get guarantee\n    print(ideal_out_port.to_string())\n    e_trunc = truncation_error(pi=ideal_out_port, po=out_port)\n\n    # write guarantee in the contract, note the propagation is encoded in the polyhedral constraints\n    ret_contract[\"guarantees\"] = [\n        {\n            \"coefficients\": {\n                f\"{in_port.name}_e\": -in_port_const.a + in_port_const.e,\n                f\"{in_port.name}_a\": -in_port_const.e,\n                f\"{out_port.name}_e\": 1,\n            },\n            \"constant\": e_trunc,\n        },\n        {\"coefficients\": {f\"{out_port.name}_a\": 1}, \"constant\": out_port.a},\n        # {\"coefficients\":{f\"{out_port.name}_a\": 1}, \"constant\":in_port_const.a * in_port.a},\n        {\"coefficients\": {f\"{out_port.name}_a\": 1, f\"{in_port.name}_a\": -in_port_const.a}, \"constant\": 0},\n    ]\n    return ret_contract\n</pre> def form_contract_add(     in_port1: PortWordLength, in_port2: PortWordLength, out_port: PortWordLength ) -&gt; dict[str, object]:     \"\"\"     Create contract in dictionary form for an addition operation.      The contract includes information about the bound for its output value and the bound for its maximum error      Args:         in_port1: PortWordLength: input port word length         in_port2: PortWordLength: input port word length         out_port: PortWordLength: output port word length      Returns:         The contract in dictionary form for an addition operation.     \"\"\"     ret_contract: dict[str, object] = {}     # define input/output vars     ret_contract[\"input_vars\"] = [         f\"{in_port1.name}_a\",         f\"{in_port1.name}_e\",         f\"{in_port2.name}_a\",         f\"{in_port2.name}_e\",     ]     ret_contract[\"output_vars\"] = [f\"{out_port.name}_a\", f\"{out_port.name}_e\"]     # get assumption     ideal_out_port = compute_required_word_length_add(in1=in_port1, in2=in_port2)     assumption_value = get_assumption_value(pi=ideal_out_port, po=out_port)     # write assumption in the contract     if assumption_value == float(\"inf\"):         ret_contract[\"assumptions\"] = []     else:         ret_contract[\"assumptions\"] = [             {\"coefficients\": {f\"{in_port1.name}_a\": 1, f\"{in_port2.name}_a\": 1}, \"constant\": assumption_value}         ]     # get guarantee     e_trunc = truncation_error(pi=ideal_out_port, po=out_port)      # write guarantee in the contract, note the propagation is encoded in the polyhedral constraints     ret_contract[\"guarantees\"] = [         {             \"coefficients\": {f\"{in_port1.name}_e\": -1, f\"{in_port2.name}_e\": -1, f\"{out_port.name}_e\": 1},             \"constant\": e_trunc,         },         {\"coefficients\": {f\"{out_port.name}_a\": 1}, \"constant\": out_port.a},         # {\"coefficients\":{f\"{out_port.name}_a\": 1}, \"constant\":in_port1.a + in_port2.a},         {\"coefficients\": {f\"{out_port.name}_a\": 1, f\"{in_port1.name}_a\": -1, f\"{in_port2.name}_a\": -1}, \"constant\": 0},     ]     return ret_contract   def form_contract_mult_const(     in_port: PortWordLength, in_port_const: PortWordLength, out_port: PortWordLength ) -&gt; dict[str, object]:     \"\"\"     Create contract in dictionary form for a constant coefficient multiplication operation.      The contract includes information about the bound for its output value and the bound for its maximum error      Args:         in_port: PortWordLength: input port word length         in_port_const: PortWordLength: constant input port word length         out_port: PortWordLength: output port word length      Returns:         The contract in dictionary form for a constant coefficient multiplication operation.     \"\"\"     ret_contract: dict[str, object] = {}     # define input/output vars     ret_contract[\"input_vars\"] = [f\"{in_port.name}_a\", f\"{in_port.name}_e\"]     ret_contract[\"output_vars\"] = [f\"{out_port.name}_a\", f\"{out_port.name}_e\"]     # get assumption     ideal_out_port = compute_required_word_length_mult(in1=in_port, in2=in_port_const)     assumption_value = get_assumption_value(pi=ideal_out_port, po=out_port)     # write assumption in the contract     if assumption_value == float(\"inf\"):         ret_contract[\"assumptions\"] = []     else:         print(assumption_value)         ret_contract[\"assumptions\"] = [             {\"coefficients\": {f\"{in_port.name}_a\": in_port_const.a}, \"constant\": assumption_value}         ]     # get guarantee     print(ideal_out_port.to_string())     e_trunc = truncation_error(pi=ideal_out_port, po=out_port)      # write guarantee in the contract, note the propagation is encoded in the polyhedral constraints     ret_contract[\"guarantees\"] = [         {             \"coefficients\": {                 f\"{in_port.name}_e\": -in_port_const.a + in_port_const.e,                 f\"{in_port.name}_a\": -in_port_const.e,                 f\"{out_port.name}_e\": 1,             },             \"constant\": e_trunc,         },         {\"coefficients\": {f\"{out_port.name}_a\": 1}, \"constant\": out_port.a},         # {\"coefficients\":{f\"{out_port.name}_a\": 1}, \"constant\":in_port_const.a * in_port.a},         {\"coefficients\": {f\"{out_port.name}_a\": 1, f\"{in_port.name}_a\": -in_port_const.a}, \"constant\": 0},     ]     return ret_contract In\u00a0[16]: Copied! <pre>def example_contract_formulation() -&gt; None:\n\"\"\"Example of contract formulation\"\"\"\n    p1 = PortWordLength(n=7, p=3, name=\"p1\")\n    p2 = PortWordLength(n=5, p=2, name=\"p2\")\n    p3 = PortWordLength(n=5, p=3, name=\"p3\")\n    c1 = form_contract_add(in_port1=p1, in_port2=p2, out_port=p3)\n    print(c1)\n    contract1 = PolyhedralContract.from_dict(c1)\n    print(str(contract1))\n\n    e5 = 0.03\n    p4 = PortWordLength(n=7, p=3, name=\"p4\")\n    p5 = PortWordLength(n=5, p=2, e=e5, value=\"11011\", name=\"p5\")  # const\n    p6 = PortWordLength(n=5, p=3, name=\"p6\")\n    c2 = form_contract_mult_const(in_port=p4, in_port_const=p5, out_port=p6)\n    contract2 = PolyhedralContract.from_dict(c2)\n    print(str(contract2))\n\n\nexample_contract_formulation()\n</pre> def example_contract_formulation() -&gt; None:     \"\"\"Example of contract formulation\"\"\"     p1 = PortWordLength(n=7, p=3, name=\"p1\")     p2 = PortWordLength(n=5, p=2, name=\"p2\")     p3 = PortWordLength(n=5, p=3, name=\"p3\")     c1 = form_contract_add(in_port1=p1, in_port2=p2, out_port=p3)     print(c1)     contract1 = PolyhedralContract.from_dict(c1)     print(str(contract1))      e5 = 0.03     p4 = PortWordLength(n=7, p=3, name=\"p4\")     p5 = PortWordLength(n=5, p=2, e=e5, value=\"11011\", name=\"p5\")  # const     p6 = PortWordLength(n=5, p=3, name=\"p6\")     c2 = form_contract_mult_const(in_port=p4, in_port_const=p5, out_port=p6)     contract2 = PolyhedralContract.from_dict(c2)     print(str(contract2))   example_contract_formulation() <pre>{'input_vars': ['p1_a', 'p1_e', 'p2_a', 'p2_e'], 'output_vars': ['p3_a', 'p3_e'], 'assumptions': [{'coefficients': {'p1_a': 1, 'p2_a': 1}, 'constant': 8.0}], 'guarantees': [{'coefficients': {'p1_e': -1, 'p2_e': -1, 'p3_e': 1}, 'constant': 0.1875}, {'coefficients': {'p3_a': 1}, 'constant': 7.75}, {'coefficients': {'p3_a': 1, 'p1_a': -1, 'p2_a': -1}, 'constant': 0}]}\nInVars: [p1_a, p1_e, p2_a, p2_e]\nOutVars:[p3_a, p3_e]\nA: [\n  p1_a + p2_a &lt;= 8.0\n]\nG: [\n  -p1_e - p2_e + p3_e &lt;= 0.1875\n  p3_a &lt;= 7.75\n  -p1_a - p2_a + p3_a &lt;= 0.0\n]\n8.0\nPort: , (n, p) = (12, 5), e = 0, a = 31.9921875\nInVars: [p4_a, p4_e]\nOutVars:[p6_a, p6_e]\nA: [\n  3.375 p4_a &lt;= 8.0\n]\nG: [\n  -0.03 p4_a - 3.345 p4_e + p6_e &lt;= 0.2421875\n  p6_a &lt;= 7.75\n  -3.375 p4_a + p6_a &lt;= 0.0\n]\n</pre> <p>First, we express each port using the PortWordLength class, and then form the contracts for the operations.</p> In\u00a0[17]: Copied! <pre>def create_example1() -&gt; tuple:\n\"\"\"\n    Generate the example contracts and ports for the example\n\n    Returns:\n        A tuple with 2 elements. The first one is the list of contract, and the other is the list of ports\n    \"\"\"\n    p1 = PortWordLength(n=5, p=2, name=\"p1\")\n    p2 = PortWordLength(n=5, p=3, name=\"p2\")\n    p3 = PortWordLength(n=5, p=3, name=\"p3\")\n    c1 = form_contract_add(in_port1=p1, in_port2=p2, out_port=p3)\n\n    p4 = PortWordLength(n=7, p=3, name=\"p4\")\n    p5 = PortWordLength(n=6, p=3, name=\"p5\")\n    c2 = form_contract_add(in_port1=p3, in_port2=p4, out_port=p5)\n\n    contract1 = PolyhedralContract.from_dict(c1)\n    contract2 = PolyhedralContract.from_dict(c2)\n    contracts = [contract1, contract2]\n    ports = [p1, p2, p3, p4, p5]\n    return contracts, ports\n</pre> def create_example1() -&gt; tuple:     \"\"\"     Generate the example contracts and ports for the example      Returns:         A tuple with 2 elements. The first one is the list of contract, and the other is the list of ports     \"\"\"     p1 = PortWordLength(n=5, p=2, name=\"p1\")     p2 = PortWordLength(n=5, p=3, name=\"p2\")     p3 = PortWordLength(n=5, p=3, name=\"p3\")     c1 = form_contract_add(in_port1=p1, in_port2=p2, out_port=p3)      p4 = PortWordLength(n=7, p=3, name=\"p4\")     p5 = PortWordLength(n=6, p=3, name=\"p5\")     c2 = form_contract_add(in_port1=p3, in_port2=p4, out_port=p5)      contract1 = PolyhedralContract.from_dict(c1)     contract2 = PolyhedralContract.from_dict(c2)     contracts = [contract1, contract2]     ports = [p1, p2, p3, p4, p5]     return contracts, ports <p>We then use the composition to get the contract of the two adders.</p> In\u00a0[18]: Copied! <pre>def example_composition_two_adder() -&gt; None:\n\"\"\"Example of showing composition of two adder contracts\"\"\"\n    contracts, ports = create_example1()\n    contract1 = contracts[0]\n    contract2 = contracts[1]\n    print(\"Contract 1:\\n\" + str(contract1))\n    print(\"Contract 2:\\n\" + str(contract2))\n    contract_sys = contract1.compose(contract2)\n    print(\"Contract Sys:\\n\" + str(contract_sys))\n\n\nexample_composition_two_adder()\n</pre> def example_composition_two_adder() -&gt; None:     \"\"\"Example of showing composition of two adder contracts\"\"\"     contracts, ports = create_example1()     contract1 = contracts[0]     contract2 = contracts[1]     print(\"Contract 1:\\n\" + str(contract1))     print(\"Contract 2:\\n\" + str(contract2))     contract_sys = contract1.compose(contract2)     print(\"Contract Sys:\\n\" + str(contract_sys))   example_composition_two_adder() <pre>Contract 1:\nInVars: [p1_a, p1_e, p2_a, p2_e]\nOutVars:[p3_a, p3_e]\nA: [\n  p1_a + p2_a &lt;= 8.0\n]\nG: [\n  -p1_e - p2_e + p3_e &lt;= 0.125\n  p3_a &lt;= 7.75\n  -p1_a - p2_a + p3_a &lt;= 0.0\n]\nContract 2:\nInVars: [p3_a, p3_e, p4_a, p4_e]\nOutVars:[p5_a, p5_e]\nA: [\n  p3_a + p4_a &lt;= 8.0\n]\nG: [\n  -p3_e - p4_e + p5_e &lt;= 0.0625\n  p5_a &lt;= 7.875\n  -p3_a - p4_a + p5_a &lt;= 0.0\n]\nContract Sys:\nInVars: [p1_a, p1_e, p2_a, p2_e, p4_a, p4_e]\nOutVars:[p5_a, p5_e]\nA: [\n  p4_a &lt;= 0.25\n  p1_a + p2_a &lt;= 8.0\n]\nG: [\n  -p1_e - p2_e - p4_e + p5_e &lt;= 0.1875\n  -p4_a + p5_a &lt;= 7.75\n  -p1_a - p2_a - p4_a + p5_a &lt;= 0.0\n  p5_a &lt;= 7.875\n]\n</pre> <p>The composed contract shows the upper bound value and upper bound error of the output using the upper bound value and upper bound error of the inputs.</p> <p>As we know the input word length, we can encode the input contracts with the upper bound value and upper bound error of the inputs. Let's see what will happen to the composition if we compose the contracts with the input contracts.</p> In\u00a0[19]: Copied! <pre>def form_contract_input(in_port: PortWordLength) -&gt; dict[str, object]:\n\"\"\"\n    Create contract in dictionary form for a input port to the system.\n\n    The contract includes information about the bound for its output value and the bound for its maximum error\n\n    Args:\n        in_port: PortWordLength: input port word length\n\n    Returns:\n        The contract in dictionary form for a input port to the system.\n    \"\"\"\n    ret_contract: dict[str, object] = {}\n    # define input/output vars\n    ret_contract[\"input_vars\"] = []\n    ret_contract[\"output_vars\"] = [f\"{in_port.name}_a\", f\"{in_port.name}_e\"]\n    # get assumption\n    ret_contract[\"assumptions\"] = []\n    ret_contract[\"guarantees\"] = [\n        {\"coefficients\": {f\"{in_port.name}_a\": 1}, \"constant\": in_port.a},\n        {\"coefficients\": {f\"{in_port.name}_a\": -1}, \"constant\": 0},\n        {\"coefficients\": {f\"{in_port.name}_e\": 1}, \"constant\": in_port.e},\n        {\"coefficients\": {f\"{in_port.name}_e\": -1}, \"constant\": -in_port.e},\n    ]\n    return ret_contract\n</pre> def form_contract_input(in_port: PortWordLength) -&gt; dict[str, object]:     \"\"\"     Create contract in dictionary form for a input port to the system.      The contract includes information about the bound for its output value and the bound for its maximum error      Args:         in_port: PortWordLength: input port word length      Returns:         The contract in dictionary form for a input port to the system.     \"\"\"     ret_contract: dict[str, object] = {}     # define input/output vars     ret_contract[\"input_vars\"] = []     ret_contract[\"output_vars\"] = [f\"{in_port.name}_a\", f\"{in_port.name}_e\"]     # get assumption     ret_contract[\"assumptions\"] = []     ret_contract[\"guarantees\"] = [         {\"coefficients\": {f\"{in_port.name}_a\": 1}, \"constant\": in_port.a},         {\"coefficients\": {f\"{in_port.name}_a\": -1}, \"constant\": 0},         {\"coefficients\": {f\"{in_port.name}_e\": 1}, \"constant\": in_port.e},         {\"coefficients\": {f\"{in_port.name}_e\": -1}, \"constant\": -in_port.e},     ]     return ret_contract In\u00a0[20]: Copied! <pre>def composition_with_inputs(\n    contracts: list[PolyhedralContract], ports: list[PortWordLength]\n) -&gt; PolyhedralContract | None:\n\"\"\"\n    Composition of the two adder system considering input infomation\n\n    Args:\n        contracts: list of PolyhedralContract for the adders\n        ports: list of port wordlengths for the ports\n\n    Returns:\n        The composition result if the composition is valid\n    \"\"\"\n    p1 = ports[0]\n    p2 = ports[1]\n    p4 = ports[3]\n    contract1 = contracts[0]\n    contract2 = contracts[1]\n\n    c_p1 = form_contract_input(in_port=p1)\n    c_p2 = form_contract_input(in_port=p2)\n    c_p4 = form_contract_input(in_port=p4)\n\n    contract_p1 = PolyhedralContract.from_dict(c_p1)\n    contract_p2 = PolyhedralContract.from_dict(c_p2)\n    contract_p4 = PolyhedralContract.from_dict(c_p4)\n\n    # compose the system\n    try:\n        contract_sys = contract1.compose(contract2)\n    except ValueError as e:\n        print(\"Composition Error\")\n        print(e)\n        return None\n    try:\n        contract_sys = contract_p1.compose(contract_sys)\n    except ValueError as e:\n        print(\"Composition Error\")\n        print(e)\n        return None\n    try:\n        contract_sys = contract_p2.compose(contract_sys)\n    except ValueError as e:\n        print(\"Composition Error\")\n        print(e)\n        return None\n    try:\n        contract_sys = contract_p4.compose(contract_sys)\n    except ValueError as e:\n        print(\"Composition Error\")\n        print(e)\n        return None\n\n    print(\"Contract Sys:\\n\" + str(contract_sys))\n    return contract_sys\n\n\ndef example_composition_without_input_bounds() -&gt; None:\n\"\"\"Example of composition without input bounds\"\"\"\n    contracts, ports = create_example1()\n    composition_with_inputs(contracts, ports)\n\n\nexample_composition_without_input_bounds()\n</pre> def composition_with_inputs(     contracts: list[PolyhedralContract], ports: list[PortWordLength] ) -&gt; PolyhedralContract | None:     \"\"\"     Composition of the two adder system considering input infomation      Args:         contracts: list of PolyhedralContract for the adders         ports: list of port wordlengths for the ports      Returns:         The composition result if the composition is valid     \"\"\"     p1 = ports[0]     p2 = ports[1]     p4 = ports[3]     contract1 = contracts[0]     contract2 = contracts[1]      c_p1 = form_contract_input(in_port=p1)     c_p2 = form_contract_input(in_port=p2)     c_p4 = form_contract_input(in_port=p4)      contract_p1 = PolyhedralContract.from_dict(c_p1)     contract_p2 = PolyhedralContract.from_dict(c_p2)     contract_p4 = PolyhedralContract.from_dict(c_p4)      # compose the system     try:         contract_sys = contract1.compose(contract2)     except ValueError as e:         print(\"Composition Error\")         print(e)         return None     try:         contract_sys = contract_p1.compose(contract_sys)     except ValueError as e:         print(\"Composition Error\")         print(e)         return None     try:         contract_sys = contract_p2.compose(contract_sys)     except ValueError as e:         print(\"Composition Error\")         print(e)         return None     try:         contract_sys = contract_p4.compose(contract_sys)     except ValueError as e:         print(\"Composition Error\")         print(e)         return None      print(\"Contract Sys:\\n\" + str(contract_sys))     return contract_sys   def example_composition_without_input_bounds() -&gt; None:     \"\"\"Example of composition without input bounds\"\"\"     contracts, ports = create_example1()     composition_with_inputs(contracts, ports)   example_composition_without_input_bounds() <pre>Composition Error\nCould not eliminate variables ['p2_a']\nby refining the assumptions \n[\n  p2_a &lt;= 4.125\n]\nusing guarantees \n[\n  p2_a &lt;= 7.75\n  -p2_a &lt;= 0.0\n  p2_e = 0.0\n]\n\n</pre> <p>Then we consider the case where additional upper bound constraints are known for the inputs:</p> In\u00a0[21]: Copied! <pre>def example_composition_with_input_bounds() -&gt; None:\n\"\"\"Example of composition with correct input bounds\"\"\"\n    contracts, ports = create_example1()\n    p1 = ports[0]\n    p2 = ports[1]\n    p4 = ports[3]\n    p1.value = \"10000\"\n    p2.value = \"01111\"\n    p4.value = \"0000001\"\n    composition_with_inputs(contracts, ports)\n\n\nexample_composition_with_input_bounds()\n</pre> def example_composition_with_input_bounds() -&gt; None:     \"\"\"Example of composition with correct input bounds\"\"\"     contracts, ports = create_example1()     p1 = ports[0]     p2 = ports[1]     p4 = ports[3]     p1.value = \"10000\"     p2.value = \"01111\"     p4.value = \"0000001\"     composition_with_inputs(contracts, ports)   example_composition_with_input_bounds() <pre>Contract Sys:\nInVars: []\nOutVars:[p5_a, p5_e]\nA: [\n  \n]\nG: [\n  p5_a &lt;= 5.8125\n  p5_e &lt;= 0.1875\n]\n</pre> <p>In this case, we set the upper bound value of $P_1$ to be $4$, $P_2$ to be $3.75$, and $P_4$ to be $0.0625$.  Under these input constraints, the operation is compatible with the inputs.  And we obtain the composition results, which show the upper bound value and upper bound error of the output.</p> <p>We can utilize Pacti to perform local optimization on word lengths. Given the system specification as a contract, word length optimization aims to reduce the word length while ensuring that the resulting implementation meets the system specification. Quotient is a contract operation that allows us to break down specifications to a certain subsystem. In this example, we try to reduce the word length of $P_3$.</p> <p></p> <p>Since the word length of a variable affects the contract of operations that directly produce or use the variable, we can consider a subsystem consisting of those operations. For $P_3$, the subsystem will be the composition of the two adders.</p> <p>Assume our system specification is as follows:</p> <pre><code>A: True\nG: 1*p5_e &lt;= 0.1,\n</code></pre> <p>which requires the upper bound error of the output $P_5$ to be smaller than 0.1.</p> <p>We can invoke Pacti to compute the quotient to get the subsystem contract:</p> In\u00a0[22]: Copied! <pre>def get_desired_system_contract() -&gt; PolyhedralContract:\n\"\"\"\n    Generate contracts for the top-level specification\n\n    Returns:\n        The top-level specification contract\n    \"\"\"\n    ret_contract: dict[str, object] = {}\n    ret_contract[\"input_vars\"] = []\n    ret_contract[\"output_vars\"] = [\"p5_a\", \"p5_e\"]\n    ret_contract[\"assumptions\"] = []\n    ret_contract[\"guarantees\"] = [{\"coefficients\": {\"p5_e\": 1}, \"constant\": 0.1}]\n    return PolyhedralContract.from_dict(ret_contract)\n\n\ndef example_show_top_level_spec() -&gt; None:\n\"\"\"Example of showing the top level specification\"\"\"\n    contract_spec = get_desired_system_contract()\n    print(\"Top Level Specification:\")\n    print(str(contract_spec))\n\n\nexample_show_top_level_spec()\n</pre> def get_desired_system_contract() -&gt; PolyhedralContract:     \"\"\"     Generate contracts for the top-level specification      Returns:         The top-level specification contract     \"\"\"     ret_contract: dict[str, object] = {}     ret_contract[\"input_vars\"] = []     ret_contract[\"output_vars\"] = [\"p5_a\", \"p5_e\"]     ret_contract[\"assumptions\"] = []     ret_contract[\"guarantees\"] = [{\"coefficients\": {\"p5_e\": 1}, \"constant\": 0.1}]     return PolyhedralContract.from_dict(ret_contract)   def example_show_top_level_spec() -&gt; None:     \"\"\"Example of showing the top level specification\"\"\"     contract_spec = get_desired_system_contract()     print(\"Top Level Specification:\")     print(str(contract_spec))   example_show_top_level_spec() <pre>Top Level Specification:\nInVars: []\nOutVars:[p5_a, p5_e]\nA: [\n  \n]\nG: [\n  p5_e &lt;= 0.1\n]\n</pre> In\u00a0[23]: Copied! <pre>def quotient_example1() -&gt; PolyhedralContract:\n\"\"\"\n    Generate quotient based on the top-level specification and the system.\n\n    Returns:\n        The quotient result, the contract for the two adder operations\n    \"\"\"\n    contract_spec = get_desired_system_contract()\n    contracts, ports = create_example1()\n    p1 = ports[0]\n    p2 = ports[1]\n    p4 = ports[3]\n    p1.value = \"10000\"\n    p2.value = \"01111\"\n    p4.value = \"0000001\"\n\n    c_p1 = form_contract_input(in_port=p1)\n    c_p2 = form_contract_input(in_port=p2)\n    c_p4 = form_contract_input(in_port=p4)\n\n    contract_p1 = PolyhedralContract.from_dict(c_p1)\n    contract_p2 = PolyhedralContract.from_dict(c_p2)\n    contract_p4 = PolyhedralContract.from_dict(c_p4)\n\n    tmp_c1 = contract_spec.quotient(contract_p1)\n\n    tmp_c2 = tmp_c1.quotient(contract_p2)\n    return tmp_c2.quotient(contract_p4)\n\n\ndef example_quotient() -&gt; None:\n\"\"\"Example of showing using quotient to get contracts for the two adder operations\"\"\"\n    quotient_ret = quotient_example1()\n    print(\"Quotient of the Spec:\")\n    print(str(quotient_ret))\n\n\nexample_quotient()\n</pre> def quotient_example1() -&gt; PolyhedralContract:     \"\"\"     Generate quotient based on the top-level specification and the system.      Returns:         The quotient result, the contract for the two adder operations     \"\"\"     contract_spec = get_desired_system_contract()     contracts, ports = create_example1()     p1 = ports[0]     p2 = ports[1]     p4 = ports[3]     p1.value = \"10000\"     p2.value = \"01111\"     p4.value = \"0000001\"      c_p1 = form_contract_input(in_port=p1)     c_p2 = form_contract_input(in_port=p2)     c_p4 = form_contract_input(in_port=p4)      contract_p1 = PolyhedralContract.from_dict(c_p1)     contract_p2 = PolyhedralContract.from_dict(c_p2)     contract_p4 = PolyhedralContract.from_dict(c_p4)      tmp_c1 = contract_spec.quotient(contract_p1)      tmp_c2 = tmp_c1.quotient(contract_p2)     return tmp_c2.quotient(contract_p4)   def example_quotient() -&gt; None:     \"\"\"Example of showing using quotient to get contracts for the two adder operations\"\"\"     quotient_ret = quotient_example1()     print(\"Quotient of the Spec:\")     print(str(quotient_ret))   example_quotient() <pre>Quotient of the Spec:\nInVars: [p1_a, p1_e, p2_a, p2_e, p4_a, p4_e]\nOutVars:[p5_a, p5_e]\nA: [\n  p1_a &lt;= 2.0\n  -p1_a &lt;= 0.0\n  p1_e = 0.0\n  p2_a &lt;= 3.75\n  -p2_a &lt;= 0.0\n  p2_e = 0.0\n  p4_a &lt;= 0.0625\n  -p4_a &lt;= 0.0\n  p4_e = 0.0\n]\nG: [\n  p5_e &lt;= 0.10000000000000009\n]\n</pre> <p>The above contracts show the specification for the subsystem of two adders to meet such that the system contract can be implemented correctly.  The refinement operation checks whether the selected word length meets the subsystem contract. This way of breaking down contracts into a subsystem allows us to reduce the problem size of the optimization. We can find the word length that satisfies the subsystem contracts for the two adders without considering the input constraints. As a result, we perform an exhaustive search to find the word length that meets the subsystem contract and, therefore, the system contract.</p> In\u00a0[24]: Copied! <pre>def create_example1_by_p3(p3_n: int, p3_p: int) -&gt; tuple:\n\"\"\"\n    Generate the example contracts and ports for the example, given different wordlength of p3\n\n    Args:\n        p3_n: the integer which defines the wordlength n for p3\n        p3_p: the integer which defines the wordlength p for p3\n\n    Returns:\n        A tuple with 2 elements. The first one is the list of contract, and the other is the list of ports\n    \"\"\"\n    p1 = PortWordLength(n=5, p=2, name=\"p1\")\n    p2 = PortWordLength(n=5, p=3, name=\"p2\")\n    p3 = PortWordLength(n=p3_n, p=p3_p, name=\"p3\")\n    c1 = form_contract_add(in_port1=p1, in_port2=p2, out_port=p3)\n\n    p4 = PortWordLength(n=7, p=3, name=\"p4\")\n    p5 = PortWordLength(n=6, p=3, name=\"p5\")\n    c2 = form_contract_add(in_port1=p3, in_port2=p4, out_port=p5)\n\n    p1.value = \"10000\"\n    p2.value = \"01111\"\n    p4.value = \"0000000\"\n\n    contract1 = PolyhedralContract.from_dict(c1)\n    contract2 = PolyhedralContract.from_dict(c2)\n    # print(\"Contract 1:\\n\" + str(contract1))\n    # print(\"Contract 2:\\n\" + str(contract2))\n    contracts = [contract1, contract2]\n    ports = [p1, p2, p3, p4, p5]\n    return contracts, ports\n\n\ndef exhaustive_search() -&gt; int:\n\"\"\"\n    Perform exhaustive search on finding the minimum wordlength that satisfy the top-level specification\n\n    Returns:\n        The word length n for p3\n    \"\"\"\n    quotient_ret = quotient_example1()\n    for n in range(5, 10):\n        # print(n)\n        p = 3  # keep the same number of bits (2) before binary point\n        contracts, ports = create_example1_by_p3(p3_n=n, p3_p=p)\n        contract1 = contracts[0]\n        contract2 = contracts[1]\n        try:\n            contract_sys = contract1.compose(contract2)\n            # contract_sys = compose_all(contract1, contract2, p1, p2, p3, p4, p5)\n            # print(str(contract_sys))\n        except ValueError:\n            continue\n\n        if contract_sys.refines(quotient_ret):\n            return n\n    return -1\n\n\ndef example_word_length_optimization() -&gt; None:\n\"\"\"Example of showing word length optimization on p3 for the case study\"\"\"\n    n = exhaustive_search()\n    print(f\"Wordlength for P3 to satisfy the spec is n = {n}\")\n\n\nexample_word_length_optimization()\n</pre> def create_example1_by_p3(p3_n: int, p3_p: int) -&gt; tuple:     \"\"\"     Generate the example contracts and ports for the example, given different wordlength of p3      Args:         p3_n: the integer which defines the wordlength n for p3         p3_p: the integer which defines the wordlength p for p3      Returns:         A tuple with 2 elements. The first one is the list of contract, and the other is the list of ports     \"\"\"     p1 = PortWordLength(n=5, p=2, name=\"p1\")     p2 = PortWordLength(n=5, p=3, name=\"p2\")     p3 = PortWordLength(n=p3_n, p=p3_p, name=\"p3\")     c1 = form_contract_add(in_port1=p1, in_port2=p2, out_port=p3)      p4 = PortWordLength(n=7, p=3, name=\"p4\")     p5 = PortWordLength(n=6, p=3, name=\"p5\")     c2 = form_contract_add(in_port1=p3, in_port2=p4, out_port=p5)      p1.value = \"10000\"     p2.value = \"01111\"     p4.value = \"0000000\"      contract1 = PolyhedralContract.from_dict(c1)     contract2 = PolyhedralContract.from_dict(c2)     # print(\"Contract 1:\\n\" + str(contract1))     # print(\"Contract 2:\\n\" + str(contract2))     contracts = [contract1, contract2]     ports = [p1, p2, p3, p4, p5]     return contracts, ports   def exhaustive_search() -&gt; int:     \"\"\"     Perform exhaustive search on finding the minimum wordlength that satisfy the top-level specification      Returns:         The word length n for p3     \"\"\"     quotient_ret = quotient_example1()     for n in range(5, 10):         # print(n)         p = 3  # keep the same number of bits (2) before binary point         contracts, ports = create_example1_by_p3(p3_n=n, p3_p=p)         contract1 = contracts[0]         contract2 = contracts[1]         try:             contract_sys = contract1.compose(contract2)             # contract_sys = compose_all(contract1, contract2, p1, p2, p3, p4, p5)             # print(str(contract_sys))         except ValueError:             continue          if contract_sys.refines(quotient_ret):             return n     return -1   def example_word_length_optimization() -&gt; None:     \"\"\"Example of showing word length optimization on p3 for the case study\"\"\"     n = exhaustive_search()     print(f\"Wordlength for P3 to satisfy the spec is n = {n}\")   example_word_length_optimization() <pre>Wordlength for P3 to satisfy the spec is n = 6\n</pre> <p>And we successfully find the word length of 6 that meets the system specification.</p> <p>Assume the word lengths of all variables in the system are (6, 0). We can obtain the upper bound error of the output as the previous example:</p> In\u00a0[25]: Copied! <pre>def example2_filter_design() -&gt; None:\n\"\"\"Example showing the composition of the filter design\"\"\"\n    in1 = PortWordLength(n=6, p=0, e=0, name=\"in1\")\n    in2 = PortWordLength(n=6, p=0, e=0, name=\"in2\")\n    in3 = PortWordLength(n=6, p=0, e=0, name=\"in3\")\n    const1 = PortWordLength(n=6, p=0, name=\"const1\")\n    const2 = PortWordLength(n=6, p=0, name=\"const2\")\n    const3 = PortWordLength(n=6, p=0, name=\"const3\")\n    mult_out1 = PortWordLength(n=6, p=0, name=\"mult_out1\")\n    mult_out2 = PortWordLength(n=6, p=0, name=\"mult_out2\")\n    mult_out3 = PortWordLength(n=6, p=0, name=\"mult_out3\")\n    add_out1 = PortWordLength(n=6, p=0, name=\"add_out1\")\n    add_out2 = PortWordLength(n=6, p=0, name=\"add_out2\")\n\n    a = 0.2\n    b = 0.6\n    c = 0.2\n    const1.value = float_to_bin(a, const1)\n    const2.value = float_to_bin(b, const2)\n    const3.value = float_to_bin(c, const3)\n    const1.e = a - const1.value_num()\n    const2.e = b - const2.value_num()\n    const3.e = c - const3.value_num()\n\n    print(f\"truncated coefficient: {a} to {const1.value_num()}\")\n    print(f\"truncated coefficient: {b} to {const2.value_num()}\")\n    print(f\"truncated coefficient: {c} to {const3.value_num()}\")\n\n    c1 = form_contract_mult_const(in_port=in1, in_port_const=const1, out_port=mult_out1)\n    c2 = form_contract_mult_const(in_port=in2, in_port_const=const2, out_port=mult_out2)\n    c3 = form_contract_mult_const(in_port=in3, in_port_const=const3, out_port=mult_out3)\n\n    ci1 = form_contract_input(in_port=in1)\n    ci2 = form_contract_input(in_port=in2)\n    ci3 = form_contract_input(in_port=in3)\n\n    contract1 = PolyhedralContract.from_dict(c1)\n    contract2 = PolyhedralContract.from_dict(c2)\n    contract3 = PolyhedralContract.from_dict(c3)\n    contract_i1 = PolyhedralContract.from_dict(ci1)\n    contract_i2 = PolyhedralContract.from_dict(ci2)\n    contract_i3 = PolyhedralContract.from_dict(ci3)\n    c4 = form_contract_add(in_port1=mult_out1, in_port2=mult_out2, out_port=add_out1)\n    c5 = form_contract_add(in_port1=add_out1, in_port2=mult_out3, out_port=add_out2)\n    contract4 = PolyhedralContract.from_dict(c4)\n    contract5 = PolyhedralContract.from_dict(c5)\n\n    contract_system = contract_i1.compose(contract1)\n    contract_system = contract_system.compose(contract_i2)\n    contract_system = contract_system.compose(contract2)\n    contract_system = contract_system.compose(contract_i3)\n    contract_system = contract_system.compose(contract3)\n    contract_system = contract_system.compose(contract4)\n    contract_system = contract_system.compose(contract5)\n    print(str(contract_system))\n\n\nexample2_filter_design()\n</pre> def example2_filter_design() -&gt; None:     \"\"\"Example showing the composition of the filter design\"\"\"     in1 = PortWordLength(n=6, p=0, e=0, name=\"in1\")     in2 = PortWordLength(n=6, p=0, e=0, name=\"in2\")     in3 = PortWordLength(n=6, p=0, e=0, name=\"in3\")     const1 = PortWordLength(n=6, p=0, name=\"const1\")     const2 = PortWordLength(n=6, p=0, name=\"const2\")     const3 = PortWordLength(n=6, p=0, name=\"const3\")     mult_out1 = PortWordLength(n=6, p=0, name=\"mult_out1\")     mult_out2 = PortWordLength(n=6, p=0, name=\"mult_out2\")     mult_out3 = PortWordLength(n=6, p=0, name=\"mult_out3\")     add_out1 = PortWordLength(n=6, p=0, name=\"add_out1\")     add_out2 = PortWordLength(n=6, p=0, name=\"add_out2\")      a = 0.2     b = 0.6     c = 0.2     const1.value = float_to_bin(a, const1)     const2.value = float_to_bin(b, const2)     const3.value = float_to_bin(c, const3)     const1.e = a - const1.value_num()     const2.e = b - const2.value_num()     const3.e = c - const3.value_num()      print(f\"truncated coefficient: {a} to {const1.value_num()}\")     print(f\"truncated coefficient: {b} to {const2.value_num()}\")     print(f\"truncated coefficient: {c} to {const3.value_num()}\")      c1 = form_contract_mult_const(in_port=in1, in_port_const=const1, out_port=mult_out1)     c2 = form_contract_mult_const(in_port=in2, in_port_const=const2, out_port=mult_out2)     c3 = form_contract_mult_const(in_port=in3, in_port_const=const3, out_port=mult_out3)      ci1 = form_contract_input(in_port=in1)     ci2 = form_contract_input(in_port=in2)     ci3 = form_contract_input(in_port=in3)      contract1 = PolyhedralContract.from_dict(c1)     contract2 = PolyhedralContract.from_dict(c2)     contract3 = PolyhedralContract.from_dict(c3)     contract_i1 = PolyhedralContract.from_dict(ci1)     contract_i2 = PolyhedralContract.from_dict(ci2)     contract_i3 = PolyhedralContract.from_dict(ci3)     c4 = form_contract_add(in_port1=mult_out1, in_port2=mult_out2, out_port=add_out1)     c5 = form_contract_add(in_port1=add_out1, in_port2=mult_out3, out_port=add_out2)     contract4 = PolyhedralContract.from_dict(c4)     contract5 = PolyhedralContract.from_dict(c5)      contract_system = contract_i1.compose(contract1)     contract_system = contract_system.compose(contract_i2)     contract_system = contract_system.compose(contract2)     contract_system = contract_system.compose(contract_i3)     contract_system = contract_system.compose(contract3)     contract_system = contract_system.compose(contract4)     contract_system = contract_system.compose(contract5)     print(str(contract_system))   example2_filter_design() <pre>truncated coefficient: 0.2 to 0.1875\ntruncated coefficient: 0.6 to 0.59375\ntruncated coefficient: 0.2 to 0.1875\nPort: , (n, p) = (12, 0), e = 0, a = 0.999755859375\nPort: , (n, p) = (12, 0), e = 0, a = 0.999755859375\nPort: , (n, p) = (12, 0), e = 0, a = 0.999755859375\nInVars: []\nOutVars:[add_out2_a, add_out2_e]\nA: [\n  \n]\nG: [\n  add_out2_e &lt;= 0.076904296875\n  add_out2_a &lt;= 0.95361328125\n]\n</pre> <p>The result shows that the upper bound error of the output <code>add_out_e</code> is 0.07690.</p> <p>Note that the upper bound is not tight as we abstract the calculation and consider the worse case truncation error for each operation. The worst case might not happen in all operations simultaneouly, and thus the bound is pessimistic. However, a pessimistic bound still allows us to analyze the design. If the obtained error is smaller than the specification, we can rest assured that the design already satisfies the system specification.</p> <p>Though it is sufficient for us to efficiently obtain an upper bound and perform optimization to get a better design, we still want to know how tight the bound is. In the following, we try to enumerate all input combinations to find the actual maximum error:</p> In\u00a0[26]: Copied! <pre>def example_enumerate_error() -&gt; None:\n\"\"\"Find the actual bound by enumerating the input combinations\"\"\"\n    in1 = PortWordLength(n=6, p=0, e=0, name=\"in1\")\n    in2 = PortWordLength(n=6, p=0, e=0, name=\"in2\")\n    in3 = PortWordLength(n=6, p=0, e=0, name=\"in3\")\n    const1 = PortWordLength(n=6, p=0, name=\"const1\")\n    const2 = PortWordLength(n=6, p=0, name=\"const2\")\n    const3 = PortWordLength(n=6, p=0, name=\"const3\")\n    mult_out1 = PortWordLength(n=6, p=0, name=\"mult_out1\")\n    mult_out2 = PortWordLength(n=6, p=0, name=\"mult_out2\")\n    mult_out3 = PortWordLength(n=6, p=0, name=\"mult_out3\")\n    add_out1 = PortWordLength(n=6, p=0, name=\"add_out1\")\n    add_out2 = PortWordLength(n=6, p=0, name=\"add_out2\")\n\n    a = 0.2\n    b = 0.6\n    c = 0.2\n    const1.value = float_to_bin(a, const1)\n    const2.value = float_to_bin(b, const2)\n    const3.value = float_to_bin(c, const3)\n\n    diff_max: float = 0\n    a_max: float = 0\n    i1_max: float = 0\n    i2_max: float = 0\n    i3_max: float = 0\n    for i1, i2, i3 in itertools.combinations(range(0, 2**6), 3):\n        i1_float = i1 / 2**6\n        in1_a = float_to_bin(i1_float, in1)\n        in1.value = in1_a\n\n        i2_float = i2 / 2**6\n        in2_a = float_to_bin(i2_float, in2)\n        in2.value = in2_a\n\n        i3_float = i3 / 2**6\n        in3_a = float_to_bin(i3_float, in3)\n        in3.value = in3_a\n\n        port_mult(in1, const1, mult_out1)\n        port_mult(in2, const2, mult_out2)\n        port_mult(in3, const3, mult_out3)\n        port_add(mult_out1, mult_out2, add_out1)\n        port_add(add_out1, mult_out3, add_out2)\n        actual_result = add_out2.value_num()\n        ideal_result = i1_float * a + i2_float * b + i3_float * c\n        diff = ideal_result - actual_result\n\n        if diff &gt; diff_max:\n            diff_max = diff\n            i1_max = i1_float\n            i2_max = i2_float\n            i3_max = i3_float\n        if actual_result &gt; a_max:\n            a_max = actual_result\n\n    print(diff_max, i1_max, i2_max, i3_max, a_max)\n\n\nexample_enumerate_error()\n</pre> def example_enumerate_error() -&gt; None:     \"\"\"Find the actual bound by enumerating the input combinations\"\"\"     in1 = PortWordLength(n=6, p=0, e=0, name=\"in1\")     in2 = PortWordLength(n=6, p=0, e=0, name=\"in2\")     in3 = PortWordLength(n=6, p=0, e=0, name=\"in3\")     const1 = PortWordLength(n=6, p=0, name=\"const1\")     const2 = PortWordLength(n=6, p=0, name=\"const2\")     const3 = PortWordLength(n=6, p=0, name=\"const3\")     mult_out1 = PortWordLength(n=6, p=0, name=\"mult_out1\")     mult_out2 = PortWordLength(n=6, p=0, name=\"mult_out2\")     mult_out3 = PortWordLength(n=6, p=0, name=\"mult_out3\")     add_out1 = PortWordLength(n=6, p=0, name=\"add_out1\")     add_out2 = PortWordLength(n=6, p=0, name=\"add_out2\")      a = 0.2     b = 0.6     c = 0.2     const1.value = float_to_bin(a, const1)     const2.value = float_to_bin(b, const2)     const3.value = float_to_bin(c, const3)      diff_max: float = 0     a_max: float = 0     i1_max: float = 0     i2_max: float = 0     i3_max: float = 0     for i1, i2, i3 in itertools.combinations(range(0, 2**6), 3):         i1_float = i1 / 2**6         in1_a = float_to_bin(i1_float, in1)         in1.value = in1_a          i2_float = i2 / 2**6         in2_a = float_to_bin(i2_float, in2)         in2.value = in2_a          i3_float = i3 / 2**6         in3_a = float_to_bin(i3_float, in3)         in3.value = in3_a          port_mult(in1, const1, mult_out1)         port_mult(in2, const2, mult_out2)         port_mult(in3, const3, mult_out3)         port_add(mult_out1, mult_out2, add_out1)         port_add(add_out1, mult_out3, add_out2)         actual_result = add_out2.value_num()         ideal_result = i1_float * a + i2_float * b + i3_float * c         diff = ideal_result - actual_result          if diff &gt; diff_max:             diff_max = diff             i1_max = i1_float             i2_max = i2_float             i3_max = i3_float         if actual_result &gt; a_max:             a_max = actual_result      print(diff_max, i1_max, i2_max, i3_max, a_max)   example_enumerate_error() <pre>0.06874999999999998 0.828125 0.890625 0.90625 0.90625\n</pre> <p>The actual bound is about $0.0687$, which is slightly smaller than our derived bound of $0.0769$. This verifies that our upper bound error is indeed an upper bound for all input combinations.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#introduction","title":"Introduction\u00b6","text":"<p>In this case study, we show Pacti can work with a contract-based methodology to aid word-length optimization of digital signal processing integrated circuit design.</p> <p>A digital signal processing system takes digital signals as inputs and generates the output signals by applying digital filters. The input signals are usually obtained through an analog-to-digital converter(ADC) from analog signals acquired from the environment by sensors. The impulse response of the digital filter is a set of coefficients that multiply with the input signals. The result is summed up to get the output signals.</p> <p>Implementation of a digital filter in hardware is a time-consuming and error-prone process. To push the power, performance, and area to their limits, the floating-point operations are converted to fixed-point ones to reduce hardware costs and improve efficiency. However, the conversion incurs challenges, including the risk of overflow and lower accuracy. As a fixed-point number can represent smaller range than a floating-point one with the same number of bits, overflow might occur after the conversion. The fixed-point number with fewer bits tends to have lower accuracy as all bits in the fractional parts exceeding its fractional bits have to be discarded.</p> <p>The following figure shows a multiplication operation using fixed-point numbers. </p> <p>As a result, verifying and optimizing word length for fixed-point implementation is crucial for integrated circuit implementations. To prevent overflow and ensure the inaccuracy is acceptable, we need to bound the error of the system given the wordlength.  In this case study, we apply contracts to compute the bounds of error of fixed-point arithmetic implementation.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#preliminaries","title":"Preliminaries\u00b6","text":"<p>First, we introduce the fixed-point number.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#representation-of-fixed-point-number","title":"Representation of Fixed-point Number\u00b6","text":"<p>A word length of a fixed-point variable $x$ can denoted as a tuple $(x_n, x_p)$, where $x_n$ denotes the number of bits, and $x_p$ is number of bits for the integer parts. For example, a fixed-point number with word length $(5,2)$ with bit value \"11011\" means the binary number $11.011$, equivalent to $3.375$ in decimal.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#error-sources-in-fixed-point-arithmetic","title":"Error Sources in Fixed-point Arithmetic\u00b6","text":"<p>The error of fixed-point arithmetic comes from the following sources:</p> <ol> <li>Truncation Errors:</li> </ol> <p>A truncation error occurs when a fixed-point number is converted from a longer representation to a shorter one. As the number of bits is insufficient to represent the number perfectly, the least significant bits are truncated to match the word length. Truncation errors occur in fixed-point operations when the word length of the output variable is smaller than the ideal result. 2. Quantization Error: The quantization error occurs when an analog signal is converted into a digital one or when the coefficients are encoded into digital formats. As a fixed-point number cannot represent any real number with infinite precision, the signals and coefficients have to be quantized, and errors are introduced in the process. 3. Inaccurate Source: This error comes from the measurement in the analog signal because of noise and non-ideal effect on the sensor and could be seen as a random noise on the analog signal.</p> <p>The following figure shows the three types of error in the example. </p> <p>Given a input analog signal, the input signal and filter coefficients are first quantized into fixed-point numbers. Then the arithmetic operations, based on the algorithm or filter design, are performed on these fixed-point numbers. The results of the operations are truncated to fit into the fixed-point numbers of the output of the arithmetic operations.</p> <p>During the process, differences between the fixed-point numbers representation and the ideal numbers result in errors. These errors propagate through the operations and thus affect the accuracy of the output signal.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#forming-contract-for-capturing-error-of-fixed-point-number","title":"Forming contract for capturing error of fixed-point number\u00b6","text":"<p>Here we introduce how to form the contract for finding error bounds of the fixed-point number operation. First, we model the truncation errors and investigate how an operation result in the truncation errors. Then we consider the propagation of the error in different operations. We formulate the contract by combining the truncation errors and propagation of the error.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#modeling-of-error-from-operations","title":"Modeling of Error from Operations\u00b6","text":"<p>Each operation can be seen as a two-staged process. First, an ideal output with certain wordlength is generated without losing any accuracy, given the word lengths of all input ports. Then the ideal output is truncated to the actual output port. Therefore, the modeling of the ideal output wordlength and the truncation error is required to formulate the contract.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#operation-error-modeling","title":"Operation Error Modeling\u00b6","text":"<p>In the following, we detail how to model the truncation error. We divide the truncation error into two cases according to the number of bits for integer part.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#case-1-identical-number-of-bits-in-integer-part","title":"Case 1: Identical Number of Bits in Integer Part\u00b6","text":"<p>As the integer part has the same number of bits, overflow does not occur in this case. The least significant bits are truncated if the resulting word length is shorter. The maximal truncation error from the word length $(x_n, x_p)$ to the word length $(x_n', x_p)$ is $2^{x_p}(2^{-x_n'}-2^{-x_n})$, when $x_n &gt; x_n'$. If $x_n &lt; x_n'$, there is no truncation, and thus the truncation error is exactly $0$.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#case-2-different-number-of-bits-in-integer-part","title":"Case 2. Different Number of Bits in Integer Part\u00b6","text":"<p>As the integer parts have different numbers of bits, overflow could occur if the resulting number cannot hold the original integer values. If an overflow occurs, the result deviates from the ideal value, and thus we expect no overflow occurs during the computation. This expectation will be applied as the assumption in subsequent parts when we formulate contracts.</p> <p>Consider the case when converting a variable $x$ with word length $(x_n, x_p)$ to the variable $x'$ with word length $(x_n', x_p')$. We have to ensure that the value of $x$ does not incur overflow in $x'$. Therefore, it is reasonable to assume that we know that $x$ is bounded by $2^{x_p'}$ so that $x'$ can represent the number without overflows.</p> <p>Then, we can ignore the unnecessary most significant bits ($x_p - x_p'$), as they are always $0$s under the assumption. As a result, $(x_n, x_p)$ can be seen as $(x_n - x_p + x_p', x_p')$.  The two numbers now have identical numbers of bits in their integer parts, and thus we can apply case 1 to get the truncation errors under the assumption.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#ideal-output-wordlength","title":"Ideal Output Wordlength\u00b6","text":"<p>Now we know how to get the truncation errors given the word length of two numbers, but what is the word length truncated in operations?</p> <p>Each operation requires a minimum ideal output word length to fully hold the resulting value without losing any information. Assuming a binary operator, with inputs being $x$ and $y$ and output being $z$, we represent the ideal output word length using $(z_n^*, z_p^*)$. The ideal output word length is then truncated to fit the output port.</p> <p>Therefore, we need to know the ideal output word length for the operations. Let's first examine the addition and then the multiplication.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#addition","title":"Addition\u00b6","text":"<p>The following equations show the ideal output word length for addition.</p> <p>$z_n^* = \\max(x_n, y_n - y_p + x_p) + \\min(0, x_p - y_p) + 1$,</p> <p>$z_p^* = \\max(x_p, y_p) + 1$.</p> <p>The rationale behind the equations is to keep every bit from both inputs and include an additional bit for the carry.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#multiplication","title":"Multiplication\u00b6","text":"<p>The following equations show the ideal output word length for multiplication.</p> <p>$z_n^* = x_n + y_n$,</p> <p>$z_p* = x_p, y_p$.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#propagation-of-error","title":"Propagation of Error\u00b6","text":"<p>Since fixed-point arithmetic incurs errors, the error could propagate through the previous operation to the final output. This error can be seen as independent of truncation error, as truncation errors are applied to the actual input numbers, which already contain the propagation errors. As a result, the error in the output variable $z$, denoted as $z_e$, can be represented as the sum of the propagation error and the truncation error in the stage:</p> <p>$z_e = z_{et} + z_{ep}$,</p> <p>where $z_{ep}$ is the propagation error from inputs, and $z_{et}$ denotes the truncation error occurs in the operation.</p> <p>Let's now see how the error is propagated in different operations.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#general-operation","title":"General Operation\u00b6","text":"<p>The propagation error is bounded by the maximum differences between the ideal value and the actual values. Therefore, the propagation errors can be modeled as follows:</p> <p>$z_{ep} = \\max_{0&lt;=x&lt;=x_a, 0&lt;=y&lt;=y_a}(f(x, y)) - f(x-x_e, y-y_e))$,</p> <p>where $x_{a}$ and $y_{a}$ is the upper bound of input variables $x$ and $y$, respectively.</p> <p>According to this equation, we can derive the propagation error for addition and multiplication operations.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#propagation-of-error-in-addition","title":"Propagation of Error in Addition\u00b6","text":"<p>The error is exactly the sum of error from both inputs. $z_{ep} = x_{e} + y_{e}$</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#propagation-of-error-in-multiplication","title":"Propagation of Error in Multiplication\u00b6","text":"<p>The error is as follows:</p> <p>$z_{ep} = x_{a}*y_{e} + y_{a}*x_{e} - x_{e} * y_{e}$,</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#contract-formulation","title":"Contract Formulation\u00b6","text":"<p>We can formulate contracts for each operation by combining the modeling of error bounds from propagation and truncation. A contract is a pair of an assumption and a guarantee $C = (A, G)$, where $C$ represents the contract, $A$ denotes its assumption, and $G$ is the guarantee. In the following, we shall introduce the contract formulation for different operations.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#ports-in-contract","title":"Ports in Contract\u00b6","text":"<p>Contracts specify system behaviors by describing the assignment of values in ports.  For our case study, we see a variable $x$ as a combination of two ports: the upper bound value port and the upper bound error port.  The upper bound value port $x_a$ tells the connected component the maximum value the variable can be, and the upper bound error port $x_e$   passes the maximum error to the connected component.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#assumption","title":"Assumption\u00b6","text":"<p>The assumption ensures no overflow occurs during the truncation, which has been introduced in the case where truncation involves two variables with different numbers of bits in the integer parts.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#guarantee","title":"Guarantee\u00b6","text":"<p>The guarantee of the contract includes two parts. The first part describes the upper bound value, and the second states the upper bound error.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#example-1","title":"Example 1\u00b6","text":"<p>Consider the following simple system with two adders.</p> <p></p> <p>The word length is labeled beside the variable.  We will show how Pacti can be applied to get the error bound for the word length.</p>"},{"location":"_case_studies/cs-digital-signal-processing/dsp_wl/#example-2-filter-design","title":"Example 2: Filter Design\u00b6","text":"<p>Now we apply the contract to a simple filter that computes the moving average of the input signal, as shown in the figure below,</p> <p></p> <p>, where the coefficient is $a = 0.2$, $b = 0.6$, and $c = 0.2$. Therefore, $y[n] = 0.2 \\times x[n-2] + 0.6 \\times x[n-1] + 0.2 \\times x[n] $.</p>"},{"location":"_case_studies/cs-multiagent-planning/multiagent/","title":"Trajectory planning for multi-agent systems","text":"<p>Multi-agent path finding (MAPF) is a problem that has been studied for a large number of years for applications including robotics, aviation, video games, and more [Dresner and Stone 2008, Ma et al. 2017, Pallottino et al. 2007, Silver 2005, Wurman et al. 2008]. It raises the question of how multiple agents can reach their goal position without colliding with each other.</p> <p>In this case study we are using contracts defined in pacti to ensure that the resulting path is conflict-free. We are focusing on vertex conflicts, where two or more agents cannot share a grid cell, and swapping conflicts, preventing two agents from swapping positions in two adjacent cells. For a detailed survey on objective functions and conflict types, see [Stern et al. 2019].</p> <p>In the following section we will explain the problem setup and illustrate our approach of using contracts to find a safe strategy for the robots. The benefit of using contracts for this application is how modularly we can add/remove robots or additional contraints to the problem.</p> <p>In the video below you can see the implementation of the resulting strategy for five robots on the Robotarium [Wilson et al. 2020].</p> <p></p> <p>This case study shows how Pacti can be used to formalize a multiagent navigation problem and synthesize a strategy for the robots to reach their respective goal position without crashing into each other.</p> <p>We will start by importing the relevant packages.</p> In\u00a0[1]: Copied! <pre>%matplotlib inline\nimport numpy as np\nfrom utils.multiagent_utils import (\n    Coord,\n    Robot,\n    distance,\n    find_move_candidates_three,\n    get_collision_contract,\n    get_swapping_contract,\n    strategy,\n    strategy_multiple,\n)\nfrom utils.plotting_utils import (\n    Snapshot,\n    animate,\n    plot_grid_world,\n    save_trace\n)\n\nfrom pacti.iocontract import Var\nfrom pacti.terms.polyhedra import PolyhedralContractCompound\nfrom typing import List\n</pre> %matplotlib inline import numpy as np from utils.multiagent_utils import (     Coord,     Robot,     distance,     find_move_candidates_three,     get_collision_contract,     get_swapping_contract,     strategy,     strategy_multiple, ) from utils.plotting_utils import (     Snapshot,     animate,     plot_grid_world,     save_trace )  from pacti.iocontract import Var from pacti.terms.polyhedra import PolyhedralContractCompound from typing import List <p>First we will create the grid world with the dimensions $grid_{n} \\times grid_{m}$ for our robots to move in. Each robot starts at their respective initial condition, with the task to reach its goal position on the grid.  To initialize the robots and set up the grid world, we will call the functions that we imported from multiagent_utils.</p> In\u00a0[2]: Copied! <pre># Define the grid world dimensions n x m\ngrid_n = 6\ngrid_m = 3\n\n# Initialize the robots\nr1 = Robot(\"A\", (0, 0), (5, 2))\nr2 = Robot(\"B\", (0, 2), (5, 0))\nrobots = [r1, r2]\n\nplot_grid_world(grid_n, grid_m, robots)\n</pre> # Define the grid world dimensions n x m grid_n = 6 grid_m = 3  # Initialize the robots r1 = Robot(\"A\", (0, 0), (5, 2)) r2 = Robot(\"B\", (0, 2), (5, 0)) robots = [r1, r2]  plot_grid_world(grid_n, grid_m, robots) <p>We will break up the execution into individual timesteps as our planning horizon to reduce the complexity of the planning problem. This horizon length can be increased depending on the problem to be solved, but for the purpose of this case study we will do our planning in increments of single time steps.</p> <p>The figure below will give an overview of the process per timestep, on the right we will see the resulting traces of the robots when following a strategy found using Pacti.</p> <p></p> <p>This figure shows how we will use the contracts for each time step to place constraints on the movement of the robots. The contracts that we will take into account are $\\mathcal{C}_{\\text{dyn}}$, which describes the dynamics of each robot,  $\\mathcal{C}_{\\text{collision}}$, which will ensure that no two robots will occupy the same grid cell, and  $\\mathcal{C}_{\\text{swapping}}$, which ensure that two robots cannot swap positions (they would collide during the transition). For each time step we will repeat this process and update the positions of the robots according to the chosen move. Applying this strategy will result in a trajectory as shown on the right side of the figure.</p> <p>Now we define the contracts for the robots' dynamics, the input variables are the current position of each robot in $x$ and $y$ coordinates and the current timestep $t=i$. The output variables are the next position of the robots $(x_{i+1},y_{i+1})$ and the next timestep $i+1$.</p> <p>In the assumptions we define the initial positions and time step as the current position of the robot and the current timestep: $$t_i = t $$ $$x_i = x$$ $$y_i = y$$</p> <p>The guarantees of the contract are defining the dynamics and ensure that the time step increases by 1. $$t_{i+1} - t_i = 1$$</p> <p>The dynamics allow any single cell vertical or horizontal transitions to an adjacent cell on the grid (but not diagonal) and are specified as $$|x_i - x_{i+1}| + |y_i - y_{i+1}| \\leq 1.$$ We will break this constraint up into four separate constraints: $$x_{i+1} - x_i + y_{i+1} - y_i \\leq 1$$ $$x_{i+1} - x_i - y_{i+1} + y_i \\leq 1$$ $$-x_{i+1} + x_i + y_{i+1} - y_i \\leq 1$$ $$-x_{i+1} + x_i - y_{i+1} + y_i \\leq 1$$</p> <p>We also ensure that the robot has to remain within the grid, specified as: $$x_{i+1} &lt; grid_n$$ $$y_{i+1} &lt; grid_m$$</p> <p>Note that we need one dynamics contract for each robot, as the contract can only describe the dynamics for the robot whose behavior it describes. We are extending the input and output variables to include the variables for the other robots and the other contracts that we will use later, but each robot's dynamics contract only specifies the guarantees for its respecive robot's coordinates for the next timestep. In the code the subscript $0$ corresponds to timestep $i$ and the subscript $1$ corresponds to timestep $i+1$.</p> <p>This contract implementing the constraints explained above is defined in the following function:</p> In\u00a0[3]: Copied! <pre>def get_dynamics_contract_robot(name: str, init_pos: Coord, timestep: int) -&gt; PolyhedralContractCompound:  # noqa: WPS210\n\"\"\"\n    Function to set up the contract encoding the dynamics for a single robot for the next timestep.\n\n    Args:\n        name: name of the robot\n        init_pos: current coordinates of the robot\n        timestep: current timestep\n\n    Returns:\n        Resulting contract compound that encodes the dynamics for the robot.\n    \"\"\"\n    x_str_0 = 'x_{0}_0'.format(name)\n    y_str_0 = 'y_{0}_0'.format(name)\n    x_str_1 = 'x_{0}_1'.format(name)\n    y_str_1 = 'y_{0}_1'.format(name)\n    t_0 = 't_0'\n    t_1 = 't_1'\n\n    contract = PolyhedralContractCompound.from_string(\n        input_vars=[x_str_0, y_str_0, t_0],\n        output_vars=[x_str_1, y_str_1, t_1],\n        assumptions=[\n            [\n                \"{0} = {1}\".format(x_str_0, init_pos.x),\n                \"{0} = {1}\".format(y_str_0, init_pos.y),\n                \"{0} = {1}\".format(t_0, timestep),\n            ]\n        ],\n        guarantees=[\n            [\n                \"{0} - {1} = 1\".format(t_1, t_0),\n                \"{0} - {1} + {2} - {3} &lt;= 1\".format(x_str_1, x_str_0, y_str_1, y_str_0),\n                \"{0} - {1} - {2} + {3} &lt;= 1\".format(x_str_1, x_str_0, y_str_1, y_str_0),\n                \"-{0} + {1} + {2} - {3} &lt;= 1\".format(x_str_1, x_str_0, y_str_1, y_str_0),\n                \"-{0} + {1} - {2} + {3} &lt;= 1\".format(x_str_1, x_str_0, y_str_1, y_str_0),\n                \"{0} &lt;= {1}\".format(x_str_1, grid_n - 1),\n                \"{0} &lt;= {1}\".format(y_str_1, grid_m - 1),\n                \"-{0} &lt;= 0\".format(x_str_1),\n                \"-{0} &lt;= 0\".format(y_str_1),\n            ]\n        ],\n    )\n    return contract\n</pre> def get_dynamics_contract_robot(name: str, init_pos: Coord, timestep: int) -&gt; PolyhedralContractCompound:  # noqa: WPS210     \"\"\"     Function to set up the contract encoding the dynamics for a single robot for the next timestep.      Args:         name: name of the robot         init_pos: current coordinates of the robot         timestep: current timestep      Returns:         Resulting contract compound that encodes the dynamics for the robot.     \"\"\"     x_str_0 = 'x_{0}_0'.format(name)     y_str_0 = 'y_{0}_0'.format(name)     x_str_1 = 'x_{0}_1'.format(name)     y_str_1 = 'y_{0}_1'.format(name)     t_0 = 't_0'     t_1 = 't_1'      contract = PolyhedralContractCompound.from_string(         input_vars=[x_str_0, y_str_0, t_0],         output_vars=[x_str_1, y_str_1, t_1],         assumptions=[             [                 \"{0} = {1}\".format(x_str_0, init_pos.x),                 \"{0} = {1}\".format(y_str_0, init_pos.y),                 \"{0} = {1}\".format(t_0, timestep),             ]         ],         guarantees=[             [                 \"{0} - {1} = 1\".format(t_1, t_0),                 \"{0} - {1} + {2} - {3} &lt;= 1\".format(x_str_1, x_str_0, y_str_1, y_str_0),                 \"{0} - {1} - {2} + {3} &lt;= 1\".format(x_str_1, x_str_0, y_str_1, y_str_0),                 \"-{0} + {1} + {2} - {3} &lt;= 1\".format(x_str_1, x_str_0, y_str_1, y_str_0),                 \"-{0} + {1} - {2} + {3} &lt;= 1\".format(x_str_1, x_str_0, y_str_1, y_str_0),                 \"{0} &lt;= {1}\".format(x_str_1, grid_n - 1),                 \"{0} &lt;= {1}\".format(y_str_1, grid_m - 1),                 \"-{0} &lt;= 0\".format(x_str_1),                 \"-{0} &lt;= 0\".format(y_str_1),             ]         ],     )     return contract In\u00a0[4]: Copied! <pre>def collision_contract() -&gt; PolyhedralContractCompound:\n\"\"\"\n    Function to ensure no collisions between two robots.\n\n    Returns:\n        Resulting contract compound that ensures no collisions.\n    \"\"\"\n    contract = PolyhedralContractCompound.from_string(\n        input_vars=[\"current_distance\"],\n        output_vars=[\"x_A_1\", \"y_A_1\", \"x_B_1\", \"y_B_1\"],\n        assumptions=[[\"-current_distance &lt;= -1\"]],\n        guarantees=[\n            [\"x_A_1 - x_B_1 + y_A_1 - y_B_1 &lt;= -1\"],\n            [\"- x_A_1 + x_B_1 - y_A_1 + y_B_1 &lt;= -1\"],\n            [\"x_A_1 - x_B_1 - y_A_1 + y_B_1 &lt;= -1\"],\n            [\"- x_A_1 + x_B_1 + y_A_1 - y_B_1 &lt;= -1\"],\n        ],\n    )\n    return contract\n</pre> def collision_contract() -&gt; PolyhedralContractCompound:     \"\"\"     Function to ensure no collisions between two robots.      Returns:         Resulting contract compound that ensures no collisions.     \"\"\"     contract = PolyhedralContractCompound.from_string(         input_vars=[\"current_distance\"],         output_vars=[\"x_A_1\", \"y_A_1\", \"x_B_1\", \"y_B_1\"],         assumptions=[[\"-current_distance &lt;= -1\"]],         guarantees=[             [\"x_A_1 - x_B_1 + y_A_1 - y_B_1 &lt;= -1\"],             [\"- x_A_1 + x_B_1 - y_A_1 + y_B_1 &lt;= -1\"],             [\"x_A_1 - x_B_1 - y_A_1 + y_B_1 &lt;= -1\"],             [\"- x_A_1 + x_B_1 + y_A_1 - y_B_1 &lt;= -1\"],         ],     )     return contract In\u00a0[5]: Copied! <pre>def swapping_contract() -&gt; PolyhedralContractCompound:\n\"\"\"\n    Function to ensure no swapping between two robots.\n\n    Returns:\n        Resulting contract compound that ensures no swapping.\n    \"\"\"\n    contract = PolyhedralContractCompound.from_string(\n        input_vars=[\"delta_x\", \"delta_y\", \"current_distance\"],\n        output_vars=[],\n        assumptions=[\n            [\n                \"-current_distance &lt;= -1\",\n            ]\n        ],\n        guarantees=[\n            [\n                \"-delta_x - delta_y &lt;= -1\",\n            ]\n        ],\n    )\n    return contract\n</pre> def swapping_contract() -&gt; PolyhedralContractCompound:     \"\"\"     Function to ensure no swapping between two robots.      Returns:         Resulting contract compound that ensures no swapping.     \"\"\"     contract = PolyhedralContractCompound.from_string(         input_vars=[\"delta_x\", \"delta_y\", \"current_distance\"],         output_vars=[],         assumptions=[             [                 \"-current_distance &lt;= -1\",             ]         ],         guarantees=[             [                 \"-delta_x - delta_y &lt;= -1\",             ]         ],     )     return contract <p>Now we use Pacti to create the contracts from the functions and display them to confirm we set them up as desired.</p> In\u00a0[6]: Copied! <pre>c_dyn_a = get_dynamics_contract_robot(r1.name, r1.pos, 0)\nc_dyn_b = get_dynamics_contract_robot(r2.name, r2.pos, 0)\nc_collision = collision_contract()\nc_swapping = swapping_contract()\n\nprint(\"Dynamics Contract Robot A:\\n {0} \\n\".format(c_dyn_a))\nprint(\"Dynamics Contract Robot B:\\n {0} \\n\".format(c_dyn_b))\nprint(\"Collision Contract:\\n {0} \\n\".format(c_collision))\nprint(\"Swapping Contract:\\n {0}\".format(c_swapping))\n</pre> c_dyn_a = get_dynamics_contract_robot(r1.name, r1.pos, 0) c_dyn_b = get_dynamics_contract_robot(r2.name, r2.pos, 0) c_collision = collision_contract() c_swapping = swapping_contract()  print(\"Dynamics Contract Robot A:\\n {0} \\n\".format(c_dyn_a)) print(\"Dynamics Contract Robot B:\\n {0} \\n\".format(c_dyn_b)) print(\"Collision Contract:\\n {0} \\n\".format(c_collision)) print(\"Swapping Contract:\\n {0}\".format(c_swapping)) <pre>Dynamics Contract Robot A:\n InVars: [x_A_0, y_A_0, t_0]\nOutVars:[x_A_1, y_A_1, t_1]\nA: [\n  x_A_0 = 0.0\n  y_A_0 = 0.0\n  t_0 = 0.0\n]\nG: [\n  -t_0 + t_1 = 1.0\n  |-x_A_0 + x_A_1 - y_A_0 + y_A_1| &lt;= 1.0\n  |-x_A_0 + x_A_1 + y_A_0 - y_A_1| &lt;= 1.0\n  x_A_1 &lt;= 5.0\n  y_A_1 &lt;= 2.0\n  -x_A_1 &lt;= 0.0\n  -y_A_1 &lt;= 0.0\n] \n\nDynamics Contract Robot B:\n InVars: [x_B_0, y_B_0, t_0]\nOutVars:[x_B_1, y_B_1, t_1]\nA: [\n  x_B_0 = 0.0\n  y_B_0 = 2.0\n  t_0 = 0.0\n]\nG: [\n  -t_0 + t_1 = 1.0\n  |-x_B_0 + x_B_1 - y_B_0 + y_B_1| &lt;= 1.0\n  |-x_B_0 + x_B_1 + y_B_0 - y_B_1| &lt;= 1.0\n  x_B_1 &lt;= 5.0\n  y_B_1 &lt;= 2.0\n  -x_B_1 &lt;= 0.0\n  -y_B_1 &lt;= 0.0\n] \n\nCollision Contract:\n InVars: [current_distance]\nOutVars:[x_A_1, y_A_1, x_B_1, y_B_1]\nA: [\n  -current_distance &lt;= -1.0\n]\nG: [\n  x_A_1 - x_B_1 + y_A_1 - y_B_1 &lt;= -1.0\n]\nor \n[\n  -x_A_1 + x_B_1 - y_A_1 + y_B_1 &lt;= -1.0\n]\nor \n[\n  x_A_1 - x_B_1 - y_A_1 + y_B_1 &lt;= -1.0\n]\nor \n[\n  -x_A_1 + x_B_1 + y_A_1 - y_B_1 &lt;= -1.0\n] \n\nSwapping Contract:\n InVars: [delta_x, delta_y, current_distance]\nOutVars:[]\nA: [\n  -current_distance &lt;= -1.0\n]\nG: [\n  -delta_x - delta_y &lt;= -1.0\n]\n</pre> In\u00a0[7]: Copied! <pre>c_combined_dynamics = c_dyn_a.merge(c_dyn_b)\nprint(c_combined_dynamics)\n</pre> c_combined_dynamics = c_dyn_a.merge(c_dyn_b) print(c_combined_dynamics) <pre>InVars: [x_A_0, y_A_0, t_0, x_B_0, y_B_0]\nOutVars:[x_A_1, y_A_1, t_1, x_B_1, y_B_1]\nA: [\n  x_A_0 = 0.0\n  y_A_0 = 0.0\n  t_0 = 0.0\n  x_B_0 = 0.0\n  y_B_0 = 2.0\n]\nG: [\n  -t_0 + t_1 = 1.0\n  |-x_A_0 + x_A_1 - y_A_0 + y_A_1| &lt;= 1.0\n  |-x_A_0 + x_A_1 + y_A_0 - y_A_1| &lt;= 1.0\n  x_A_1 &lt;= 5.0\n  y_A_1 &lt;= 2.0\n  -x_A_1 &lt;= 0.0\n  -y_A_1 &lt;= 0.0\n  |-x_B_0 + x_B_1 - y_B_0 + y_B_1| &lt;= 1.0\n  |-x_B_0 + x_B_1 + y_B_0 - y_B_1| &lt;= 1.0\n  x_B_1 &lt;= 5.0\n  y_B_1 &lt;= 2.0\n  -x_B_1 &lt;= 0.0\n  -y_B_1 &lt;= 0.0\n]\n</pre> <p>Next we will merge the collision and swapping conflict contracts with each other and then with the combined dynamics contract <code>c_combined_dynamics</code> to make sure that the robots will never collide and adhere to their dynamics.</p> In\u00a0[8]: Copied! <pre>c_no_conflicts = c_collision.merge(c_swapping)\nc_dynamics_no_conflicts = c_combined_dynamics.merge(c_no_conflicts)\nprint(c_dynamics_no_conflicts)\n</pre> c_no_conflicts = c_collision.merge(c_swapping) c_dynamics_no_conflicts = c_combined_dynamics.merge(c_no_conflicts) print(c_dynamics_no_conflicts) <pre>InVars: [x_A_0, y_A_0, t_0, x_B_0, y_B_0, current_distance, delta_x, delta_y]\nOutVars:[x_A_1, y_A_1, t_1, x_B_1, y_B_1]\nA: [\n  x_A_0 = 0.0\n  y_A_0 = 0.0\n  t_0 = 0.0\n  x_B_0 = 0.0\n  y_B_0 = 2.0\n  -current_distance &lt;= -1.0\n]\nG: [\n  -t_0 + t_1 = 1.0\n  |-x_A_0 + x_A_1 - y_A_0 + y_A_1| &lt;= 1.0\n  |-x_A_0 + x_A_1 + y_A_0 - y_A_1| &lt;= 1.0\n  x_A_1 &lt;= 5.0\n  y_A_1 &lt;= 2.0\n  -x_A_1 &lt;= 0.0\n  -y_A_1 &lt;= 0.0\n  |-x_B_0 + x_B_1 - y_B_0 + y_B_1| &lt;= 1.0\n  |-x_B_0 + x_B_1 + y_B_0 - y_B_1| &lt;= 1.0\n  x_B_1 &lt;= 5.0\n  y_B_1 &lt;= 2.0\n  -x_B_1 &lt;= 0.0\n  -y_B_1 &lt;= 0.0\n  x_A_1 - x_B_1 + y_A_1 - y_B_1 &lt;= -1.0\n  -delta_x - delta_y &lt;= -1.0\n]\nor \n[\n  -t_0 + t_1 = 1.0\n  |-x_A_0 + x_A_1 - y_A_0 + y_A_1| &lt;= 1.0\n  |-x_A_0 + x_A_1 + y_A_0 - y_A_1| &lt;= 1.0\n  x_A_1 &lt;= 5.0\n  y_A_1 &lt;= 2.0\n  -x_A_1 &lt;= 0.0\n  -y_A_1 &lt;= 0.0\n  |-x_B_0 + x_B_1 - y_B_0 + y_B_1| &lt;= 1.0\n  |-x_B_0 + x_B_1 + y_B_0 - y_B_1| &lt;= 1.0\n  x_B_1 &lt;= 5.0\n  y_B_1 &lt;= 2.0\n  -x_B_1 &lt;= 0.0\n  -y_B_1 &lt;= 0.0\n  -x_A_1 + x_B_1 - y_A_1 + y_B_1 &lt;= -1.0\n  -delta_x - delta_y &lt;= -1.0\n]\nor \n[\n  -t_0 + t_1 = 1.0\n  |-x_A_0 + x_A_1 - y_A_0 + y_A_1| &lt;= 1.0\n  |-x_A_0 + x_A_1 + y_A_0 - y_A_1| &lt;= 1.0\n  x_A_1 &lt;= 5.0\n  y_A_1 &lt;= 2.0\n  -x_A_1 &lt;= 0.0\n  -y_A_1 &lt;= 0.0\n  |-x_B_0 + x_B_1 - y_B_0 + y_B_1| &lt;= 1.0\n  |-x_B_0 + x_B_1 + y_B_0 - y_B_1| &lt;= 1.0\n  x_B_1 &lt;= 5.0\n  y_B_1 &lt;= 2.0\n  -x_B_1 &lt;= 0.0\n  -y_B_1 &lt;= 0.0\n  x_A_1 - x_B_1 - y_A_1 + y_B_1 &lt;= -1.0\n  -delta_x - delta_y &lt;= -1.0\n]\nor \n[\n  -t_0 + t_1 = 1.0\n  |-x_A_0 + x_A_1 - y_A_0 + y_A_1| &lt;= 1.0\n  |-x_A_0 + x_A_1 + y_A_0 - y_A_1| &lt;= 1.0\n  x_A_1 &lt;= 5.0\n  y_A_1 &lt;= 2.0\n  -x_A_1 &lt;= 0.0\n  -y_A_1 &lt;= 0.0\n  |-x_B_0 + x_B_1 - y_B_0 + y_B_1| &lt;= 1.0\n  |-x_B_0 + x_B_1 + y_B_0 - y_B_1| &lt;= 1.0\n  x_B_1 &lt;= 5.0\n  y_B_1 &lt;= 2.0\n  -x_B_1 &lt;= 0.0\n  -y_B_1 &lt;= 0.0\n  -x_A_1 + x_B_1 + y_A_1 - y_B_1 &lt;= -1.0\n  -delta_x - delta_y &lt;= -1.0\n]\n</pre> <p>Now we can evaluate the resulting contract <code>c_dynamics_no_conflicts</code> to find all possible moves that the robots can take which will satisfy our specification. From this list we can implement any desired strategy that will lead the robots to their goal.</p> In\u00a0[9]: Copied! <pre>def find_move_candidates(robot1: Robot, robot2: Robot, T_0: int, contract: PolyhedralContractCompound) -&gt; list:  # noqa: N803,WPS210\n\"\"\"\n    Function to find the possible next positions for the next timestep.\n\n    Args:\n        robot1: first robot\n        robot2: second robot\n        T_0: current timestep\n        contract: contract that includes the dynamics of all robots and conflict constraints\n\n    Returns:\n        List of conflict-free, possible next positions for both robots.\n    \"\"\"\n    x_A_0 = Var(\"x_A_0\")\n    y_A_0 = Var(\"y_A_0\")\n    x_B_0 = Var(\"x_B_0\")\n    y_B_0 = Var(\"y_B_0\")\n    current_distance = Var(\"current_distance\")\n    t_0 = Var(\"t_0\")\n    t_1 = Var(\"t_1\")\n    x_A_1 = Var(\"x_A_1\")\n    y_A_1 = Var(\"y_A_1\")\n    x_B_1 = Var(\"x_B_1\")\n    y_B_1 = Var(\"y_B_1\")\n    delta_x = Var(\"delta_x\")\n    delta_y = Var(\"delta_y\")\n\n    X_A_0 = robot1.pos.x\n    Y_A_0 = robot1.pos.y\n    X_B_0 = robot2.pos.x\n    Y_B_0 = robot2.pos.y\n    cur_dist = np.abs(X_A_0 - X_B_0) + np.abs(Y_A_0 - Y_B_0)\n\n    T_1 = T_0 + 1\n\n    # find possible next position [(x,y),(x,y)] options for robots\n    possible_moves = []\n\n    for x_a in list({max(X_A_0 - 1, 0), X_A_0, min(X_A_0 + 1, grid_n - 1)}):\n        for y_a in list({max(Y_A_0 - 1, 0), Y_A_0, min(Y_A_0 + 1, grid_m - 1)}):\n            for x_b in list({max(X_B_0 - 1, 0), X_B_0, min(X_B_0 + 1, grid_n - 1)}):\n                for y_b in list({max(Y_B_0 - 1, 0), Y_B_0, min(Y_B_0 + 1, grid_m - 1)}):\n\n                    del_x = (x_a - x_b) * (X_A_0 - X_B_0)\n                    del_y = (y_a - y_b) * (Y_A_0 - Y_B_0)\n\n                    var_dict = {\n                        x_A_0: X_A_0,\n                        y_A_0: Y_A_0,\n                        x_B_0: X_B_0,\n                        y_B_0: Y_B_0,\n                        current_distance: cur_dist,\n                        t_0: T_0,\n                        t_1: T_1,\n                        x_A_1: x_a,\n                        y_A_1: y_a,\n                        x_B_1: x_b,\n                        y_B_1: y_b,\n                        delta_x: del_x,\n                        delta_y: del_y,\n                    }\n\n                    if contract.a.contains_behavior(var_dict) and contract.g.contains_behavior(var_dict):\n\n                        possible_moves.append([(x_a, y_a), (x_b, y_b)])  # noqa: WPS220\n\n    return possible_moves\n\n\nt_0 = 0\nmove_candidates = find_move_candidates(r1, r2, t_0, c_dynamics_no_conflicts)\n\n# now pick a move and run it again for the next timestep!\nmove = strategy(move_candidates, (r1.goal, r2.goal))\nprint(\"These are the possible positions for the next timestep: {0}\".format(move_candidates))\n\nprint(\"The chosen move is {0}\".format(move))\n</pre> def find_move_candidates(robot1: Robot, robot2: Robot, T_0: int, contract: PolyhedralContractCompound) -&gt; list:  # noqa: N803,WPS210     \"\"\"     Function to find the possible next positions for the next timestep.      Args:         robot1: first robot         robot2: second robot         T_0: current timestep         contract: contract that includes the dynamics of all robots and conflict constraints      Returns:         List of conflict-free, possible next positions for both robots.     \"\"\"     x_A_0 = Var(\"x_A_0\")     y_A_0 = Var(\"y_A_0\")     x_B_0 = Var(\"x_B_0\")     y_B_0 = Var(\"y_B_0\")     current_distance = Var(\"current_distance\")     t_0 = Var(\"t_0\")     t_1 = Var(\"t_1\")     x_A_1 = Var(\"x_A_1\")     y_A_1 = Var(\"y_A_1\")     x_B_1 = Var(\"x_B_1\")     y_B_1 = Var(\"y_B_1\")     delta_x = Var(\"delta_x\")     delta_y = Var(\"delta_y\")      X_A_0 = robot1.pos.x     Y_A_0 = robot1.pos.y     X_B_0 = robot2.pos.x     Y_B_0 = robot2.pos.y     cur_dist = np.abs(X_A_0 - X_B_0) + np.abs(Y_A_0 - Y_B_0)      T_1 = T_0 + 1      # find possible next position [(x,y),(x,y)] options for robots     possible_moves = []      for x_a in list({max(X_A_0 - 1, 0), X_A_0, min(X_A_0 + 1, grid_n - 1)}):         for y_a in list({max(Y_A_0 - 1, 0), Y_A_0, min(Y_A_0 + 1, grid_m - 1)}):             for x_b in list({max(X_B_0 - 1, 0), X_B_0, min(X_B_0 + 1, grid_n - 1)}):                 for y_b in list({max(Y_B_0 - 1, 0), Y_B_0, min(Y_B_0 + 1, grid_m - 1)}):                      del_x = (x_a - x_b) * (X_A_0 - X_B_0)                     del_y = (y_a - y_b) * (Y_A_0 - Y_B_0)                      var_dict = {                         x_A_0: X_A_0,                         y_A_0: Y_A_0,                         x_B_0: X_B_0,                         y_B_0: Y_B_0,                         current_distance: cur_dist,                         t_0: T_0,                         t_1: T_1,                         x_A_1: x_a,                         y_A_1: y_a,                         x_B_1: x_b,                         y_B_1: y_b,                         delta_x: del_x,                         delta_y: del_y,                     }                      if contract.a.contains_behavior(var_dict) and contract.g.contains_behavior(var_dict):                          possible_moves.append([(x_a, y_a), (x_b, y_b)])  # noqa: WPS220      return possible_moves   t_0 = 0 move_candidates = find_move_candidates(r1, r2, t_0, c_dynamics_no_conflicts)  # now pick a move and run it again for the next timestep! move = strategy(move_candidates, (r1.goal, r2.goal)) print(\"These are the possible positions for the next timestep: {0}\".format(move_candidates))  print(\"The chosen move is {0}\".format(move)) <pre>These are the possible positions for the next timestep: [[(0, 0), (0, 1)], [(0, 0), (0, 2)], [(0, 0), (1, 2)], [(0, 1), (0, 2)], [(0, 1), (1, 2)], [(1, 0), (0, 1)], [(1, 0), (0, 2)], [(1, 0), (1, 2)]]\nThe chosen move is [(0, 1), (1, 2)]\n</pre> <p>Now we can put everything together and run the simulation of our two robots navigating the grid together.</p> <p>Note: If you do not have <code>ffmpeg</code> install, you will need to install it to create the animation (https://www.ffmpeg.org).</p> In\u00a0[10]: Copied! <pre>r1 = Robot(\"A\", (0, 0), (5, 2))\nr2 = Robot(\"B\", (0, 2), (5, 0))\ntrace: List[Snapshot] = []\nrobots = [r1, r2]\nnum_iter = 15\n\nt_0 = 0\ntrace = save_trace(\n    trace, [(r1.pos.x, r1.pos.y), (r2.pos.x, r2.pos.y)], [(r1.goal.x, r1.goal.y), (r2.goal.x, r2.goal.y)]\n)\n\n# Create the contracts ensuring no conflicts\nc_collision = collision_contract()\nc_swapping = swapping_contract()\nc_no_conflicts = c_collision.merge(c_swapping)\n\nfor _i in range(0, num_iter):  # noqa: WPS122\n    # set up the dynamics contracts\n    c_dyn1 = get_dynamics_contract_robot(r1.name, r1.pos, t_0)\n    c_dyn2 = get_dynamics_contract_robot(r2.name, r2.pos, t_0)\n    merged_dyn_contract = c_dyn1.merge(c_dyn2)\n\n    # merge the dynamics contract with the conflict contracts\n    c_dynamics_no_conflicts = merged_dyn_contract.merge(c_no_conflicts)\n\n    move_candidates = find_move_candidates(r1, r2, t_0, c_dynamics_no_conflicts)\n\n    move = strategy(move_candidates, (r1.goal, r2.goal))\n    r1.move(move[0])\n    r2.move(move[1])\n\n    trace = save_trace(\n        trace, [(r1.pos.x, r1.pos.y), (r2.pos.x, r2.pos.y)], [(r1.goal.x, r1.goal.y), (r2.goal.x, r2.goal.y)]\n    )\n\n    if distance([[r1.pos.x, r1.pos.y], [r2.pos.x, r2.pos.y]], [r1.goal, r2.goal]) == 0:\n        break\n\nanimate(trace, grid_n, grid_m, \"2_robots\")\n</pre> r1 = Robot(\"A\", (0, 0), (5, 2)) r2 = Robot(\"B\", (0, 2), (5, 0)) trace: List[Snapshot] = [] robots = [r1, r2] num_iter = 15  t_0 = 0 trace = save_trace(     trace, [(r1.pos.x, r1.pos.y), (r2.pos.x, r2.pos.y)], [(r1.goal.x, r1.goal.y), (r2.goal.x, r2.goal.y)] )  # Create the contracts ensuring no conflicts c_collision = collision_contract() c_swapping = swapping_contract() c_no_conflicts = c_collision.merge(c_swapping)  for _i in range(0, num_iter):  # noqa: WPS122     # set up the dynamics contracts     c_dyn1 = get_dynamics_contract_robot(r1.name, r1.pos, t_0)     c_dyn2 = get_dynamics_contract_robot(r2.name, r2.pos, t_0)     merged_dyn_contract = c_dyn1.merge(c_dyn2)      # merge the dynamics contract with the conflict contracts     c_dynamics_no_conflicts = merged_dyn_contract.merge(c_no_conflicts)      move_candidates = find_move_candidates(r1, r2, t_0, c_dynamics_no_conflicts)      move = strategy(move_candidates, (r1.goal, r2.goal))     r1.move(move[0])     r2.move(move[1])      trace = save_trace(         trace, [(r1.pos.x, r1.pos.y), (r2.pos.x, r2.pos.y)], [(r1.goal.x, r1.goal.y), (r2.goal.x, r2.goal.y)]     )      if distance([[r1.pos.x, r1.pos.y], [r2.pos.x, r2.pos.y]], [r1.goal, r2.goal]) == 0:         break  animate(trace, grid_n, grid_m, \"2_robots\") <pre>Rendering 8 frames...\n</pre>    Your browser does not support the video tag.  <p>This is how to set up a multi-agent navigation problem in Pacti with a horizon of a single timestep, if desired this horizon can be extended by composing multiple timesteps to ensure that the robots will not get stuck depending on the obstacle placement and the actions that the robots are taking. For this case study we will continue using a horizon length of one but we will increase the number of robots in our grid world.</p> In\u00a0[11]: Copied! <pre># set grid world dimensions n x m\ngrid_n = 5\ngrid_m = 5\n\n# Intitialize the robots\nr1 = Robot(\"A\", (0, 0), (4, 4))\nr2 = Robot(\"B\", (0, 2), (4, 2))\nr3 = Robot(\"C\", (0, 4), (4, 0))\nrobots = [r1, r2, r3]\nnum_iter = 30\n\n# Get the collision contracts\nc_collision = get_collision_contract(robots)\nc_swapping = get_swapping_contract(robots)\n\nc_no_conflicts = c_collision.merge(c_swapping)\n\nt_0 = 0\ntrace = []\ntrace = save_trace(\n    trace,\n    [(r1.pos.x, r1.pos.y), (r2.pos.x, r2.pos.y), (r3.pos.x, r3.pos.y)],\n    [(r1.goal.x, r1.goal.y), (r2.goal.x, r2.goal.y), (r3.goal.x, r3.goal.y)],\n)\nlast_pos = None\n\nfor _j in range(0, num_iter):  # noqa: WPS122\n    # merge the dynamics contracts\n    c_dyn1 = get_dynamics_contract_robot(r1.name, r1.pos, t_0)\n    c_dyn2 = get_dynamics_contract_robot(r2.name, r2.pos, t_0)\n    c_dyn3 = get_dynamics_contract_robot(r3.name, r3.pos, t_0)\n\n    merged_dyn_contract_1_2 = c_dyn1.merge(c_dyn2)  # noqa: WPS114\n    merged_dyn_contract = merged_dyn_contract_1_2.merge(c_dyn3)\n\n    # merge dynamics with the no conflict contracts\n    multiagent_contract = merged_dyn_contract.merge(c_no_conflicts)\n\n    moves_list, t_1 = find_move_candidates_three(grid_n, grid_m, robots, t_0, multiagent_contract)\n\n    goals = (r1.goal, r2.goal, r3.goal)\n    cur_pos = (r1.pos.x, r1.pos.y), (r2.pos.x, r2.pos.y), (r3.pos.x, r3.pos.y)\n    cur_dist = distance(cur_pos, goals)\n\n    move = strategy_multiple(moves_list, goals, cur_pos, last_pos)\n    last_pos = cur_pos\n\n    r1.move(move[0])\n    r2.move(move[1])\n    r3.move(move[2])\n\n    trace = save_trace(\n        trace,\n        [(r1.pos.x, r1.pos.y), (r2.pos.x, r2.pos.y), (r3.pos.x, r3.pos.y)],\n        [(r1.goal.x, r1.goal.y), (r2.goal.x, r2.goal.y), (r3.goal.x, r3.goal.y)],\n    )\n\n    if distance([[r1.pos.x, r1.pos.y], [r2.pos.x, r2.pos.y], [r3.pos.x, r3.pos.y]], [r1.goal, r2.goal, r3.goal]) == 0:\n        break\n\nanimate(trace, grid_n, grid_m, \"3_robots\")\n</pre> # set grid world dimensions n x m grid_n = 5 grid_m = 5  # Intitialize the robots r1 = Robot(\"A\", (0, 0), (4, 4)) r2 = Robot(\"B\", (0, 2), (4, 2)) r3 = Robot(\"C\", (0, 4), (4, 0)) robots = [r1, r2, r3] num_iter = 30  # Get the collision contracts c_collision = get_collision_contract(robots) c_swapping = get_swapping_contract(robots)  c_no_conflicts = c_collision.merge(c_swapping)  t_0 = 0 trace = [] trace = save_trace(     trace,     [(r1.pos.x, r1.pos.y), (r2.pos.x, r2.pos.y), (r3.pos.x, r3.pos.y)],     [(r1.goal.x, r1.goal.y), (r2.goal.x, r2.goal.y), (r3.goal.x, r3.goal.y)], ) last_pos = None  for _j in range(0, num_iter):  # noqa: WPS122     # merge the dynamics contracts     c_dyn1 = get_dynamics_contract_robot(r1.name, r1.pos, t_0)     c_dyn2 = get_dynamics_contract_robot(r2.name, r2.pos, t_0)     c_dyn3 = get_dynamics_contract_robot(r3.name, r3.pos, t_0)      merged_dyn_contract_1_2 = c_dyn1.merge(c_dyn2)  # noqa: WPS114     merged_dyn_contract = merged_dyn_contract_1_2.merge(c_dyn3)      # merge dynamics with the no conflict contracts     multiagent_contract = merged_dyn_contract.merge(c_no_conflicts)      moves_list, t_1 = find_move_candidates_three(grid_n, grid_m, robots, t_0, multiagent_contract)      goals = (r1.goal, r2.goal, r3.goal)     cur_pos = (r1.pos.x, r1.pos.y), (r2.pos.x, r2.pos.y), (r3.pos.x, r3.pos.y)     cur_dist = distance(cur_pos, goals)      move = strategy_multiple(moves_list, goals, cur_pos, last_pos)     last_pos = cur_pos      r1.move(move[0])     r2.move(move[1])     r3.move(move[2])      trace = save_trace(         trace,         [(r1.pos.x, r1.pos.y), (r2.pos.x, r2.pos.y), (r3.pos.x, r3.pos.y)],         [(r1.goal.x, r1.goal.y), (r2.goal.x, r2.goal.y), (r3.goal.x, r3.goal.y)],     )      if distance([[r1.pos.x, r1.pos.y], [r2.pos.x, r2.pos.y], [r3.pos.x, r3.pos.y]], [r1.goal, r2.goal, r3.goal]) == 0:         break  animate(trace, grid_n, grid_m, \"3_robots\") <pre>Rendering 21 frames...\n</pre>    Your browser does not support the video tag.  <p>This analysis can be extended by adding obstacles (by adding a contract that ensures no collision with obstacles) and adding more robots to the grid as desired.  We showed how to set up our contracts to describe the viewpoint for a single timestep, and how to modularly add contracts describing the dynamics of individual robots and conflicts.</p> <p>Depending on the obstacle geometry and the number of robots, it may be necessary to consider a longer horizon to reach the goal more efficiently - prevent situations where the robots get stuck. For this we could compose the contracts for multiple timesteps and pick the strategy on the possible action set resulting from this analysis, which we leave to future work.</p>"},{"location":"_case_studies/cs-multiagent-planning/multiagent/#trajectory-planning-for-multi-agent-systems","title":"Trajectory planning for multi-agent systems\u00b6","text":""},{"location":"_case_studies/cs-multiagent-planning/multiagent/#create-gridworld-and-robots","title":"Create gridworld and robots\u00b6","text":""},{"location":"_case_studies/cs-multiagent-planning/multiagent/#define-dynamics-contracts-for-each-robot-per-timestep","title":"Define dynamics contracts for each robot per timestep\u00b6","text":""},{"location":"_case_studies/cs-multiagent-planning/multiagent/#collision-conflict-contract","title":"Collision Conflict Contract\u00b6","text":"<p>Next we describe the contracts that will ensure that our robots do not collide. For this we will place constraints on the distance between a pair of robots, and ensure that is will always be larger or equal to one cell - meaning two robots will never share the same cell (i.e. collide).</p> <p>To describe the this requirement in linear inequalities, we need to break up the collision requirement into four inequalities. Each inequality will place constraints on both robots for a specific configuration with regards to each other (for example robot A is to the top right of robot B).</p> <p>As the guarantees of these contracts are mutually exclusive (robots can only be in one configuration at a time - Robot A cannot be to the right and to the left of robot B at the same time), we need to consider each of these collision quadrants separately in our analysis. To achieve this, we are using a <code>PolyhedralContractCompound</code> which allows for disjoint guarantees (and disjoint assumptions if desired).</p> <p>The linear inequalities ensuring no collision for two robots $A$ and $B$ are defined as follows.</p> <p>We assume that the two robots do not collide: $$\\text{distance}(A,B) \\geq 1$$</p> <p>The guarantees are that at least one of these inequalities is satisfied:</p> $$ x^A_1 - x^B_1 + y^A_1 - y^B_1 \\leq -1 $$$$ x^A_1 - x^B_1 - y^A_1 + y^B_1 \\leq -1 $$$$ x^A_1 + x^B_1 + y^A_1 - y^B_1 \\leq -1 $$$$ x^A_1 + x^B_1 - y^A_1 + y^B_1 \\leq -1 $$"},{"location":"_case_studies/cs-multiagent-planning/multiagent/#swapping-dynamic-collision-contract","title":"Swapping (Dynamic Collision) Contract\u00b6","text":"<p>Next we define the contract that determines that the robots will also stay collision free during their transition to another cell, meaning that two robots cannot swap places in the grid, as they would collide while traversing the same edge in opposite directions. We do this by manipulating the $x$ and $y$ coordinates of the two robots as follows:</p> <p>$$    \\delta x = (x^A_i - x^B_i) * (x^A_{i+1} - x^B_{i+1}) $$  $$    \\delta y = (y^A_i - y^B_i) * (y^A_{i+1} - y^B_{i+1}) $$</p> <p>$$\\delta_x + \\delta_y \\geq 1$$</p> <p>Of course this contract also assumes no collision.</p> <p>We manipulated the variables for this contract to reduce the number of disjoint polyhedra, instead of encoding the requirement as another set of docjoint guarantees on the positions.</p>"},{"location":"_case_studies/cs-multiagent-planning/multiagent/#merging-the-contracts","title":"Merging the contracts\u00b6","text":"<p>We are ready to start merging the contracts. We start by merging the dynamics contracts for each of the robots. This contract now holds all the information for possible steps that both robots can take, but it does not ensure no collisions yet. Now let's take a look at the contract describing the dynamics for both robots.</p>"},{"location":"_case_studies/cs-multiagent-planning/multiagent/#extension-to-three-robots","title":"Extension to three robots\u00b6","text":""},{"location":"_case_studies/cs-multiagent-planning/multiagent/#references","title":"References\u00b6","text":"<p>Dresner and Stone 2008</p> <p>Dresner, K. and Stone, P., 2008. A multiagent approach to autonomous intersection management. Journal of artificial intelligence research, 31, pp.591-656.</p> <p>Ma et al. 2017</p> <p>Ma, H., Yang, J., Cohen, L., Kumar, T.S. and Koenig, S., 2017, September. Feasibility study: Moving non-homogeneous teams in congested video game environments. In Thirteenth Artificial Intelligence and Interactive Digital Entertainment Conference.</p> <p>Pallottino et al. 2007</p> <p>Pallottino, L., Scordio, V.G., Bicchi, A. and Frazzoli, E., 2007. Decentralized cooperative policy for conflict resolution in multivehicle systems. IEEE Transactions on Robotics, 23(6), pp.1170-1183.</p> <p>Silver 2005</p> <p>Silver, D., 2005. Cooperative pathfinding. In Proceedings of the aaai conference on artificial intelligence and interactive digital entertainment (Vol. 1, No. 1, pp. 117-122).</p> <p>Stern et al. 2019</p> <p>Stern, R., Sturtevant, N.R., Felner, A., Koenig, S., Ma, H., Walker, T.T., Li, J., Atzmon, D., Cohen, L., Kumar, T.S. and Bart\u00e1k, R., 2019, July. Multi-agent pathfinding: Definitions, variants, and benchmarks. In Twelfth Annual Symposium on Combinatorial Search.</p> <p>Wilson et al. 2020</p> <p>Wilson, S., Glotfelter, P., Wang, L., Mayya, S., Notomista, G., Mote, M. and Egerstedt, M., 2020. The robotarium: Globally impactful opportunities, challenges, and lessons learned in remote-access, distributed control of multirobot systems. IEEE Control Systems Magazine, 40(1), pp.26-44.</p> <p>Wurman et al. 2008</p> <p>Wurman, P.R., D'Andrea, R. and Mountz, M., 2008. Coordinating hundreds of cooperative, autonomous vehicles in warehouses. AI magazine, 29(1), pp.9-9.</p>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/","title":"Mars 2020 Entry-Descent-Landing","text":"In\u00a0[3]: Copied! <pre>from IPython import display\nfrom base64 import b64decode\nfrom edl import *\n</pre> from IPython import display from base64 import b64decode from edl import * <p>This case study demonstrates using Pacti for formalizing a simplified version of a Mars Entry-Descent-Landing mission scenario based on the following paper: R. Prakash et al. 2008 and the Mars 2020 EDL timeline from https://mars.nasa.gov/mars2020/timeline/landing/entry-descent-landing/</p> <p></p> <p>The figure above shows the EDL phase timeline annotated with significant waypoints (e.g., Parachute Deploy, Backshell Separation). These waypoints describe the nominal characteristics of the system state at critical events during the timeline. The EDL phase timeline involves a complex orchestration of multiple subsystems (e.g., backshell, parachute, descent stage engines, and sky crane). Since each EDL subsystem is designed to operate within a specific region of the system state, it makes sense to break the timeline of the EDL phase into phase segments corresponding to the different configurations of the system where particular subsystems play an active role in decelerating the descent. For the Mars 2020 EDL subsystems, this leads to EDL phase segments described below according to the major subsystems involved:</p> EDL phase segment Active subsystem S1 Backshell S2 Parachute S3 Descent stage engines S4 Sky crane <p>The left diagram shows a notional view of a phase segment characterized in terms of entry/exit conditions on state variables -- typically an interval of possible values. For this case study, we focus on time and spacecraft velocity, a subset of the Mars 2020 EDL phase segment state variables. This entry/exit characterization of each phase segment leads to an intuitive view of the EDL phase timeline as a sequence of phase contracts where the exit conditions of a segment, e.g, <code>S1</code>, constrain the entry conditions for the next segment, e.g., <code>S2</code>.</p> <p>We call a scenario the combination of:</p> <ul> <li>end-to-end entry/exit conditions; i.e.: range of values for <code>t0</code> and <code>v0</code> for entry conditions, <code>t4</code> and <code>v4</code> for exit conditions</li> <li>a sequence of contracts for the phase segments; i.e., <code>S1</code>, ... <code>S4</code></li> </ul> <p>We could easily encode this scenario in Pacti; however, the composition of algebraic contracts corresponding to the phase segments would result in a very rigid end-to-end scenario contract. In effect, it would be the responsibility of the designer to make sure that all constraints are satisfiable. This encoding strategy is sketched on the left side of the figure below. With time and velocity as the pair of entry/exit condition variables, entry and exit conditions are geometrical rectangles as illustrated on the left. Pacti would be able to compose segment <code>Si</code> with segment <code>Si+1</code> if and only if the rectangle of the entry conditions of <code>Si+1</code> includes the rectangle of the exit conditions of <code>Si</code>. While technically possible, this encoding strategy would provide little value to the EDL designers because they would have the burden to find compatible exit-to-entry conditions for all composed segments.</p> <p>This case study adopts an advanced encoding illustrated on the right side of the figure. The key idea involves encoding segment contracts with a special variable that encodes a linear constraint relating time and velocity. Geometrically, this means that each segment will induce a trapezoid corresponding to the admissible values of time and velocity according to this linear constraint. By leaving this special variable unbound in the scenario -- that is, it is not an end-to-end entry/exit condition variable --, composing two segments, <code>Si</code> and <code>Si+1</code>, yields a combination of trapezoid constraints parameterized with the special variables of both segments. This advanced encoding methodology takes advantage of a powerful feature of Pacti's polyhedral algebra: composing contracts effectively becomes a convex optimization problem.</p> <p>Applying this advanced encoding with special variables to the end-to-end EDL phase segment contracts will result in the composition sketched below on the right side of the figure.</p> <p>The special variables are <code>dt0</code>, <code>dt1</code>, <code>dt2</code>, and <code>dt3</code>; they correspond to the time interval allocated to each phase segment. Since these special variables do not appear as end-to-end EDL phase contract entry/exit conditions, they are effectively unbound in the scenario. These unbound variables parameterize the end-to-end EDL phase contract and provide EDL designers 'knobs' to explore time allocation tradeoffs among the phase segments. The rest of this notebook formalizes this encoding approach using Pacti's polyhedral algebra and illustrates an application of polyhedral contract algebra to explore some aspects of segment design characteristics.</p> <p>The comparison between the two encoding approaches described above serves to illustrate the importance of what Albert Sangiovanni-Vincentelli calls \"freedom from choice\" E. Lee. 2019: Systems engineers must thinking carefully about devising an abstraction of the intented purpose of the requirement that can be encoded within the limited expressiveness of Pacti's convex polyhedral contract algebra. It would be tempting to dismiss Pacti's polyhedral algebra as too simplistic given the highly nonlinear nature of the phenomenology involved. However, systems engineers would have to confront the complexity resulting from numerous options for modeling languages and tools. In exchange for eliminating these choices, systems engineers are free to excercise their creativity and intellect to devise useful abstractions that capture the intent of the requirements. What makes Pacti somewhat unique compared to other modeling languages and tools is the ability to carry out algebraic operations on requirements formalized as contracts: in exchange from eliminating modeling language choice, systems engineers gain the freedom to explore different ways of encoding requirements and apply algebraic operations to gain insights into them.</p> In\u00a0[4]: Copied! <pre># The following Python imports provide access to the Pacti API \n# and to the plotting libraries for visualizing algebraic contracts.\n\n%matplotlib widget\n\nfrom pacti.iocontract import *\nfrom pacti.terms.polyhedra import *\nimport matplotlib.pyplot as plt\n</pre> # The following Python imports provide access to the Pacti API  # and to the plotting libraries for visualizing algebraic contracts.  %matplotlib widget  from pacti.iocontract import * from pacti.terms.polyhedra import * import matplotlib.pyplot as plt <p>The contract below defines <code>dt0</code> as a special input variable to characterize the resulting velocity decrease due to the atmospheric entry subsystems active during this segment.</p> In\u00a0[7]: Copied! <pre># EDL begins when the spacecraft reaches the top of the Martian atmosphere, traveling nearly 20,000 kilometers per hour (kph).\nprint(f\"atmospheric_v_entry = {atmospheric_v_entry}\")\n\n# The heat shield slows the spacecraft to under 1,600 kph.\n# This point marks be the exit of the atmospheric entry segment\n# and the entry of the parachute deployment segment.\nprint(f\"atmospheric_v_exit = {atmospheric_v_exit}\")\n\nprint(f\"atmospheric_t_entry = {atmospheric_t_entry}\")\nprint(f\"atmospheric_t_exit = {atmospheric_t_exit}\")\n\natmospheric_t_duration = atmospheric_t_exit - atmospheric_t_entry\natmospheric_t_duration_min = atmospheric_t_duration*0.96\natmospheric_t_duration_max = atmospheric_t_duration*1.03\n\natmospheric_deacceleration = abs((atmospheric_v_entry - atmospheric_v_exit) / (atmospheric_t_entry - atmospheric_t_exit))\nprint(f\"atmospheric_deacceleration={atmospheric_deacceleration}\")\n\natmospheric_min_deacceleration = atmospheric_deacceleration*0.94\nprint(f\"atmospheric_min_deacceleration={atmospheric_min_deacceleration}\")\n\natmospheric_max_deacceleration = atmospheric_deacceleration*1.03\nprint(f\"atmospheric_max_deacceleration={atmospheric_max_deacceleration}\")\n\nS1 = PolyhedralContract.from_string(\n    input_vars=[\n      \"dt0\",          # time duration for the atmospheric segment from entry to exit.\n      \"v0\"            # velocity @ entry\n    ],\n    output_vars=[\n      \"v1\"            # velocity @ exit\n    ],\n    assumptions=[\n      # velocity @ entry\n      f\"v0 = {atmospheric_v_entry}\"\n    ],\n    guarantees=[\n      # validity bounds on minimum exit velocity\n      # 1000 &lt;= v1\n      \"-v1 &lt;= -1000\",\n      \n      # atmospheric_min_deacceleration * dt0 &lt;= v0 - v1 &lt;= atmospheric_max_deacceleration * dt0\n      # v0 - v1 &lt;= atmospheric_max_deacceleration * dt0\n      f\" v0 - v1 - {atmospheric_max_deacceleration} dt0 &lt;= 0\",\n\n      # atmospheric_min_deacceleration * dt0 &lt;= v0 - v1\n      f\"-v0 + v1 + {atmospheric_min_deacceleration} dt0 &lt;= 0\"\n    ])\n\nprint(f\"\\nContract S1:\\n\\n{S1}\")\n</pre> # EDL begins when the spacecraft reaches the top of the Martian atmosphere, traveling nearly 20,000 kilometers per hour (kph). print(f\"atmospheric_v_entry = {atmospheric_v_entry}\")  # The heat shield slows the spacecraft to under 1,600 kph. # This point marks be the exit of the atmospheric entry segment # and the entry of the parachute deployment segment. print(f\"atmospheric_v_exit = {atmospheric_v_exit}\")  print(f\"atmospheric_t_entry = {atmospheric_t_entry}\") print(f\"atmospheric_t_exit = {atmospheric_t_exit}\")  atmospheric_t_duration = atmospheric_t_exit - atmospheric_t_entry atmospheric_t_duration_min = atmospheric_t_duration*0.96 atmospheric_t_duration_max = atmospheric_t_duration*1.03  atmospheric_deacceleration = abs((atmospheric_v_entry - atmospheric_v_exit) / (atmospheric_t_entry - atmospheric_t_exit)) print(f\"atmospheric_deacceleration={atmospheric_deacceleration}\")  atmospheric_min_deacceleration = atmospheric_deacceleration*0.94 print(f\"atmospheric_min_deacceleration={atmospheric_min_deacceleration}\")  atmospheric_max_deacceleration = atmospheric_deacceleration*1.03 print(f\"atmospheric_max_deacceleration={atmospheric_max_deacceleration}\")  S1 = PolyhedralContract.from_string(     input_vars=[       \"dt0\",          # time duration for the atmospheric segment from entry to exit.       \"v0\"            # velocity @ entry     ],     output_vars=[       \"v1\"            # velocity @ exit     ],     assumptions=[       # velocity @ entry       f\"v0 = {atmospheric_v_entry}\"     ],     guarantees=[       # validity bounds on minimum exit velocity       # 1000 &lt;= v1       \"-v1 &lt;= -1000\",              # atmospheric_min_deacceleration * dt0 &lt;= v0 - v1 &lt;= atmospheric_max_deacceleration * dt0       # v0 - v1 &lt;= atmospheric_max_deacceleration * dt0       f\" v0 - v1 - {atmospheric_max_deacceleration} dt0 &lt;= 0\",        # atmospheric_min_deacceleration * dt0 &lt;= v0 - v1       f\"-v0 + v1 + {atmospheric_min_deacceleration} dt0 &lt;= 0\"     ])  print(f\"\\nContract S1:\\n\\n{S1}\") <pre>atmospheric_v_entry = 20000.0\natmospheric_v_exit = 1600.0\natmospheric_t_entry = 0\natmospheric_t_exit = 90.0\natmospheric_deacceleration=204.44444444444446\natmospheric_min_deacceleration=192.17777777777778\natmospheric_max_deacceleration=210.57777777777778\n\nContract S1:\n\nInVars: [dt0, v0]\nOutVars:[v1]\nA: [\n  v0 = 2e+04\n]\nG: [\n  -v1 &lt;= -1000\n  -210.6 dt0 + v0 - v1 &lt;= 0\n  192.2 dt0 - v0 + v1 &lt;= 0\n]\n</pre> <p>Even through linear constraints are conceptually simple, it is very helpful to project the space of admissible solutions shown in the blue trapezoid below. Pacti provides a simple 2D plotting projection capability for either contract assumptions or guarantees as shown below. Doing so requires:</p> <ul> <li>choosing two variables from the inputs and outputs, <code>x_var</code> and <code>y_var</code>;</li> <li>specifying values for all remaining variables, <code>var_values</code>;</li> <li>specifying a range for the plot, <code>x_lims</code> and <code>y_lims</code>.</li> </ul> <p>The plot provides a useful interactive capability that tracks the mouse movement and shows underneath the plot the <code>x</code>, <code>y</code> coordinates of the mouse cursor.</p> <p>During notebook authoring, this interactive capability is available only in a Jupyter environment such as Microsoft VS Code with the Microsoft Jupyter extension or with JetBrains' PyCharm Professional.</p> <p>Note that neither the Github Jupyter notebook rendering nor the doc generator support the interactive plot functionality.</p> In\u00a0[8]: Copied! <pre>_ = plot_guarantees(\n    contract=S1,\n    x_var=Var(\"dt0\"),\n    y_var=Var(\"v1\"),\n    var_values={\n        Var(\"v0\"):atmospheric_v_entry\n    },\n    x_lims=(0, 120),\n    y_lims=(800, 21000)\n)\n</pre> _ = plot_guarantees(     contract=S1,     x_var=Var(\"dt0\"),     y_var=Var(\"v1\"),     var_values={         Var(\"v0\"):atmospheric_v_entry     },     x_lims=(0, 120),     y_lims=(800, 21000) )                      Figure                  <p>One can zoom into a region of interest by changing the limits of the plot as shown below:</p> In\u00a0[9]: Copied! <pre>_ = plot_guarantees(\n    contract=S1,\n    x_var=Var(\"dt0\"),\n    y_var=Var(\"v1\"),\n    var_values={\n        Var(\"v0\"):atmospheric_v_entry\n    },\n    x_lims=(80, 120),\n    y_lims=(800, 1800)\n)\n</pre> _ = plot_guarantees(     contract=S1,     x_var=Var(\"dt0\"),     y_var=Var(\"v1\"),     var_values={         Var(\"v0\"):atmospheric_v_entry     },     x_lims=(80, 120),     y_lims=(800, 1800) )                      Figure                  In\u00a0[11]: Copied! <pre># The parachute can be safely deployed when the velocity is less than 1,600 kph.\nparachute_v_entry = 1600.0\n\n# The parachute maximum deceleration capability is 320 kph.\nparachute_v_exit = 320.0\n\nparachute_t_entry = 90.0\nparachute_t_exit = 350.0\nparachute_t_duration = parachute_t_exit - parachute_t_entry\nparachute_t_duration_min = parachute_t_duration*0.96\nparachute_t_duration_max = parachute_t_duration*1.03\n\nparachute_deacceleration = abs((parachute_v_entry - parachute_v_exit) / (parachute_t_entry - parachute_t_exit))\nprint(f\"parachute_deacceleration={parachute_deacceleration}\")\n\nparachute_min_deacceleration = parachute_deacceleration*0.94\nprint(f\"parachute_min_deacceleration={parachute_min_deacceleration}\")\n\nparachute_max_deacceleration = parachute_deacceleration*1.03\nprint(f\"parachute_max_deacceleration={parachute_max_deacceleration}\")\n\nS2 = PolyhedralContract.from_string(\n    input_vars=[\n      \"dt1\",          # time duration for the parachute deployment segment from entry to exit.\n      \"v1\"            # entry velocity\n    ],\n    output_vars=[\n      \"v2\"            # exit velocity\n    ],\n    assumptions=[\n      # velocity @ entry\n      f\"v1 &lt;= {parachute_v_entry}\"\n    ],\n    guarantees=[\n      # # parachute effectiveness is limited to v2 &gt;= 320\n      f\"-v2 &lt;= -{parachute_v_exit}\",\n      \n      # parachute_min_deacceleration * dt1 &lt;= v1 - v2 &lt;= parachute_max_deacceleration * dt1\n      # v1 - v2 &lt;= parachute_max_deacceleration * dt1\n      f\" v1 - v2 - {parachute_max_deacceleration} dt1 &lt;= 0\",\n\n      # parachutec_min_deacceleration * dt1 &lt;= v1 - v2\n      f\"-v1 + v2 + {parachute_min_deacceleration} dt1 &lt;= 0\"\n   ])\n\nprint(f\"\\nContract S2:\\n\\n{S2}\")\n</pre> # The parachute can be safely deployed when the velocity is less than 1,600 kph. parachute_v_entry = 1600.0  # The parachute maximum deceleration capability is 320 kph. parachute_v_exit = 320.0  parachute_t_entry = 90.0 parachute_t_exit = 350.0 parachute_t_duration = parachute_t_exit - parachute_t_entry parachute_t_duration_min = parachute_t_duration*0.96 parachute_t_duration_max = parachute_t_duration*1.03  parachute_deacceleration = abs((parachute_v_entry - parachute_v_exit) / (parachute_t_entry - parachute_t_exit)) print(f\"parachute_deacceleration={parachute_deacceleration}\")  parachute_min_deacceleration = parachute_deacceleration*0.94 print(f\"parachute_min_deacceleration={parachute_min_deacceleration}\")  parachute_max_deacceleration = parachute_deacceleration*1.03 print(f\"parachute_max_deacceleration={parachute_max_deacceleration}\")  S2 = PolyhedralContract.from_string(     input_vars=[       \"dt1\",          # time duration for the parachute deployment segment from entry to exit.       \"v1\"            # entry velocity     ],     output_vars=[       \"v2\"            # exit velocity     ],     assumptions=[       # velocity @ entry       f\"v1 &lt;= {parachute_v_entry}\"     ],     guarantees=[       # # parachute effectiveness is limited to v2 &gt;= 320       f\"-v2 &lt;= -{parachute_v_exit}\",              # parachute_min_deacceleration * dt1 &lt;= v1 - v2 &lt;= parachute_max_deacceleration * dt1       # v1 - v2 &lt;= parachute_max_deacceleration * dt1       f\" v1 - v2 - {parachute_max_deacceleration} dt1 &lt;= 0\",        # parachutec_min_deacceleration * dt1 &lt;= v1 - v2       f\"-v1 + v2 + {parachute_min_deacceleration} dt1 &lt;= 0\"    ])  print(f\"\\nContract S2:\\n\\n{S2}\") <pre>parachute_deacceleration=4.923076923076923\nparachute_min_deacceleration=4.627692307692308\nparachute_max_deacceleration=5.070769230769232\n\nContract S2:\n\nInVars: [dt1, v1]\nOutVars:[v2]\nA: [\n  v1 &lt;= 1600\n]\nG: [\n  -v2 &lt;= -320\n  -5.071 dt1 + v1 - v2 &lt;= 0\n  4.628 dt1 - v1 + v2 &lt;= 0\n]\n</pre> <p>Similar to the previous contract, it is helpful to plot the full range of the segment contract to confirm that the admissible region corresponds to the intent of the contract before focusing on a subregion of interest.</p> In\u00a0[12]: Copied! <pre>_ = plot_guarantees(\n    contract=S2,\n    x_var=Var(\"dt1\"),\n    y_var=Var(\"v2\"),\n    var_values={\n        Var(\"v1\"):parachute_v_entry\n    },\n    x_lims=(0, 300),\n    y_lims=(250, 1800)\n)\n</pre> _ = plot_guarantees(     contract=S2,     x_var=Var(\"dt1\"),     y_var=Var(\"v2\"),     var_values={         Var(\"v1\"):parachute_v_entry     },     x_lims=(0, 300),     y_lims=(250, 1800) )                      Figure                  In\u00a0[13]: Copied! <pre>_ = plot_guarantees(\n    contract=S2,\n    x_var=Var(\"dt1\"),\n    y_var=Var(\"v2\"),\n    var_values={\n        Var(\"v1\"):parachute_v_entry\n    },\n    x_lims=(200, 300),\n    y_lims=(250, 400)\n)\n</pre> _ = plot_guarantees(     contract=S2,     x_var=Var(\"dt1\"),     y_var=Var(\"v2\"),     var_values={         Var(\"v1\"):parachute_v_entry     },     x_lims=(200, 300),     y_lims=(250, 400) )                      Figure                  In\u00a0[14]: Copied! <pre>S12 = S1.compose(S2)\nprint(f\"\\nScenario so far: S1 || S2\\n\\n{S12}\")\n</pre> S12 = S1.compose(S2) print(f\"\\nScenario so far: S1 || S2\\n\\n{S12}\") <pre>\nScenario so far: S1 || S2\n\nInVars: [dt0, v0, dt1]\nOutVars:[v2]\nA: [\n  -192.2 dt0 + v0 &lt;= 1600\n  v0 = 2e+04\n]\nG: [\n  -5.071 dt1 - v2 &lt;= -1000\n  -v2 &lt;= -320\n  192.2 dt0 + 4.628 dt1 - v0 + v2 &lt;= 0\n]\n</pre> <p>Plotting the guarantees for the nominal entry conditions (i.e., <code>v0=atmospheric_v_entry</code>) requires using a value of <code>dt0</code> that is compatible with the constraints. In the example below, we use <code>dt0=98</code>.</p> In\u00a0[15]: Copied! <pre>_ = plot_guarantees(\n    contract=S12,\n    x_var=Var(\"dt1\"),\n    y_var=Var(\"v2\"),\n    var_values={\n        Var(\"v0\"):atmospheric_v_entry,\n        Var(\"dt0\"):98\n    },\n    x_lims=(60, 180),\n    y_lims=(200, 1000)\n)\n</pre> _ = plot_guarantees(     contract=S12,     x_var=Var(\"dt1\"),     y_var=Var(\"v2\"),     var_values={         Var(\"v0\"):atmospheric_v_entry,         Var(\"dt0\"):98     },     x_lims=(60, 180),     y_lims=(200, 1000) )                      Figure                  In\u00a0[17]: Copied! <pre>powered_descent_v_entry = 600.0\npowered_descent_v_exit = 2.7\n\npowered_descent_t_entry = 350.0\npowered_descent_t_exit = 398.0\npowered_descent_t_duration =powered_descent_t_exit - powered_descent_t_entry\npowered_descent_t_duration_min = powered_descent_t_duration*0.96\npowered_descent_t_duration_max = powered_descent_t_duration*1.03\n\npowered_descent_deacceleration = abs((powered_descent_v_entry - powered_descent_v_exit) / (powered_descent_t_entry - powered_descent_t_exit))\nprint(f\"powered_descent_deacceleration={powered_descent_deacceleration}\")\n\npowered_descent_min_deacceleration = powered_descent_deacceleration*0.94\nprint(f\"powered_descent_min_deacceleration={powered_descent_min_deacceleration}\")\n\npowered_descent_max_deacceleration = powered_descent_deacceleration*1.03\nprint(f\"powered_descent_max_deacceleration={powered_descent_max_deacceleration}\")\n\nS3 = PolyhedralContract.from_string(\n    input_vars=[\n      \"dt2\",          # time duration for the powered descent from entry to exit.\n      \"v2\"            # entry velocity\n    ],\n    output_vars=[\n      \"v3\"            # exit velocity\n    ],\n    assumptions=[\n      # velocity @ entry\n      f\"v2 &lt;= {powered_descent_v_entry}\",\n    ],\n    guarantees=[\n      # velocity @ exit\n      \"-v3 &lt;= 0\",\n      \n      # powered_descent_min_deacceleration * dt2 &lt;= v2 - v3 &lt;= powered_descent_max_deacceleration * dt1\n      # v2 - v3 &lt;= powered_descent_max_deacceleration * dt2\n      f\" v2 - v3 - {powered_descent_max_deacceleration} dt2 &lt;= 0\",\n\n      # powered_descent_min_deacceleration * dt2 &lt;= v2 - v3\n      f\"-v2 + v3 + {powered_descent_min_deacceleration} dt2 &lt;= 0\"\n    ])\n\nprint(f\"\\nContract S3:\\n\\n{S3}\")\n</pre> powered_descent_v_entry = 600.0 powered_descent_v_exit = 2.7  powered_descent_t_entry = 350.0 powered_descent_t_exit = 398.0 powered_descent_t_duration =powered_descent_t_exit - powered_descent_t_entry powered_descent_t_duration_min = powered_descent_t_duration*0.96 powered_descent_t_duration_max = powered_descent_t_duration*1.03  powered_descent_deacceleration = abs((powered_descent_v_entry - powered_descent_v_exit) / (powered_descent_t_entry - powered_descent_t_exit)) print(f\"powered_descent_deacceleration={powered_descent_deacceleration}\")  powered_descent_min_deacceleration = powered_descent_deacceleration*0.94 print(f\"powered_descent_min_deacceleration={powered_descent_min_deacceleration}\")  powered_descent_max_deacceleration = powered_descent_deacceleration*1.03 print(f\"powered_descent_max_deacceleration={powered_descent_max_deacceleration}\")  S3 = PolyhedralContract.from_string(     input_vars=[       \"dt2\",          # time duration for the powered descent from entry to exit.       \"v2\"            # entry velocity     ],     output_vars=[       \"v3\"            # exit velocity     ],     assumptions=[       # velocity @ entry       f\"v2 &lt;= {powered_descent_v_entry}\",     ],     guarantees=[       # velocity @ exit       \"-v3 &lt;= 0\",              # powered_descent_min_deacceleration * dt2 &lt;= v2 - v3 &lt;= powered_descent_max_deacceleration * dt1       # v2 - v3 &lt;= powered_descent_max_deacceleration * dt2       f\" v2 - v3 - {powered_descent_max_deacceleration} dt2 &lt;= 0\",        # powered_descent_min_deacceleration * dt2 &lt;= v2 - v3       f\"-v2 + v3 + {powered_descent_min_deacceleration} dt2 &lt;= 0\"     ])  print(f\"\\nContract S3:\\n\\n{S3}\") <pre>powered_descent_deacceleration=12.44375\npowered_descent_min_deacceleration=11.697125\npowered_descent_max_deacceleration=12.8170625\n\nContract S3:\n\nInVars: [dt2, v2]\nOutVars:[v3]\nA: [\n  v2 &lt;= 600\n]\nG: [\n  -v3 &lt;= 0\n  -12.82 dt2 + v2 - v3 &lt;= 0\n  11.7 dt2 - v2 + v3 &lt;= 0\n]\n</pre> <p>Here, we plot only a region of interest where the exit velocity may reach zero depending on the value of <code>dt2</code>.</p> In\u00a0[18]: Copied! <pre>_ = plot_guarantees(\n    contract=S3,\n    x_var=Var(\"dt2\"),\n    y_var=Var(\"v3\"),\n    var_values={\n        Var(\"v2\"):powered_descent_v_entry\n    },\n    x_lims=(20, 60),\n    y_lims=(0, 400)\n)\n</pre> _ = plot_guarantees(     contract=S3,     x_var=Var(\"dt2\"),     y_var=Var(\"v3\"),     var_values={         Var(\"v2\"):powered_descent_v_entry     },     x_lims=(20, 60),     y_lims=(0, 400) )                      Figure                  In\u00a0[19]: Copied! <pre>S123 = S12.compose(S3)\nprint(f\"\\nScenario so far: S1 || S2 || S3\\n\\n{S123}\")\n</pre> S123 = S12.compose(S3) print(f\"\\nScenario so far: S1 || S2 || S3\\n\\n{S123}\") <pre>\nScenario so far: S1 || S2 || S3\n\nInVars: [dt0, v0, dt1, dt2]\nOutVars:[v3]\nA: [\n  -192.2 dt0 - 4.628 dt1 + v0 &lt;= 600\n  -192.2 dt0 + v0 &lt;= 1600\n  v0 = 2e+04\n]\nG: [\n  -5.071 dt1 - 12.82 dt2 - v3 &lt;= -1000\n  -12.82 dt2 - v3 &lt;= -320\n  -v3 &lt;= 0\n  192.2 dt0 + 4.628 dt1 + 11.7 dt2 - v0 + v3 &lt;= 0\n]\n</pre> <p>Plotting the guarantees of the composition so far for the nominal entry conditions (i.e., <code>v0=atmospheric_v_entry</code>) requires choosing values for the remaining 'knobs': <code>dt0</code> and <code>dt1</code>.</p> In\u00a0[20]: Copied! <pre>_ = plot_guarantees(\n    contract=S123,\n    x_var=Var(\"dt2\"),\n    y_var=Var(\"v3\"),\n    var_values={\n        Var(\"v0\"):atmospheric_v_entry,\n        Var(\"dt0\"):98,\n        Var(\"dt1\"):130,\n    },\n    x_lims=(40, 60),\n    y_lims=(0, 10)\n)\n</pre> _ = plot_guarantees(     contract=S123,     x_var=Var(\"dt2\"),     y_var=Var(\"v3\"),     var_values={         Var(\"v0\"):atmospheric_v_entry,         Var(\"dt0\"):98,         Var(\"dt1\"):130,     },     x_lims=(40, 60),     y_lims=(0, 10) )                      Figure                  In\u00a0[21]: Copied! <pre># The sky crane maneuver initiates at a velocity less than 2.7 kph.\nprint(f\"skycrane_v_entry = {skycrane_v_entry}\")\n\n# The sky crane maneuver ends when the rover velocity reaches 0 kph.\nprint(f\"skycrane_v_exit = {skycrane_v_exit}\")\n\nprint(f\"skycrane_t_entry = {skycrane_t_entry}\")\nprint(f\"skycrane_t_exit = {skycrane_t_exit}\")\n\nskycrane_t_duration = skycrane_t_exit - skycrane_t_entry\nskycrane_t_duration_min = skycrane_t_duration*0.96\nskycrane_t_duration_max = skycrane_t_duration*1.03\n\nskycrane_deacceleration = abs((skycrane_v_entry - skycrane_v_exit) / (skycrane_t_entry - skycrane_t_exit))\nprint(f\"skycrane_deacceleration={skycrane_deacceleration}\")\n\nskycrane_min_deacceleration = skycrane_deacceleration*0.94\nprint(f\"skycrane_min_deacceleration={skycrane_min_deacceleration}\")\n\nskycrane_max_deacceleration = skycrane_deacceleration*1.03\nprint(f\"skycrane_max_deacceleration={skycrane_max_deacceleration}\")\n\nS4 = PolyhedralContract.from_string(\n    input_vars=[\n      \"dt3\",          # time duration for the powered descent from entry to exit.\n      \"v3\"            # entry velocity\n    ],\n    output_vars=[\n      \"v4\"            # exit velocity\n    ],\n    assumptions=[\n      # velocity @ entry\n      f\"v3 &lt;= {skycrane_v_entry}\"\n    ],\n    guarantees=[\n      # velocity @ exit\n      \"-v4 &lt;= 0\",\n\n      # skycrane_min_deacceleration * dt3 &lt;= v3 - v4 &lt;= skycrane_max_deacceleration * dt1\n      # v3 - v4 &lt;= skycrane_max_deacceleration * dt3\n      f\" v3 - v4 - {skycrane_max_deacceleration} dt3 &lt;= 0\",\n\n      # skycrane_min_deacceleration * dt3 &lt;= v3 - v4\n      f\"-v3 + v4 + {skycrane_min_deacceleration} dt3 &lt;= 0\"\n    ])\n\nprint(f\"\\nContract S4:\\n\\n{S4}\")\n</pre> # The sky crane maneuver initiates at a velocity less than 2.7 kph. print(f\"skycrane_v_entry = {skycrane_v_entry}\")  # The sky crane maneuver ends when the rover velocity reaches 0 kph. print(f\"skycrane_v_exit = {skycrane_v_exit}\")  print(f\"skycrane_t_entry = {skycrane_t_entry}\") print(f\"skycrane_t_exit = {skycrane_t_exit}\")  skycrane_t_duration = skycrane_t_exit - skycrane_t_entry skycrane_t_duration_min = skycrane_t_duration*0.96 skycrane_t_duration_max = skycrane_t_duration*1.03  skycrane_deacceleration = abs((skycrane_v_entry - skycrane_v_exit) / (skycrane_t_entry - skycrane_t_exit)) print(f\"skycrane_deacceleration={skycrane_deacceleration}\")  skycrane_min_deacceleration = skycrane_deacceleration*0.94 print(f\"skycrane_min_deacceleration={skycrane_min_deacceleration}\")  skycrane_max_deacceleration = skycrane_deacceleration*1.03 print(f\"skycrane_max_deacceleration={skycrane_max_deacceleration}\")  S4 = PolyhedralContract.from_string(     input_vars=[       \"dt3\",          # time duration for the powered descent from entry to exit.       \"v3\"            # entry velocity     ],     output_vars=[       \"v4\"            # exit velocity     ],     assumptions=[       # velocity @ entry       f\"v3 &lt;= {skycrane_v_entry}\"     ],     guarantees=[       # velocity @ exit       \"-v4 &lt;= 0\",        # skycrane_min_deacceleration * dt3 &lt;= v3 - v4 &lt;= skycrane_max_deacceleration * dt1       # v3 - v4 &lt;= skycrane_max_deacceleration * dt3       f\" v3 - v4 - {skycrane_max_deacceleration} dt3 &lt;= 0\",        # skycrane_min_deacceleration * dt3 &lt;= v3 - v4       f\"-v3 + v4 + {skycrane_min_deacceleration} dt3 &lt;= 0\"     ])  print(f\"\\nContract S4:\\n\\n{S4}\") <pre>skycrane_v_entry = 2.7\nskycrane_v_exit = 0\nskycrane_t_entry = 398.0\nskycrane_t_exit = 410.0\nskycrane_deacceleration=0.225\nskycrane_min_deacceleration=0.2115\nskycrane_max_deacceleration=0.23175\n\nContract S4:\n\nInVars: [dt3, v3]\nOutVars:[v4]\nA: [\n  v3 &lt;= 2.7\n]\nG: [\n  -v4 &lt;= 0\n  -0.2318 dt3 + v3 - v4 &lt;= 0\n  0.2115 dt3 - v3 + v4 &lt;= 0\n]\n</pre> <p>Here, we plot only a region of interest where the exit velocity may reach zero depending on the value of dt3.</p> In\u00a0[22]: Copied! <pre>_ = plot_guarantees(\n    contract=S4,\n    x_var=Var(\"dt3\"),\n    y_var=Var(\"v4\"),\n    var_values={\n        Var(\"v3\"):skycrane_v_entry\n    },\n    x_lims=(0, 15),\n    y_lims=(0, 3)\n)\n</pre> _ = plot_guarantees(     contract=S4,     x_var=Var(\"dt3\"),     y_var=Var(\"v4\"),     var_values={         Var(\"v3\"):skycrane_v_entry     },     x_lims=(0, 15),     y_lims=(0, 3) )                      Figure                  In\u00a0[23]: Copied! <pre>S1234 = S123.compose(S4)\nprint(f\"\\nScenario so far: S1 || S2 || S3 || S4\\n\\n{S1234}\")\n</pre> S1234 = S123.compose(S4) print(f\"\\nScenario so far: S1 || S2 || S3 || S4\\n\\n{S1234}\") <pre>\nScenario so far: S1 || S2 || S3 || S4\n\nInVars: [dt0, v0, dt1, dt2, dt3]\nOutVars:[v4]\nA: [\n  -192.2 dt0 - 4.628 dt1 - 11.7 dt2 + v0 &lt;= 2.7\n  -192.2 dt0 - 4.628 dt1 + v0 &lt;= 600\n  -192.2 dt0 + v0 &lt;= 1600\n  v0 = 2e+04\n]\nG: [\n  -5.071 dt1 - 12.82 dt2 - 0.2318 dt3 - v4 &lt;= -1000\n  -12.82 dt2 - 0.2318 dt3 - v4 &lt;= -320\n  192.2 dt0 + 4.628 dt1 + 11.7 dt2 + 0.2115 dt3 - v0 + v4 &lt;= 0\n  -v4 &lt;= 0\n]\n</pre> <p>Plotting the guarantees of the composition so far for the nominal entry conditions (i.e., v0=atmospheric_v_entry) requires choosing values for the remaining 'knobs': <code>dt0</code>, <code>dt1</code>, and <code>dt2</code>.</p> In\u00a0[24]: Copied! <pre>_ = plot_guarantees(\n    contract=S1234,\n    x_var=Var(\"dt3\"),\n    y_var=Var(\"v4\"),\n    var_values={\n        Var(\"v0\"):atmospheric_v_entry,\n        Var(\"dt0\"):98,\n        Var(\"dt1\"):128,\n        Var(\"dt2\"):49\n    },\n    x_lims=(0, 10),\n    y_lims=(0, 2)\n)\n</pre> _ = plot_guarantees(     contract=S1234,     x_var=Var(\"dt3\"),     y_var=Var(\"v4\"),     var_values={         Var(\"v0\"):atmospheric_v_entry,         Var(\"dt0\"):98,         Var(\"dt1\"):128,         Var(\"dt2\"):49     },     x_lims=(0, 10),     y_lims=(0, 2) )                      Figure                  In\u00a0[25]: Copied! <pre>EDL0 = PolyhedralContract.from_string(\n    input_vars=[\n      \"t0\",          # time @ entry\n      \"v0\"           # velocity @ entry\n    ],\n    output_vars=[\n      \"t4\",\n      \"v4\"            # velocity @ exit\n    ],\n    assumptions=[\n      # time @ entry\n      f\"t0 = {atmospheric_t_entry}\",\n\n      # velocity @ entry\n      f\"v0 = {atmospheric_v_entry}\",\n    ],\n    guarantees=[\n      # bound for time @ exit\n      \"t4 &lt;= 500\",\n      \"-t4 &lt;= 0\",\n\n      # bound for velocity @ exit\n      \"v4 &lt;= 2.7\",\n      f\"-v4 &lt;= {skycrane_v_exit}\"\n    ])\nprint(f\"toplevel EDL scenario contract: EDL0\\n\\n{EDL0}\")\n</pre> EDL0 = PolyhedralContract.from_string(     input_vars=[       \"t0\",          # time @ entry       \"v0\"           # velocity @ entry     ],     output_vars=[       \"t4\",       \"v4\"            # velocity @ exit     ],     assumptions=[       # time @ entry       f\"t0 = {atmospheric_t_entry}\",        # velocity @ entry       f\"v0 = {atmospheric_v_entry}\",     ],     guarantees=[       # bound for time @ exit       \"t4 &lt;= 500\",       \"-t4 &lt;= 0\",        # bound for velocity @ exit       \"v4 &lt;= 2.7\",       f\"-v4 &lt;= {skycrane_v_exit}\"     ]) print(f\"toplevel EDL scenario contract: EDL0\\n\\n{EDL0}\") <pre>toplevel EDL scenario contract: EDL0\n\nInVars: [t0, v0]\nOutVars:[t4, v4]\nA: [\n  t0 = 0\n  v0 = 2e+04\n]\nG: [\n  t4 &lt;= 500\n  -t4 &lt;= 0\n  v4 &lt;= 2.7\n  -v4 &lt;= 0\n]\n</pre> In\u00a0[26]: Copied! <pre>EndToEndDTconstraints = EDL0.quotient(S1234)\nprint(f\"End-to-end DT constraints: EndToEndDTconstraints\\n\\n{EndToEndDTconstraints}\")\n</pre> EndToEndDTconstraints = EDL0.quotient(S1234) print(f\"End-to-end DT constraints: EndToEndDTconstraints\\n\\n{EndToEndDTconstraints}\") <pre>End-to-end DT constraints: EndToEndDTconstraints\n\nInVars: [t0]\nOutVars:[t4, dt0, dt1, dt2, dt3]\nA: [\n  t0 = 0\n]\nG: [\n  t4 &lt;= 500\n  -t4 &lt;= 0\n  -0.2115 dt3 &lt;= 5.4\n  -192.2 dt0 - 4.628 dt1 - 11.7 dt2 &lt;= -2e+04\n  -192.2 dt0 - 4.628 dt1 &lt;= -1.94e+04\n  -192.2 dt0 &lt;= -1.84e+04\n]\n</pre> In\u00a0[27]: Copied! <pre>EDL1 = PolyhedralContract.from_string(\n    input_vars=[\n      \"t0\",          # time @ entry\n      \"dt0\",         # duration of S1\n      \"dt1\",         # duration of S2\n      \"dt2\",         # duration of S3\n      \"dt3\",         # duration of S4\n      \"v0\"           # velocity @ entry\n    ],\n    output_vars=[\n      \"v4\"            # velocity @ exit\n    ],\n    assumptions=[\n      # time @ entry\n      f\"t0 = {atmospheric_t_entry}\",\n\n      # velocity @ entry\n      f\"v0 = {atmospheric_v_entry}\",\n\n      \"-dt0 &lt;= 100\",\n      \"-dt0 &lt;= -96\",\n      \"dt1 &lt;= 130\",\n      \"-dt1 &lt;= -126\",\n      \"dt2 &lt;= 52\",\n      \"-dt2 &lt;= -47\",\n      \"dt3 &lt;= 5.1\",\n      \"-dt3 &lt;= -4.9\",\n    ],\n    guarantees=[\n      # velocity @ exit\n      \"v4 &lt;= 2.7\",\n      f\"-v4 &lt;= {skycrane_v_exit}\"\n    ])\nprint(f\"toplevel EDL scenario contract with allocation bounds: EDL1\\n\\n{EDL1}\")\n</pre> EDL1 = PolyhedralContract.from_string(     input_vars=[       \"t0\",          # time @ entry       \"dt0\",         # duration of S1       \"dt1\",         # duration of S2       \"dt2\",         # duration of S3       \"dt3\",         # duration of S4       \"v0\"           # velocity @ entry     ],     output_vars=[       \"v4\"            # velocity @ exit     ],     assumptions=[       # time @ entry       f\"t0 = {atmospheric_t_entry}\",        # velocity @ entry       f\"v0 = {atmospheric_v_entry}\",        \"-dt0 &lt;= 100\",       \"-dt0 &lt;= -96\",       \"dt1 &lt;= 130\",       \"-dt1 &lt;= -126\",       \"dt2 &lt;= 52\",       \"-dt2 &lt;= -47\",       \"dt3 &lt;= 5.1\",       \"-dt3 &lt;= -4.9\",     ],     guarantees=[       # velocity @ exit       \"v4 &lt;= 2.7\",       f\"-v4 &lt;= {skycrane_v_exit}\"     ]) print(f\"toplevel EDL scenario contract with allocation bounds: EDL1\\n\\n{EDL1}\") <pre>toplevel EDL scenario contract with allocation bounds: EDL1\n\nInVars: [t0, dt0, dt1, dt2, dt3, v0]\nOutVars:[v4]\nA: [\n  t0 = 0\n  v0 = 2e+04\n  -dt0 &lt;= 100\n  -dt0 &lt;= -96\n  dt1 &lt;= 130\n  -dt1 &lt;= -126\n  dt2 &lt;= 52\n  -dt2 &lt;= -47\n  dt3 &lt;= 5.1\n  -dt3 &lt;= -4.9\n]\nG: [\n  v4 &lt;= 2.7\n  -v4 &lt;= 0\n]\n</pre> <p>Suppose we have contracts for a subset of the EDL segments, <code>S1</code>, <code>S2</code>, and <code>S4</code>. Given the toplevel EDL scenario contract with allocation bounds, we calculate a contract for the missing subsystem, <code>S3</code>, with a simple script of algebraic manipulations:</p> <ul> <li>first, compose all available segment contracts for <code>S1</code>, <code>S2</code>, and <code>S4</code>,</li> <li>then, calculate the difference between the toplevel EDL scenario contract with allocation bounds and the 3-segment composite contract.</li> </ul> In\u00a0[28]: Copied! <pre># First, compose the contracts we have: S1, S2, and S4.\nS124 = S12.compose(S4)\nprint(f\"Contract for S1 || S2 || S4:\\n\\n{S124}\")\n</pre> # First, compose the contracts we have: S1, S2, and S4. S124 = S12.compose(S4) print(f\"Contract for S1 || S2 || S4:\\n\\n{S124}\") <pre>Contract for S1 || S2 || S4:\n\nInVars: [dt0, v0, dt1, dt3, v3]\nOutVars:[v2, v4]\nA: [\n  -192.2 dt0 + v0 &lt;= 1600\n  v0 = 2e+04\n  v3 &lt;= 2.7\n]\nG: [\n  -5.071 dt1 - v2 &lt;= -1000\n  -v2 &lt;= -320\n  192.2 dt0 + 4.628 dt1 - v0 + v2 &lt;= 0\n  -v4 &lt;= 0\n  -0.2318 dt3 + v3 - v4 &lt;= 0\n  0.2115 dt3 - v3 + v4 &lt;= 0\n]\n</pre> In\u00a0[29]: Copied! <pre># Then, define the missing S3 as the quotient of toplevel contract w.r.t. what we have.\nmissingS3 = EDL1.quotient(S124)\nprint(f\"Contract for the missing S3 segment:\\n\\n{missingS3}\")\n</pre> # Then, define the missing S3 as the quotient of toplevel contract w.r.t. what we have. missingS3 = EDL1.quotient(S124) print(f\"Contract for the missing S3 segment:\\n\\n{missingS3}\") <pre>Contract for the missing S3 segment:\n\nInVars: [t0, dt2, v2]\nOutVars:[v3]\nA: [\n  t0 = 0\n  dt2 &lt;= 52\n  -dt2 &lt;= -47\n]\nG: [\n  v3 &lt;= 2.7\n]\n</pre> <p>It is good practice to verify the results; so let's recompose the scenario segments, starting from <code>S1</code> and <code>S2</code> we already have and composing the missing <code>S3</code> contract calculated above:</p> In\u00a0[30]: Copied! <pre>S123_implied = S12.compose(missingS3)\nprint(S123_implied)\n</pre> S123_implied = S12.compose(missingS3) print(S123_implied) <pre>InVars: [dt0, v0, dt1, t0, dt2]\nOutVars:[v3]\nA: [\n  t0 = 0\n  dt2 &lt;= 52\n  -dt2 &lt;= -47\n  -192.2 dt0 + v0 &lt;= 1600\n  v0 = 2e+04\n]\nG: [\n  192.2 dt0 - 0.4431 dt1 - v0 &lt;= -1000\n  192.2 dt0 + 4.628 dt1 - v0 &lt;= -320\n  v3 &lt;= 2.7\n]\n</pre> <p>.. and compose that with the last segment, <code>S4</code>, we already have:</p> In\u00a0[31]: Copied! <pre>S1234_implied = S123_implied.compose(S4)\nprint(S1234_implied)\n</pre> S1234_implied = S123_implied.compose(S4) print(S1234_implied) <pre>InVars: [dt0, v0, dt1, t0, dt2, dt3]\nOutVars:[v4]\nA: [\n  t0 = 0\n  dt2 &lt;= 52\n  -dt2 &lt;= -47\n  -192.2 dt0 + v0 &lt;= 1600\n  v0 = 2e+04\n]\nG: [\n  192.2 dt0 - 0.4431 dt1 - v0 &lt;= -1000\n  192.2 dt0 + 4.628 dt1 - v0 &lt;= -320\n  0.2115 dt3 + v4 &lt;= 2.7\n  -v4 &lt;= 0\n  -0.02025 dt3 &lt;= 0\n]\n</pre> <p>Now, we can verify that this end-to-end scenario contract based on the missing contract for <code>S3</code> is algebraically a refinement of the toplevel EDL scenario contract with allocation bounds.</p> In\u00a0[32]: Copied! <pre>print(S1234_implied.refines(EDL1))\n</pre> print(S1234_implied.refines(EDL1)) <pre>True\n</pre>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#mars-entry-descent-landing-mission-scenario","title":"Mars Entry-Descent-Landing Mission Scenario\u00b6","text":""},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#formalizing-edl-phase-segments-as-algebraic-contracts","title":"Formalizing EDL Phase segments as algebraic contracts\u00b6","text":"<p>Given the segmentation of the EDL phase timeline according to major active subsystems, EDL designers need to spread the end-to-end EDL phase requirement -- slowing the spacecraft from 20,0000 kilometers per hour down to zero -- into segment allocations. Subsystem designers work with highly complex models of subsystems to characterize subsystem performance against a broad range of uncertainties within the requirement allocation bounds of the relevant segment. Often, subsystem designers need to renegotiate the requirement allocations among segments to explore design trades or to resolve interface issues between segments. Since EDL segment requirements evolve often, it becomes necessary to communicate among all stakeholders the current requirement baseline at a level of abstraction high enough to yield a reasonably concise baseline that all stakeholders can easily understand and yet sufficiently detailed and precise that domain experts can rigorously relate to their detailed engineering models. We propose Pacti's polyhedral convex algebra as a candidate for a rigorous formalism for specifying abstract requirements as algebraic contracts.</p> <p>This proposal rests on the observation that current EDL phase design practices already capture a kind of algebraic contract as illustrated below:</p>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#segment-s1-parachute-entry","title":"Segment S1: parachute Entry\u00b6","text":"<p>For explanations, see: https://mars.nasa.gov/resources/25445/perseverance-rover-decelerating-in-the-martian-atmosphere-illustration/</p> <p></p>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#segment-s2-parachute-deployment","title":"Segment S2: Parachute Deployment\u00b6","text":"<p>Similar to the atmospheric entry segment above, the parachute deployment contract below defines <code>dt1</code> as a special input variable to characterize the resulting velocity decrease due to the parachute and related subsystems active during this segment.</p>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#scenario-so-far-s1-s2","title":"Scenario so far: S1 || S2\u00b6","text":"<p>We can build the scenario so far by composing the phase segments, i.e., <code>S1 || S2</code>. Doing so provides useful feedback to diagnose incompatible contracts. Successful composition provides a high-level summary of the resulting contract since composition eliminates intermediate variables. In the example below, <code>v1</code> was such an intermediate variable since it is an output of <code>S1</code> and an input of <code>S2</code>. Notice how Pacti retain the special 'knob' variables of both contracts, <code>dt1</code> and <code>dt2</code>, because these special variables are inputs only.</p>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#segment-s3-powered-descent","title":"Segment S3: Powered Descent\u00b6","text":"<p>Similar to previous segment encodings, the powered descent contract below defines <code>dt2</code> as a special input variable to characterize the resulting velocity decrease due to the powered descent stage subsystem active during this segment.</p>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#scenario-so-far-s1-s2-s3","title":"Scenario so far: S1 || S2 || S3\u00b6","text":"<p>Similar to the above, we expect Pacti to eliminate the intermediate variables, <code>v1</code> and <code>v2</code>, and to retain all of our special 'knob' variables, <code>dt0</code>, <code>dt1</code>, and <code>dt2</code>,  from the composed contracts.</p>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#segment-s4-sky-crane","title":"Segment S4: Sky Crane\u00b6","text":"<p>Similar to previous segment encodings, the sky crane contract below defines <code>dt3</code> as a special input variable to characterize the resulting velocity decrease due to the sky crane subsystem active during this segment.</p>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#scenario-so-far-s1-s2-s3-s4","title":"Scenario so far: S1 || S2 || S3 || S4\u00b6","text":"<p>Similar to the above, we expect Pacti to eliminate the intermediate variables, <code>v1</code>, <code>v2</code>, and <code>v3</code> and to retain all of our special 'knob' variables, <code>dt0</code>, <code>dt1</code>, <code>dt2</code>, and <code>dt3</code> from the composed contracts.</p>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#using-contract-algebra-for-manipulating-contracts","title":"Using contract algebra for manipulating contracts\u00b6","text":"<p>Pacti provides 3 algebraic operations on contracts:</p> <ul> <li>composition, which builds systems from subsystem contracts as shown above</li> <li>quotient, which computes a kind of difference operation</li> <li>refinement, which verifies that a detailed contract conforms with an abstract contract.</li> </ul> <p>Here, we demonstrate two applications of the quotient operation for:</p> <ul> <li>deriving end-to-end constraints for the special 'knob' variables,</li> <li>calculating a missing contract and of the refinement operation to verify the results.</li> </ul> <p>Before we go into these details, we need to write a specification for the toplevel EDL phase itself, which is very simple:</p> <ul> <li>assume the entry conditions are as given (exact values in this example)</li> <li>guarantee the desired exit conditions are as given (value ranges in this example)</li> </ul>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#deriving-end-to-end-allocation-constraints","title":"Deriving end-to-end allocation constraints\u00b6","text":"<p>Given the toplevel, end-to-end EDL scenario contract, we want to extract the derived constraints for our special 'knob' input variables governing the allocated resources to each phase segment. These derived constraints capture the relationships that an admissible allocation of resources must satisfy as a function of the remaining variables, i.e., <code>t0</code> and <code>t4</code>. Notice that Pacti managed to simplify the constraints by eliminating both input and output velocities, <code>v0</code> and <code>v4</code>.</p>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#calculating-the-contract-for-a-missing-subsystem","title":"Calculating the contract for a missing subsystem\u00b6","text":"<p>Suppose that the EDL designers are aware of the allocation-based modeling strategy with the special 'knob' input variables: <code>dt0</code>, ... <code>dt3</code>. At the toplevel, one could specify allocation limits for each segment contract as specified below.</p>"},{"location":"_case_studies/cs-space-mission/mars_entry_descent_landing/mars_edl_2nd_encoding/#references","title":"References\u00b6","text":"<p> R. Prakash et al. 2008</p> <p>R. Prakash et al., \"Mars Science Laboratory Entry, Descent, and Landing System Overview,\" 2008 IEEE Aerospace Conference, Big Sky, MT, USA, 2008, pp. 1-18, doi: 10.1109/AERO.2008.4526283.</p> <p> E. Lee. 2019</p> <p>E. Lee, \"Freedom From Choice and the Power of Models: in Honor of Alberto Sangiovanni-Vincentelli\", In Proceedings of the 2019 International Symposium on Physical Design, April 2019.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission/","title":"Overview","text":"<p>This case study demonstrates using Pacti for the design and analysis of operational space mission scenarios. Normally, designing and analyzing such space missions and their scenarios involves complex simulation models covering the significant interactions that can influence the behavior of the systems involved. Several factors drive the complexity of such simulation models including the scope of subsystem interactions and the cross-domain interactions that require coordination among multiple domain experts. Is there a simpler way to explore the salient aspects of a space mission design/analysis problem than building a complex simulation? We believe that Pacti shows such a simpler approach; however, it requires switching the design paradigm from simulation-based to contract-based-- see Benveniste et al. 2018 and Sangiovanni-Vincentelli et al. 2013.</p> <p>This case study focuses on the problem of operating a CubeSat-sized spacecraft/small-body asteroid rendezvous mission as described in detail in Nesnas et al. 2021. For autonomous operation, this would involve an onboard planning/scheduling system based on a generalized timeline representation as described in Chien et al. 2012. Examples of such timeline representation modeling include Rabideau et al. 2017 and Chen et al. 2003. Such systems reflect deliberate design decisions to limit the expressiveness of constraint formulas for planning/scheduling due to considerations of the limited computational resources available on space mission systems and performance requirements for computing solutions. In contrast to the general class of 1st order constraint formulas of PDDL (see Ghallab et al. 1998), such systems involve computationally efficient linear inequalities of the form:</p> $$aX &lt;= b$$<p>where $x$ is a timeline variable and $a,b$ are constants that may encode temporal information about the schedule of a task instance.</p> <p>Since this class of constraint formula fits the expressiveness of Pacti's polyhedral constraints, this case study explores modeling tasks for an onboard automated planning/scheduling system as assume-guarantee components using Pacti.</p> In\u00a0[1]: Copied! <pre>from IPython import display\nfrom base64 import b64decode\nfrom contract_utils import *\n</pre> from IPython import display from base64 import b64decode from contract_utils import * <p>The following figure illustrates a simplification of the CubeSat-sized spacecraft/small-body asteroid approach scenario described in more detail in Nesnas et al. 2021. Note: the Sun, Earth, spacecraft and small-body asteroid are shown at different scales for illustration purposes.</p> <p>To communicate with Earth, the cubesat-sized spacecraft (blue cube) must orient its fixed antennas towards Earth (line A). Depending on the trajectory, this orientation may be suboptimal for the spacecraft panels to produce maximum electrical power (line B). The spacecraft must make optical measurements of the small body asteroid to estimate its relative trajectory (line C) as part of the onboard autonomous navigation. This navigation requires pointing the spacecraft's thrusters in the direction of a velocity vector (line D) according to a trajectory correction maneuver (TCM). After several carefully designed TCMs, the spacecraft will eventually reach the small body asteroid and land on it as described in Nesnas et al. 2021. For onboard planning/scheduling these behaviors would be modeled as tasks in the style of Rabideau et al. 2017 and Chen et al. 2003; that is, tasks would involve linear inequality constraints for specifying their pre/post conditions and their effects. The following describes the specification of these behaviors in Pacti's assume-guarantee paradigm.</p> <p>The simplified space mission scenario described above involves the following tasks:</p> Task Name Task Description Pointing Constraint DSN Communicate with Earth Line A SBO Acquire Small body observations Line B TCM Perform a Trajectory Correction Maneuver Line C CHARGING Ensure power Line D <p>Planning and scheduling these tasks will result in a scenario of task instances as illustrated below where red dashed rectangles show the temporal extent of each scheduled task instance.</p> <p>To help stakeholders understand the constraints involved in planning/scheduling these tasks, it is necessary to characterize their impacts on key system states as described below:</p> Variable name Value range Variable description <code>t</code> $[0-..]$ time <code>soc</code> $[0-100]$ Spacecraft's battery state-of-charge <code>d</code> $[0-100]$ Spacecraft's current onboard science data storage from small body observations <code>c</code> $&gt;= 0$ Spacecraft cummulative science data from small body observations <code>u</code> $[0-100]$ Spacecraft-small-body relative trajectory uncertainty <code>r</code> $[0-100]$ Spacecraft's relative distance (100=trajectory at beginning of scenario, 0=trajectory at rendez-vous with small body) <code>temp</code> $[0-100]$ Spacecraft's thurster temperature (0=cold, 100=hot) <p>This approach was initially attractive because it resembles what current planning/scheduling systems do: propagating values of state variables across the impacts of scheduled task instances. However, this approach turned out to be impractical because adding more variables leads to significant practical hurdles:</p> <ul> <li>it is difficult to tell whether viewpoints are coupled or not;</li> <li>plotting convex regions of admissible values becomes more difficult because such regions could have a dimension &gt; 2, thereby requiring some kind of projection to visualize;</li> <li>it prevents collaborative engineering where different experts could work independently on modeling their viewpoints separately;</li> <li>it prevents detecting when it becomes necessary to couple viewpoints, an important indicator of domain complexity that warrants careful analysis.</li> </ul> <p>For these reasons, this case study is split into distinct viewpoints for power, data, navigation, and thermal.</p> In\u00a0[5]: Copied! <pre>scenario_requirements = PolyhedralContract.from_string(\n    input_vars = [\n        \"t_entry\",    # scenario start time\n        \"soc_entry\",  # initial battery SOC\n        \"d_entry\",    # initial data storage volume\n        \"c_entry\",    # initial cumulative data volume\n        \"u_entry\",    # initial trajectory uncertainty\n        \"r_entry\",    # initial relative distance\n        \"temp_entry\", # initial spacecraft thruster temperature\n    ],\n    output_vars = [\n        \"t_exit\",     # scenario end time\n        \"soc_exit\",   # final battery SOC\n        \"d_exit\",     # final data storage volume\n        \"c_exit\",     # final cumulative data volume\n        \"u_exit\",     # final trajectory uncertainty\n        \"r_exit\",     # final relative distance\n        \"temp_exit\",  # final spacecraft thruster temperature\n    ],\n    assumptions = [\n        \"t_entry = 0\",      # start @ t=0\n        \"soc_entry = 100\",  # start with battery fully charged\n        \"d_entry = 0\",      # start with no science data storage\n        \"c_entry = 0\",      # start with no cumulative science data\n        \"u_entry = 20\",     # start with trajectory estimation uncertainty = 20% (ground-based calculations)\n        \"r_entry = 100\",    # start with relative distance = 100%\n        \"temp_entry = 0\",   # start with cold thruster temperature\n    ],\n    guarantees = [\n        \"t_exit = 300\",     # projected end @ t=300\n        \"-soc_exit &lt;= 70\",  # goal: battery &gt;= 70% SOC\n        \"d_exit = 0\",       # goal: all science data downlinked\n        \"-c_exit &lt;= -1e4\",  # goal: at least 10^4 cumulative science data observations\n        \"u_exit &lt;= 1\",      # goal: trajectory estimation uncertainty &lt;= 1%\n        \"r_exit &lt;= 10\",     # goal: relative distance below 10%\n        \"-r_exit &lt;= -5\",    # goal: relative distance above 5%\n        \"-temp_exit &lt;= 0\",  # goal: no constraint on thruster temperature since they cool very quickly\n    ],\n)\nprint(f\"scenario_requirements:\\n\\n{scenario_requirements}\")\n</pre> scenario_requirements = PolyhedralContract.from_string(     input_vars = [         \"t_entry\",    # scenario start time         \"soc_entry\",  # initial battery SOC         \"d_entry\",    # initial data storage volume         \"c_entry\",    # initial cumulative data volume         \"u_entry\",    # initial trajectory uncertainty         \"r_entry\",    # initial relative distance         \"temp_entry\", # initial spacecraft thruster temperature     ],     output_vars = [         \"t_exit\",     # scenario end time         \"soc_exit\",   # final battery SOC         \"d_exit\",     # final data storage volume         \"c_exit\",     # final cumulative data volume         \"u_exit\",     # final trajectory uncertainty         \"r_exit\",     # final relative distance         \"temp_exit\",  # final spacecraft thruster temperature     ],     assumptions = [         \"t_entry = 0\",      # start @ t=0         \"soc_entry = 100\",  # start with battery fully charged         \"d_entry = 0\",      # start with no science data storage         \"c_entry = 0\",      # start with no cumulative science data         \"u_entry = 20\",     # start with trajectory estimation uncertainty = 20% (ground-based calculations)         \"r_entry = 100\",    # start with relative distance = 100%         \"temp_entry = 0\",   # start with cold thruster temperature     ],     guarantees = [         \"t_exit = 300\",     # projected end @ t=300         \"-soc_exit &lt;= 70\",  # goal: battery &gt;= 70% SOC         \"d_exit = 0\",       # goal: all science data downlinked         \"-c_exit &lt;= -1e4\",  # goal: at least 10^4 cumulative science data observations         \"u_exit &lt;= 1\",      # goal: trajectory estimation uncertainty &lt;= 1%         \"r_exit &lt;= 10\",     # goal: relative distance below 10%         \"-r_exit &lt;= -5\",    # goal: relative distance above 5%         \"-temp_exit &lt;= 0\",  # goal: no constraint on thruster temperature since they cool very quickly     ], ) print(f\"scenario_requirements:\\n\\n{scenario_requirements}\")  <pre>scenario_requirements:\n\nInVars: [t_entry, soc_entry, d_entry, c_entry, u_entry, r_entry, temp_entry]\nOutVars:[t_exit, soc_exit, d_exit, c_exit, u_exit, r_exit, temp_exit]\nA: [\n  t_entry = 0.0\n  soc_entry = 100.0\n  d_entry = 0.0\n  c_entry = 0.0\n  u_entry = 20.0\n  r_entry = 100.0\n  temp_entry = 0.0\n]\nG: [\n  t_exit = 300.0\n  -soc_exit &lt;= 70.0\n  d_exit = 0.0\n  -c_exit &lt;= -10000.0\n  u_exit &lt;= 1.0\n  r_exit &lt;= 10.0\n  -r_exit &lt;= -5.0\n  -temp_exit &lt;= 0.0\n]\n</pre>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission/#space-mission-case-study","title":"Space Mission Case Study\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission/#a-simple-space-mission-scenario","title":"A simple space mission scenario\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission/#modeling-task-behaviors-as-assume-guarantee-contracts","title":"Modeling task behaviors as assume-guarantee contracts\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission/#qualitative-impacts","title":"Qualitative Impacts\u00b6","text":"<p>The following table summarizes a rough qualitative description of each task's impacts on the system states with a simple scale, <code>+</code>, <code>0</code>, and <code>-</code>, for, respectively, increase, no change, or decrease.</p> Viewpoint State CHARGING DSN SBO TCM Power <code>soc</code> + - - - Science <code>d</code> 0 - + 0 <code>c</code> 0 0 + 0 Navigation <code>u</code> + + - + <code>r</code> 0 0 0 + Thermal <code>temp</code> - - - + <p>For power, only the CHARGING task ensures the optimal orientation of the spacecraft's solar panels for charging the battery. All other tasks consume power where the spacecraft attitude pointing requirements may result in a net discharge of the battery.</p> <p>For science &amp; communication, the onboard science data storage will evolve up and down according to the SBO and DSN tasks respectively while the cumulative science data will increase with SBO tasks.</p> <p>For navigation, the relative trajectory estimation uncertainty grows with tasks that require spacecraft attitude changes (i.e. CHARGING, DSN, and SBO); the only way to reduce this estimation uncertainty is to perform direct optical measurements in the SBO task to refine the onboard navigation trajectory estimate. The TCM task performs so-called delta-V maneuvers calculated to improve the spacecraft's relative distance from the small body.</p> <p>For thermal, each delta-V maneuver in a TCM task requires pre-heating the spacecraft thrusters that otherwise cool off very quickly during all other tasks.</p> <p>While this qualitative characterization suffices to convey a sense of the phenomena involved, we need a quantitative characterization to explore the feasibility of mission scenarios from a planning/scheduling perspective and to explore different scenario strategies. The following diagram illustrates a quantitative characterization of a scenario using Pacti's polyhedral algebra for specifying assume/guarantee constraints over input/output variables. Each task instance in the scenario has a corresponding contract (e.g. A and B in the figure example). By forcing the input of a subsequent task (e.g. B) to be equal to the outputs of a previous task (e.g. A), we can thus encode a temporal ordering constraint for these tasks (i.e., B starts immediately after A finishes). Modeling task instance duration as an explicit input variable (e.g. $duration_A$), we can model quantitative linear relationships about the task behavior as a function of its duration.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission/#mission-scenario-requirements","title":"Mission scenario requirements\u00b6","text":"<p>At the mission level, we can specify an end-to-end mission scenario requirement as assumptions/guarantees over the system state variables as shown below. Note that the scenario requirement omits any reference to the task duration as these must remain unconstrained so that Pacti can compute an admissible schedule by finding values of task durations that satisfy all task constraints.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission/#references","title":"References\u00b6","text":"<p> Benveniste et al. 2018</p> <p>Benveniste, A., Caillaud, B., Nickovic, D., Passerone, R., Raclet, J-B., Reinkemeier, P., Sangiovanni-Vincentelli, A., Damm, W., Henzinger, T. A., and Larsen, K. G. Contracts for system design. Foundations and Trends\u00ae in Electronic Design Automation 12, no. 2-3 (2018): 124-400.</p> <p> Sangiovanni-Vincentelli et al. 2012</p> <p>Sangiovanni-Vincentelli, A., Damm, W., and Passerone, R. Taming Dr. Frankenstein: Contract-based design for cyber-physical systems. European journal of control 18.3 (2012): 217-238.</p> <p> Toche et al. 2020</p> <p>Toche, B.; Pellerin, R.; and Fortin, C.  Set-based design: a review and new directions.  In Design Science, Volume 6, e18, 2020.</p> <p> Chien et al. 2012</p> <p>Chien, S.; Johnston, M.; Policella, N.; Frank, J.; Lenzen, C.; Giuliano, M.; and Kavelaars, A.  A generalized timeline representation, services, and interface for automating space mission operations.  In International Conference On Space Operations (SpaceOps 2012), Stockholm, Sweden, June 2012.</p> <p> Rabideau et al. 2017</p> <p>Rabideau, G.; Chien, S.; Galer, M.; Nespoli, F.; and Costa, M.  Managing Spacecraft Memory Buffers with Concurrent Data Collection and Downlink.  Journal of Aerospace Information Systems (JAIS). December 2017.</p> <p> Chen et al. 2003</p> <p>Chen, Y. and Wah, B.  Automated Planning and Scheduling using Calculus of Variations. 13th International Conference on Automated Planning&amp;Scheduling (ICAPS 2003), Trento, Italy, June 2003.</p> <p> Ghallab et al. 1998</p> <p>Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., &amp; Weld, D. (1998).  PDDL - The Planning Domain Definition Language.</p> <p> Nesnas et al. 2021</p> <p>Nesnas, I. A. D., Hockman, B. J., Bandopadhyay, S., Morrell, B. J., Lubey, D. P., Villa, J., Bayard, D. S., Osmundson, A., Jarvis, B., Bersani, M., Bhaskaran, S. Autonomous Exploration of Small Bodies Toward Greater Autonomy for Deep Space Missions In Frontiers in Robotics and AI, volume 8, November 2021.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_3viewpoints/","title":"Schedulability Analysis with 3 Viewpoints","text":"In\u00a0[1]: Copied! <pre>%matplotlib widget\n\nfrom IPython import display\nfrom base64 import b64decode\nfrom pacti.terms.polyhedra import *\nfrom pacti.utils import read_contracts_from_file\nfrom contract_utils import *\n</pre> %matplotlib widget  from IPython import display from base64 import b64decode from pacti.terms.polyhedra import * from pacti.utils import read_contracts_from_file from contract_utils import * In\u00a0[2]: Copied! <pre>op_req_pwr1=PolyhedralContract.from_string(\n    input_vars=[\n        \"soc1_entry\",\n        \"duration_dsn1\",\n        \"duration_charging2\",\n        \"duration_sbo3\",\n        \"duration_tcm_heating4\",\n        \"duration_tcm_deltav5\",\n    ],\n    output_vars=[\n        \"output_soc1\",\n        \"output_soc2\",\n        \"output_soc3\",\n        \"output_soc4\",\n        \"output_soc5\"\n    ],\n    assumptions=[\n        \"soc1_entry=80\",\n        \"-duration_dsn1 &lt;= -10\",\n        \"-duration_charging2 &lt;= -10\",\n        \"-duration_sbo3 &lt;= -10\",\n        \"-duration_tcm_heating4 &lt;= -10\",\n        \"-duration_tcm_deltav5 &lt;= -10\",\n    ],\n    guarantees=[\n        \"-output_soc1 &lt;= -40\",\n        \"-output_soc2 &lt;= -40\",\n        \"-output_soc3 &lt;= -40\",\n        \"-output_soc4 &lt;= -40\",\n        \"-output_soc5 &lt;= -40\",\n    ])\n</pre> op_req_pwr1=PolyhedralContract.from_string(     input_vars=[         \"soc1_entry\",         \"duration_dsn1\",         \"duration_charging2\",         \"duration_sbo3\",         \"duration_tcm_heating4\",         \"duration_tcm_deltav5\",     ],     output_vars=[         \"output_soc1\",         \"output_soc2\",         \"output_soc3\",         \"output_soc4\",         \"output_soc5\"     ],     assumptions=[         \"soc1_entry=80\",         \"-duration_dsn1 &lt;= -10\",         \"-duration_charging2 &lt;= -10\",         \"-duration_sbo3 &lt;= -10\",         \"-duration_tcm_heating4 &lt;= -10\",         \"-duration_tcm_deltav5 &lt;= -10\",     ],     guarantees=[         \"-output_soc1 &lt;= -40\",         \"-output_soc2 &lt;= -40\",         \"-output_soc3 &lt;= -40\",         \"-output_soc4 &lt;= -40\",         \"-output_soc5 &lt;= -40\",     ]) <p>The following specification defines a aggressive operational regime that requires the battery state of charge to be at minimum 10% based on an initial state of charge of 80%; we force a non-trivial schedule by requiring that the duration of each task be no less than 10 units.</p> In\u00a0[3]: Copied! <pre>op_req_pwr2=PolyhedralContract.from_string(\n    input_vars=[\n        \"soc1_entry\",\n        \"duration_dsn1\",\n        \"duration_charging2\",\n        \"duration_sbo3\",\n        \"duration_tcm_heating4\",\n        \"duration_tcm_deltav5\",\n    ],\n    output_vars=[\n        \"output_soc1\",\n        \"output_soc2\",\n        \"output_soc3\",\n        \"output_soc4\",\n        \"output_soc5\"\n    ],\n    assumptions=[\n        \"soc1_entry=80\",\n        \"-duration_dsn1 &lt;= -10\",\n        \"-duration_charging2 &lt;= -10\",\n        \"-duration_sbo3 &lt;= -10\",\n        \"-duration_tcm_heating4 &lt;= -10\",\n        \"-duration_tcm_deltav5 &lt;= -10\",\n    ],\n    guarantees=[\n        \"-output_soc1 &lt;= -10\",\n        \"-output_soc2 &lt;= -10\",\n        \"-output_soc3 &lt;= -10\",\n        \"-output_soc4 &lt;= -10\",\n        \"-output_soc5 &lt;= -10\",\n    ]\n)\n</pre> op_req_pwr2=PolyhedralContract.from_string(     input_vars=[         \"soc1_entry\",         \"duration_dsn1\",         \"duration_charging2\",         \"duration_sbo3\",         \"duration_tcm_heating4\",         \"duration_tcm_deltav5\",     ],     output_vars=[         \"output_soc1\",         \"output_soc2\",         \"output_soc3\",         \"output_soc4\",         \"output_soc5\"     ],     assumptions=[         \"soc1_entry=80\",         \"-duration_dsn1 &lt;= -10\",         \"-duration_charging2 &lt;= -10\",         \"-duration_sbo3 &lt;= -10\",         \"-duration_tcm_heating4 &lt;= -10\",         \"-duration_tcm_deltav5 &lt;= -10\",     ],     guarantees=[         \"-output_soc1 &lt;= -10\",         \"-output_soc2 &lt;= -10\",         \"-output_soc3 &lt;= -10\",         \"-output_soc4 &lt;= -10\",         \"-output_soc5 &lt;= -10\",     ] ) In\u00a0[4]: Copied! <pre>op_req_sci0=PolyhedralContract.from_string(\n    input_vars=[\n        \"c1_entry\",\n        \"d1_entry\",\n        \"duration_dsn1\",\n        \"duration_charging2\",\n        \"duration_sbo3\",\n        \"duration_tcm_heating4\",\n        \"duration_tcm_deltav5\",\n    ],\n    output_vars=[\n        \"output_c5\",\n        \"output_d5\",\n    ],\n    assumptions=[\n        \"c1_entry=0\",\n        \"d1_entry=100\",\n        \"-duration_dsn1 &lt;= -10\",\n        \"-duration_charging2 &lt;= -10\",\n        \"-duration_sbo3 &lt;= -10\",\n        \"-duration_tcm_heating4 &lt;= -10\",\n        \"-duration_tcm_deltav5 &lt;= -10\",\n    ],\n    guarantees=[\n    ]\n)\n</pre> op_req_sci0=PolyhedralContract.from_string(     input_vars=[         \"c1_entry\",         \"d1_entry\",         \"duration_dsn1\",         \"duration_charging2\",         \"duration_sbo3\",         \"duration_tcm_heating4\",         \"duration_tcm_deltav5\",     ],     output_vars=[         \"output_c5\",         \"output_d5\",     ],     assumptions=[         \"c1_entry=0\",         \"d1_entry=100\",         \"-duration_dsn1 &lt;= -10\",         \"-duration_charging2 &lt;= -10\",         \"-duration_sbo3 &lt;= -10\",         \"-duration_tcm_heating4 &lt;= -10\",         \"-duration_tcm_deltav5 &lt;= -10\",     ],     guarantees=[     ] ) <p>The following specification defines a conservative operational regime that requires the spacecraft to downlink at least 50% of its onboard science data storage while acquiring at least 60 units of science data from the initial conditions defined above.</p> In\u00a0[5]: Copied! <pre>op_req_sci1=op_req_sci0.merge(PolyhedralContract.from_string(\n    input_vars=[],\n    output_vars=[\n        \"output_c5\",\n        \"output_d5\",\n    ],\n    assumptions=[],\n    guarantees=[\n        \"-output_c5 &lt;= -20\",\n        \"-output_d5 &lt;= -30\",\n    ]\n))\n</pre> op_req_sci1=op_req_sci0.merge(PolyhedralContract.from_string(     input_vars=[],     output_vars=[         \"output_c5\",         \"output_d5\",     ],     assumptions=[],     guarantees=[         \"-output_c5 &lt;= -20\",         \"-output_d5 &lt;= -30\",     ] )) <p>The following specification defines an aggressive operational regime that requires the spacecraft to downlink at least 90% of its onboard science data storage while acquiring at least 80 units of science data from the initial conditions defined above.</p> In\u00a0[6]: Copied! <pre>op_req_sci2=op_req_sci0.merge(PolyhedralContract.from_string(\n    input_vars=[],\n    output_vars=[\n        \"output_c5\",\n        \"output_d5\",\n    ],\n    assumptions=[],\n    guarantees=[\n        \"-output_c5 &lt;= -80\",\n        \"-output_d5 &lt;= -90\",\n    ]\n))\n</pre> op_req_sci2=op_req_sci0.merge(PolyhedralContract.from_string(     input_vars=[],     output_vars=[         \"output_c5\",         \"output_d5\",     ],     assumptions=[],     guarantees=[         \"-output_c5 &lt;= -80\",         \"-output_d5 &lt;= -90\",     ] )) In\u00a0[7]: Copied! <pre>op_req_nav1=PolyhedralContract.from_string(\n    input_vars=[\n        \"u1_entry\",\n        \"r1_entry\",\n        \"duration_dsn1\",\n        \"duration_charging2\",\n        \"duration_sbo3\",\n        \"duration_tcm_heating4\",\n        \"duration_tcm_deltav5\",\n    ],\n    output_vars=[\n        \"output_u5\",\n        \"output_r5\",\n    ],\n    assumptions=[\n        \"u1_entry=30\",\n        \"r1_entry=100\",\n        \"-duration_dsn1 &lt;= -10\",\n        \"-duration_charging2 &lt;= -10\",\n        \"-duration_sbo3 &lt;= -10\",\n        \"-duration_tcm_heating4 &lt;= -10\",\n        \"-duration_tcm_deltav5 &lt;= -10\",\n    ],\n    guarantees=[\n        \"output_u5 &lt;= 80\",\n        \"output_r5 &lt;= 80\",\n    ]\n)\n</pre> op_req_nav1=PolyhedralContract.from_string(     input_vars=[         \"u1_entry\",         \"r1_entry\",         \"duration_dsn1\",         \"duration_charging2\",         \"duration_sbo3\",         \"duration_tcm_heating4\",         \"duration_tcm_deltav5\",     ],     output_vars=[         \"output_u5\",         \"output_r5\",     ],     assumptions=[         \"u1_entry=30\",         \"r1_entry=100\",         \"-duration_dsn1 &lt;= -10\",         \"-duration_charging2 &lt;= -10\",         \"-duration_sbo3 &lt;= -10\",         \"-duration_tcm_heating4 &lt;= -10\",         \"-duration_tcm_deltav5 &lt;= -10\",     ],     guarantees=[         \"output_u5 &lt;= 80\",         \"output_r5 &lt;= 80\",     ] ) <p>The following specification defines an aggressive operational regime that requires the spacecraft to reduce navigation uncertainty to below 20% from an initial level of 70% and to reduce trajectory relative distance to below 70% starting from an inital level of 100%. As before,  we force a non-trivial schedule by requiring that the duration of each task be no less than 10 units.</p> In\u00a0[8]: Copied! <pre>op_req_nav2=PolyhedralContract.from_string(\n    input_vars=[\n        \"u1_entry\",\n        \"r1_entry\",\n        \"duration_dsn1\",\n        \"duration_charging2\",\n        \"duration_sbo3\",\n        \"duration_tcm_heating4\",\n        \"duration_tcm_deltav5\",\n    ],\n    output_vars=[\n        \"output_u5\",\n        \"output_r5\",\n    ],\n    assumptions=[\n        \"u1_entry=30\",\n        \"r1_entry=100\",\n        \"-duration_dsn1 &lt;= -10\",\n        \"-duration_charging2 &lt;= -10\",\n        \"-duration_sbo3 &lt;= -10\",\n        \"-duration_tcm_heating4 &lt;= -10\",\n        \"-duration_tcm_deltav5 &lt;= -10\",\n    ],\n    guarantees=[\n        \"output_u5 &lt;= 70\",\n        \"output_r5 &lt;= 80\",\n    ]\n)\n</pre> op_req_nav2=PolyhedralContract.from_string(     input_vars=[         \"u1_entry\",         \"r1_entry\",         \"duration_dsn1\",         \"duration_charging2\",         \"duration_sbo3\",         \"duration_tcm_heating4\",         \"duration_tcm_deltav5\",     ],     output_vars=[         \"output_u5\",         \"output_r5\",     ],     assumptions=[         \"u1_entry=30\",         \"r1_entry=100\",         \"-duration_dsn1 &lt;= -10\",         \"-duration_charging2 &lt;= -10\",         \"-duration_sbo3 &lt;= -10\",         \"-duration_tcm_heating4 &lt;= -10\",         \"-duration_tcm_deltav5 &lt;= -10\",     ],     guarantees=[         \"output_u5 &lt;= 70\",         \"output_r5 &lt;= 80\",     ] ) In\u00a0[9]: Copied! <pre>scenario_pwr = read_contracts_from_file(file_name=\"json/scenario_power.json\")[0][0]\nscenario_sci = read_contracts_from_file(file_name=\"json/scenario_science.json\")[0][0]\nscenario_nav = read_contracts_from_file(file_name=\"json/scenario_nav.json\")[0][0]\n</pre> scenario_pwr = read_contracts_from_file(file_name=\"json/scenario_power.json\")[0][0] scenario_sci = read_contracts_from_file(file_name=\"json/scenario_science.json\")[0][0] scenario_nav = read_contracts_from_file(file_name=\"json/scenario_nav.json\")[0][0] <p>Next, we explore algebraic combinations of scenarios and operational requirements with the confidence that the order in which we merge the requirements and scenarios is irrelevant. This flexibility gives an opportunity for collaborative design exploration where different teams could explore merging different combinations of viewpoints and requirement variants (e.g., conservative vs. aggressive).</p> In\u00a0[10]: Copied! <pre>all_scenarios = scenario_pwr.merge(scenario_sci).merge(scenario_nav)\nprint(f\"all_scenarios:\\n{all_scenarios}\")\n</pre> all_scenarios = scenario_pwr.merge(scenario_sci).merge(scenario_nav) print(f\"all_scenarios:\\n{all_scenarios}\") <pre>all_scenarios:\nInVars: [soc1_entry, duration_dsn1, duration_charging2, duration_sbo3, duration_tcm_heating4, duration_tcm_deltav5, d1_entry, c1_entry, u1_entry, r1_entry]\nOutVars:[output_soc1, output_soc2, output_soc4, output_soc3, output_soc5, output_d1, output_c1, output_d2, output_c2, output_d4, output_c4, output_d3, output_c3, output_d5, output_c5, output_u1, output_r1, output_u2, output_r2, output_u4, output_r4, output_u3, output_r3, output_u5, output_r5]\nA: [\n  -duration_tcm_deltav5 &lt;= 0.0\n  -duration_tcm_heating4 &lt;= 0.0\n  -duration_sbo3 &lt;= 0.0\n  -duration_charging2 &lt;= 0.0\n  -duration_dsn1 &lt;= 0.0\n  4.2 duration_dsn1 - soc1_entry &lt;= 0.0\n  d1_entry &lt;= 100.0\n  -d1_entry &lt;= 0.0\n  -u1_entry &lt;= 0.0\n  u1_entry &lt;= 100.0\n  -r1_entry &lt;= 0.0\n  r1_entry &lt;= 100.0\n]\nG: [\n  -4.2 duration_dsn1 - output_soc1 + soc1_entry &lt;= 0.0\n  3.8 duration_dsn1 + output_soc1 - soc1_entry &lt;= 0.0\n  -4.0 duration_charging2 - output_soc1 + output_soc2 &lt;= 0.0\n  3.0 duration_charging2 + output_soc1 - output_soc2 &lt;= 0.0\n  output_soc2 &lt;= 100.0\n  -1.4 duration_sbo3 + output_soc2 - output_soc3 &lt;= 0.0\n  duration_sbo3 - output_soc2 + output_soc3 &lt;= 0.0\n  -0.8 duration_tcm_heating4 + output_soc3 - output_soc4 &lt;= 0.0\n  0.7 duration_tcm_heating4 - output_soc3 + output_soc4 &lt;= 0.0\n  -0.6 duration_tcm_deltav5 + output_soc4 - output_soc5 &lt;= 0.0\n  0.5 duration_tcm_deltav5 - output_soc4 + output_soc5 &lt;= 0.0\n  d1_entry - 5.5 duration_dsn1 - output_d1 &lt;= 0.0\n  -d1_entry + 5.2 duration_dsn1 + output_d1 &lt;= 0.0\n  -output_d1 &lt;= 0.0\n  -c1_entry + output_c1 = 0.0\n  -output_d1 + output_d2 = 0.0\n  -output_c1 + output_c2 = 0.0\n  -4.0 duration_sbo3 - output_d2 + output_d3 &lt;= 0.0\n  3.0 duration_sbo3 + output_d2 - output_d3 &lt;= 0.0\n  -4.0 duration_sbo3 - output_c2 + output_c3 &lt;= 0.0\n  3.0 duration_sbo3 + output_c2 - output_c3 &lt;= 0.0\n  -output_d3 + output_d4 = 0.0\n  -output_c3 + output_c4 = 0.0\n  -output_d4 + output_d5 = 0.0\n  -output_c4 + output_c5 = 0.0\n  output_u1 - u1_entry &lt;= 2.0\n  -output_u1 + u1_entry &lt;= -1.0\n  output_r1 - r1_entry = 0.0\n  output_u2 &lt;= 100.0\n  -output_u1 + output_u2 &lt;= 2.0\n  output_u1 - output_u2 &lt;= -1.0\n  -output_r1 + output_r2 = 0.0\n  -0.6 duration_sbo3 + output_u2 - output_u3 &lt;= 0.0\n  0.4 duration_sbo3 - output_u2 + output_u3 &lt;= 0.0\n  -output_u3 &lt;= 0.0\n  -output_r2 + output_r3 = 0.0\n  -output_u3 + output_u4 = 0.0\n  -output_r3 + output_r4 = 0.0\n  output_u5 &lt;= 100.0\n  -1.6 duration_tcm_deltav5 - output_u4 + output_u5 &lt;= 0.0\n  1.5 duration_tcm_deltav5 + output_u4 - output_u5 &lt;= 0.0\n  -0.5 duration_tcm_deltav5 + output_r4 - output_r5 &lt;= 0.0\n  0.4 duration_tcm_deltav5 - output_r4 + output_r5 &lt;= 0.0\n  -output_r5 &lt;= 0.0\n]\n</pre> <p>Next, we check whether there exists an admissible set of scenario schedules for all conservative operational requirements.</p> In\u00a0[11]: Copied! <pre>all_conservative_op_reqs = all_scenarios.merge(op_req_pwr1).merge(op_req_sci1).merge(op_req_nav1)\nprint(f\"all_conservative_op_reqs=\\n{all_conservative_op_reqs}\")\n</pre> all_conservative_op_reqs = all_scenarios.merge(op_req_pwr1).merge(op_req_sci1).merge(op_req_nav1) print(f\"all_conservative_op_reqs=\\n{all_conservative_op_reqs}\") <pre>all_conservative_op_reqs=\nInVars: [soc1_entry, duration_dsn1, duration_charging2, duration_sbo3, duration_tcm_heating4, duration_tcm_deltav5, d1_entry, c1_entry, u1_entry, r1_entry]\nOutVars:[output_soc1, output_soc2, output_soc4, output_soc3, output_soc5, output_d1, output_c1, output_d2, output_c2, output_d4, output_c4, output_d3, output_c3, output_d5, output_c5, output_u1, output_r1, output_u2, output_r2, output_u4, output_r4, output_u3, output_r3, output_u5, output_r5]\nA: [\n  -duration_tcm_deltav5 &lt;= 0.0\n  -duration_tcm_heating4 &lt;= 0.0\n  -duration_sbo3 &lt;= 0.0\n  -duration_charging2 &lt;= 0.0\n  -duration_dsn1 &lt;= 0.0\n  4.2 duration_dsn1 - soc1_entry &lt;= 0.0\n  d1_entry = 100.0\n  -d1_entry &lt;= 0.0\n  -u1_entry &lt;= 0.0\n  u1_entry &lt;= 100.0\n  -r1_entry &lt;= 0.0\n  r1_entry = 100.0\n  soc1_entry = 80.0\n  -duration_dsn1 &lt;= -10.0\n  -duration_charging2 &lt;= -10.0\n  -duration_sbo3 &lt;= -10.0\n  -duration_tcm_heating4 &lt;= -10.0\n  -duration_tcm_deltav5 &lt;= -10.0\n  c1_entry = 0.0\n  u1_entry = 30.0\n]\nG: [\n  3.8 duration_dsn1 + output_soc1 - soc1_entry &lt;= 0.0\n  -4.0 duration_charging2 - output_soc1 + output_soc2 &lt;= 0.0\n  3.0 duration_charging2 + output_soc1 - output_soc2 &lt;= 0.0\n  output_soc2 &lt;= 100.0\n  -1.4 duration_sbo3 + output_soc2 - output_soc3 &lt;= 0.0\n  duration_sbo3 - output_soc2 + output_soc3 &lt;= 0.0\n  -0.8 duration_tcm_heating4 + output_soc3 - output_soc4 &lt;= 0.0\n  0.7 duration_tcm_heating4 - output_soc3 + output_soc4 &lt;= 0.0\n  -0.6 duration_tcm_deltav5 + output_soc4 - output_soc5 &lt;= 0.0\n  0.5 duration_tcm_deltav5 - output_soc4 + output_soc5 &lt;= 0.0\n  d1_entry - 5.5 duration_dsn1 - output_d1 &lt;= 0.0\n  -d1_entry + 5.2 duration_dsn1 + output_d1 &lt;= 0.0\n  -c1_entry + output_c1 = 0.0\n  -output_d1 + output_d2 = 0.0\n  -output_c1 + output_c2 = 0.0\n  -4.0 duration_sbo3 - output_d2 + output_d3 &lt;= 0.0\n  3.0 duration_sbo3 + output_d2 - output_d3 &lt;= 0.0\n  -4.0 duration_sbo3 - output_c2 + output_c3 &lt;= 0.0\n  3.0 duration_sbo3 + output_c2 - output_c3 &lt;= 0.0\n  -output_d3 + output_d4 = 0.0\n  -output_c3 + output_c4 = 0.0\n  -output_d4 + output_d5 = 0.0\n  -output_c4 + output_c5 = 0.0\n  output_u1 - u1_entry &lt;= 2.0\n  -output_u1 + u1_entry &lt;= -1.0\n  output_r1 - r1_entry = 0.0\n  -output_u1 + output_u2 &lt;= 2.0\n  output_u1 - output_u2 &lt;= -1.0\n  -output_r1 + output_r2 = 0.0\n  -0.6 duration_sbo3 + output_u2 - output_u3 &lt;= 0.0\n  0.4 duration_sbo3 - output_u2 + output_u3 &lt;= 0.0\n  -output_r2 + output_r3 = 0.0\n  -output_u3 + output_u4 = 0.0\n  -output_r3 + output_r4 = 0.0\n  -1.6 duration_tcm_deltav5 - output_u4 + output_u5 &lt;= 0.0\n  1.5 duration_tcm_deltav5 + output_u4 - output_u5 &lt;= 0.0\n  -0.5 duration_tcm_deltav5 + output_r4 - output_r5 &lt;= 0.0\n  -output_soc1 &lt;= -40.0\n  -output_soc5 &lt;= -40.0\n  output_u5 &lt;= 80.0\n  output_r5 &lt;= 80.0\n]\n</pre> In\u00a0[12]: Copied! <pre>all_aggressive_op_reqs = all_scenarios.merge(op_req_pwr2).merge(op_req_sci2).merge(op_req_nav2)\nprint(f\"all_aggressive_op_reqs=\\n{all_aggressive_op_reqs}\")\n</pre> all_aggressive_op_reqs = all_scenarios.merge(op_req_pwr2).merge(op_req_sci2).merge(op_req_nav2) print(f\"all_aggressive_op_reqs=\\n{all_aggressive_op_reqs}\") <pre>all_aggressive_op_reqs=\nInVars: [soc1_entry, duration_dsn1, duration_charging2, duration_sbo3, duration_tcm_heating4, duration_tcm_deltav5, d1_entry, c1_entry, u1_entry, r1_entry]\nOutVars:[output_soc1, output_soc2, output_soc4, output_soc3, output_soc5, output_d1, output_c1, output_d2, output_c2, output_d4, output_c4, output_d3, output_c3, output_d5, output_c5, output_u1, output_r1, output_u2, output_r2, output_u4, output_r4, output_u3, output_r3, output_u5, output_r5]\nA: [\n  -duration_tcm_deltav5 &lt;= 0.0\n  -duration_tcm_heating4 &lt;= 0.0\n  -duration_sbo3 &lt;= 0.0\n  -duration_charging2 &lt;= 0.0\n  -duration_dsn1 &lt;= 0.0\n  4.2 duration_dsn1 - soc1_entry &lt;= 0.0\n  d1_entry = 100.0\n  -d1_entry &lt;= 0.0\n  -u1_entry &lt;= 0.0\n  u1_entry &lt;= 100.0\n  -r1_entry &lt;= 0.0\n  r1_entry = 100.0\n  soc1_entry = 80.0\n  -duration_dsn1 &lt;= -10.0\n  -duration_charging2 &lt;= -10.0\n  -duration_sbo3 &lt;= -10.0\n  -duration_tcm_heating4 &lt;= -10.0\n  -duration_tcm_deltav5 &lt;= -10.0\n  c1_entry = 0.0\n  u1_entry = 30.0\n]\nG: [\n  -4.2 duration_dsn1 - output_soc1 + soc1_entry &lt;= 0.0\n  3.8 duration_dsn1 + output_soc1 - soc1_entry &lt;= 0.0\n  -4.0 duration_charging2 - output_soc1 + output_soc2 &lt;= 0.0\n  3.0 duration_charging2 + output_soc1 - output_soc2 &lt;= 0.0\n  output_soc2 &lt;= 100.0\n  -1.4 duration_sbo3 + output_soc2 - output_soc3 &lt;= 0.0\n  duration_sbo3 - output_soc2 + output_soc3 &lt;= 0.0\n  -0.8 duration_tcm_heating4 + output_soc3 - output_soc4 &lt;= 0.0\n  0.7 duration_tcm_heating4 - output_soc3 + output_soc4 &lt;= 0.0\n  -0.6 duration_tcm_deltav5 + output_soc4 - output_soc5 &lt;= 0.0\n  0.5 duration_tcm_deltav5 - output_soc4 + output_soc5 &lt;= 0.0\n  d1_entry - 5.5 duration_dsn1 - output_d1 &lt;= 0.0\n  -d1_entry + 5.2 duration_dsn1 + output_d1 &lt;= 0.0\n  -output_d1 &lt;= 0.0\n  -c1_entry + output_c1 = 0.0\n  -output_d1 + output_d2 = 0.0\n  -output_c1 + output_c2 = 0.0\n  -4.0 duration_sbo3 - output_d2 + output_d3 &lt;= 0.0\n  3.0 duration_sbo3 + output_d2 - output_d3 &lt;= 0.0\n  -4.0 duration_sbo3 - output_c2 + output_c3 &lt;= 0.0\n  3.0 duration_sbo3 + output_c2 - output_c3 &lt;= 0.0\n  -output_d3 + output_d4 = 0.0\n  -output_c3 + output_c4 = 0.0\n  -output_d4 + output_d5 = 0.0\n  -output_c4 + output_c5 = 0.0\n  output_u1 - u1_entry &lt;= 2.0\n  -output_u1 + u1_entry &lt;= -1.0\n  output_r1 - r1_entry = 0.0\n  -output_u1 + output_u2 &lt;= 2.0\n  output_u1 - output_u2 &lt;= -1.0\n  -output_r1 + output_r2 = 0.0\n  -0.6 duration_sbo3 + output_u2 - output_u3 &lt;= 0.0\n  0.4 duration_sbo3 - output_u2 + output_u3 &lt;= 0.0\n  -output_u3 &lt;= 0.0\n  -output_r2 + output_r3 = 0.0\n  -output_u3 + output_u4 = 0.0\n  -output_r3 + output_r4 = 0.0\n  -1.6 duration_tcm_deltav5 - output_u4 + output_u5 &lt;= 0.0\n  1.5 duration_tcm_deltav5 + output_u4 - output_u5 &lt;= 0.0\n  -0.5 duration_tcm_deltav5 + output_r4 - output_r5 &lt;= 0.0\n  -output_soc1 &lt;= -10.0\n  -output_soc5 &lt;= -10.0\n  output_u5 &lt;= 70.0\n  output_r5 &lt;= 80.0\n]\n</pre> In\u00a0[13]: Copied! <pre>def show_bounds(c: PolyhedralContract):\n    print(\"Task duration bounds:\")\n    print(f\"    step1_dsn: \"+str(c.get_variable_bounds(\"duration_dsn1\")))\n    print(f\"    step2_charging: \"+str(c.get_variable_bounds(\"duration_charging2\")))\n    print(f\"    step3_sbo: \"+str(c.get_variable_bounds(\"duration_sbo3\")))\n    print(f\"    step4_tcm_heating: \"+str(c.get_variable_bounds(\"duration_tcm_heating4\")))\n    print(f\"    step5_tcm_deltav: \"+str(c.get_variable_bounds(\"duration_tcm_deltav5\")))\n\n    print(\"Power bounds:\")\n    print(f\"    soc5: \"+str(c.get_variable_bounds(\"output_soc5\")))\n    print(\"Science bounds:\")\n    print(f\"    d5: \"+str(c.get_variable_bounds(\"output_d5\")))\n    print(f\"    c5: \"+str(c.get_variable_bounds(\"output_c5\")))\n    print(\"Navigation bounds:\")\n    print(f\"    u5: \"+str(c.get_variable_bounds(\"output_u5\")))\n    print(f\"    r5: \"+str(c.get_variable_bounds(\"output_r5\")))\n\n    max_soc = c.optimize(\"0.2 output_soc1 + 0.2 output_soc2 + 0.2 output_soc3 + 0.2 output_soc4 + 0.2 output_soc5\", maximize=True)\n    min_soc = c.optimize(\"0.2 output_soc1 + 0.2 output_soc2 + 0.2 output_soc3 + 0.2 output_soc4 + 0.2 output_soc5\", maximize=False)\n    print(f\"[min, max] average SOC=[{min_soc}, {max_soc}]\")\n</pre> def show_bounds(c: PolyhedralContract):     print(\"Task duration bounds:\")     print(f\"    step1_dsn: \"+str(c.get_variable_bounds(\"duration_dsn1\")))     print(f\"    step2_charging: \"+str(c.get_variable_bounds(\"duration_charging2\")))     print(f\"    step3_sbo: \"+str(c.get_variable_bounds(\"duration_sbo3\")))     print(f\"    step4_tcm_heating: \"+str(c.get_variable_bounds(\"duration_tcm_heating4\")))     print(f\"    step5_tcm_deltav: \"+str(c.get_variable_bounds(\"duration_tcm_deltav5\")))      print(\"Power bounds:\")     print(f\"    soc5: \"+str(c.get_variable_bounds(\"output_soc5\")))     print(\"Science bounds:\")     print(f\"    d5: \"+str(c.get_variable_bounds(\"output_d5\")))     print(f\"    c5: \"+str(c.get_variable_bounds(\"output_c5\")))     print(\"Navigation bounds:\")     print(f\"    u5: \"+str(c.get_variable_bounds(\"output_u5\")))     print(f\"    r5: \"+str(c.get_variable_bounds(\"output_r5\")))      max_soc = c.optimize(\"0.2 output_soc1 + 0.2 output_soc2 + 0.2 output_soc3 + 0.2 output_soc4 + 0.2 output_soc5\", maximize=True)     min_soc = c.optimize(\"0.2 output_soc1 + 0.2 output_soc2 + 0.2 output_soc3 + 0.2 output_soc4 + 0.2 output_soc5\", maximize=False)     print(f\"[min, max] average SOC=[{min_soc}, {max_soc}]\") In\u00a0[14]: Copied! <pre>show_bounds(all_conservative_op_reqs)\n</pre> show_bounds(all_conservative_op_reqs) <pre>Task duration bounds:\n    step1_dsn: (10.0, 10.526315789473685)\n    step2_charging: (11.25, 20.0)\n    step3_sbo: (20.0, 33.0)\n    step4_tcm_heating: (10.0, 28.571428571428573)\n    step5_tcm_deltav: (40.0, 44.333333333333336)\nPower bounds:\n    soc5: (40.0, 53.0)\nScience bounds:\n    d5: (102.10526315789474, 180.0)\n    c5: (60.0, 132.0)\nNavigation bounds:\n    u5: (72.2, 80.0)\n    r5: (77.83333333333333, 80.0)\n[min, max] average SOC=[58.800000000000004, 69.6]\n</pre> In\u00a0[15]: Copied! <pre>show_bounds(all_aggressive_op_reqs)\n</pre> show_bounds(all_aggressive_op_reqs) <pre>Task duration bounds:\n    step1_dsn: (10.0, 18.42105263157895)\n    step2_charging: (10.0, 30.0)\n    step3_sbo: (36.66666666666667, 63.0)\n    step4_tcm_heating: (10.0, 47.61904761904761)\n    step5_tcm_deltav: (40.0, 46.666666666666664)\nPower bounds:\n    soc5: (10.0, 36.33333333333333)\nScience bounds:\n    d5: (110.00000000000001, 300.0)\n    c5: (110.00000000000001, 252.0)\nNavigation bounds:\n    u5: (60.0, 70.0)\n    r5: (76.66666666666667, 80.0)\n[min, max] average SOC=[32.13333333333333, 59.599999999999994]\n</pre> In\u00a0[16]: Copied! <pre>display.Image(b64decode(pacti_interactive_scenario_plot_concept))\n</pre> display.Image(b64decode(pacti_interactive_scenario_plot_concept)) Out[16]:"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_3viewpoints/#scenario-design-analysis-across-viewpoints","title":"Scenario design analysis across viewpoints\u00b6","text":"<p>Operating a space mission system requires allocating resources among tasks in order to satisfy operational requirements across multiple domain-specific viewpoints. For this case study, we developed scenarios in 4 viewpoints as summarized qualitative in the table below:</p> Viewpoint State CHARGING DSN SBO TCM Power <code>soc</code> + - - - Science <code>d</code> 0 - + 0 <code>c</code> 0 0 + 0 Navigation <code>u</code> + + - + <code>r</code> 0 0 0 + Thermal <code>temp</code> - - - + <p>The specification of the thermal scenario helped us realize that there are no significant thermal interactions among the scenario tasks that would constraint possible schedules. Therefore, it makes sense to omit the thermal viewpoint for the scenario analysis, leaving power, science &amp; communication, and navigation as the significant viewpoints to use for optimizing the scenario design.</p> <p>Now, we need to gather operational requirements for each of the three viewpoints.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_3viewpoints/#operational-requirements-by-viewpoint","title":"Operational requirements by viewpoint\u00b6","text":"<p>Here, we adopt a simple methodology for exploring admissible scenario schedules as sets of possible solutions to the duration of each task. The idea is to elicit operational requirements as constraints on the entry/exit scenario state variables. We use a forcing technique to ensure that admissible solutions correspond to schedules where each task has a positive scheduled duration.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_3viewpoints/#power","title":"Power\u00b6","text":"<p>The following specification defines a conservative operational regime that requires the battery state of charge to be at minimum 40% based on an initial state of charge of 80%; we force a non-trivial schedule by requiring that the duration of each task be no less than 10 units.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_3viewpoints/#science-communication","title":"Science &amp; Communication\u00b6","text":"<p>It is useful to calculate how much science the avionics capability can deliver. For this, the following operational requirement specifies the initial conditions only. As before,  we force a non-trivial schedule by requiring that the duration of each task be no less than 10 units.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_3viewpoints/#navigation","title":"Navigation\u00b6","text":"<p>The following specification defines a conservative operational regime that requires the spacecraft to reduce navigation uncertainty to below 40% from an initial level of 70% and to reduce trajectory relative distance to below 80% starting from an inital level of 100%. As before,  we force a non-trivial schedule by requiring that the duration of each task be no less than 10 units.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_3viewpoints/#exploring-combinations-of-operational-scenario-requirements","title":"Exploring combinations of operational scenario requirements\u00b6","text":"<p>So far, we have defined conservative and aggressive operational requirements for each viewpoint. We can exploit the commutativity property of Pacti's contract merge operation to explore combinations of these requirements.</p> <p>The first step involves reading the viewpoint-specific scenarios from their respective viewpoint-specific scenario case studies as shown below:</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_navigation/","title":"Navigation Viewpoint","text":"In\u00a0[1]: Copied! <pre>%matplotlib widget\n\n#from IPython import display\nfrom base64 import b64decode\nfrom pacti import write_contracts_to_file\nfrom pacti.terms.polyhedra import *\nfrom pacti.iocontract import IoContract, Var\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport os\nimport numpy as np\nfrom matplotlib import patches\nimport pdb\nfrom matplotlib.collections import PatchCollection\nfrom contract_utils import *\n</pre> %matplotlib widget  #from IPython import display from base64 import b64decode from pacti import write_contracts_to_file from pacti.terms.polyhedra import * from pacti.iocontract import IoContract, Var from PIL import Image import matplotlib.pyplot as plt import os import numpy as np from matplotlib import patches import pdb from matplotlib.collections import PatchCollection from contract_utils import * In\u00a0[2]: Copied! <pre>def uncertainty_generating_nav(s: int, noise: Tuple[float, float]) -&gt; PolyhedralContract:\n  spec = PolyhedralContract.from_string(\n    input_vars = [\n      f\"u{s}_entry\",    # initial trajectory estimation uncertainty\n      f\"r{s}_entry\",    # initial relative trajectory distance\n    ],\n    output_vars = [\n      f\"u{s}_exit\",     # final trajectory estimation uncertainty\n      f\"r{s}_exit\",     # final relative trajectory distance\n    ],\n    assumptions = [\n      # 0 &lt;= u{s}_entry &lt;= 100\n      f\"-u{s}_entry &lt;= 0\",\n      f\" u{s}_entry &lt;= 100\",\n\n      # 0 &lt;= r{s}_entry &lt;= 100\n      f\"-r{s}_entry &lt;= 0\",\n      f\" r{s}_entry &lt;= 100\",\n    ],\n    guarantees = [\n      # upper bound u{s}_exit &lt;= 100\n      f\"u{s}_exit &lt;= 100\",\n      \n      # noise(min) &lt;= u{exit} - u{entry} &lt;= noise(max)\n      f\" u{s}_exit - u{s}_entry &lt;=  {noise[1]}\",\n      f\"-u{s}_exit + u{s}_entry &lt;= -{noise[0]}\",\n\n      # no change to relative trajectory distance\n      f\"r{s}_exit - r{s}_entry = 0\",\n    ])\n  return spec\n</pre> def uncertainty_generating_nav(s: int, noise: Tuple[float, float]) -&gt; PolyhedralContract:   spec = PolyhedralContract.from_string(     input_vars = [       f\"u{s}_entry\",    # initial trajectory estimation uncertainty       f\"r{s}_entry\",    # initial relative trajectory distance     ],     output_vars = [       f\"u{s}_exit\",     # final trajectory estimation uncertainty       f\"r{s}_exit\",     # final relative trajectory distance     ],     assumptions = [       # 0 &lt;= u{s}_entry &lt;= 100       f\"-u{s}_entry &lt;= 0\",       f\" u{s}_entry &lt;= 100\",        # 0 &lt;= r{s}_entry &lt;= 100       f\"-r{s}_entry &lt;= 0\",       f\" r{s}_entry &lt;= 100\",     ],     guarantees = [       # upper bound u{s}_exit &lt;= 100       f\"u{s}_exit &lt;= 100\",              # noise(min) &lt;= u{exit} - u{entry} &lt;= noise(max)       f\" u{s}_exit - u{s}_entry &lt;=  {noise[1]}\",       f\"-u{s}_exit + u{s}_entry &lt;= -{noise[0]}\",        # no change to relative trajectory distance       f\"r{s}_exit - r{s}_entry = 0\",     ])   return spec In\u00a0[3]: Copied! <pre>charging1_nav = uncertainty_generating_nav(s=2, noise=(1.0, 2.0))\nprint(f\"Contract charging1_nav:\\n\\n{charging1_nav}\")\n</pre> charging1_nav = uncertainty_generating_nav(s=2, noise=(1.0, 2.0)) print(f\"Contract charging1_nav:\\n\\n{charging1_nav}\") <pre>Contract charging1_nav:\n\nInVars: [u2_entry, r2_entry]\nOutVars:[u2_exit, r2_exit]\nA: [\n  -u2_entry &lt;= 0\n  u2_entry &lt;= 100\n  -r2_entry &lt;= 0\n  r2_entry &lt;= 100\n]\nG: [\n  u2_exit &lt;= 100\n  -u2_entry + u2_exit &lt;= 2\n  u2_entry - u2_exit &lt;= -1\n  -r2_entry + r2_exit = 0\n]\n</pre> In\u00a0[4]: Copied! <pre>dsn1_nav = uncertainty_generating_nav(s=1, noise=(1.0, 2.0))\nprint(f\"Contract dsn1_nav:\\n\\n{dsn1_nav}\")\n</pre> dsn1_nav = uncertainty_generating_nav(s=1, noise=(1.0, 2.0)) print(f\"Contract dsn1_nav:\\n\\n{dsn1_nav}\") <pre>Contract dsn1_nav:\n\nInVars: [u1_entry, r1_entry]\nOutVars:[u1_exit, r1_exit]\nA: [\n  -u1_entry &lt;= 0\n  u1_entry &lt;= 100\n  -r1_entry &lt;= 0\n  r1_entry &lt;= 100\n]\nG: [\n  u1_exit &lt;= 100\n  -u1_entry + u1_exit &lt;= 2\n  u1_entry - u1_exit &lt;= -1\n  -r1_entry + r1_exit = 0\n]\n</pre> In\u00a0[5]: Copied! <pre># Parameters:\n# - s: start index of the timeline variables\n# - improvement: rate of trajectory estimation uncertainty improvement during the task instance\ndef SBO_nav_uncertainty(s: int, improvement: Tuple[float, float]) -&gt; PolyhedralContract:\n  spec = PolyhedralContract.from_string(\n    input_vars = [\n      f\"u{s}_entry\",      # initial trajectory uncertainty\n      f\"duration_sbo{s}\", # knob variable for SBO duration\n    ],\n    output_vars = [\n      f\"u{s}_exit\",       # final trajectory uncertainty\n    ],\n    assumptions = [\n      # Task has a positive scheduled duration\n      f\"-duration_sbo{s} &lt;= 0\",\n\n      # Upper-bound on the trajectory estimation uncertainty\n      f\"u{s}_entry &lt;= 100\",\n    ],\n    guarantees = [\n      # upper bound u{s}_exit &lt;= 100\n      f\"u{s}_exit &lt;= 100\",\n      \n      # duration*improvement(min) &lt;= u{entry} - u{exit} &lt;= duration*improvement(max)\n      f\" u{s}_entry - u{s}_exit - {improvement[1]}*duration_sbo{s} &lt;= 0\",\n      f\"-u{s}_entry + u{s}_exit + {improvement[0]}*duration_sbo{s} &lt;= 0\",\n\n      # Lower-bound on the trajectory estimation uncertainty\n      f\"-u{s}_exit &lt;= 0\",\n    ])\n  return spec\n\nsbo1_nav_uncertainty = SBO_nav_uncertainty(s=3, improvement=(0.4, 0.6))\nprint(f\"Contract sbo1_nav:\\n\\n{sbo1_nav_uncertainty}\")\n\n_ = plot_guarantees(contract=sbo1_nav_uncertainty,\n                x_var=Var(\"duration_sbo3\"),\n                y_var=Var(\"u3_exit\"),\n                var_values={\n                  Var(\"u3_entry\"):50,\n                },\n                x_lims=(0,100),\n                y_lims=(0,100))\n</pre> # Parameters: # - s: start index of the timeline variables # - improvement: rate of trajectory estimation uncertainty improvement during the task instance def SBO_nav_uncertainty(s: int, improvement: Tuple[float, float]) -&gt; PolyhedralContract:   spec = PolyhedralContract.from_string(     input_vars = [       f\"u{s}_entry\",      # initial trajectory uncertainty       f\"duration_sbo{s}\", # knob variable for SBO duration     ],     output_vars = [       f\"u{s}_exit\",       # final trajectory uncertainty     ],     assumptions = [       # Task has a positive scheduled duration       f\"-duration_sbo{s} &lt;= 0\",        # Upper-bound on the trajectory estimation uncertainty       f\"u{s}_entry &lt;= 100\",     ],     guarantees = [       # upper bound u{s}_exit &lt;= 100       f\"u{s}_exit &lt;= 100\",              # duration*improvement(min) &lt;= u{entry} - u{exit} &lt;= duration*improvement(max)       f\" u{s}_entry - u{s}_exit - {improvement[1]}*duration_sbo{s} &lt;= 0\",       f\"-u{s}_entry + u{s}_exit + {improvement[0]}*duration_sbo{s} &lt;= 0\",        # Lower-bound on the trajectory estimation uncertainty       f\"-u{s}_exit &lt;= 0\",     ])   return spec  sbo1_nav_uncertainty = SBO_nav_uncertainty(s=3, improvement=(0.4, 0.6)) print(f\"Contract sbo1_nav:\\n\\n{sbo1_nav_uncertainty}\")  _ = plot_guarantees(contract=sbo1_nav_uncertainty,                 x_var=Var(\"duration_sbo3\"),                 y_var=Var(\"u3_exit\"),                 var_values={                   Var(\"u3_entry\"):50,                 },                 x_lims=(0,100),                 y_lims=(0,100)) <pre>Contract sbo1_nav:\n\nInVars: [u3_entry, duration_sbo3]\nOutVars:[u3_exit]\nA: [\n  -duration_sbo3 &lt;= 0\n  u3_entry &lt;= 100\n]\nG: [\n  -0.6 duration_sbo3 + u3_entry - u3_exit &lt;= 0\n  0.4 duration_sbo3 - u3_entry + u3_exit &lt;= 0\n  -u3_exit &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[6]: Copied! <pre>sbo1_nav_progress = nochange_contract(s=3, name=\"r\")\nprint(f\"sbo_nav_progress:\\n{sbo1_nav_progress}\")\n</pre> sbo1_nav_progress = nochange_contract(s=3, name=\"r\") print(f\"sbo_nav_progress:\\n{sbo1_nav_progress}\") <pre>sbo_nav_progress:\nInVars: [r3_entry]\nOutVars:[r3_exit]\nA: [\n  -r3_entry &lt;= 0\n]\nG: [\n  -r3_entry + r3_exit = 0\n]\n</pre> In\u00a0[7]: Copied! <pre>sbo1_nav = sbo1_nav_uncertainty.merge(sbo1_nav_progress)\nprint(f\"sbo1_nav:\\n{sbo1_nav}\")\n</pre> sbo1_nav = sbo1_nav_uncertainty.merge(sbo1_nav_progress) print(f\"sbo1_nav:\\n{sbo1_nav}\") <pre>sbo1_nav:\nInVars: [u3_entry, duration_sbo3, r3_entry]\nOutVars:[u3_exit, r3_exit]\nA: [\n  -duration_sbo3 &lt;= 0\n  u3_entry &lt;= 100\n  -r3_entry &lt;= 0\n]\nG: [\n  -0.6 duration_sbo3 + u3_entry - u3_exit &lt;= 0\n  0.4 duration_sbo3 - u3_entry + u3_exit &lt;= 0\n  -u3_exit &lt;= 0\n  -r3_entry + r3_exit = 0\n]\n</pre> In\u00a0[8]: Copied! <pre>tcm1_nav_heating = nochange_contract(s=4, name=\"u\").merge(nochange_contract(s=4, name=\"r\"))\nprint(f\"sbo_nav_progress:\\n{tcm1_nav_heating}\")\n</pre> tcm1_nav_heating = nochange_contract(s=4, name=\"u\").merge(nochange_contract(s=4, name=\"r\")) print(f\"sbo_nav_progress:\\n{tcm1_nav_heating}\") <pre>sbo_nav_progress:\nInVars: [u4_entry, r4_entry]\nOutVars:[u4_exit, r4_exit]\nA: [\n  -u4_entry &lt;= 0\n  -r4_entry &lt;= 0\n]\nG: [\n  -u4_entry + u4_exit = 0\n  -r4_entry + r4_exit = 0\n]\n</pre> In\u00a0[9]: Copied! <pre>def TCM_navigation_deltav_uncertainty(s: int, noise: Tuple[float, float]) -&gt; PolyhedralContract:\n  spec = PolyhedralContract.from_string(\n    input_vars = [\n      f\"u{s}_entry\",              # initial trajectory estimation uncertainty\n      f\"duration_tcm_deltav{s}\",  # knob variable for TCM deltav duration\n\n    ],\n    output_vars = [\n      f\"u{s}_exit\",               # final trajectory estimation uncertainty\n    ],\n    assumptions = [\n      # Task has a positive scheduled duration\n      f\"-duration_tcm_deltav{s} &lt;= 0\",\n\n      # 0 &lt;= u{s}_entry &lt;= 100\n      f\"-u{s}_entry &lt;= 0\",\n      f\" u{s}_entry &lt;= 100\",\n    ],\n    guarantees = [\n      # upper bound u{s}_exit &lt;= 100\n      f\"u{s}_exit &lt;= 100\",\n      \n      # noise(min) &lt;= u{exit} - u{entry} &lt;= noise(max)\n      f\" u{s}_exit - u{s}_entry - {noise[1]} duration_tcm_deltav{s} &lt;= 0\",\n      f\"-u{s}_exit + u{s}_entry + {noise[0]} duration_tcm_deltav{s} &lt;= 0\",\n    ])\n  return spec\n\ntcm1_nav_deltav_uncertainty = TCM_navigation_deltav_uncertainty(s=5, noise=(1.5, 1.6))\nprint(f\"Contract tcm1_nav_deltav_uncertainty:\\n\\n{tcm1_nav_deltav_uncertainty}\")\n\n_ = plot_guarantees(contract=tcm1_nav_deltav_uncertainty,\n                x_var=Var(\"duration_tcm_deltav5\"),\n                y_var=Var(\"u5_exit\"),\n                var_values={\n                  Var(\"u5_entry\"):20,\n                },\n                x_lims=(0,100),\n                y_lims=(0,100))\n</pre> def TCM_navigation_deltav_uncertainty(s: int, noise: Tuple[float, float]) -&gt; PolyhedralContract:   spec = PolyhedralContract.from_string(     input_vars = [       f\"u{s}_entry\",              # initial trajectory estimation uncertainty       f\"duration_tcm_deltav{s}\",  # knob variable for TCM deltav duration      ],     output_vars = [       f\"u{s}_exit\",               # final trajectory estimation uncertainty     ],     assumptions = [       # Task has a positive scheduled duration       f\"-duration_tcm_deltav{s} &lt;= 0\",        # 0 &lt;= u{s}_entry &lt;= 100       f\"-u{s}_entry &lt;= 0\",       f\" u{s}_entry &lt;= 100\",     ],     guarantees = [       # upper bound u{s}_exit &lt;= 100       f\"u{s}_exit &lt;= 100\",              # noise(min) &lt;= u{exit} - u{entry} &lt;= noise(max)       f\" u{s}_exit - u{s}_entry - {noise[1]} duration_tcm_deltav{s} &lt;= 0\",       f\"-u{s}_exit + u{s}_entry + {noise[0]} duration_tcm_deltav{s} &lt;= 0\",     ])   return spec  tcm1_nav_deltav_uncertainty = TCM_navigation_deltav_uncertainty(s=5, noise=(1.5, 1.6)) print(f\"Contract tcm1_nav_deltav_uncertainty:\\n\\n{tcm1_nav_deltav_uncertainty}\")  _ = plot_guarantees(contract=tcm1_nav_deltav_uncertainty,                 x_var=Var(\"duration_tcm_deltav5\"),                 y_var=Var(\"u5_exit\"),                 var_values={                   Var(\"u5_entry\"):20,                 },                 x_lims=(0,100),                 y_lims=(0,100)) <pre>Contract tcm1_nav_deltav_uncertainty:\n\nInVars: [u5_entry, duration_tcm_deltav5]\nOutVars:[u5_exit]\nA: [\n  -duration_tcm_deltav5 &lt;= 0\n  -u5_entry &lt;= 0\n  u5_entry &lt;= 100\n]\nG: [\n  u5_exit &lt;= 100\n  -1.6 duration_tcm_deltav5 - u5_entry + u5_exit &lt;= 0\n  1.5 duration_tcm_deltav5 + u5_entry - u5_exit &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[10]: Copied! <pre>def TCM_navigation_deltav_progress(s: int, progress: Tuple[float, float]) -&gt; PolyhedralContract:\n  spec = PolyhedralContract.from_string(\n    input_vars = [\n      f\"r{s}_entry\",              # initial trajectory relative distance\n      f\"duration_tcm_deltav{s}\",  # knob variable for TCM deltav duration\n    ],\n    output_vars = [\n      f\"r{s}_exit\",               # final trajectory relative distance\n    ],\n    assumptions = [\n      # upper bound on trajectory relative distance\n      f\"r{s}_entry &lt;= 100\",\n    ],\n    guarantees = [\n      # duration*improvement(min) &lt;= r{entry} - r{exit} &lt;= duration*improvement(max)\n      f\" r{s}_entry - r{s}_exit - {progress[1]}*duration_tcm_deltav{s} &lt;= 0\",\n      f\"-r{s}_entry + r{s}_exit + {progress[0]}*duration_tcm_deltav{s} &lt;= 0\",\n\n      # lower bound on trajectory relative distance\n      f\"-r{s}_exit &lt;= 0\",\n    ])\n  return spec\n\ntcm1_nav_deltav_progress = TCM_navigation_deltav_progress(s=5, progress=(0.4, 0.5))\nprint(f\"Contract tcm1_navigation_deltav_progress:\\n\\n{tcm1_nav_deltav_progress}\")\n\n_ = plot_guarantees(contract=tcm1_nav_deltav_progress,\n                x_var=Var(\"duration_tcm_deltav5\"),\n                y_var=Var(\"r5_exit\"),\n                var_values={\n                  Var(\"r5_entry\"):100,\n                },\n                x_lims=(0,100),\n                y_lims=(0,100))\n</pre> def TCM_navigation_deltav_progress(s: int, progress: Tuple[float, float]) -&gt; PolyhedralContract:   spec = PolyhedralContract.from_string(     input_vars = [       f\"r{s}_entry\",              # initial trajectory relative distance       f\"duration_tcm_deltav{s}\",  # knob variable for TCM deltav duration     ],     output_vars = [       f\"r{s}_exit\",               # final trajectory relative distance     ],     assumptions = [       # upper bound on trajectory relative distance       f\"r{s}_entry &lt;= 100\",     ],     guarantees = [       # duration*improvement(min) &lt;= r{entry} - r{exit} &lt;= duration*improvement(max)       f\" r{s}_entry - r{s}_exit - {progress[1]}*duration_tcm_deltav{s} &lt;= 0\",       f\"-r{s}_entry + r{s}_exit + {progress[0]}*duration_tcm_deltav{s} &lt;= 0\",        # lower bound on trajectory relative distance       f\"-r{s}_exit &lt;= 0\",     ])   return spec  tcm1_nav_deltav_progress = TCM_navigation_deltav_progress(s=5, progress=(0.4, 0.5)) print(f\"Contract tcm1_navigation_deltav_progress:\\n\\n{tcm1_nav_deltav_progress}\")  _ = plot_guarantees(contract=tcm1_nav_deltav_progress,                 x_var=Var(\"duration_tcm_deltav5\"),                 y_var=Var(\"r5_exit\"),                 var_values={                   Var(\"r5_entry\"):100,                 },                 x_lims=(0,100),                 y_lims=(0,100)) <pre>Contract tcm1_navigation_deltav_progress:\n\nInVars: [r5_entry, duration_tcm_deltav5]\nOutVars:[r5_exit]\nA: [\n  r5_entry &lt;= 100\n]\nG: [\n  -0.5 duration_tcm_deltav5 + r5_entry - r5_exit &lt;= 0\n  0.4 duration_tcm_deltav5 - r5_entry + r5_exit &lt;= 0\n  -r5_exit &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[11]: Copied! <pre>tcm1_nav_deltav = tcm1_nav_deltav_uncertainty.merge(tcm1_nav_deltav_progress)\nprint(f\"Contract tcm1_nav_deltav:\\n\\n{tcm1_nav_deltav}\")\n</pre> tcm1_nav_deltav = tcm1_nav_deltav_uncertainty.merge(tcm1_nav_deltav_progress) print(f\"Contract tcm1_nav_deltav:\\n\\n{tcm1_nav_deltav}\") <pre>Contract tcm1_nav_deltav:\n\nInVars: [u5_entry, duration_tcm_deltav5, r5_entry]\nOutVars:[u5_exit, r5_exit]\nA: [\n  -duration_tcm_deltav5 &lt;= 0\n  -u5_entry &lt;= 0\n  u5_entry &lt;= 100\n  r5_entry &lt;= 100\n]\nG: [\n  u5_exit &lt;= 100\n  -1.6 duration_tcm_deltav5 - u5_entry + u5_exit &lt;= 0\n  1.5 duration_tcm_deltav5 + u5_entry - u5_exit &lt;= 0\n  -0.5 duration_tcm_deltav5 + r5_entry - r5_exit &lt;= 0\n  0.4 duration_tcm_deltav5 - r5_entry + r5_exit &lt;= 0\n  -r5_exit &lt;= 0\n]\n</pre> In\u00a0[12]: Copied! <pre>tcm1_nav = scenario_sequence(c1=tcm1_nav_heating, c2=tcm1_nav_deltav, variables=[\"u\", \"r\"], c1index=4)\nprint(f\"Contract tcm1_nav:\\n\\n{tcm1_nav}\")\n</pre> tcm1_nav = scenario_sequence(c1=tcm1_nav_heating, c2=tcm1_nav_deltav, variables=[\"u\", \"r\"], c1index=4) print(f\"Contract tcm1_nav:\\n\\n{tcm1_nav}\") <pre>Contract tcm1_nav:\n\nInVars: [u4_entry, r4_entry, duration_tcm_deltav5]\nOutVars:[u5_exit, r5_exit, output_u4, output_r4]\nA: [\n  -duration_tcm_deltav5 &lt;= 0\n  u4_entry &lt;= 100\n  r4_entry &lt;= 100\n  -u4_entry &lt;= 0\n  -r4_entry &lt;= 0\n]\nG: [\n  output_u4 - u4_entry = 0\n  output_r4 - r4_entry = 0\n  u5_exit &lt;= 100\n  -1.6 duration_tcm_deltav5 - output_u4 + u5_exit &lt;= 0\n  1.5 duration_tcm_deltav5 + output_u4 - u5_exit &lt;= 0\n  -0.5 duration_tcm_deltav5 + output_r4 - r5_exit &lt;= 0\n  0.4 duration_tcm_deltav5 - output_r4 + r5_exit &lt;= 0\n  -r5_exit &lt;= 0\n]\n</pre> In\u00a0[13]: Copied! <pre>steps12=scenario_sequence(c1=dsn1_nav, c2=charging1_nav, variables=[\"u\", \"r\"], c1index=1)\nprint(f\"---- Steps 1,2\\n{steps12}\")\nprint(steps12.get_variable_bounds(\"output_u1\"))\nprint(steps12.get_variable_bounds(\"output_r1\"))\n</pre> steps12=scenario_sequence(c1=dsn1_nav, c2=charging1_nav, variables=[\"u\", \"r\"], c1index=1) print(f\"---- Steps 1,2\\n{steps12}\") print(steps12.get_variable_bounds(\"output_u1\")) print(steps12.get_variable_bounds(\"output_r1\")) <pre>---- Steps 1,2\nInVars: [u1_entry, r1_entry]\nOutVars:[u2_exit, r2_exit, output_u1, output_r1]\nA: [\n  -u1_entry &lt;= 0\n  u1_entry &lt;= 100\n  -r1_entry &lt;= 0\n  r1_entry &lt;= 100\n]\nG: [\n  output_u1 - u1_entry &lt;= 2\n  -output_u1 + u1_entry &lt;= -1\n  output_r1 - r1_entry = 0\n  u2_exit &lt;= 100\n  -output_u1 + u2_exit &lt;= 2\n  output_u1 - u2_exit &lt;= -1\n  -output_r1 + r2_exit = 0\n]\n(1.0, 99.0)\n(0.0, 100.0)\n</pre> In\u00a0[14]: Copied! <pre>steps123=scenario_sequence(c1=steps12, c2=sbo1_nav, variables=[\"u\", \"r\"], c1index=2)\nprint(f\"---- Steps 1,2,3\\n{steps123}\")\nprint(steps123.get_variable_bounds(\"output_u2\"))\nprint(steps123.get_variable_bounds(\"output_r2\"))\n</pre> steps123=scenario_sequence(c1=steps12, c2=sbo1_nav, variables=[\"u\", \"r\"], c1index=2) print(f\"---- Steps 1,2,3\\n{steps123}\") print(steps123.get_variable_bounds(\"output_u2\")) print(steps123.get_variable_bounds(\"output_r2\")) <pre>---- Steps 1,2,3\nInVars: [u1_entry, r1_entry, duration_sbo3]\nOutVars:[output_u1, output_r1, u3_exit, r3_exit, output_u2, output_r2]\nA: [\n  -duration_sbo3 &lt;= 0\n  -u1_entry &lt;= 0\n  u1_entry &lt;= 100\n  -r1_entry &lt;= 0\n  r1_entry &lt;= 100\n]\nG: [\n  output_u1 - u1_entry &lt;= 2\n  -output_u1 + u1_entry &lt;= -1\n  output_r1 - r1_entry = 0\n  output_u2 &lt;= 100\n  -output_u1 + output_u2 &lt;= 2\n  output_u1 - output_u2 &lt;= -1\n  -output_r1 + output_r2 = 0\n  -0.6 duration_sbo3 + output_u2 - u3_exit &lt;= 0\n  0.4 duration_sbo3 - output_u2 + u3_exit &lt;= 0\n  -u3_exit &lt;= 0\n  -output_r2 + r3_exit = 0\n]\n(2.0, 100.0)\n(0.0, 100.0)\n</pre> In\u00a0[15]: Copied! <pre>steps1234=scenario_sequence(c1=steps123, c2=tcm1_nav, variables=[\"u\", \"r\"], c1index=3)\nprint(f\"---- Steps 1,2,3,4\\n{steps1234}\")\nprint(steps1234.get_variable_bounds(\"output_u3\"))\nprint(steps1234.get_variable_bounds(\"output_r3\"))\nprint(steps1234.get_variable_bounds(\"duration_tcm_deltav5\"))\n</pre> steps1234=scenario_sequence(c1=steps123, c2=tcm1_nav, variables=[\"u\", \"r\"], c1index=3) print(f\"---- Steps 1,2,3,4\\n{steps1234}\") print(steps1234.get_variable_bounds(\"output_u3\")) print(steps1234.get_variable_bounds(\"output_r3\")) print(steps1234.get_variable_bounds(\"duration_tcm_deltav5\")) <pre>---- Steps 1,2,3,4\nInVars: [u1_entry, r1_entry, duration_sbo3, duration_tcm_deltav5]\nOutVars:[output_u1, output_r1, output_u2, output_r2, u5_exit, r5_exit, output_u4, output_r4, output_u3, output_r3]\nA: [\n  -duration_tcm_deltav5 &lt;= 0\n  -duration_sbo3 &lt;= 0\n  -u1_entry &lt;= 0\n  u1_entry &lt;= 100\n  -r1_entry &lt;= 0\n  r1_entry &lt;= 100\n]\nG: [\n  output_u1 - u1_entry &lt;= 2\n  -output_u1 + u1_entry &lt;= -1\n  output_r1 - r1_entry = 0\n  output_u2 &lt;= 100\n  -output_u1 + output_u2 &lt;= 2\n  output_u1 - output_u2 &lt;= -1\n  -output_r1 + output_r2 = 0\n  -0.6 duration_sbo3 + output_u2 - output_u3 &lt;= 0\n  0.4 duration_sbo3 - output_u2 + output_u3 &lt;= 0\n  -output_u3 &lt;= 0\n  -output_r2 + output_r3 = 0\n  -output_u3 + output_u4 = 0\n  -output_r3 + output_r4 = 0\n  u5_exit &lt;= 100\n  -1.6 duration_tcm_deltav5 - output_u4 + u5_exit &lt;= 0\n  1.5 duration_tcm_deltav5 + output_u4 - u5_exit &lt;= 0\n  -0.5 duration_tcm_deltav5 + output_r4 - r5_exit &lt;= 0\n  0.4 duration_tcm_deltav5 - output_r4 + r5_exit &lt;= 0\n  -r5_exit &lt;= 0\n]\n(0.0, 100.0)\n(0.0, 100.0)\n(0.0, 66.66666666666667)\n</pre> In\u00a0[16]: Copied! <pre>scenario_nav=steps1234.rename_variables([\n    (\"u4_exit\", \"output_u4\"), \n    (\"r4_exit\", \"output_r4\"),\n    (\"u5_exit\", \"output_u5\"), \n    (\"r5_exit\", \"output_r5\")])\nprint(f\"scenario_nav={scenario_nav}\")\n</pre> scenario_nav=steps1234.rename_variables([     (\"u4_exit\", \"output_u4\"),      (\"r4_exit\", \"output_r4\"),     (\"u5_exit\", \"output_u5\"),      (\"r5_exit\", \"output_r5\")]) print(f\"scenario_nav={scenario_nav}\") <pre>scenario_nav=InVars: [u1_entry, r1_entry, duration_sbo3, duration_tcm_deltav5]\nOutVars:[output_u1, output_r1, output_u2, output_r2, output_u4, output_r4, output_u3, output_r3, output_u5, output_r5]\nA: [\n  -duration_tcm_deltav5 &lt;= 0\n  -duration_sbo3 &lt;= 0\n  -u1_entry &lt;= 0\n  u1_entry &lt;= 100\n  -r1_entry &lt;= 0\n  r1_entry &lt;= 100\n]\nG: [\n  output_u1 - u1_entry &lt;= 2\n  -output_u1 + u1_entry &lt;= -1\n  output_r1 - r1_entry = 0\n  output_u2 &lt;= 100\n  -output_u1 + output_u2 &lt;= 2\n  output_u1 - output_u2 &lt;= -1\n  -output_r1 + output_r2 = 0\n  -0.6 duration_sbo3 + output_u2 - output_u3 &lt;= 0\n  0.4 duration_sbo3 - output_u2 + output_u3 &lt;= 0\n  -output_u3 &lt;= 0\n  -output_r2 + output_r3 = 0\n  -output_u3 + output_u4 = 0\n  -output_r3 + output_r4 = 0\n  output_u5 &lt;= 100\n  -1.6 duration_tcm_deltav5 - output_u4 + output_u5 &lt;= 0\n  1.5 duration_tcm_deltav5 + output_u4 - output_u5 &lt;= 0\n  -0.5 duration_tcm_deltav5 + output_r4 - output_r5 &lt;= 0\n  0.4 duration_tcm_deltav5 - output_r4 + output_r5 &lt;= 0\n  -output_r5 &lt;= 0\n]\n</pre> In\u00a0[17]: remove_cell Copied! <pre>write_contracts_to_file(contracts=[scenario_nav], names=[\"scenario_nav\"], file_name=\"json/scenario_nav.json\")\n</pre> write_contracts_to_file(contracts=[scenario_nav], names=[\"scenario_nav\"], file_name=\"json/scenario_nav.json\")"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_navigation/#navigation-viewpoint-modeling","title":"Navigation viewpoint modeling\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_navigation/#uncertainty-generating-tasks-chrg-dsn","title":"Uncertainty-generating tasks (CHRG, DSN)\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_navigation/#charging-task","title":"CHARGING Task\u00b6","text":"<p>Objective: charge the spacecraft battery</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint with a fixed impact:</p> <ul> <li>the spacecraft's attitude change to the Sun injects a small disturbance that increases the trajectory estimation uncertainty.</li> </ul>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_navigation/#dsn-task","title":"DSN Task\u00b6","text":"<p>Objective: downlink science data to Earth.</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint with a fixed impact:</p> <ul> <li>the spacecraft's attitude change to Earth injects a small disturbance that increases the trajectory estimation uncertainty.</li> </ul>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_navigation/#sbo-task","title":"SBO Task\u00b6","text":"<p>Objective: Acquire small body observations (science data &amp; navigation)</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint with impacts that are linear with the duration of the task:</p> <ul> <li>the trajectory estimation error decreases proportionally to an improvement rate.</li> </ul> <p>Note that this task has no impact on the relative trajectory progress.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_navigation/#tcm-task-perform-a-trajectory-correction-maneuver","title":"TCM Task (Perform a Trajectory Correction Maneuver)\u00b6","text":"<p>Objective: Perform a delta-V maneuver to bring the spacecraft trajectory closer to that of the small body.</p> <p>As described in the qualitative impacts table, this function affects three viewpoints, each with impacts that are linear with the duration of the task:</p> <ul> <li>The navigation trajectory improves by a delta during the delta-V subtask.</li> </ul> <p>Note: the heating subtask has no impact on navigation.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_navigation/#tcm-heating-subtask","title":"TCM Heating SubTask\u00b6","text":"<p>Since TCM Heating has no impact on navigation, we use the no-change contract utility to specify this property for the two navigation viewpoint state variables: <code>u</code> and <code>r</code>.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_navigation/#tcm-deltav-subtask","title":"TCM DeltaV SubTask\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_navigation/#navigation-schedule-analysis","title":"Navigation Schedule Analysis\u00b6","text":"<p>Let's consider a simple 4-step schedule of the following sequence of task instances, which we compose:</p> <ul> <li>DSN</li> <li>CHARGING</li> <li>SBO</li> <li>TCM</li> </ul>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_power/","title":"Power Viewpoint","text":"In\u00a0[1]: Copied! <pre>%matplotlib widget\n\n#from IPython import display\nfrom base64 import b64decode\nfrom pacti import write_contracts_to_file\nfrom pacti.terms.polyhedra import *\nfrom pacti.iocontract import IoContract, Var\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport os\nimport numpy as np\nfrom matplotlib import patches\nimport pdb\nfrom matplotlib.collections import PatchCollection\nfrom contract_utils import *\n</pre> %matplotlib widget  #from IPython import display from base64 import b64decode from pacti import write_contracts_to_file from pacti.terms.polyhedra import * from pacti.iocontract import IoContract, Var from PIL import Image import matplotlib.pyplot as plt import os import numpy as np from matplotlib import patches import pdb from matplotlib.collections import PatchCollection from contract_utils import * In\u00a0[2]: Copied! <pre># Parameters:\n# - s: index of the timeline variables\n# - generation: (min, max) rate of battery charge during the task instance\ndef CHRG_power(s: int, generation: Tuple[float, float]) -&gt; PolyhedralContract:\n  spec = PolyhedralContract.from_string(\n    input_vars = [\n      f\"soc{s}_entry\",          # initial battery SOC\n      f\"duration_charging{s}\",  # variable task duration\n    ],\n    output_vars = [\n      f\"soc{s}_exit\",           # final battery SOC\n    ],\n    assumptions = [\n      # Task has a positive scheduled duration\n      f\"-duration_charging{s} &lt;= 0\",\n      # Upper bound on entry soc\n      f\"soc{s}_entry &lt;= 100.0\",\n      # Lower bound on entry soc\n      f\"-soc{s}_entry &lt;= 0\",\n      # Battery should not overcharge\n      f\"soc{s}_entry + {generation[1]}*duration_charging{s} &lt;= 100\",\n    ],\n    guarantees = [\n      # duration*generation(min) &lt;= soc{exit} - soc{entry} &lt;= duration*generation(max)\n      f\" soc{s}_exit - soc{s}_entry - {generation[1]}*duration_charging{s} &lt;= 0\",\n      f\"-soc{s}_exit + soc{s}_entry + {generation[0]}*duration_charging{s} &lt;= 0\",\n\n      # Battery cannot exceed maximum SOC\n      f\"soc{s}_exit &lt;= 100.0\",\n      \n      # Battery should not completely discharge\n      f\"-soc{s}_exit &lt;= 0\",\n    ])\n  return spec\n\ncharging1_power = CHRG_power(s=2, generation=(3.0, 4.0))\nprint(f\"Contract charging1_power:\\n\\n{charging1_power}\")\n\n_ = plot_guarantees(contract=charging1_power,\n                x_var=Var(\"duration_charging2\"),\n                y_var=Var(\"soc2_exit\"),\n                var_values={\n                  Var(\"soc2_entry\"):42,\n                },\n                x_lims=(0,100),\n                y_lims=(0,100))\n</pre> # Parameters: # - s: index of the timeline variables # - generation: (min, max) rate of battery charge during the task instance def CHRG_power(s: int, generation: Tuple[float, float]) -&gt; PolyhedralContract:   spec = PolyhedralContract.from_string(     input_vars = [       f\"soc{s}_entry\",          # initial battery SOC       f\"duration_charging{s}\",  # variable task duration     ],     output_vars = [       f\"soc{s}_exit\",           # final battery SOC     ],     assumptions = [       # Task has a positive scheduled duration       f\"-duration_charging{s} &lt;= 0\",       # Upper bound on entry soc       f\"soc{s}_entry &lt;= 100.0\",       # Lower bound on entry soc       f\"-soc{s}_entry &lt;= 0\",       # Battery should not overcharge       f\"soc{s}_entry + {generation[1]}*duration_charging{s} &lt;= 100\",     ],     guarantees = [       # duration*generation(min) &lt;= soc{exit} - soc{entry} &lt;= duration*generation(max)       f\" soc{s}_exit - soc{s}_entry - {generation[1]}*duration_charging{s} &lt;= 0\",       f\"-soc{s}_exit + soc{s}_entry + {generation[0]}*duration_charging{s} &lt;= 0\",        # Battery cannot exceed maximum SOC       f\"soc{s}_exit &lt;= 100.0\",              # Battery should not completely discharge       f\"-soc{s}_exit &lt;= 0\",     ])   return spec  charging1_power = CHRG_power(s=2, generation=(3.0, 4.0)) print(f\"Contract charging1_power:\\n\\n{charging1_power}\")  _ = plot_guarantees(contract=charging1_power,                 x_var=Var(\"duration_charging2\"),                 y_var=Var(\"soc2_exit\"),                 var_values={                   Var(\"soc2_entry\"):42,                 },                 x_lims=(0,100),                 y_lims=(0,100)) <pre>Contract charging1_power:\n\nInVars: [soc2_entry, duration_charging2]\nOutVars:[soc2_exit]\nA: [\n  -duration_charging2 &lt;= 0\n  soc2_entry &lt;= 100\n  -soc2_entry &lt;= 0\n  4 duration_charging2 + soc2_entry &lt;= 100\n]\nG: [\n  -4 duration_charging2 - soc2_entry + soc2_exit &lt;= 0\n  3 duration_charging2 + soc2_entry - soc2_exit &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[3]: Copied! <pre># Parameters:\n# - s: start index of the timeline variables\n# - consumption: (min, max) rate of battery discharge during the task instance\ndef power_consumer(s: int, task: str, consumption: Tuple[float, float]) -&gt; PolyhedralContract:\n  spec = PolyhedralContract.from_string(\n    input_vars = [\n      f\"soc{s}_entry\",          # initial battery SOC\n      f\"duration_{task}{s}\",    # variable task duration\n    ],\n    output_vars = [\n      f\"soc{s}_exit\",           # final battery SOC\n    ],\n    assumptions = [\n      # Task has a positive scheduled duration\n      f\"-duration_{task}{s} &lt;= 0\",\n      # Upper bound on entry soc\n      f\"soc{s}_entry &lt;= 100.0\",\n      # Lower bound on entry soc\n      f\"-soc{s}_entry &lt;= 0\",\n      # Battery has enough energy for worst-case consumption throughout the task instance\n      f\"-soc{s}_entry + {consumption[1]}*duration_{task}{s} &lt;= 0\",\n    ],\n    guarantees = [\n      # duration*consumption(min) &lt;= soc{entry} - soc{exit} &lt;= duration*consumption(max)\n      f\" soc{s}_entry - soc{s}_exit - {consumption[1]}*duration_{task}{s} &lt;= 0\",\n      f\"-soc{s}_entry + soc{s}_exit + {consumption[0]}*duration_{task}{s} &lt;= 0\",\n\n      # Battery cannot exceed maximum SOC\n      f\"soc{s}_exit &lt;= 100.0\",\n      \n      # Battery should not completely discharge\n      f\"-soc{s}_exit &lt;= 0\",\n    ])\n  return spec\n</pre> # Parameters: # - s: start index of the timeline variables # - consumption: (min, max) rate of battery discharge during the task instance def power_consumer(s: int, task: str, consumption: Tuple[float, float]) -&gt; PolyhedralContract:   spec = PolyhedralContract.from_string(     input_vars = [       f\"soc{s}_entry\",          # initial battery SOC       f\"duration_{task}{s}\",    # variable task duration     ],     output_vars = [       f\"soc{s}_exit\",           # final battery SOC     ],     assumptions = [       # Task has a positive scheduled duration       f\"-duration_{task}{s} &lt;= 0\",       # Upper bound on entry soc       f\"soc{s}_entry &lt;= 100.0\",       # Lower bound on entry soc       f\"-soc{s}_entry &lt;= 0\",       # Battery has enough energy for worst-case consumption throughout the task instance       f\"-soc{s}_entry + {consumption[1]}*duration_{task}{s} &lt;= 0\",     ],     guarantees = [       # duration*consumption(min) &lt;= soc{entry} - soc{exit} &lt;= duration*consumption(max)       f\" soc{s}_entry - soc{s}_exit - {consumption[1]}*duration_{task}{s} &lt;= 0\",       f\"-soc{s}_entry + soc{s}_exit + {consumption[0]}*duration_{task}{s} &lt;= 0\",        # Battery cannot exceed maximum SOC       f\"soc{s}_exit &lt;= 100.0\",              # Battery should not completely discharge       f\"-soc{s}_exit &lt;= 0\",     ])   return spec In\u00a0[4]: Copied! <pre>dsn1_power = power_consumer(s=1, task=\"dsn\", consumption=(3.8, 4.2))\nprint(f\"Contract dsn1_power:\\n\\n{dsn1_power}\")\n\n_ = plot_guarantees(contract=dsn1_power,\n                x_var=Var(\"duration_dsn1\"),\n                y_var=Var(\"soc1_exit\"),\n                var_values={\n                  Var(\"soc1_entry\"):80,\n                },\n                x_lims=(0,20),\n                y_lims=(0,80))\n</pre> dsn1_power = power_consumer(s=1, task=\"dsn\", consumption=(3.8, 4.2)) print(f\"Contract dsn1_power:\\n\\n{dsn1_power}\")  _ = plot_guarantees(contract=dsn1_power,                 x_var=Var(\"duration_dsn1\"),                 y_var=Var(\"soc1_exit\"),                 var_values={                   Var(\"soc1_entry\"):80,                 },                 x_lims=(0,20),                 y_lims=(0,80)) <pre>Contract dsn1_power:\n\nInVars: [soc1_entry, duration_dsn1]\nOutVars:[soc1_exit]\nA: [\n  -duration_dsn1 &lt;= 0\n  soc1_entry &lt;= 100\n  -soc1_entry &lt;= 0\n  4.2 duration_dsn1 - soc1_entry &lt;= 0\n]\nG: [\n  -4.2 duration_dsn1 + soc1_entry - soc1_exit &lt;= 0\n  3.8 duration_dsn1 - soc1_entry + soc1_exit &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[5]: Copied! <pre>sbo1_power = power_consumer(s=3, task=\"sbo\", consumption=(1.0, 1.4))\nprint(f\"Contract sbo1_power:\\n\\n{sbo1_power}\")\n\n_ = plot_guarantees(contract=sbo1_power,\n                x_var=Var(\"duration_sbo3\"),\n                y_var=Var(\"soc3_exit\"),\n                var_values={\n                  Var(\"soc3_entry\"):80,\n                },\n                x_lims=(0,100),\n                y_lims=(0,100))\n</pre> sbo1_power = power_consumer(s=3, task=\"sbo\", consumption=(1.0, 1.4)) print(f\"Contract sbo1_power:\\n\\n{sbo1_power}\")  _ = plot_guarantees(contract=sbo1_power,                 x_var=Var(\"duration_sbo3\"),                 y_var=Var(\"soc3_exit\"),                 var_values={                   Var(\"soc3_entry\"):80,                 },                 x_lims=(0,100),                 y_lims=(0,100)) <pre>Contract sbo1_power:\n\nInVars: [soc3_entry, duration_sbo3]\nOutVars:[soc3_exit]\nA: [\n  -duration_sbo3 &lt;= 0\n  soc3_entry &lt;= 100\n  -soc3_entry &lt;= 0\n  1.4 duration_sbo3 - soc3_entry &lt;= 0\n]\nG: [\n  -1.4 duration_sbo3 + soc3_entry - soc3_exit &lt;= 0\n  duration_sbo3 - soc3_entry + soc3_exit &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[6]: Copied! <pre>tcm1_heating_power = power_consumer(s=4, task=\"tcm_heating\", consumption=(0.7, 0.8))\nprint(f\"Contract tcm1_heating_power:\\n\\n{tcm1_heating_power}\")\n\n_ = plot_guarantees(contract=tcm1_heating_power,\n                x_var=Var(\"duration_tcm_heating4\"),\n                y_var=Var(\"soc4_exit\"),\n                var_values={\n                  Var(\"soc4_entry\"):80,\n                },\n                x_lims=(0,100),\n                y_lims=(0,100))\n</pre> tcm1_heating_power = power_consumer(s=4, task=\"tcm_heating\", consumption=(0.7, 0.8)) print(f\"Contract tcm1_heating_power:\\n\\n{tcm1_heating_power}\")  _ = plot_guarantees(contract=tcm1_heating_power,                 x_var=Var(\"duration_tcm_heating4\"),                 y_var=Var(\"soc4_exit\"),                 var_values={                   Var(\"soc4_entry\"):80,                 },                 x_lims=(0,100),                 y_lims=(0,100)) <pre>Contract tcm1_heating_power:\n\nInVars: [soc4_entry, duration_tcm_heating4]\nOutVars:[soc4_exit]\nA: [\n  -duration_tcm_heating4 &lt;= 0\n  soc4_entry &lt;= 100\n  -soc4_entry &lt;= 0\n  0.8 duration_tcm_heating4 - soc4_entry &lt;= 0\n]\nG: [\n  -0.8 duration_tcm_heating4 + soc4_entry - soc4_exit &lt;= 0\n  0.7 duration_tcm_heating4 - soc4_entry + soc4_exit &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[7]: Copied! <pre>tcm1_deltav_power = power_consumer(s=5, task=\"tcm_deltav\", consumption=(0.5, 0.6))\nprint(f\"Contract tcm1_deltav_power:\\n\\n{tcm1_deltav_power}\")\n\n_ = plot_guarantees(contract=tcm1_deltav_power,\n                x_var=Var(\"duration_tcm_deltav5\"),\n                y_var=Var(\"soc5_exit\"),\n                var_values={\n                  Var(\"soc5_entry\"):80,\n                },\n                x_lims=(0,100),\n                y_lims=(0,100))\n</pre> tcm1_deltav_power = power_consumer(s=5, task=\"tcm_deltav\", consumption=(0.5, 0.6)) print(f\"Contract tcm1_deltav_power:\\n\\n{tcm1_deltav_power}\")  _ = plot_guarantees(contract=tcm1_deltav_power,                 x_var=Var(\"duration_tcm_deltav5\"),                 y_var=Var(\"soc5_exit\"),                 var_values={                   Var(\"soc5_entry\"):80,                 },                 x_lims=(0,100),                 y_lims=(0,100)) <pre>Contract tcm1_deltav_power:\n\nInVars: [soc5_entry, duration_tcm_deltav5]\nOutVars:[soc5_exit]\nA: [\n  -duration_tcm_deltav5 &lt;= 0\n  soc5_entry &lt;= 100\n  -soc5_entry &lt;= 0\n  0.6 duration_tcm_deltav5 - soc5_entry &lt;= 0\n]\nG: [\n  -0.6 duration_tcm_deltav5 + soc5_entry - soc5_exit &lt;= 0\n  0.5 duration_tcm_deltav5 - soc5_entry + soc5_exit &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[8]: Copied! <pre>tcm1_power=scenario_sequence(c1=tcm1_heating_power, c2=tcm1_deltav_power, variables=[\"soc\"], c1index=4)\nprint(f\"========= tcm1_power\\n{tcm1_power}\")\ntcm1_power.get_variable_bounds(\"soc5_exit\")\n</pre> tcm1_power=scenario_sequence(c1=tcm1_heating_power, c2=tcm1_deltav_power, variables=[\"soc\"], c1index=4) print(f\"========= tcm1_power\\n{tcm1_power}\") tcm1_power.get_variable_bounds(\"soc5_exit\") <pre>========= tcm1_power\nInVars: [soc4_entry, duration_tcm_heating4, duration_tcm_deltav5]\nOutVars:[soc5_exit, output_soc4]\nA: [\n  -duration_tcm_deltav5 &lt;= 0\n  0.6 duration_tcm_deltav5 + 0.8 duration_tcm_heating4 - soc4_entry &lt;= 0\n  -duration_tcm_heating4 &lt;= 0\n  soc4_entry &lt;= 100\n]\nG: [\n  -0.8 duration_tcm_heating4 - output_soc4 + soc4_entry &lt;= 0\n  0.7 duration_tcm_heating4 + output_soc4 - soc4_entry &lt;= 0\n  -0.6 duration_tcm_deltav5 + output_soc4 - soc5_exit &lt;= 0\n  0.5 duration_tcm_deltav5 - output_soc4 + soc5_exit &lt;= 0\n]\n</pre> Out[8]: <pre>(-1.4210854715202004e-14, 100.0)</pre> In\u00a0[9]: Copied! <pre>steps12=scenario_sequence(c1=dsn1_power, c2=charging1_power, variables=[\"soc\"], c1index=1)\nprint(f\"---- Steps 1,2\\n{steps12}\")\nsteps12.get_variable_bounds(\"output_soc1\")\n</pre> steps12=scenario_sequence(c1=dsn1_power, c2=charging1_power, variables=[\"soc\"], c1index=1) print(f\"---- Steps 1,2\\n{steps12}\") steps12.get_variable_bounds(\"output_soc1\") <pre>---- Steps 1,2\nInVars: [soc1_entry, duration_dsn1, duration_charging2]\nOutVars:[soc2_exit, output_soc1]\nA: [\n  -duration_charging2 &lt;= 0\n  4 duration_charging2 - 3.8 duration_dsn1 + soc1_entry &lt;= 100\n  -duration_dsn1 &lt;= 0\n  soc1_entry &lt;= 100\n  4.2 duration_dsn1 - soc1_entry &lt;= 0\n]\nG: [\n  -4.2 duration_dsn1 - output_soc1 + soc1_entry &lt;= 0\n  3.8 duration_dsn1 + output_soc1 - soc1_entry &lt;= 0\n  -4 duration_charging2 - output_soc1 + soc2_exit &lt;= 0\n  3 duration_charging2 + output_soc1 - soc2_exit &lt;= 0\n]\n</pre> Out[9]: <pre>(0.0, 100.0)</pre> In\u00a0[19]: Copied! <pre>steps23=scenario_sequence(c1=charging1_power, c2=sbo1_power, variables=[\"soc\"], c1index=2)\nprint(f\"---- Steps 2,3\\n{steps23}\")\nprint(\"output_soc2:\"+str(steps23.get_variable_bounds(\"output_soc2\")))\nprint(\"soc3_exit:\"+str(steps23.get_variable_bounds(\"soc3_exit\")))\n</pre> steps23=scenario_sequence(c1=charging1_power, c2=sbo1_power, variables=[\"soc\"], c1index=2) print(f\"---- Steps 2,3\\n{steps23}\") print(\"output_soc2:\"+str(steps23.get_variable_bounds(\"output_soc2\"))) print(\"soc3_exit:\"+str(steps23.get_variable_bounds(\"soc3_exit\"))) <pre>---- Steps 2,3\nInVars: [soc2_entry, duration_charging2, duration_sbo3]\nOutVars:[soc3_exit, output_soc2]\nA: [\n  -duration_sbo3 &lt;= 0\n  -3 duration_charging2 + 1.4 duration_sbo3 - soc2_entry &lt;= 0\n  -duration_charging2 &lt;= 0\n  -soc2_entry &lt;= 0\n  4 duration_charging2 + soc2_entry &lt;= 100\n]\nG: [\n  -4 duration_charging2 + output_soc2 - soc2_entry &lt;= 0\n  3 duration_charging2 - output_soc2 + soc2_entry &lt;= 0\n  -1.4 duration_sbo3 + output_soc2 - soc3_exit &lt;= 0\n  duration_sbo3 - output_soc2 + soc3_exit &lt;= 0\n]\noutput_soc2:(0.0, 100.0)\nsoc3_exit:(0.0, 100.0)\n</pre> In\u00a0[20]: Copied! <pre>steps1_23=scenario_sequence(c1=dsn1_power, c2=steps23, variables=[\"soc\"], c1index=1)\nprint(f\"---- Steps 1 and 2,3\\n{steps1_23}\")\nprint(\"output_soc1:\"+str(steps1_23.get_variable_bounds(\"output_soc1\")))\nprint(\"output_soc2:\"+str(steps1_23.get_variable_bounds(\"output_soc2\")))\nprint(\"soc3_exit:\"+str(steps1_23.get_variable_bounds(\"soc3_exit\")))\n</pre> steps1_23=scenario_sequence(c1=dsn1_power, c2=steps23, variables=[\"soc\"], c1index=1) print(f\"---- Steps 1 and 2,3\\n{steps1_23}\") print(\"output_soc1:\"+str(steps1_23.get_variable_bounds(\"output_soc1\"))) print(\"output_soc2:\"+str(steps1_23.get_variable_bounds(\"output_soc2\"))) print(\"soc3_exit:\"+str(steps1_23.get_variable_bounds(\"soc3_exit\"))) <pre>---- Steps 1 and 2,3\nInVars: [soc1_entry, duration_dsn1, duration_charging2, duration_sbo3]\nOutVars:[soc3_exit, output_soc2, output_soc1]\nA: [\n  -duration_sbo3 &lt;= 0\n  -3 duration_charging2 + 4.2 duration_dsn1 + 1.4 duration_sbo3 - soc1_entry &lt;= 0\n  -duration_charging2 &lt;= 0\n  4 duration_charging2 - 3.8 duration_dsn1 + soc1_entry &lt;= 100\n  -duration_dsn1 &lt;= 0\n  soc1_entry &lt;= 100\n  4.2 duration_dsn1 - soc1_entry &lt;= 0\n]\nG: [\n  -4.2 duration_dsn1 - output_soc1 + soc1_entry &lt;= 0\n  3.8 duration_dsn1 + output_soc1 - soc1_entry &lt;= 0\n  -4 duration_charging2 - output_soc1 + output_soc2 &lt;= 0\n  3 duration_charging2 + output_soc1 - output_soc2 &lt;= 0\n  -1.4 duration_sbo3 + output_soc2 - soc3_exit &lt;= 0\n  duration_sbo3 - output_soc2 + soc3_exit &lt;= 0\n]\noutput_soc1:(0.0, 100.0)\noutput_soc2:(0.0, 100.0)\nsoc3_exit:(0.0, 100.0)\n</pre> In\u00a0[18]: Copied! <pre>steps123=scenario_sequence(c1=steps12, c2=sbo1_power, variables=[\"soc\"], c1index=2)\nprint(f\"---- Steps 1,2,3\\n{steps123}\")\nprint(\"output_soc1:\"+str(steps123.get_variable_bounds(\"output_soc1\")))\nprint(\"output_soc2:\"+str(steps123.get_variable_bounds(\"output_soc2\")))\nprint(\"soc3_exit:\"+str(steps123.get_variable_bounds(\"soc3_exit\")))\nprint(steps123.get_variable_bounds(\"duration_dsn1\"))\nprint(steps123.get_variable_bounds(\"duration_charging2\"))\nprint(steps123.get_variable_bounds(\"duration_sbo3\"))\n</pre> steps123=scenario_sequence(c1=steps12, c2=sbo1_power, variables=[\"soc\"], c1index=2) print(f\"---- Steps 1,2,3\\n{steps123}\") print(\"output_soc1:\"+str(steps123.get_variable_bounds(\"output_soc1\"))) print(\"output_soc2:\"+str(steps123.get_variable_bounds(\"output_soc2\"))) print(\"soc3_exit:\"+str(steps123.get_variable_bounds(\"soc3_exit\"))) print(steps123.get_variable_bounds(\"duration_dsn1\")) print(steps123.get_variable_bounds(\"duration_charging2\")) print(steps123.get_variable_bounds(\"duration_sbo3\")) <pre>---- Steps 1,2,3\nInVars: [soc1_entry, duration_dsn1, duration_charging2, duration_sbo3]\nOutVars:[output_soc1, soc3_exit, output_soc2]\nA: [\n  -duration_sbo3 &lt;= 0\n  -3 duration_charging2 + 3.8 duration_dsn1 + 1.4 duration_sbo3 - soc1_entry &lt;= 0\n  -duration_charging2 &lt;= 0\n  4 duration_charging2 - 3.8 duration_dsn1 + soc1_entry &lt;= 100\n  -duration_dsn1 &lt;= 0\n  soc1_entry &lt;= 100\n  4.2 duration_dsn1 - soc1_entry &lt;= 0\n]\nG: [\n  -4.2 duration_dsn1 - output_soc1 + soc1_entry &lt;= 0\n  3.8 duration_dsn1 + output_soc1 - soc1_entry &lt;= 0\n  -4 duration_charging2 - output_soc1 + output_soc2 &lt;= 0\n  3 duration_charging2 + output_soc1 - output_soc2 &lt;= 0\n  -1.4 duration_sbo3 + output_soc2 - soc3_exit &lt;= 0\n  duration_sbo3 - output_soc2 + soc3_exit &lt;= 0\n]\noutput_soc1:(0.0, 100.0)\noutput_soc2:(0.0, 100.0)\nsoc3_exit:(-9.523809523809533, 100.0)\n(0.0, 23.80952380952381)\n(0.0, 25.0)\n(0.0, 71.42857142857143)\n</pre> In\u00a0[22]: Copied! <pre>back34=scenario_sequence(c1=sbo1_power, c2=tcm1_power, variables=[\"soc\"], c1index=3)\nprint(f\"---- Steps 3,4\\n{back34}\")\nprint(\"output_soc3:\"+str(back34.get_variable_bounds(\"output_soc3\")))\nprint(\"output_soc4:\"+str(back34.get_variable_bounds(\"output_soc4\")))\nprint(\"soc5_exit:\"+str(back34.get_variable_bounds(\"soc5_exit\")))\n</pre> back34=scenario_sequence(c1=sbo1_power, c2=tcm1_power, variables=[\"soc\"], c1index=3) print(f\"---- Steps 3,4\\n{back34}\") print(\"output_soc3:\"+str(back34.get_variable_bounds(\"output_soc3\"))) print(\"output_soc4:\"+str(back34.get_variable_bounds(\"output_soc4\"))) print(\"soc5_exit:\"+str(back34.get_variable_bounds(\"soc5_exit\"))) <pre>---- Steps 3,4\nInVars: [soc3_entry, duration_sbo3, duration_tcm_heating4, duration_tcm_deltav5]\nOutVars:[soc5_exit, output_soc4, output_soc3]\nA: [\n  -duration_tcm_deltav5 &lt;= 0\n  1.4 duration_sbo3 + 0.6 duration_tcm_deltav5 + 0.8 duration_tcm_heating4 - soc3_entry &lt;= 0\n  -duration_tcm_heating4 &lt;= 0\n  -duration_sbo3 &lt;= 0\n  soc3_entry &lt;= 100\n]\nG: [\n  -1.4 duration_sbo3 - output_soc3 + soc3_entry &lt;= 0\n  duration_sbo3 + output_soc3 - soc3_entry &lt;= 0\n  -0.8 duration_tcm_heating4 + output_soc3 - output_soc4 &lt;= 0\n  0.7 duration_tcm_heating4 - output_soc3 + output_soc4 &lt;= 0\n  -0.6 duration_tcm_deltav5 + output_soc4 - soc5_exit &lt;= 0\n  0.5 duration_tcm_deltav5 - output_soc4 + soc5_exit &lt;= 0\n]\noutput_soc3:(0.0, 100.0)\noutput_soc4:(0.0, 100.0)\nsoc5_exit:(-1.4210854715202004e-14, 100.0)\n</pre> In\u00a0[23]: Copied! <pre>back234=scenario_sequence(c1=charging1_power, c2=back34, variables=[\"soc\"], c1index=2)\nprint(f\"---- Steps 2,3,4\\n{back234}\")\nprint(\"output_soc2:\"+str(back234.get_variable_bounds(\"output_soc2\")))\nprint(\"output_soc3:\"+str(back234.get_variable_bounds(\"output_soc3\")))\nprint(\"output_soc4:\"+str(back234.get_variable_bounds(\"output_soc4\")))\nprint(\"soc5_exit:\"+str(back234.get_variable_bounds(\"soc5_exit\")))\n</pre> back234=scenario_sequence(c1=charging1_power, c2=back34, variables=[\"soc\"], c1index=2) print(f\"---- Steps 2,3,4\\n{back234}\") print(\"output_soc2:\"+str(back234.get_variable_bounds(\"output_soc2\"))) print(\"output_soc3:\"+str(back234.get_variable_bounds(\"output_soc3\"))) print(\"output_soc4:\"+str(back234.get_variable_bounds(\"output_soc4\"))) print(\"soc5_exit:\"+str(back234.get_variable_bounds(\"soc5_exit\"))) <pre>---- Steps 2,3,4\nInVars: [soc2_entry, duration_charging2, duration_sbo3, duration_tcm_heating4, duration_tcm_deltav5]\nOutVars:[soc5_exit, output_soc4, output_soc3, output_soc2]\nA: [\n  -duration_tcm_deltav5 &lt;= 0\n  -3 duration_charging2 + 1.4 duration_sbo3 + 0.6 duration_tcm_deltav5 + 0.8 duration_tcm_heating4 - soc2_entry &lt;= 0\n  -duration_tcm_heating4 &lt;= 0\n  -duration_sbo3 &lt;= 0\n  -duration_charging2 &lt;= 0\n  -soc2_entry &lt;= 0\n  4 duration_charging2 + soc2_entry &lt;= 100\n]\nG: [\n  -4 duration_charging2 + output_soc2 - soc2_entry &lt;= 0\n  3 duration_charging2 - output_soc2 + soc2_entry &lt;= 0\n  -1.4 duration_sbo3 + output_soc2 - output_soc3 &lt;= 0\n  duration_sbo3 - output_soc2 + output_soc3 &lt;= 0\n  -0.8 duration_tcm_heating4 + output_soc3 - output_soc4 &lt;= 0\n  0.7 duration_tcm_heating4 - output_soc3 + output_soc4 &lt;= 0\n  -0.6 duration_tcm_deltav5 + output_soc4 - soc5_exit &lt;= 0\n  0.5 duration_tcm_deltav5 - output_soc4 + soc5_exit &lt;= 0\n]\noutput_soc2:(0.0, 100.0)\noutput_soc3:(0.0, 100.0)\noutput_soc4:(0.0, 100.0)\nsoc5_exit:(0.0, 100.0)\n</pre> In\u00a0[24]: Copied! <pre>back1234=scenario_sequence(c1=dsn1_power, c2=back234, variables=[\"soc\"], c1index=1)\nprint(f\"---- Steps 1,2,3,4\\n{back1234}\")\nprint(\"output_soc2:\"+str(back1234.get_variable_bounds(\"output_soc1\")))\nprint(\"output_soc2:\"+str(back1234.get_variable_bounds(\"output_soc2\")))\nprint(\"output_soc3:\"+str(back1234.get_variable_bounds(\"output_soc3\")))\nprint(\"output_soc4:\"+str(back1234.get_variable_bounds(\"output_soc4\")))\nprint(\"soc5_exit:\"+str(back1234.get_variable_bounds(\"soc5_exit\")))\n</pre> back1234=scenario_sequence(c1=dsn1_power, c2=back234, variables=[\"soc\"], c1index=1) print(f\"---- Steps 1,2,3,4\\n{back1234}\") print(\"output_soc2:\"+str(back1234.get_variable_bounds(\"output_soc1\"))) print(\"output_soc2:\"+str(back1234.get_variable_bounds(\"output_soc2\"))) print(\"output_soc3:\"+str(back1234.get_variable_bounds(\"output_soc3\"))) print(\"output_soc4:\"+str(back1234.get_variable_bounds(\"output_soc4\"))) print(\"soc5_exit:\"+str(back1234.get_variable_bounds(\"soc5_exit\"))) <pre>---- Steps 1,2,3,4\nInVars: [soc1_entry, duration_dsn1, duration_charging2, duration_sbo3, duration_tcm_heating4, duration_tcm_deltav5]\nOutVars:[soc5_exit, output_soc4, output_soc3, output_soc2, output_soc1]\nA: [\n  -duration_tcm_deltav5 &lt;= 0\n  -3 duration_charging2 + 4.2 duration_dsn1 + 1.4 duration_sbo3 + 0.6 duration_tcm_deltav5 + 0.8 duration_tcm_heating4 - soc1_entry &lt;= 0\n  -duration_tcm_heating4 &lt;= 0\n  -duration_sbo3 &lt;= 0\n  -duration_charging2 &lt;= 0\n  4 duration_charging2 - 3.8 duration_dsn1 + soc1_entry &lt;= 100\n  -duration_dsn1 &lt;= 0\n  soc1_entry &lt;= 100\n  4.2 duration_dsn1 - soc1_entry &lt;= 0\n]\nG: [\n  -4.2 duration_dsn1 - output_soc1 + soc1_entry &lt;= 0\n  3.8 duration_dsn1 + output_soc1 - soc1_entry &lt;= 0\n  -4 duration_charging2 - output_soc1 + output_soc2 &lt;= 0\n  3 duration_charging2 + output_soc1 - output_soc2 &lt;= 0\n  -1.4 duration_sbo3 + output_soc2 - output_soc3 &lt;= 0\n  duration_sbo3 - output_soc2 + output_soc3 &lt;= 0\n  -0.8 duration_tcm_heating4 + output_soc3 - output_soc4 &lt;= 0\n  0.7 duration_tcm_heating4 - output_soc3 + output_soc4 &lt;= 0\n  -0.6 duration_tcm_deltav5 + output_soc4 - soc5_exit &lt;= 0\n  0.5 duration_tcm_deltav5 - output_soc4 + soc5_exit &lt;= 0\n]\noutput_soc2:(0.0, 100.0)\noutput_soc2:(0.0, 100.0)\noutput_soc3:(0.0, 100.0)\noutput_soc4:(0.0, 100.0)\nsoc5_exit:(0.0, 100.0)\n</pre> In\u00a0[17]: Copied! <pre>steps1234=scenario_sequence(c1=steps123, c2=tcm1_power, variables=[\"soc\"], c1index=3)\nprint(f\"---- Steps 1,2,3,4\\n{steps1234}\")\nprint(\"output_soc1:\"+str(steps123.get_variable_bounds(\"output_soc1\")))\nprint(\"output_soc2:\"+str(steps123.get_variable_bounds(\"output_soc2\")))\nprint(\"output_soc3:\"+str(steps123.get_variable_bounds(\"output_soc3\")))\nprint(\"output_soc4:\"+str(steps123.get_variable_bounds(\"output_soc4\")))\nprint(\"soc5_exit:\"+str(steps123.get_variable_bounds(\"soc5_exit\")))\nprint(steps1234.get_variable_bounds(\"duration_dsn1\"))\nprint(steps1234.get_variable_bounds(\"duration_charging2\"))\nprint(steps1234.get_variable_bounds(\"duration_sbo3\"))\nprint(steps1234.get_variable_bounds(\"duration_tcm_heating4\"))\nprint(steps1234.get_variable_bounds(\"duration_tcm_deltav5\"))\n</pre> steps1234=scenario_sequence(c1=steps123, c2=tcm1_power, variables=[\"soc\"], c1index=3) print(f\"---- Steps 1,2,3,4\\n{steps1234}\") print(\"output_soc1:\"+str(steps123.get_variable_bounds(\"output_soc1\"))) print(\"output_soc2:\"+str(steps123.get_variable_bounds(\"output_soc2\"))) print(\"output_soc3:\"+str(steps123.get_variable_bounds(\"output_soc3\"))) print(\"output_soc4:\"+str(steps123.get_variable_bounds(\"output_soc4\"))) print(\"soc5_exit:\"+str(steps123.get_variable_bounds(\"soc5_exit\"))) print(steps1234.get_variable_bounds(\"duration_dsn1\")) print(steps1234.get_variable_bounds(\"duration_charging2\")) print(steps1234.get_variable_bounds(\"duration_sbo3\")) print(steps1234.get_variable_bounds(\"duration_tcm_heating4\")) print(steps1234.get_variable_bounds(\"duration_tcm_deltav5\")) <pre>---- Steps 1,2,3,4\nInVars: [soc1_entry, duration_dsn1, duration_charging2, duration_sbo3, duration_tcm_heating4, duration_tcm_deltav5]\nOutVars:[output_soc1, output_soc2, soc5_exit, output_soc4, output_soc3]\nA: [\n  -duration_tcm_deltav5 &lt;= 0\n  -4 duration_charging2 + 3.8 duration_dsn1 + 1.4 duration_sbo3 + 0.6 duration_tcm_deltav5 + 0.8 duration_tcm_heating4 - soc1_entry &lt;= 0\n  -duration_tcm_heating4 &lt;= 0\n  -duration_sbo3 &lt;= 0\n  -3 duration_charging2 + 3.8 duration_dsn1 + 1.4 duration_sbo3 - soc1_entry &lt;= 0\n  -duration_charging2 &lt;= 0\n  4 duration_charging2 - 3.8 duration_dsn1 + soc1_entry &lt;= 100\n  -duration_dsn1 &lt;= 0\n  soc1_entry &lt;= 100\n  4.2 duration_dsn1 - soc1_entry &lt;= 0\n]\nG: [\n  -4.2 duration_dsn1 - output_soc1 + soc1_entry &lt;= 0\n  3.8 duration_dsn1 + output_soc1 - soc1_entry &lt;= 0\n  -4 duration_charging2 - output_soc1 + output_soc2 &lt;= 0\n  3 duration_charging2 + output_soc1 - output_soc2 &lt;= 0\n  -1.4 duration_sbo3 + output_soc2 - output_soc3 &lt;= 0\n  duration_sbo3 - output_soc2 + output_soc3 &lt;= 0\n  -0.8 duration_tcm_heating4 + output_soc3 - output_soc4 &lt;= 0\n  0.7 duration_tcm_heating4 - output_soc3 + output_soc4 &lt;= 0\n  -0.6 duration_tcm_deltav5 + output_soc4 - soc5_exit &lt;= 0\n  0.5 duration_tcm_deltav5 - output_soc4 + soc5_exit &lt;= 0\n]\noutput_soc1:(0.0, 100.0)\noutput_soc2:(0.0, 100.0)\noutput_soc3:(None, None)\noutput_soc4:(None, None)\nsoc5_exit:(None, None)\n(0.0, 23.80952380952381)\n(0.0, 25.0)\n(0.0, 71.42857142857143)\n(0.0, 125.0)\n(0.0, 166.66666666666669)\n</pre> In\u00a0[12]: Copied! <pre>scenario_power=steps1234.rename_variables([(\"soc5_exit\", \"output_soc5\")])\nprint(f\"scenario_power={scenario_power}\")\n</pre> scenario_power=steps1234.rename_variables([(\"soc5_exit\", \"output_soc5\")]) print(f\"scenario_power={scenario_power}\") <pre>scenario_power=InVars: [soc1_entry, duration_dsn1, duration_charging2, duration_sbo3, duration_tcm_heating4, duration_tcm_deltav5]\nOutVars:[output_soc1, output_soc2, output_soc4, output_soc3, output_soc5]\nA: [\n  -duration_tcm_deltav5 &lt;= 0\n  -4 duration_charging2 + 3.8 duration_dsn1 + 1.4 duration_sbo3 + 0.6 duration_tcm_deltav5 + 0.8 duration_tcm_heating4 - soc1_entry &lt;= 0\n  -duration_tcm_heating4 &lt;= 0\n  -duration_sbo3 &lt;= 0\n  -3 duration_charging2 + 3.8 duration_dsn1 + 1.4 duration_sbo3 - soc1_entry &lt;= 0\n  -duration_charging2 &lt;= 0\n  4 duration_charging2 - 3.8 duration_dsn1 + soc1_entry &lt;= 100\n  -duration_dsn1 &lt;= 0\n  soc1_entry &lt;= 100\n  4.2 duration_dsn1 - soc1_entry &lt;= 0\n]\nG: [\n  -4.2 duration_dsn1 - output_soc1 + soc1_entry &lt;= 0\n  3.8 duration_dsn1 + output_soc1 - soc1_entry &lt;= 0\n  -4 duration_charging2 - output_soc1 + output_soc2 &lt;= 0\n  3 duration_charging2 + output_soc1 - output_soc2 &lt;= 0\n  -1.4 duration_sbo3 + output_soc2 - output_soc3 &lt;= 0\n  duration_sbo3 - output_soc2 + output_soc3 &lt;= 0\n  -0.8 duration_tcm_heating4 + output_soc3 - output_soc4 &lt;= 0\n  0.7 duration_tcm_heating4 - output_soc3 + output_soc4 &lt;= 0\n  -0.6 duration_tcm_deltav5 + output_soc4 - output_soc5 &lt;= 0\n  0.5 duration_tcm_deltav5 - output_soc4 + output_soc5 &lt;= 0\n]\n</pre> In\u00a0[13]: remove_cell Copied! <pre>write_contracts_to_file(contracts=[scenario_power], names=[\"scenario_power\"], file_name=\"json/scenario_power.json\")\n</pre> write_contracts_to_file(contracts=[scenario_power], names=[\"scenario_power\"], file_name=\"json/scenario_power.json\")"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_power/#power-viewpoint-modeling","title":"Power viewpoint modeling\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_power/#charging-task","title":"CHARGING Task\u00b6","text":"<p>Objective: charge the spacecraft battery</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint with impacts that are linear with the duration of the task:</p> <ul> <li>the battery charges proportionally to a generation rate.</li> </ul>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_power/#power-consuming-tasks-dsn-sbo-tcm","title":"Power-consuming Tasks (DSN, SBO, TCM)\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_power/#dsn-task","title":"DSN Task\u00b6","text":"<p>Objective: downlink science data to Earth.</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint with impacts that are linear with the duration of the task:</p> <ul> <li>the battery discharges proportionally to a consumption rate.</li> </ul>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_power/#sbo-task-small-body-observations","title":"SBO Task (Small body observations)\u00b6","text":"<p>Objective: Acquire small body observations (science data &amp; navigation)</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint with impacts that are linear with the duration of the task:</p> <ul> <li>the battery discharges proportionally to a consumption rate.</li> </ul>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_power/#tcm-task-perform-a-trajectory-correction-maneuver","title":"TCM Task (Perform a Trajectory Correction Maneuver)\u00b6","text":"<p>Objective: Perform a delta-V maneuver to bring the spacecraft trajectory closer to that of the small body.</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint with impacts that are linear with the duration of the task:</p> <ul> <li>Power: the thrusters must be heated before firing them, thereby discharging the battery proportionally to a consumption rate.</li> </ul> <p>Since heating the thruster must happen just before firing them, this task is modeled as the composition of two subtasks: Heating and DeltaV.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_power/#tcm-heating-subtask","title":"TCM Heating SubTask\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_power/#tcm-deltav-subtask","title":"TCM DeltaV SubTask\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_power/#composing-tcm-subtasks","title":"Composing TCM SubTasks\u00b6","text":"<p>Algebraic composition allows us to capture the requirement that a TCM Heating subtask must always precede a TCM DeltaV subtask by composing them.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_power/#power-schedule-analysis","title":"Power Schedule Analysis\u00b6","text":"<p>Let's consider a simple 4-step schedule of the following sequence of task instances, which we compose:</p> <ul> <li>DSN</li> <li>CHARGING</li> <li>SBO</li> <li>TCM</li> </ul>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_power/#power-schedule-constraints","title":"Power Schedule constraints\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_science/","title":"Science & Communication Viewpoint","text":"In\u00a0[1]: Copied! <pre>%matplotlib widget\n\n#from IPython import display\nfrom base64 import b64decode\nfrom pacti import write_contracts_to_file\nfrom pacti.terms.polyhedra import *\nfrom pacti.iocontract import IoContract, Var\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport os\nimport numpy as np\nfrom matplotlib import patches\nimport pdb\nfrom matplotlib.collections import PatchCollection\nfrom contract_utils import *\n</pre> %matplotlib widget  #from IPython import display from base64 import b64decode from pacti import write_contracts_to_file from pacti.terms.polyhedra import * from pacti.iocontract import IoContract, Var from PIL import Image import matplotlib.pyplot as plt import os import numpy as np from matplotlib import patches import pdb from matplotlib.collections import PatchCollection from contract_utils import * In\u00a0[2]: Copied! <pre>charging1_science = nochange_contract(s=2, name=\"d\").merge(nochange_contract(s=2, name=\"c\"))\nprint(f\"charging1_science:\\n\\n{charging1_science}\")\n</pre> charging1_science = nochange_contract(s=2, name=\"d\").merge(nochange_contract(s=2, name=\"c\")) print(f\"charging1_science:\\n\\n{charging1_science}\") <pre>charging1_science:\n\nInVars: [d2_entry, c2_entry]\nOutVars:[d2_exit, c2_exit]\nA: [\n  -d2_entry &lt;= 0\n  -c2_entry &lt;= 0\n]\nG: [\n  -d2_entry + d2_exit = 0\n  -c2_entry + c2_exit = 0\n]\n</pre> In\u00a0[3]: Copied! <pre># - s: start index of the timeline variables\n# - speed: (min, max) downlink rate during the task instance\ndef DSN_data(s: int, speed: Tuple[float, float]) -&gt; PolyhedralContract:\n  spec = PolyhedralContract.from_string(\n    input_vars = [\n      f\"d{s}_entry\",        # initial data volume\n      f\"duration_dsn{s}\",   # variable task duration\n    ],\n    output_vars = [\n      f\"d{s}_exit\",          # final data volume\n    ],\n    assumptions = [\n      # Task has a positive scheduled duration\n      f\"-duration_dsn{s} &lt;= 0\",\n\n      # downlink data upper bound\n      f\" d{s}_entry &lt;= 100\",\n\n      # downlink data lower bound\n      f\"-d{s}_entry &lt;= 0\",\n    ],\n    guarantees = [\n      # duration*speed(min) &lt;= d{entry} - d{exit} &lt;= duration*speed(max)\n      f\" d{s}_entry - d{s}_exit - {speed[1]}*duration_dsn{s} &lt;= 0\",\n      f\"-d{s}_entry + d{s}_exit + {speed[0]}*duration_dsn{s} &lt;= 0\",\n\n      # downlink cannot continue if there is no data left.\n      f\"-d{s}_exit &lt;= 0\",\n    ])\n  return spec\n\ndsn1_science_storage = DSN_data(s=1, speed=(5.2, 5.5))\nprint(f\"Contract dsn1_science_storage:\\n\\n{dsn1_science_storage}\")\n\n_ = plot_guarantees(contract=dsn1_science_storage,\n                x_var=Var(\"duration_dsn1\"),\n                y_var=Var(\"d1_exit\"),\n                var_values={\n                  Var(\"d1_entry\"):80,\n                },\n                x_lims=(0,20),\n                y_lims=(0,80))\n</pre> # - s: start index of the timeline variables # - speed: (min, max) downlink rate during the task instance def DSN_data(s: int, speed: Tuple[float, float]) -&gt; PolyhedralContract:   spec = PolyhedralContract.from_string(     input_vars = [       f\"d{s}_entry\",        # initial data volume       f\"duration_dsn{s}\",   # variable task duration     ],     output_vars = [       f\"d{s}_exit\",          # final data volume     ],     assumptions = [       # Task has a positive scheduled duration       f\"-duration_dsn{s} &lt;= 0\",        # downlink data upper bound       f\" d{s}_entry &lt;= 100\",        # downlink data lower bound       f\"-d{s}_entry &lt;= 0\",     ],     guarantees = [       # duration*speed(min) &lt;= d{entry} - d{exit} &lt;= duration*speed(max)       f\" d{s}_entry - d{s}_exit - {speed[1]}*duration_dsn{s} &lt;= 0\",       f\"-d{s}_entry + d{s}_exit + {speed[0]}*duration_dsn{s} &lt;= 0\",        # downlink cannot continue if there is no data left.       f\"-d{s}_exit &lt;= 0\",     ])   return spec  dsn1_science_storage = DSN_data(s=1, speed=(5.2, 5.5)) print(f\"Contract dsn1_science_storage:\\n\\n{dsn1_science_storage}\")  _ = plot_guarantees(contract=dsn1_science_storage,                 x_var=Var(\"duration_dsn1\"),                 y_var=Var(\"d1_exit\"),                 var_values={                   Var(\"d1_entry\"):80,                 },                 x_lims=(0,20),                 y_lims=(0,80)) <pre>Contract dsn1_science_storage:\n\nInVars: [d1_entry, duration_dsn1]\nOutVars:[d1_exit]\nA: [\n  -duration_dsn1 &lt;= 0\n  d1_entry &lt;= 100\n  -d1_entry &lt;= 0\n]\nG: [\n  d1_entry - d1_exit - 5.5 duration_dsn1 &lt;= 0\n  -d1_entry + d1_exit + 5.2 duration_dsn1 &lt;= 0\n  -d1_exit &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[4]: Copied! <pre>dsn1_science_cumulative = nochange_contract(s=1, name=\"c\")\nprint(f\"dsn1_science_cumulative:\\n\\n{dsn1_science_cumulative}\")\n</pre> dsn1_science_cumulative = nochange_contract(s=1, name=\"c\") print(f\"dsn1_science_cumulative:\\n\\n{dsn1_science_cumulative}\") <pre>dsn1_science_cumulative:\n\nInVars: [c1_entry]\nOutVars:[c1_exit]\nA: [\n  -c1_entry &lt;= 0\n]\nG: [\n  -c1_entry + c1_exit = 0\n]\n</pre> In\u00a0[5]: Copied! <pre>dsn1_science = dsn1_science_storage.merge(dsn1_science_cumulative)\nprint(f\"dsn1_science:\\n\\n{dsn1_science}\")\n</pre> dsn1_science = dsn1_science_storage.merge(dsn1_science_cumulative) print(f\"dsn1_science:\\n\\n{dsn1_science}\") <pre>dsn1_science:\n\nInVars: [d1_entry, duration_dsn1, c1_entry]\nOutVars:[d1_exit, c1_exit]\nA: [\n  -duration_dsn1 &lt;= 0\n  d1_entry &lt;= 100\n  -d1_entry &lt;= 0\n  -c1_entry &lt;= 0\n]\nG: [\n  d1_entry - d1_exit - 5.5 duration_dsn1 &lt;= 0\n  -d1_entry + d1_exit + 5.2 duration_dsn1 &lt;= 0\n  -d1_exit &lt;= 0\n  -c1_entry + c1_exit = 0\n]\n</pre> In\u00a0[6]: Copied! <pre># Parameters:\n# - s: start index of the timeline variables\n# - generation: (min, max) rate of small body observations during the task instance\ndef SBO_science_storage(s: int, generation: Tuple[float, float]) -&gt; PolyhedralContract:\n  spec = PolyhedralContract.from_string(\n    input_vars = [\n      f\"d{s}_entry\",        # initial data storage volume\n      f\"duration_sbo{s}\",   # knob variable for SBO duration\n    ],\n    output_vars = [\n      f\"d{s}_exit\",         # final data storage volume\n    ],\n    assumptions = [\n      # Task has a positive scheduled duration\n      f\"-duration_sbo{s} &lt;= 0\",\n\n      # There is enough data storage available\n      f\"d{s}_entry + {generation[1]}*duration_sbo{s} &lt;= 100\",\n\n      # downlink data lower bound\n      f\"-d{s}_entry &lt;= 0\",\n    ],\n    guarantees = [\n      # duration*generation(min) &lt;= d{exit} - d{entry} &lt;= duration*generation(max)\n      f\" d{s}_exit - d{s}_entry - {generation[1]}*duration_sbo{s} &lt;= 0\",\n      f\"-d{s}_exit + d{s}_entry + {generation[0]}*duration_sbo{s} &lt;= 0\",\n\n      # Data volume cannot exceed the available storage capacity\n      f\"d{s}_exit &lt;= 100\",\n    ])\n  return spec\n\nsbo1_science_storage = SBO_science_storage(s=3, generation=(3.0, 4.0))\nprint(f\"Contract sbo1_science_storage:\\n\\n{sbo1_science_storage}\")\n\n_ = plot_guarantees(contract=sbo1_science_storage,\n                x_var=Var(\"duration_sbo3\"),\n                y_var=Var(\"d3_exit\"),\n                var_values={\n                  Var(\"d3_entry\"):0,\n                },\n                x_lims=(0,100),\n                y_lims=(0,100))\n</pre> # Parameters: # - s: start index of the timeline variables # - generation: (min, max) rate of small body observations during the task instance def SBO_science_storage(s: int, generation: Tuple[float, float]) -&gt; PolyhedralContract:   spec = PolyhedralContract.from_string(     input_vars = [       f\"d{s}_entry\",        # initial data storage volume       f\"duration_sbo{s}\",   # knob variable for SBO duration     ],     output_vars = [       f\"d{s}_exit\",         # final data storage volume     ],     assumptions = [       # Task has a positive scheduled duration       f\"-duration_sbo{s} &lt;= 0\",        # There is enough data storage available       f\"d{s}_entry + {generation[1]}*duration_sbo{s} &lt;= 100\",        # downlink data lower bound       f\"-d{s}_entry &lt;= 0\",     ],     guarantees = [       # duration*generation(min) &lt;= d{exit} - d{entry} &lt;= duration*generation(max)       f\" d{s}_exit - d{s}_entry - {generation[1]}*duration_sbo{s} &lt;= 0\",       f\"-d{s}_exit + d{s}_entry + {generation[0]}*duration_sbo{s} &lt;= 0\",        # Data volume cannot exceed the available storage capacity       f\"d{s}_exit &lt;= 100\",     ])   return spec  sbo1_science_storage = SBO_science_storage(s=3, generation=(3.0, 4.0)) print(f\"Contract sbo1_science_storage:\\n\\n{sbo1_science_storage}\")  _ = plot_guarantees(contract=sbo1_science_storage,                 x_var=Var(\"duration_sbo3\"),                 y_var=Var(\"d3_exit\"),                 var_values={                   Var(\"d3_entry\"):0,                 },                 x_lims=(0,100),                 y_lims=(0,100)) <pre>Contract sbo1_science_storage:\n\nInVars: [d3_entry, duration_sbo3]\nOutVars:[d3_exit]\nA: [\n  -duration_sbo3 &lt;= 0\n  d3_entry + 4 duration_sbo3 &lt;= 100\n  -d3_entry &lt;= 0\n]\nG: [\n  -d3_entry + d3_exit - 4 duration_sbo3 &lt;= 0\n  d3_entry - d3_exit + 3 duration_sbo3 &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[7]: Copied! <pre>def SBO_science_comulative(s: int, generation: Tuple[float, float]) -&gt; PolyhedralContract:\n  spec = PolyhedralContract.from_string(\n    input_vars = [\n      f\"c{s}_entry\",        # initial cumulative data volume\n      f\"duration_sbo{s}\",   # knob variable for SBO duration\n    ],\n    output_vars = [\n      f\"c{s}_exit\",         # final cumulative data volume\n    ],\n    assumptions = [\n      # Task has a positive scheduled duration\n      f\"-duration_sbo{s} &lt;= 0\",\n\n      # cumulative data lower bound\n      f\"-c{s}_entry &lt;= 0\",\n    ],\n    guarantees = [\n      # duration*generation(min) &lt;= c{exit} - c{entry} &lt;= duration*generation(max)\n      f\" c{s}_exit - c{s}_entry - {generation[1]}*duration_sbo{s} &lt;= 0\",\n      f\"-c{s}_exit + c{s}_entry + {generation[0]}*duration_sbo{s} &lt;= 0\",\n    ])\n  return spec\n\nsbo1_science_cumulative = SBO_science_comulative(s=3, generation=(3.0, 4.0))\nprint(f\"Contract sbo1_science_cumulative:\\n\\n{sbo1_science_cumulative}\")\n\n_ = plot_guarantees(contract=sbo1_science_cumulative,\n                x_var=Var(\"duration_sbo3\"),\n                y_var=Var(\"c3_exit\"),\n                var_values={\n                  Var(\"c3_entry\"):0,\n                },\n                x_lims=(0,100),\n                y_lims=(0,100))\n</pre> def SBO_science_comulative(s: int, generation: Tuple[float, float]) -&gt; PolyhedralContract:   spec = PolyhedralContract.from_string(     input_vars = [       f\"c{s}_entry\",        # initial cumulative data volume       f\"duration_sbo{s}\",   # knob variable for SBO duration     ],     output_vars = [       f\"c{s}_exit\",         # final cumulative data volume     ],     assumptions = [       # Task has a positive scheduled duration       f\"-duration_sbo{s} &lt;= 0\",        # cumulative data lower bound       f\"-c{s}_entry &lt;= 0\",     ],     guarantees = [       # duration*generation(min) &lt;= c{exit} - c{entry} &lt;= duration*generation(max)       f\" c{s}_exit - c{s}_entry - {generation[1]}*duration_sbo{s} &lt;= 0\",       f\"-c{s}_exit + c{s}_entry + {generation[0]}*duration_sbo{s} &lt;= 0\",     ])   return spec  sbo1_science_cumulative = SBO_science_comulative(s=3, generation=(3.0, 4.0)) print(f\"Contract sbo1_science_cumulative:\\n\\n{sbo1_science_cumulative}\")  _ = plot_guarantees(contract=sbo1_science_cumulative,                 x_var=Var(\"duration_sbo3\"),                 y_var=Var(\"c3_exit\"),                 var_values={                   Var(\"c3_entry\"):0,                 },                 x_lims=(0,100),                 y_lims=(0,100)) <pre>Contract sbo1_science_cumulative:\n\nInVars: [c3_entry, duration_sbo3]\nOutVars:[c3_exit]\nA: [\n  -duration_sbo3 &lt;= 0\n  -c3_entry &lt;= 0\n]\nG: [\n  -c3_entry + c3_exit - 4 duration_sbo3 &lt;= 0\n  c3_entry - c3_exit + 3 duration_sbo3 &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[8]: Copied! <pre>sbo1_science = sbo1_science_storage.merge(sbo1_science_cumulative)\nprint(f\"Contract sbo1_science:\\n\\n{sbo1_science}\")\n</pre> sbo1_science = sbo1_science_storage.merge(sbo1_science_cumulative) print(f\"Contract sbo1_science:\\n\\n{sbo1_science}\") <pre>Contract sbo1_science:\n\nInVars: [d3_entry, duration_sbo3, c3_entry]\nOutVars:[d3_exit, c3_exit]\nA: [\n  -duration_sbo3 &lt;= 0\n  d3_entry + 4 duration_sbo3 &lt;= 100\n  -d3_entry &lt;= 0\n  -c3_entry &lt;= 0\n]\nG: [\n  -d3_entry + d3_exit - 4 duration_sbo3 &lt;= 0\n  d3_entry - d3_exit + 3 duration_sbo3 &lt;= 0\n  -c3_entry + c3_exit - 4 duration_sbo3 &lt;= 0\n  c3_entry - c3_exit + 3 duration_sbo3 &lt;= 0\n]\n</pre> In\u00a0[9]: Copied! <pre>tcm1_science_heating = nochange_contract(s=4, name=\"d\").merge(nochange_contract(s=4, name=\"c\"))\nprint(f\"tcm1_science_heating:\\n{tcm1_science_heating}\")\n</pre> tcm1_science_heating = nochange_contract(s=4, name=\"d\").merge(nochange_contract(s=4, name=\"c\")) print(f\"tcm1_science_heating:\\n{tcm1_science_heating}\") <pre>tcm1_science_heating:\nInVars: [d4_entry, c4_entry]\nOutVars:[d4_exit, c4_exit]\nA: [\n  -d4_entry &lt;= 0\n  -c4_entry &lt;= 0\n]\nG: [\n  -d4_entry + d4_exit = 0\n  -c4_entry + c4_exit = 0\n]\n</pre> In\u00a0[10]: Copied! <pre>tcm1_science_deltav = nochange_contract(s=5, name=\"d\").merge(nochange_contract(s=5, name=\"c\"))\nprint(f\"tcm1_science_deltav:\\n{tcm1_science_deltav}\")\n</pre> tcm1_science_deltav = nochange_contract(s=5, name=\"d\").merge(nochange_contract(s=5, name=\"c\")) print(f\"tcm1_science_deltav:\\n{tcm1_science_deltav}\") <pre>tcm1_science_deltav:\nInVars: [d5_entry, c5_entry]\nOutVars:[d5_exit, c5_exit]\nA: [\n  -d5_entry &lt;= 0\n  -c5_entry &lt;= 0\n]\nG: [\n  -d5_entry + d5_exit = 0\n  -c5_entry + c5_exit = 0\n]\n</pre> In\u00a0[11]: Copied! <pre>tcm1_science = scenario_sequence(c1=tcm1_science_heating, c2=tcm1_science_deltav, variables=[\"d\", \"c\"], c1index=4)\nprint(f\"tcm1_science:\\n{tcm1_science}\")\n</pre> tcm1_science = scenario_sequence(c1=tcm1_science_heating, c2=tcm1_science_deltav, variables=[\"d\", \"c\"], c1index=4) print(f\"tcm1_science:\\n{tcm1_science}\") <pre>tcm1_science:\nInVars: [d4_entry, c4_entry]\nOutVars:[d5_exit, c5_exit, output_d4, output_c4]\nA: [\n  -d4_entry &lt;= 0\n  -c4_entry &lt;= 0\n]\nG: [\n  -d4_entry + output_d4 = 0\n  -c4_entry + output_c4 = 0\n  d5_exit - output_d4 = 0\n  c5_exit - output_c4 = 0\n]\n</pre> In\u00a0[12]: Copied! <pre>print(dsn1_science)\n</pre> print(dsn1_science) <pre>InVars: [d1_entry, duration_dsn1, c1_entry]\nOutVars:[d1_exit, c1_exit]\nA: [\n  -duration_dsn1 &lt;= 0\n  d1_entry &lt;= 100\n  -d1_entry &lt;= 0\n  -c1_entry &lt;= 0\n]\nG: [\n  d1_entry - d1_exit - 5.5 duration_dsn1 &lt;= 0\n  -d1_entry + d1_exit + 5.2 duration_dsn1 &lt;= 0\n  -d1_exit &lt;= 0\n  -c1_entry + c1_exit = 0\n]\n</pre> In\u00a0[13]: Copied! <pre>steps12=scenario_sequence(c1=dsn1_science, c2=charging1_science, variables=[\"d\", \"c\"], c1index=1)\nprint(f\"---- Steps 1,2\\n{steps12}\")\nprint(steps12.get_variable_bounds(\"output_d1\"))\nprint(steps12.get_variable_bounds(\"output_c1\"))\n</pre> steps12=scenario_sequence(c1=dsn1_science, c2=charging1_science, variables=[\"d\", \"c\"], c1index=1) print(f\"---- Steps 1,2\\n{steps12}\") print(steps12.get_variable_bounds(\"output_d1\")) print(steps12.get_variable_bounds(\"output_c1\")) <pre>---- Steps 1,2\nInVars: [d1_entry, duration_dsn1, c1_entry]\nOutVars:[d2_exit, c2_exit, output_d1, output_c1]\nA: [\n  -duration_dsn1 &lt;= 0\n  d1_entry &lt;= 100\n  -d1_entry &lt;= 0\n  -c1_entry &lt;= 0\n]\nG: [\n  d1_entry - 5.5 duration_dsn1 - output_d1 &lt;= 0\n  -d1_entry + 5.2 duration_dsn1 + output_d1 &lt;= 0\n  -output_d1 &lt;= 0\n  -c1_entry + output_c1 = 0\n  d2_exit - output_d1 = 0\n  c2_exit - output_c1 = 0\n]\n(0.0, 100.0)\n(0.0, None)\n</pre> In\u00a0[14]: Copied! <pre>steps123=scenario_sequence(c1=steps12, c2=sbo1_science, variables=[\"d\", \"c\"], c1index=2)\nprint(f\"---- Steps 1,2,3\\n{steps123}\")\nprint(steps123.get_variable_bounds(\"output_d2\"))\nprint(steps123.get_variable_bounds(\"output_c2\"))\nprint(steps123.get_variable_bounds(\"duration_sbo3\"))\n</pre> steps123=scenario_sequence(c1=steps12, c2=sbo1_science, variables=[\"d\", \"c\"], c1index=2) print(f\"---- Steps 1,2,3\\n{steps123}\") print(steps123.get_variable_bounds(\"output_d2\")) print(steps123.get_variable_bounds(\"output_c2\")) print(steps123.get_variable_bounds(\"duration_sbo3\")) <pre>---- Steps 1,2,3\nInVars: [d1_entry, duration_dsn1, c1_entry, duration_sbo3]\nOutVars:[output_d1, output_c1, d3_exit, c3_exit, output_d2, output_c2]\nA: [\n  -duration_sbo3 &lt;= 0\n  d1_entry - 5.2 duration_dsn1 + 4 duration_sbo3 &lt;= 100\n  -duration_dsn1 &lt;= 0\n  d1_entry &lt;= 100\n  -d1_entry &lt;= 0\n  -c1_entry &lt;= 0\n]\nG: [\n  d1_entry - 5.5 duration_dsn1 - output_d1 &lt;= 0\n  -d1_entry + 5.2 duration_dsn1 + output_d1 &lt;= 0\n  -output_d1 &lt;= 0\n  -c1_entry + output_c1 = 0\n  -output_d1 + output_d2 = 0\n  -output_c1 + output_c2 = 0\n  d3_exit - 4 duration_sbo3 - output_d2 &lt;= 0\n  -d3_exit + 3 duration_sbo3 + output_d2 &lt;= 0\n  c3_exit - 4 duration_sbo3 - output_c2 &lt;= 0\n  -c3_exit + 3 duration_sbo3 + output_c2 &lt;= 0\n]\n(0.0, 100.0)\n(0.0, None)\n(0.0, 25.0)\n</pre> In\u00a0[15]: Copied! <pre>steps1234=scenario_sequence(c1=steps123, c2=tcm1_science, variables=[\"d\", \"c\"], c1index=3)\nprint(f\"---- Steps 1,2,3,4\\n{steps1234}\")\nprint(steps1234.get_variable_bounds(\"output_d3\"))\nprint(steps1234.get_variable_bounds(\"output_c3\"))\n</pre> steps1234=scenario_sequence(c1=steps123, c2=tcm1_science, variables=[\"d\", \"c\"], c1index=3) print(f\"---- Steps 1,2,3,4\\n{steps1234}\") print(steps1234.get_variable_bounds(\"output_d3\")) print(steps1234.get_variable_bounds(\"output_c3\")) <pre>---- Steps 1,2,3,4\nInVars: [d1_entry, duration_dsn1, c1_entry, duration_sbo3]\nOutVars:[output_d1, output_c1, output_d2, output_c2, d5_exit, c5_exit, output_d4, output_c4, output_d3, output_c3]\nA: [\n  -duration_sbo3 &lt;= 0\n  d1_entry - 5.2 duration_dsn1 + 4 duration_sbo3 &lt;= 100\n  -duration_dsn1 &lt;= 0\n  d1_entry &lt;= 100\n  -d1_entry &lt;= 0\n  -c1_entry &lt;= 0\n]\nG: [\n  d1_entry - 5.5 duration_dsn1 - output_d1 &lt;= 0\n  -d1_entry + 5.2 duration_dsn1 + output_d1 &lt;= 0\n  -output_d1 &lt;= 0\n  -c1_entry + output_c1 = 0\n  -output_d1 + output_d2 = 0\n  -output_c1 + output_c2 = 0\n  -4 duration_sbo3 - output_d2 + output_d3 &lt;= 0\n  3 duration_sbo3 + output_d2 - output_d3 &lt;= 0\n  -4 duration_sbo3 - output_c2 + output_c3 &lt;= 0\n  3 duration_sbo3 + output_c2 - output_c3 &lt;= 0\n  -output_d3 + output_d4 = 0\n  -output_c3 + output_c4 = 0\n  d5_exit - output_d4 = 0\n  c5_exit - output_c4 = 0\n]\n(0.0, 100.0)\n(0.0, None)\n</pre> In\u00a0[16]: Copied! <pre>scenario_science=steps1234.rename_variables([\n    (\"d4_exit\", \"output_d4\"), \n    (\"c4_exit\", \"output_c4\"),\n    (\"d5_exit\", \"output_d5\"), \n    (\"c5_exit\", \"output_c5\")])\nprint(f\"scenario_science={scenario_science}\")\n</pre> scenario_science=steps1234.rename_variables([     (\"d4_exit\", \"output_d4\"),      (\"c4_exit\", \"output_c4\"),     (\"d5_exit\", \"output_d5\"),      (\"c5_exit\", \"output_c5\")]) print(f\"scenario_science={scenario_science}\") <pre>scenario_science=InVars: [d1_entry, duration_dsn1, c1_entry, duration_sbo3]\nOutVars:[output_d1, output_c1, output_d2, output_c2, output_d4, output_c4, output_d3, output_c3, output_d5, output_c5]\nA: [\n  -duration_sbo3 &lt;= 0\n  d1_entry - 5.2 duration_dsn1 + 4 duration_sbo3 &lt;= 100\n  -duration_dsn1 &lt;= 0\n  d1_entry &lt;= 100\n  -d1_entry &lt;= 0\n  -c1_entry &lt;= 0\n]\nG: [\n  d1_entry - 5.5 duration_dsn1 - output_d1 &lt;= 0\n  -d1_entry + 5.2 duration_dsn1 + output_d1 &lt;= 0\n  -output_d1 &lt;= 0\n  -c1_entry + output_c1 = 0\n  -output_d1 + output_d2 = 0\n  -output_c1 + output_c2 = 0\n  -4 duration_sbo3 - output_d2 + output_d3 &lt;= 0\n  3 duration_sbo3 + output_d2 - output_d3 &lt;= 0\n  -4 duration_sbo3 - output_c2 + output_c3 &lt;= 0\n  3 duration_sbo3 + output_c2 - output_c3 &lt;= 0\n  -output_d3 + output_d4 = 0\n  -output_c3 + output_c4 = 0\n  -output_d4 + output_d5 = 0\n  -output_c4 + output_c5 = 0\n]\n</pre> In\u00a0[17]: remove_cell Copied! <pre>write_contracts_to_file(contracts=[scenario_science], names=[\"scenario_science\"], file_name=\"json/scenario_science.json\")\n</pre> write_contracts_to_file(contracts=[scenario_science], names=[\"scenario_science\"], file_name=\"json/scenario_science.json\")"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_science/#science-communication-viewpoint-modeling","title":"Science &amp; Communication viewpoint modeling\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_science/#charging-task","title":"CHARGING Task\u00b6","text":"<p>Objective: charge the spacecraft battery</p> <p>As summarized in the qualitative impacts table, this function has no science or communication effect.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_science/#dsn-task","title":"DSN Task\u00b6","text":"<p>Objective: downlink science data to Earth.</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint with impacts that are linear with the duration of the task:</p> <ul> <li>the onboard science data storage decreases proportionally to a downlink speed.</li> </ul> <p>Note that this task has no impact on the cumulative science data.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_science/#sbo-task-small-body-observations","title":"SBO Task (Small body observations)\u00b6","text":"<p>Objective: Acquire small body observations (science data &amp; navigation)</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint with impacts that are linear with the duration of the task:</p> <ul> <li>the science data storage grows proportionally to a generation rate.</li> <li>the cumulative science data grows proportionally at the same rate.</li> </ul>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_science/#tcm-task-perform-a-trajectory-correction-maneuver","title":"TCM Task (Perform a Trajectory Correction Maneuver)\u00b6","text":"<p>Objective: Perform a delta-V maneuver to bring the spacecraft trajectory closer to that of the small body.</p> <p>As described in the qualitative impacts table, this function has no impact on science.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_science/#tcm-heating-subtask","title":"TCM Heating SubTask\u00b6","text":"<p>Since TCM Heating has no impact on navigation, we use the no-change contract utility to specify this property for the two science viewpoint state variables: <code>d</code> and <code>c</code>.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_science/#tcm-deltav-subtask","title":"TCM DeltaV SubTask\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_science/#science-communication-schedule-analysis","title":"science &amp; Communication Schedule Analysis\u00b6","text":"<p>Let's consider a simple 4-step schedule of the following sequence of task instances, which we compose:</p> <ul> <li>DSN</li> <li>CHARGING</li> <li>SBO</li> <li>TCM</li> </ul>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_thermal/","title":"Thermal Viewpoint","text":"In\u00a0[1]: Copied! <pre>%matplotlib widget\n\n#from IPython import display\nfrom base64 import b64decode\nfrom pacti import write_contracts_to_file\nfrom pacti.terms.polyhedra import *\nfrom pacti.iocontract import IoContract, Var\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport os\nimport numpy as np\nfrom matplotlib import patches\nimport pdb\nfrom matplotlib.collections import PatchCollection\nfrom contract_utils import *\n</pre> %matplotlib widget  #from IPython import display from base64 import b64decode from pacti import write_contracts_to_file from pacti.terms.polyhedra import * from pacti.iocontract import IoContract, Var from PIL import Image import matplotlib.pyplot as plt import os import numpy as np from matplotlib import patches import pdb from matplotlib.collections import PatchCollection from contract_utils import * In\u00a0[2]: Copied! <pre>def COOLING_thermal(s: int) -&gt; PolyhedralContract:\n    spec = PolyhedralContract.from_string(\n        input_vars=[\n            f\"temp{s}_entry\",   # initial thrusters temperature\n        ],\n        output_vars=[\n            f\"temp{s}_exit\",    # final thrusters temperature\n        ],\n        assumptions=[\n            # Upper-bound thruster temperature\n            f\"temp{s}_entry &lt;= 100\",\n            # lower-bound thruster temperature\n            f\"-temp{s}_entry &lt;= 0\",\n        ],\n        guarantees=[\n            # thrusters quickly cool down to their lowest temperature\n            f\" temp{s}_exit = 0\",\n        ],\n    )\n    return spec\n</pre> def COOLING_thermal(s: int) -&gt; PolyhedralContract:     spec = PolyhedralContract.from_string(         input_vars=[             f\"temp{s}_entry\",   # initial thrusters temperature         ],         output_vars=[             f\"temp{s}_exit\",    # final thrusters temperature         ],         assumptions=[             # Upper-bound thruster temperature             f\"temp{s}_entry &lt;= 100\",             # lower-bound thruster temperature             f\"-temp{s}_entry &lt;= 0\",         ],         guarantees=[             # thrusters quickly cool down to their lowest temperature             f\" temp{s}_exit = 0\",         ],     )     return spec  In\u00a0[3]: Copied! <pre>charging1_thermal = COOLING_thermal(s=2)\nprint(f\"Contract charging1_thermal:\\n\\n{charging1_thermal}\")\n</pre> charging1_thermal = COOLING_thermal(s=2) print(f\"Contract charging1_thermal:\\n\\n{charging1_thermal}\") <pre>Contract charging1_thermal:\n\nInVars: [temp2_entry]\nOutVars:[temp2_exit]\nA: [\n  temp2_entry &lt;= 100\n  -temp2_entry &lt;= 0\n]\nG: [\n  temp2_exit = 0\n]\n</pre> In\u00a0[4]: Copied! <pre>dsn1_thermal = COOLING_thermal(s=1)\nprint(f\"Contract dsn1_thermal:\\n\\n{dsn1_thermal}\")\n</pre> dsn1_thermal = COOLING_thermal(s=1) print(f\"Contract dsn1_thermal:\\n\\n{dsn1_thermal}\") <pre>Contract dsn1_thermal:\n\nInVars: [temp1_entry]\nOutVars:[temp1_exit]\nA: [\n  temp1_entry &lt;= 100\n  -temp1_entry &lt;= 0\n]\nG: [\n  temp1_exit = 0\n]\n</pre> In\u00a0[5]: Copied! <pre>sbo1_thermal = COOLING_thermal(s=3)\nprint(f\"Contract sbo1_thermal:\\n\\n{sbo1_thermal}\")\n</pre> sbo1_thermal = COOLING_thermal(s=3) print(f\"Contract sbo1_thermal:\\n\\n{sbo1_thermal}\") <pre>Contract sbo1_thermal:\n\nInVars: [temp3_entry]\nOutVars:[temp3_exit]\nA: [\n  temp3_entry &lt;= 100\n  -temp3_entry &lt;= 0\n]\nG: [\n  temp3_exit = 0\n]\n</pre> In\u00a0[6]: Copied! <pre>def TCM_heating_thermal(s: int, heating_rate: Tuple[float, float]) -&gt; PolyhedralContract:\n    spec = PolyhedralContract.from_string(\n        input_vars=[\n            f\"temp{s}_entry\",           # initial thrusters temperature\n            f\"duration_tcm_heating{s}\", # allocation variable for TCM heating duration\n        ],\n        output_vars=[\n            f\"temp{s}_exit\",            # final thrusters temperature\n        ],\n        assumptions=[\n            # Task has a positive scheduled duration\n            f\"-duration_tcm_heating{s} &lt;= 0\",\n            # thursters should not overheat\n            f\"temp{s}_entry + {heating_rate[1]}*duration_tcm_heating{s} &lt;= 100\",\n            # lower-bound thruster temperature\n            f\"-temp{s}_entry &lt;= 0\",\n        ],\n        guarantees=[\n            # duration*heating_rate(min) &lt;= temp{exit} - temp{entry} &lt;= duration*heating_rate(max)\n            f\" temp{s}_exit - temp{s}_entry - {heating_rate[1]}*duration_tcm_heating{s} &lt;= 0\",\n            f\"-temp{s}_exit + temp{s}_entry + {heating_rate[0]}*duration_tcm_heating{s} &lt;= 0\",\n            # Upper-bound thruster temperature\n            f\"temp{s}_exit &lt;= 100\",\n        ],\n    )\n    return spec\n\ntcm1_heating_thermal = TCM_heating_thermal(s=4, heating_rate=(4.5, 4.7))\nprint(f\"Contract tcm1_heating_thermal:\\n\\n{tcm1_heating_thermal}\")\n\n_ = plot_guarantees(\n    contract=tcm1_heating_thermal,\n    x_var=Var(\"duration_tcm_heating4\"),\n    y_var=Var(\"temp4_exit\"),\n    var_values={\n        Var(\"temp4_entry\"): 0,\n    },\n    x_lims=(0, 30),\n    y_lims=(0, 100),\n)\n</pre> def TCM_heating_thermal(s: int, heating_rate: Tuple[float, float]) -&gt; PolyhedralContract:     spec = PolyhedralContract.from_string(         input_vars=[             f\"temp{s}_entry\",           # initial thrusters temperature             f\"duration_tcm_heating{s}\", # allocation variable for TCM heating duration         ],         output_vars=[             f\"temp{s}_exit\",            # final thrusters temperature         ],         assumptions=[             # Task has a positive scheduled duration             f\"-duration_tcm_heating{s} &lt;= 0\",             # thursters should not overheat             f\"temp{s}_entry + {heating_rate[1]}*duration_tcm_heating{s} &lt;= 100\",             # lower-bound thruster temperature             f\"-temp{s}_entry &lt;= 0\",         ],         guarantees=[             # duration*heating_rate(min) &lt;= temp{exit} - temp{entry} &lt;= duration*heating_rate(max)             f\" temp{s}_exit - temp{s}_entry - {heating_rate[1]}*duration_tcm_heating{s} &lt;= 0\",             f\"-temp{s}_exit + temp{s}_entry + {heating_rate[0]}*duration_tcm_heating{s} &lt;= 0\",             # Upper-bound thruster temperature             f\"temp{s}_exit &lt;= 100\",         ],     )     return spec  tcm1_heating_thermal = TCM_heating_thermal(s=4, heating_rate=(4.5, 4.7)) print(f\"Contract tcm1_heating_thermal:\\n\\n{tcm1_heating_thermal}\")  _ = plot_guarantees(     contract=tcm1_heating_thermal,     x_var=Var(\"duration_tcm_heating4\"),     y_var=Var(\"temp4_exit\"),     var_values={         Var(\"temp4_entry\"): 0,     },     x_lims=(0, 30),     y_lims=(0, 100), )  <pre>Contract tcm1_heating_thermal:\n\nInVars: [temp4_entry, duration_tcm_heating4]\nOutVars:[temp4_exit]\nA: [\n  -duration_tcm_heating4 &lt;= 0\n  4.7 duration_tcm_heating4 + temp4_entry &lt;= 100\n  -temp4_entry &lt;= 0\n]\nG: [\n  -4.7 duration_tcm_heating4 - temp4_entry + temp4_exit &lt;= 0\n  4.5 duration_tcm_heating4 + temp4_entry - temp4_exit &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[7]: Copied! <pre>def TCM_deltav_thermal(s: int, cooling_rate: Tuple[float, float], warm_temp: float) -&gt; PolyhedralContract:\n    spec = PolyhedralContract.from_string(\n        input_vars=[\n            f\"temp{s}_entry\",           # initial thrusters temperature\n            f\"duration_tcm_deltav{s}\",  # allocation variable for TCM deltav duration\n        ],\n        output_vars=[\n            f\"temp{s}_exit\",            # final thrusters temperature\n        ],\n        assumptions=[\n            # thrusters are warm\n            f\"-temp{s}_entry &lt;= -{warm_temp}\",\n        ],\n        guarantees=[\n            # duration*cooling_rate(min) &lt;= temp{entry} - temp{exit} &lt;= duration*cooling_rate(max)\n            f\" temp{s}_entry - temp{s}_exit - {cooling_rate[1]}*duration_tcm_deltav{s} &lt;= 0\",\n            f\"-temp{s}_entry + temp{s}_exit + {cooling_rate[0]}*duration_tcm_deltav{s} &lt;= 0\",\n            # lower-bound thruster temperature\n            f\"-temp{s}_exit &lt;= 0\",\n        ],\n    )\n    return spec\n\ntcm1_deltav_thermal = TCM_deltav_thermal(s=5, cooling_rate=(0.1, 0.2), warm_temp=80.0)\nprint(f\"Contract tcm1_deltav_thermal:\\n\\n{tcm1_deltav_thermal}\")\n\n_ = plot_guarantees(\n    contract=tcm1_deltav_thermal,\n    x_var=Var(\"duration_tcm_deltav5\"),\n    y_var=Var(\"temp5_exit\"),\n    var_values={\n        Var(\"temp5_entry\"): 90,\n    },\n    x_lims=(0, 100),\n    y_lims=(0, 100),\n)\n</pre> def TCM_deltav_thermal(s: int, cooling_rate: Tuple[float, float], warm_temp: float) -&gt; PolyhedralContract:     spec = PolyhedralContract.from_string(         input_vars=[             f\"temp{s}_entry\",           # initial thrusters temperature             f\"duration_tcm_deltav{s}\",  # allocation variable for TCM deltav duration         ],         output_vars=[             f\"temp{s}_exit\",            # final thrusters temperature         ],         assumptions=[             # thrusters are warm             f\"-temp{s}_entry &lt;= -{warm_temp}\",         ],         guarantees=[             # duration*cooling_rate(min) &lt;= temp{entry} - temp{exit} &lt;= duration*cooling_rate(max)             f\" temp{s}_entry - temp{s}_exit - {cooling_rate[1]}*duration_tcm_deltav{s} &lt;= 0\",             f\"-temp{s}_entry + temp{s}_exit + {cooling_rate[0]}*duration_tcm_deltav{s} &lt;= 0\",             # lower-bound thruster temperature             f\"-temp{s}_exit &lt;= 0\",         ],     )     return spec  tcm1_deltav_thermal = TCM_deltav_thermal(s=5, cooling_rate=(0.1, 0.2), warm_temp=80.0) print(f\"Contract tcm1_deltav_thermal:\\n\\n{tcm1_deltav_thermal}\")  _ = plot_guarantees(     contract=tcm1_deltav_thermal,     x_var=Var(\"duration_tcm_deltav5\"),     y_var=Var(\"temp5_exit\"),     var_values={         Var(\"temp5_entry\"): 90,     },     x_lims=(0, 100),     y_lims=(0, 100), ) <pre>Contract tcm1_deltav_thermal:\n\nInVars: [temp5_entry, duration_tcm_deltav5]\nOutVars:[temp5_exit]\nA: [\n  -temp5_entry &lt;= -80\n]\nG: [\n  -0.2 duration_tcm_deltav5 + temp5_entry - temp5_exit &lt;= 0\n  0.1 duration_tcm_deltav5 - temp5_entry + temp5_exit &lt;= 0\n  -temp5_exit &lt;= 0\n]\n</pre>                      Figure                  In\u00a0[8]: Copied! <pre>tcm1_thermal = scenario_sequence(c1=tcm1_heating_thermal, c2=tcm1_deltav_thermal, variables=[\"temp\"], c1index=4)\nprint(f\"========= tcm1_thermal\\n{tcm1_thermal}\")\n</pre> tcm1_thermal = scenario_sequence(c1=tcm1_heating_thermal, c2=tcm1_deltav_thermal, variables=[\"temp\"], c1index=4) print(f\"========= tcm1_thermal\\n{tcm1_thermal}\") <pre>========= tcm1_thermal\nInVars: [temp4_entry, duration_tcm_heating4, duration_tcm_deltav5]\nOutVars:[temp5_exit, output_temp4]\nA: [\n  -4.5 duration_tcm_heating4 - temp4_entry &lt;= -80\n  -duration_tcm_heating4 &lt;= 0\n  4.7 duration_tcm_heating4 + temp4_entry &lt;= 100\n  -temp4_entry &lt;= 0\n]\nG: [\n  -4.7 duration_tcm_heating4 + output_temp4 - temp4_entry &lt;= 0\n  4.5 duration_tcm_heating4 - output_temp4 + temp4_entry &lt;= 0\n  -0.2 duration_tcm_deltav5 + output_temp4 - temp5_exit &lt;= 0\n  0.1 duration_tcm_deltav5 - output_temp4 + temp5_exit &lt;= 0\n  -temp5_exit &lt;= 0\n]\n</pre> In\u00a0[9]: Copied! <pre>steps12 = scenario_sequence(c1=dsn1_thermal, c2=charging1_thermal, variables=[\"temp\"], c1index=1)\nprint(f\"---- Steps 1,2\\n{steps12}\")\nsteps12.get_variable_bounds(\"output_temp1\")\n</pre> steps12 = scenario_sequence(c1=dsn1_thermal, c2=charging1_thermal, variables=[\"temp\"], c1index=1) print(f\"---- Steps 1,2\\n{steps12}\") steps12.get_variable_bounds(\"output_temp1\") <pre>---- Steps 1,2\nInVars: [temp1_entry]\nOutVars:[temp2_exit, output_temp1]\nA: [\n  temp1_entry &lt;= 100\n  -temp1_entry &lt;= 0\n]\nG: [\n  output_temp1 = 0\n  temp2_exit = 0\n]\n</pre> Out[9]: <pre>(0.0, -0.0)</pre> In\u00a0[10]: Copied! <pre>steps123 = scenario_sequence(c1=steps12, c2=sbo1_thermal, variables=[\"temp\"], c1index=2)\nprint(f\"---- Steps 1,2,3\\n{steps123}\")\nprint(steps123.get_variable_bounds(\"output_temp2\"))\n</pre> steps123 = scenario_sequence(c1=steps12, c2=sbo1_thermal, variables=[\"temp\"], c1index=2) print(f\"---- Steps 1,2,3\\n{steps123}\") print(steps123.get_variable_bounds(\"output_temp2\")) <pre>---- Steps 1,2,3\nInVars: [temp1_entry]\nOutVars:[output_temp1, temp3_exit, output_temp2]\nA: [\n  temp1_entry &lt;= 100\n  -temp1_entry &lt;= 0\n]\nG: [\n  output_temp1 = 0\n  output_temp2 = 0\n  temp3_exit = 0\n]\n(0.0, -0.0)\n</pre> In\u00a0[11]: Copied! <pre>steps1234 = scenario_sequence(c1=steps123, c2=tcm1_thermal, variables=[\"temp\"], c1index=3)\nprint(f\"---- Steps 1,2,3,4\\n{steps1234}\")\nprint(steps1234.get_variable_bounds(\"output_temp3\"))\nprint(steps1234.get_variable_bounds(\"output_temp4\"))\n</pre> steps1234 = scenario_sequence(c1=steps123, c2=tcm1_thermal, variables=[\"temp\"], c1index=3) print(f\"---- Steps 1,2,3,4\\n{steps1234}\") print(steps1234.get_variable_bounds(\"output_temp3\")) print(steps1234.get_variable_bounds(\"output_temp4\")) <pre>---- Steps 1,2,3,4\nInVars: [temp1_entry, duration_tcm_heating4, duration_tcm_deltav5]\nOutVars:[output_temp1, output_temp2, temp5_exit, output_temp4, output_temp3]\nA: [\n  -4.5 duration_tcm_heating4 &lt;= -80\n  4.7 duration_tcm_heating4 &lt;= 100\n  temp1_entry &lt;= 100\n  -temp1_entry &lt;= 0\n]\nG: [\n  output_temp1 = 0\n  output_temp2 = 0\n  output_temp3 = 0\n  -4.7 duration_tcm_heating4 - output_temp3 + output_temp4 &lt;= 0\n  4.5 duration_tcm_heating4 + output_temp3 - output_temp4 &lt;= 0\n  -0.2 duration_tcm_deltav5 + output_temp4 - temp5_exit &lt;= 0\n  0.1 duration_tcm_deltav5 - output_temp4 + temp5_exit &lt;= 0\n  -temp5_exit &lt;= 0\n]\n(0.0, -0.0)\n(80.0, 100.0)\n</pre> In\u00a0[12]: Copied! <pre>scenario_thermal = steps1234.rename_variables([(\"temp5_exit\", \"output_temp5\")])\nprint(f\"scenario_power={scenario_thermal}\")\n</pre> scenario_thermal = steps1234.rename_variables([(\"temp5_exit\", \"output_temp5\")]) print(f\"scenario_power={scenario_thermal}\")  <pre>scenario_power=InVars: [temp1_entry, duration_tcm_heating4, duration_tcm_deltav5]\nOutVars:[output_temp1, output_temp2, output_temp4, output_temp3, output_temp5]\nA: [\n  -4.5 duration_tcm_heating4 &lt;= -80\n  4.7 duration_tcm_heating4 &lt;= 100\n  temp1_entry &lt;= 100\n  -temp1_entry &lt;= 0\n]\nG: [\n  output_temp1 = 0\n  output_temp2 = 0\n  output_temp3 = 0\n  -4.7 duration_tcm_heating4 - output_temp3 + output_temp4 &lt;= 0\n  4.5 duration_tcm_heating4 + output_temp3 - output_temp4 &lt;= 0\n  -0.2 duration_tcm_deltav5 + output_temp4 - output_temp5 &lt;= 0\n  0.1 duration_tcm_deltav5 - output_temp4 + output_temp5 &lt;= 0\n  -output_temp5 &lt;= 0\n]\n</pre> In\u00a0[13]: remove_cell Copied! <pre>write_contracts_to_file(contracts=[scenario_thermal], names=[\"scenario_thermal\"], file_name=\"json/scenario_thermal.json\")\n</pre> write_contracts_to_file(contracts=[scenario_thermal], names=[\"scenario_thermal\"], file_name=\"json/scenario_thermal.json\")"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_thermal/#thermal-viewpoint-modeling","title":"Thermal viewpoint modeling\u00b6","text":"<p>Except for TCM, all other tasks have the same qualitative thermal impact: the spacecraft's thrusters quickly reach their coldest temperature since they are off and have no thermal insulation or significant thermal capacity. Consequently, we define a common contract template for modeling the cooling impact in a way that is independent of the scheduled task duration.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_thermal/#charging-task","title":"CHARGING Task\u00b6","text":"<p>Objective: charge the spacecraft battery</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint according to the cooling impact defined above.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_thermal/#dsn-task","title":"DSN Task\u00b6","text":"<p>Objective: downlink science data to Earth.</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint according to the cooling impact defined above.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_thermal/#sbo-task-small-body-observations","title":"SBO Task (Small body observations)\u00b6","text":"<p>Objective: Acquire small body observations (science data &amp; navigation)</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint according to the cooling impact defined above.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_thermal/#tcm-task-perform-a-trajectory-correction-maneuver","title":"TCM Task (Perform a Trajectory Correction Maneuver)\u00b6","text":"<p>Objective: Perform a delta-V maneuver to bring the spacecraft trajectory closer to that of the small body.</p> <p>As summarized in the qualitative impacts table, this function affects this viewpoint with impacts that are linear with the duration of the task:</p> <ul> <li>Thermal:<ul> <li>the thrusters must be heated before firing them, thereby discharging the battery proportionally to a consumption rate.</li> <li>the deltaV maneuver fires the spacecraft thrusters, keeping them from cooling.</li> </ul> </li> </ul>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_thermal/#tcm-heating-subtask","title":"TCM Heating SubTask\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_thermal/#tcm-deltav-subtask","title":"TCM DeltaV SubTask\u00b6","text":""},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_thermal/#composing-tcm-subtasks","title":"Composing TCM SubTasks\u00b6","text":"<p>Algebraic composition allows us to capture the requirement that a TCM Heating subtask must always precede a TCM DeltaV subtask by composing them.</p>"},{"location":"_case_studies/cs-space-mission/space_mission/space_mission_thermal/#thermal-schedule-analysis","title":"Thermal Schedule Analysis\u00b6","text":"<p>Let's consider a simple 4-step schedule of the following sequence of task instances, which we compose:</p> <ul> <li>DSN</li> <li>CHARGING</li> <li>SBO</li> <li>TCM</li> </ul>"},{"location":"_case_studies/cs-uav-topologies/topologies/","title":"Topology generation for UAV designs using Pacti","text":"In\u00a0[1]: Copied! <pre>import random\nfrom src.contracts_utils.union import ContractsUnions\nfrom src.grammar.grammar import Grammar\nfrom src.grammar.grid import GridBuilder\nfrom src.shared.shared import DirectionsAssignment, SymbolType\nfrom src.shared.paths import rules_path\nfrom src.tools.refinement_checking import rule_matching\nfrom src.tools.plotting import create_gif\nimport matplotlib.pyplot as plt\n</pre> import random from src.contracts_utils.union import ContractsUnions from src.grammar.grammar import Grammar from src.grammar.grid import GridBuilder from src.shared.shared import DirectionsAssignment, SymbolType from src.shared.paths import rules_path from src.tools.refinement_checking import rule_matching from src.tools.plotting import create_gif import matplotlib.pyplot as plt     <p>We define three constants defining the half size ($n_{half}$) of the grid, the max number of wings and rotors that we want the UAV to have.</p> In\u00a0[2]: Copied! <pre>grid_half_size = 3\nmax_num_wings = 2\nmax_num_rotors = 4\n</pre> grid_half_size = 3 max_num_wings = 2 max_num_rotors = 4 <p>We can generate a new grid with the <code>GridBuilder</code> class</p> In\u00a0[3]: Copied! <pre>grid = GridBuilder.generate(half_size=grid_half_size)\n</pre> grid = GridBuilder.generate(half_size=grid_half_size) <p>We can build a <code>Grammar</code> object from a json file where we have defined all the rules.</p> In\u00a0[4]: Copied! <pre>grammar = Grammar.from_json(rules_json_path=rules_path)\n</pre> grammar = Grammar.from_json(rules_json_path=rules_path) <p>Then we produce an optimal assignment of integers to the diretions based on the grammar</p> In\u00a0[5]: Copied! <pre>directions_assignment = DirectionsAssignment()\ndirections_assignment.set_direction_assignment(grammar.get_directions_assignment())\n</pre> directions_assignment = DirectionsAssignment() directions_assignment.set_direction_assignment(grammar.get_directions_assignment()) <pre>Creating the object\n</pre> <p>We convert all the rules of the grammar to contracts</p> In\u00a0[6]: Copied! <pre>rule_contracts: dict[SymbolType, list[ContractsUnions]] = grammar.to_contracts()\n</pre> rule_contracts: dict[SymbolType, list[ContractsUnions]] = grammar.to_contracts() <p>We explore all the points of the grid until there are no more points to visit. At each iteration, we</p> <ul> <li>Update the current point to visit</li> <li>Get the local state wrt the point chosen</li> <li>Create the list of \"rule contracts\" that are allowed at the current iteration based on the current number of wings and propellers</li> <li>Convert the state to a contract</li> <li>Find all the matching rules to the current state</li> <li>Select one of the compatible rules randomly and apply it to the current state</li> </ul> In\u00a0[7]: Copied! <pre>step = 0\nfigures: list[plt.Figure] = []\nwhile len(grid.points_to_visit) &gt; 0:\n    # print(f\"STEP {step}\")\n    # print(f\"{len(grid.points_to_visit)} POINTS LEFT:\\t{grid.points_to_visit}\")\n    grid.update_current_point()\n    current_state = grid.local_state()\n    if step &gt; 0 and not current_state.has_non_empty_symbols():\n        continue\n    forbidden_symbols = set()\n    if grid.n_wings == max_num_wings and grid.n_rotors == max_num_rotors:\n        break\n    if grid.n_wings &gt;= max_num_wings:\n        forbidden_symbols.add(SymbolType.WING)\n    if grid.n_rotors &gt;= max_num_rotors:\n        forbidden_symbols.add(SymbolType.ROTOR)\n    rules_allowed_contracts = list({k: v for k, v in rule_contracts.items() if k not in forbidden_symbols}.values())\n    rules_allowed_contracts = [item for sublist in rules_allowed_contracts for item in sublist]\n    if step &gt; 0:\n        rules_allowed_contracts = list(filter(lambda x: x.name != \"r0\", rules_allowed_contracts))\n    rule_names_allowed = [r.name for r in rules_allowed_contracts]\n    if step == 0:\n        rules_compatible_contracts = [grammar.rules[\"r0\"]]\n    else:\n        rules_compatible_contracts = rule_matching(current_state.contract, rules_allowed_contracts)\n    r_id_from_contracts = [rc.name for rc in rules_compatible_contracts]\n    r_id_from_contracts_str = \"-\".join(sorted(r_id_from_contracts))\n    # print(f\"R_C: {r_id_from_contracts_str}\")\n    if len(list(rules_compatible_contracts)) &gt; 0:\n        chosen_rule = random.choice(list(rules_compatible_contracts))\n        grid.apply_rule(grammar.rules[chosen_rule.name])\n    else:\n        grid.apply_rule(grammar.rules[\"r19\"])\n    fig: plt.Figure = grid.figure_with_edges\n    figures.append(fig)\n    # Increase step counter\n    step += 1\n\ngrid.cleanup()\nfigures.append(grid.figure_with_edges)\nprint(f\"Design generated in {step} steps\")\ngif_path = create_gif(figures=figures, filename=\"uav_design_process.gif\")\n</pre> step = 0 figures: list[plt.Figure] = [] while len(grid.points_to_visit) &gt; 0:     # print(f\"STEP {step}\")     # print(f\"{len(grid.points_to_visit)} POINTS LEFT:\\t{grid.points_to_visit}\")     grid.update_current_point()     current_state = grid.local_state()     if step &gt; 0 and not current_state.has_non_empty_symbols():         continue     forbidden_symbols = set()     if grid.n_wings == max_num_wings and grid.n_rotors == max_num_rotors:         break     if grid.n_wings &gt;= max_num_wings:         forbidden_symbols.add(SymbolType.WING)     if grid.n_rotors &gt;= max_num_rotors:         forbidden_symbols.add(SymbolType.ROTOR)     rules_allowed_contracts = list({k: v for k, v in rule_contracts.items() if k not in forbidden_symbols}.values())     rules_allowed_contracts = [item for sublist in rules_allowed_contracts for item in sublist]     if step &gt; 0:         rules_allowed_contracts = list(filter(lambda x: x.name != \"r0\", rules_allowed_contracts))     rule_names_allowed = [r.name for r in rules_allowed_contracts]     if step == 0:         rules_compatible_contracts = [grammar.rules[\"r0\"]]     else:         rules_compatible_contracts = rule_matching(current_state.contract, rules_allowed_contracts)     r_id_from_contracts = [rc.name for rc in rules_compatible_contracts]     r_id_from_contracts_str = \"-\".join(sorted(r_id_from_contracts))     # print(f\"R_C: {r_id_from_contracts_str}\")     if len(list(rules_compatible_contracts)) &gt; 0:         chosen_rule = random.choice(list(rules_compatible_contracts))         grid.apply_rule(grammar.rules[chosen_rule.name])     else:         grid.apply_rule(grammar.rules[\"r19\"])     fig: plt.Figure = grid.figure_with_edges     figures.append(fig)     # Increase step counter     step += 1  grid.cleanup() figures.append(grid.figure_with_edges) print(f\"Design generated in {step} steps\") gif_path = create_gif(figures=figures, filename=\"uav_design_process.gif\")  <pre>Design generated in 41 steps\nGIF generated at: uav_design_process.gif\n</pre> <p>We can visualize the different steps of the design process in the following GIF:</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#topology-generation-for-uav-designs-using-pacti","title":"Topology generation for UAV designs using Pacti\u00b6","text":"<p>We demonstrate how pacti can be utilized to generate designs for Unmanned Aerial Vehicles (UAVs) under a set of predefined \"design rules\". Our primary objective is to produce a 3D grid, consisting of interconnected points that represent the abstract topology of the UAV. Each point within the grid represents a specific component of the UAV, such as fuselage, wing, rotor, etc., while each edge between two points depicts the connection among components. To achieve this, we employ a context-sensitive grammar (CSG) that formalizes the placement of UAV components on the grid based on their local context, i.e., the components around them.</p> <p>Our grammar's primary goal is to generate all legal configurations of components and their connections within the 3D grid. A context-sensitive grammar (CSG) is a formal grammar that describes a formal language through a set of rules that define how strings of symbols within the language can be generated.</p> <p>In the following, we introduce the main building blocks of our grammar: grid, context, symbols, and rules. By leveraging these components, our proposed method generates UAV designs that adhere to predefined design rules, resulting in functional and efficient UAV designs.</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#grid","title":"Grid\u00b6","text":"<p>A 3D grid of points, or simply a grid, can be formally defined as a set of ordered triplets, where each triplet represents a point in 3D space. The triplet is composed of three integer coordinates $(x, y, z)$ that specify the position of the point in the 3D grid. Let $n_{half} \\in \\mathbb{Z}$, and let $G = {(x, y, z) | x, y, z \\in \\mathbb{Z}, -n_{half} \\leq x, y, z \\leq n_{half}}$ be the set of all points in a 3D grid. We define the size of a grid $G$ as $|G| = ((n_{half} * 2) + 1)^3$.</p> <p>Below, we present an example of a grid of size 27, and we highlight the middle point of the grid, which has coordinates $(0,0,0)$:</p> <p>Using the defined grid structure, we can easily specify the position of each component of the UAV in the form of a 3D point. This facilitates the use of a context-sensitive grammar to formalize the placement of components on the grid.</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#context","title":"Context\u00b6","text":"<p>Given a 3D grid of points, we define the context of a point $p$ as a tuple of seven points, where six points are the coordinates of the adjacent points in the grid and one point is $p$ itself. We define a set of seven directions $\\Delta = (\\texttt{ego}, \\texttt{front}, \\texttt{rear}, \\texttt{left}, \\texttt{right}, \\texttt{top}, \\texttt{bottom})$. Given a point $p = (x, y, z)$, we can construct its context $Ctx(p) = (p_\\texttt{ego}, p_\\texttt{front}, p_\\texttt{rear}, p_\\texttt{left}, p_\\texttt{right}, p_\\texttt{top}, p_{bottom})$ as follows:</p> $$ \\begin{align} p_\\texttt{ego} &amp;= (x, y, z) \\\\ p_\\texttt{front} &amp;= (x, y+1, z) \\\\ p_\\texttt{rear} &amp;= (x, y-1, z) \\\\ p_\\texttt{left} &amp;= (x-1, y, z) \\\\ p_\\texttt{right} &amp;= (x+1, y-1, z) \\\\ p_\\texttt{top} &amp;= (x+1, y-1, z+1) \\\\ p_\\texttt{bottom} &amp;= (x+1, y-1, z-1) \\end{align} $$<p>Below we show an example of a grid together with context of the point $(0,0,0)$</p> <p>Note that the points at the edge of the grid have contexts with some points having coordinates outside the grid, i.e., the points adjacent to them in the specified direction are not included in the grid. The context of a point is used to define the placement of components of an UAV in the grid according to their local context.</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#symbols","title":"Symbols\u00b6","text":"<p>In our grammar, each point $p$ in the grid is associated with a symbol, denoted by $Sym(p)$. The symbols are divided into two main categories: terminal symbols and nonterminal symbols. Terminal symbols represent actual characters or words in the language that the grammar defines, while nonterminal symbols are used to represent groups or structures in the language. These symbols can be expanded or rewritten by the production rules of the grammar to generate strings in the language.</p> <p>We define the set of terminal symbols as $\\Lambda$, which contains five elements that mostly represent UAV components: ${\\texttt{Fuselage}, \\texttt{Rotor}, \\texttt{Wing}, \\texttt{Connector}, \\texttt{Empty}}$. We define the set of nonterminal symbols as $\\Theta$, which contains one element: ${\\texttt{Unoccupied}}$.</p> <p>Note that although $\\texttt{Empty}$ and $\\texttt{Unoccupied}$ represent the same concept (i.e., the absence of a component), they are different symbols. $\\texttt{Empty}$ is terminal, meaning it cannot be expanded into a new symbol, while $\\texttt{Unoccupied}$ is nonterminal.</p> <p>At initialization, all points in the grid are associated with the $\\texttt{Unoccupied}$ symbol.</p> <p>We associate each symbol with a color, as shown in the figure below:</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#local-context","title":"Local Context\u00b6","text":"<p>A local context $LC=(sym_1, sym_2, \\dots, sym_7)$ is a tuple of seven symbols, i.e. $l_c \\in \\Lambda \\cup \\Theta$, one for each direction in $\\Delta$. The figure below shows a local context $LC_i = (\\texttt{Unoccupied}, \\texttt{Unoccupied}, \\texttt{Unoccupied}, \\texttt{Fuselage}, \\texttt{Unoccupied}, \\texttt{Rotor}, \\texttt{Unoccupied})$.</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#state","title":"State\u00b6","text":"<p>The state of a point $p$ on a grid is the local context around that point, denoted by $S(p)$.</p> <p>For example, given the grid depicted below, let us consider the point $p=(0,0,0)$. We have that $S(p)=(\\texttt{Fuselage}, \\texttt{Unoccupied}, \\texttt{Unoccupied}, \\texttt{Wing}, \\texttt{Wing}, \\texttt{Rotor}, \\texttt{Unoccupied})$. In the picture below, we have associated a color with each symbol.</p> <p>Check src/grammar/grid.py for the implementation of the grid and local context.</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#rules","title":"Rules\u00b6","text":"<p>In our grammar a production rule, or rule, defines how a single nonterminal symbol can be substituted with a non-terminal symbol according to its context.</p> <p>In our grammar, a production rule, or simply a rule, defines how a single nonterminal symbol can be substituted with another non-terminal symbol based on its context.</p> <p>A rule $R_i = (\\Omega, \\Pi)$ consists of a condition $\\Omega$ and a production $\\Pi$, where:</p> <ol> <li>$\\Omega=\\{LC_0, LC_1, ..., LC_c\\}$ is a set of $c$ local contexts.</li> <li>$\\Pi = (sym, \\texttt{dir})$ where $sym \\in \\Lambda$ and $\\texttt{dir} \\in \\Delta$.</li> </ol> <p>The condition $\\Omega$ determines all the local contexts where the rule can be applied. The production $\\Pi$ specifies the nonterminal symbol $sym \\in Tau$ to be produced and the direction of the edge that connects the newly generated symbol to one of the adjacent symbols in the grid. If no connection is required, then $\\texttt{dir}$ is simply $\\texttt{ego}$.</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#matching","title":"Matching\u00b6","text":"<p>At each time step, we apply a rule to a point in the grid. A rule $R_i$ matches with a point $p$ if the local context of $p$, i.e. $S(p)$, is a subset of the conditions of $R_i$, i.e. if $S(p) \\subseteq \\Omega$. If a rule $R_i = (\\Omega, \\Pi)$ matches with a point $p$, then the production $\\Pi$ is applied to the point $p$. That is, let $\\Pi=(sym, p_{dir})$, then the symbol $sym$ is placed in $p$, i.e. $Sym(p)=sym$, and an edge is created from $p$ to $p_{dir}$. The figure below shows an example of a grid at a time step $t$, where a point $p$ matches a rule $R_i$, and the production of $R_i$ is applied to $p$, modifying the state of the grid in the next time step $t+1$.</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#grammar-and-design-generation-process","title":"Grammar and design generation process\u00b6","text":"<p>Given $n$ rules, a grammar $Gr={R_0, R_1, \\dots , R_n}$ is simply the set of all rules.</p> <p>We start with a grid where all points are associated with the nonterminal symbol Unassigned. Then, at discrete time-steps, we choose a point in the grid and try to match it with one or more rules in the grammar. If a rule matches the local context of the chosen point, we apply the production of the rule to the point, which changes its nonterminal symbol and potentially creates edges between adjacent points. We repeat this process until all points contain nonterminal symbols or until we have no rules matching in the grammar.</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#contract-formalization-with-pacti","title":"Contract formalization with Pacti\u00b6","text":"<p>We can use pacti as verification engine to match rules with points on the grid. We are going to use the composition and refinement operators to verify weather local contexts of points match rule's conditions. In the following we are going to formalize local contexts and rules with contracts of polyhedra constraints.</p> <p>We can use pacti as a verification engine to match rules with points on the grid. We are going to use the composition and refinement operators to verify weather local contexts of points match rule's conditions. To do this, we will define contracts using polyhedral constraints to formalize local contexts and rules.</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#local-directions-as-linear-constraint","title":"Local directions as linear constraint\u00b6","text":"<p>We will define a variable for every terminal and nonterminal symbol of the grammar and an integer for every direction. For example, given the grammar with nonterminal symbols $\\Lambda={\\texttt{Fuselage}, \\texttt{Rotor}, \\texttt{Wing}, \\texttt{Connector}, \\texttt{Empty}}$ and terminal symbol $\\Theta={\\texttt{Unoccupied}}$, we generate a set of variables $V = {f, r, w, c, e, u}$ where each element corresponds to the element in $\\Lambda \\cup \\Theta$ starting with the corresponding letter. We define a set of integers $\\Delta'={0,1,2,3,4,5,6}$ where every element corresponds to an element in $\\Delta={\\texttt{ego}, \\texttt{front}, \\texttt{rear}, \\texttt{left}, \\texttt{right}, \\texttt{top}, \\texttt{bottom}}$. Our goal is to represent a local context with linear constraints such as $U \\le 6~~ \\land~~ F = 7$, which prescribe a local context having $\\texttt{Unoccupied}$ in the direction corresponding to the integers $i \\in \\Delta'$ where $i \\leq 6$ and a $\\texttt{Fuselage}$ in the direction corresponding to the integer $7$. From this example we can see how the assignment of integers in $\\Delta'$ to directions in $\\Delta$ can greatly influence the number of constraints necessary to express a set of local contexts.</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#direction-assignment-problem","title":"Direction assignment problem\u00b6","text":"<p>We have seen how from a local context we can produe a set of local constraints that represents it.</p> <p>Given a grammar with $n$ rules $Gr=\\{R_0, R_1, \\dots , R_n\\}$ where every rule $R_i \\in Gr$ contains a set if local contexts, e.g. $\\Omega_i = \\{LC_0, LC_1, \\dots, LC_c\\}$; given a set of seven directions $\\Delta=\\{\\texttt{ego}, \\texttt{front}, \\texttt{rear}, \\texttt{left}, \\texttt{right}, \\texttt{top}, \\texttt{bottom}\\}$;  Produce a function $Dir: \\Delta \\rightarrow \\Delta'$ that maps elements of $\\Delta$ to elements of $\\Delta'=\\{0,1, 2,3,4,5,6\\}$ such that it minimizes the number of constraints representing the local contexts for all the rules in the grammar.</p> <p>Check the method <code>get_directions_assignment</code> in src/grammar/grammar.py for the implementation of the such function.</p> <p>For the grammar in our case study the optimal assignment is the following:</p> $$ \\begin{align} Dir(\\texttt{ego}) &amp;= 6 \\\\ Dir(\\texttt{front}) &amp;= 4 \\\\ Dir(\\texttt{rear}) &amp;= 5 \\\\ Dir(\\texttt{left}) &amp;= 0 \\\\ Dir(\\texttt{right}) &amp;= 2 \\\\ Dir(\\texttt{top}) &amp;= 3 \\\\ Dir(\\texttt{bottom}) &amp;= 1 \\end{align} $$"},{"location":"_case_studies/cs-uav-topologies/topologies/#contracts-for-state","title":"Contracts for State\u00b6","text":"<p>We can transform any state of a point $p$ in the grid into a contract having true assumptions and the set of linear constraints representing the state as guarantees.</p> <p>For example, let us consider the state in the figure below:</p> <p>We have annotated all the edges with a tuple containing respectively the integer assignment of the direction and the variable representing the symbol. The contract representing the state in the figure is the following:</p> $$ \\begin{align} \u00a0 \\mathcal{C}_{s(t)} &amp;= \u00a0 \u00a0 \u00a0 \\begin{cases} \u00a0 \u00a0 \u00a0 \u00a0 A &amp; true \\\\ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 &amp;\u00a0 \\\\ \u00a0 \u00a0 \u00a0 \u00a0 G &amp; f=4 \\land (u \\leq 3 \\lor (4 \\leq u \\leq 5))\\\\ \u00a0 \u00a0 \u00a0 \\end{cases}\\notag \\end{align} $$<p>Notice that the guarantees of $C_{s(t)}$ contain a disjunction. Since in pacti contracts can only have conjunctions of constraints, we distribute the disjunction and create new contracts that we group in a structure that we refer as ContractUnions</p> $$ \\begin{cases} \u00a0 \u00a0 \u00a0 &amp; \\mathcal{C}_{s(t)}^{1} \u00a0 \u00a0 \u00a0 \\begin{cases} \u00a0 \u00a0 \u00a0 \u00a0 A &amp; true \\\\ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 &amp;\u00a0 \\\\ \u00a0 \u00a0 \u00a0 \u00a0 G &amp; f=4 \\land u \\leq 3\\\\ \u00a0 \u00a0 \u00a0 \\end{cases}\\notag\\\\ \u00a0 \u00a0 \u00a0 &amp; \\mathcal{C}_{s(t)}^{2} \u00a0 \u00a0 \u00a0 \\begin{cases} \u00a0 \u00a0 \u00a0 \u00a0 A &amp; true \\\\ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 &amp;\u00a0 \\\\ \u00a0 \u00a0 \u00a0 \u00a0 G &amp; f=4 \\land (5 \\leq u \\leq 6))\\\\ \u00a0 \u00a0 \u00a0 \\end{cases}\\notag \u00a0 \u00a0 \\end{cases} $$"},{"location":"_case_studies/cs-uav-topologies/topologies/#contracts-for-rules","title":"Contracts for Rules\u00b6","text":"<p>Let us show how rules can be modeled as contracts. The figure below shows a pictorial representation of one rule having four local contexts as matching conditions and producing a symbol and a connection.</p> <p>The conditions describe four different states where from the ego position we can have in front a fuselage (red), a propeller (green), a wing (blue), and a connector (grey). The production prescribes the ego symbol to be a connector and a connection to the symbol in front of it. We represent the rule with a ContractUnion formed by four contracts.</p> $$ \u00a0 \u00a0 \\begin{cases} \u00a0 \u00a0 \u00a0 &amp; \\mathcal{C}_{r_{i}}^{1} \u00a0 \u00a0 \u00a0 \\begin{cases} \u00a0 \u00a0 \u00a0 \u00a0 A &amp; \\land c=4 \\land u=5 \\land f=4 \\land w=4 \\land r=4 \\\\ \u00a0 \u00a0 \u00a0 \u00a0 G &amp; c=6 \\land edge=4\\\\ \u00a0 \u00a0 \u00a0 \\end{cases}\\notag\\\\ \u00a0 \u00a0 \u00a0 &amp; \\mathcal{C}_{r_{i}}^{2} \u00a0 \u00a0 \u00a0 \\begin{cases} \u00a0 \u00a0 \u00a0 \u00a0 A &amp; \\land c=4 \\land u \\leq 3 \\land f=4 \\land w=4 \\land r=4 \\\\ \u00a0 \u00a0 \u00a0 \u00a0 G &amp; c=6 \\land edge=4\\\\ \u00a0 \u00a0 \u00a0 \\end{cases}\\notag\\\\ \u00a0 \u00a0 \u00a0 &amp; \\mathcal{C}_{r_{i}}^{3} \u00a0 \u00a0 \u00a0 \\begin{cases} \u00a0 \u00a0 \u00a0 \u00a0 A &amp; \\land c=4 \\land u=5 \\land f=4 \\land w=4 \\land r=4 \\\\ \u00a0 \u00a0 \u00a0 \u00a0 G &amp; c=6 \\land edge=4\\\\ \u00a0 \u00a0 \u00a0 \\end{cases}\\notag\\\\ \u00a0 \u00a0 \u00a0 &amp; \\mathcal{C}_{r_{i}}^{4} \u00a0 \u00a0 \u00a0 \\begin{cases} \u00a0 \u00a0 \u00a0 \u00a0 A &amp; \\land c=4 \\land u \\leq 3 \\land f=4 \\land w=4 \\land r=4 \\\\ \u00a0 \u00a0 \u00a0 \u00a0 G &amp; c=6 \\land edge=4 \u00a0 \u00a0 \u00a0 \\end{cases}\\notag \u00a0 \u00a0 \\end{cases} $$<p>The assumptions of the contract represent all possible conditions that are accepted by the rule, while the guarantees specify the symbol to be placed in the ego position ($c=6$) and provide information about a possible connection. In this case, the value of $edge=4$ indicates a connection from the ego position to direction 4, which represents the front direction.</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#assuring-matching-conditions-using-contracts-composition","title":"Assuring matching conditions using contracts composition\u00b6","text":"<p>We are using the composition operation offered by pacti to assure that a rule is a valid match for a given state. When composing two contracts pacti will check if the guarantees of a contract are compatible with the assumptions of the other contract being composed. Composing a state contract with a rule contract will automatically check if the state is compatible with the rule, as shown in the following picture.</p> <p>We have seen how both rules and states can be expressed as ContractUnion objects. When pacti composes a rule ContractUnion with a state ContractUnion, it checks if every element of the state can be composed with at least one element of the rule. Furthermore before composing a rule with a state, we produce an abstraction of every contract in the rule ContractUnion, by removing constraints related to variables which are not present in the state. The figure below shows the abstraction produced by the rule $r_{i}$ introduced before.</p>"},{"location":"_case_studies/cs-uav-topologies/topologies/#running-the-code","title":"Running the code\u00b6","text":"<p>We start with some imports</p>"},{"location":"_case_studies/cs-vehicle-perception/evaluate_perception/","title":"Evaluating Perception with respect to System-level Specifications","text":"In\u00a0[4]: Copied! <pre># Import libraries\nimport pickle as pkl\nimport matplotlib.gridspec as gridspec\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom IPython.display import Image\nfrom PIL import Image\nfrom pacti.terms.polyhedra import PolyhedralContract, plots\nfrom pacti.iocontract import Var\n</pre> # Import libraries import pickle as pkl import matplotlib.gridspec as gridspec import matplotlib.pyplot as plt import numpy as np from IPython.display import Image from PIL import Image from pacti.terms.polyhedra import PolyhedralContract, plots from pacti.iocontract import Var  <p>In this case study, we construct lower bounds for elements of the confusion matrix. Consider the car pedestrian example examined in this case study. For the purposes of this jupyter notebook, the pedestrian is located 4 cells away from the car, which is starting at cell $C_1$ with an initial speed of 1 cell/step and a maximum possible speed of 2 cells/step. Figure 1 illustrates the assume-guarantee contracts for the perception and control components of the software autonomy stack. The true state of the environment is denoted by $x_e$, the state of the car comprises of its position and speed $(x_c, v_c)$. The safety requirement on the car is that it \"shall stop at the crosswalk if there is a waiting pedestrian, and not come to a stop, otherwise\". The overall system specifications are formally expressed as safety specifications:</p> <ol> <li>If the true state of the environment is not a pedestrian, i.e. $x_e \\neq ped$, then the car must not stop at $C_{k-1}$: $$\\varphi_{1}= \\square\\big((x_e \\neq ped)\\rightarrow \\neg (x_c = C_{k-1} \\wedge v_c = 0)\\big),$$</li> <li>If $x_e = ped$, the car must stop on $C_{k-1}$: $$\\varphi_{2}  = \\square\\Big(x_e = ped\\rightarrow \\big( (x_c = C_{k-1} \\wedge v_c = 0) \\vee \\neg (x_c = C_{k-1}) \\big)\\Big),$$</li> <li>The agent should not stop at any cell $C_i$, for all $i \\in \\{1,\\ldots, k-2\\}$:</li> </ol> $$\\varphi_3 = \\square\\neg(\\bigvee_{i = 1}^{k-2} (x_c = C_i \\wedge v_c = 0)).$$  <p></p> <p>Figure 1: On the right, we see an illustration of a discrete-state representation of a car driving down a road and a pedestrian at a crosswalk. On the left, we see an illustration of a class-labeled confusion matrices with the row and column labels being classes of objects. The true positive rates for each class constitute the diagonal elements. The confusion matrix can be used to derive transition probabilities for a Markov chain representing the state evolution of the system. For each object class label $c$, we can construct a Markov chain parametrized by the true positive rate and false negative rates corresponding to the class. By randomly sampling the false negative rates, we can plot the system-level satisfaction probability as a function of the true positive rate.</p> <p>This section details the construction of controller contracts for the specific car pedestrain example given above. Suppose $c$ is the object class of the true environment. Since the probability of satisfaction of formula $\\varphi_c$ is a nonlinear function of the elements of the confusion matrix, we compute an affine lower bound of this function via sampling. For each true positive rate, $\\mathtt{TP}_{c}$, for a environment object type $c$, we generate 15 random instantiations of the false negative rates, $\\mathtt{FN}_{(c',c)}$ and $\\mathtt{FN}_{(c'',c)}$, where $c \\notin \\{c',c''\\}$. For each instantiation of the confusion matrix, we construct the corresponding Markov chain $M(\\mathtt{TP}_{c}, \\mathtt{FN}_{(c',c)}, \\mathtt{FN}_{(c'',c)})$ and compute the satisfaction probability accordingly. For all the probability samples, we then use linear programming to compute a lower bound as a function of the true positive rate.</p> In\u00a0[5]: Copied! <pre># Here we load probability points from saved pickle files. To fully recompute the results, see recompute.ipynb\n\nwith open(\"data/lb.pkl\", \"rb\") as f:\n    lbounds_ped, points_ped, tpped_vals = pkl.load(f)\nf.close()\n\nwith open(\"data/lbobj.pkl\", \"rb\") as f:\n    lbounds_obj, points_obj, tpobj_vals = pkl.load(f)\nf.close()\n\nwith open(\"data/lbempty.pkl\", \"rb\") as f:\n    lbounds_emp, points_emp, tpemp_vals = pkl.load(f)\nf.close()\n</pre> # Here we load probability points from saved pickle files. To fully recompute the results, see recompute.ipynb  with open(\"data/lb.pkl\", \"rb\") as f:     lbounds_ped, points_ped, tpped_vals = pkl.load(f) f.close()  with open(\"data/lbobj.pkl\", \"rb\") as f:     lbounds_obj, points_obj, tpobj_vals = pkl.load(f) f.close()  with open(\"data/lbempty.pkl\", \"rb\") as f:     lbounds_emp, points_emp, tpemp_vals = pkl.load(f) f.close() In\u00a0[29]: Copied! <pre># Plotting Probabilities:\ndef plot_probabilities_bounds(points, tp_vals, ubounds, lbounds, true_env, ax):\n    ax = ax\n    ax.tick_params(axis=\"both\", which=\"major\", labelsize=10)\n    ax.plot(tp_vals, points, \"b*\", label=\"sampled\")\n    if ubounds != []:\n        ub_m, ub_c = ubounds\n        y_ub = ub_m * np.array(tp_vals) + ub_c\n        plt.plot(tp_vals, y_ub, \"r\")\n\n    lb_m, lb_c = lbounds\n    y_lb = lb_m * np.array(tp_vals) + lb_c\n    ax.plot(tp_vals, y_lb, \"k\", label=\"lower bound\", linewidth=4)\n    lb = min(tp_vals)\n    ub = max(tp_vals)\n    lP = min(points)\n    uP = max(points)\n    ax.legend(prop={\"size\": 10})\n    ax.set_xlim(lb-0.01, ub+0.01)\n    ax.set_ylim(lP-0.01, uP+0.01)\n\n    ax.set_title(\"Lower bound of $\\mathbb{P}_{\" + true_env + \"}$ as a function of $\\mathtt{TP}_{\" + true_env + \"}$.\")\n    ax.set_ylabel(\"$\\mathbb{P}_{\" + true_env + \"}$\")\n    ax.set_xlabel(\"$\\mathtt{TP}_{\" + true_env + \"}$\")\n\n\nfig, (ax1, ax2, ax3) = plt.subplots(3,1, figsize=(5,7), layout=\"compressed\")\nplot_probabilities_bounds(points_ped, tpped_vals, [], lbounds_ped, \"ped\", ax1)\nplot_probabilities_bounds(points_obj, tpobj_vals, [], lbounds_obj, \"obj\",ax2)\nplot_probabilities_bounds(points_emp, tpemp_vals, [], lbounds_emp, \"emp\", ax3)\n</pre> # Plotting Probabilities: def plot_probabilities_bounds(points, tp_vals, ubounds, lbounds, true_env, ax):     ax = ax     ax.tick_params(axis=\"both\", which=\"major\", labelsize=10)     ax.plot(tp_vals, points, \"b*\", label=\"sampled\")     if ubounds != []:         ub_m, ub_c = ubounds         y_ub = ub_m * np.array(tp_vals) + ub_c         plt.plot(tp_vals, y_ub, \"r\")      lb_m, lb_c = lbounds     y_lb = lb_m * np.array(tp_vals) + lb_c     ax.plot(tp_vals, y_lb, \"k\", label=\"lower bound\", linewidth=4)     lb = min(tp_vals)     ub = max(tp_vals)     lP = min(points)     uP = max(points)     ax.legend(prop={\"size\": 10})     ax.set_xlim(lb-0.01, ub+0.01)     ax.set_ylim(lP-0.01, uP+0.01)      ax.set_title(\"Lower bound of $\\mathbb{P}_{\" + true_env + \"}$ as a function of $\\mathtt{TP}_{\" + true_env + \"}$.\")     ax.set_ylabel(\"$\\mathbb{P}_{\" + true_env + \"}$\")     ax.set_xlabel(\"$\\mathtt{TP}_{\" + true_env + \"}$\")   fig, (ax1, ax2, ax3) = plt.subplots(3,1, figsize=(5,7), layout=\"compressed\") plot_probabilities_bounds(points_ped, tpped_vals, [], lbounds_ped, \"ped\", ax1) plot_probabilities_bounds(points_obj, tpobj_vals, [], lbounds_obj, \"obj\",ax2) plot_probabilities_bounds(points_emp, tpemp_vals, [], lbounds_emp, \"emp\", ax3) <p>Now, we construct the controller contracts for each object class using Polyhedral contracts and constructing it from string. We end up we three contracts --- $\\mathcal{C}_{ped}$, $\\mathcal{C}_{obj}$, and $\\mathcal{C}_{emp}$, respectively for the $\\textit{pedestrian}$, $\\textit{object}$, and $\\textit{background}$ classes. Each contract is constructed from the lower bounds evaluated for probabilities of satisfication of specifications as shown in the Figures above.</p> In\u00a0[7]: Copied! <pre># First we construct each contract individually, and then merge the controller contract:\n## Control contract for pedestrian class\ndef control_contract_ped(lbounds_ped):\n    lb_m, lb_c = lbounds_ped\n    tp = \"tp_ped\"\n    P = \"P_ped\"\n    input_vars = [f\"{tp}\"]\n    output_vars = [f\"{P}\"]\n    assumptions = [f\"{tp} &lt;= 1\", f\"-{tp} &lt;= -0.6\"]\n    guarantees = [f\"-{P} + \"+str(lb_m)+ f\"{tp} &lt;= \"+str(-1*lb_c)]\n    Cped = PolyhedralContract.from_string(input_vars=input_vars, output_vars=output_vars, assumptions=assumptions, guarantees=guarantees)\n    return Cped\n\n\n\ndef control_contract_obj(lbounds_obj):\n    lb_m, lb_c = lbounds_obj\n\n    tp = \"tp_obj\"\n    P = \"P_obj\"\n    input_vars = [f\"{tp}\"]\n    output_vars = [f\"{P}\"]\n    assumptions = [f\"{tp} &lt;= 1\", f\"-{tp} &lt;= -0.3\"]\n    guarantees = [f\"-{P} + \"+str(lb_m)+ f\"{tp} &lt;= \"+str(-1*lb_c)]\n    Cobj = PolyhedralContract.from_string(input_vars=input_vars, output_vars=output_vars, assumptions=assumptions, guarantees=guarantees)\n    return Cobj\n\n\n\ndef control_contract_emp(lbounds_emp):\n    lb_m, lb_c = lbounds_emp\n\n    tp = \"tp_emp\"\n    P = \"P_emp\"\n    input_vars = [f\"{tp}\"]\n    output_vars = [f\"{P}\"]\n    assumptions = [f\"{tp} &lt;= 1\", f\"-{tp} &lt;= -0.6\"]\n    guarantees = [f\"-{P} + \"+str(lb_m)+ f\"{tp} &lt;= \"+str(-1*lb_c)]\n    Cemp = PolyhedralContract.from_string(input_vars=input_vars, output_vars=output_vars, assumptions=assumptions, guarantees=guarantees)\n    return Cemp\n\n\nCped = control_contract_ped(lbounds_ped)\nCobj = control_contract_obj(lbounds_obj)\nCemp = control_contract_emp(lbounds_emp)\n\nprint(\"Controller Contract for pedestrian class:\\n\" + str(Cped) + \"\\n\")\nprint(\"Controller Contract for object class:\\n\" + str(Cobj) + \"\\n\")\nprint(\"Controller Contract for empty class:\\n\" + str(Cemp) + \"\\n\")\n</pre> # First we construct each contract individually, and then merge the controller contract: ## Control contract for pedestrian class def control_contract_ped(lbounds_ped):     lb_m, lb_c = lbounds_ped     tp = \"tp_ped\"     P = \"P_ped\"     input_vars = [f\"{tp}\"]     output_vars = [f\"{P}\"]     assumptions = [f\"{tp} &lt;= 1\", f\"-{tp} &lt;= -0.6\"]     guarantees = [f\"-{P} + \"+str(lb_m)+ f\"{tp} &lt;= \"+str(-1*lb_c)]     Cped = PolyhedralContract.from_string(input_vars=input_vars, output_vars=output_vars, assumptions=assumptions, guarantees=guarantees)     return Cped    def control_contract_obj(lbounds_obj):     lb_m, lb_c = lbounds_obj      tp = \"tp_obj\"     P = \"P_obj\"     input_vars = [f\"{tp}\"]     output_vars = [f\"{P}\"]     assumptions = [f\"{tp} &lt;= 1\", f\"-{tp} &lt;= -0.3\"]     guarantees = [f\"-{P} + \"+str(lb_m)+ f\"{tp} &lt;= \"+str(-1*lb_c)]     Cobj = PolyhedralContract.from_string(input_vars=input_vars, output_vars=output_vars, assumptions=assumptions, guarantees=guarantees)     return Cobj    def control_contract_emp(lbounds_emp):     lb_m, lb_c = lbounds_emp      tp = \"tp_emp\"     P = \"P_emp\"     input_vars = [f\"{tp}\"]     output_vars = [f\"{P}\"]     assumptions = [f\"{tp} &lt;= 1\", f\"-{tp} &lt;= -0.6\"]     guarantees = [f\"-{P} + \"+str(lb_m)+ f\"{tp} &lt;= \"+str(-1*lb_c)]     Cemp = PolyhedralContract.from_string(input_vars=input_vars, output_vars=output_vars, assumptions=assumptions, guarantees=guarantees)     return Cemp   Cped = control_contract_ped(lbounds_ped) Cobj = control_contract_obj(lbounds_obj) Cemp = control_contract_emp(lbounds_emp)  print(\"Controller Contract for pedestrian class:\\n\" + str(Cped) + \"\\n\") print(\"Controller Contract for object class:\\n\" + str(Cobj) + \"\\n\") print(\"Controller Contract for empty class:\\n\" + str(Cemp) + \"\\n\") <pre>Controller Contract for pedestrian class:\nInVars: [tp_ped]\nOutVars:[P_ped]\nA: [\n  tp_ped &lt;= 1\n  -tp_ped &lt;= -0.6\n]\nG: [\n  -P_ped + 1.58 tp_ped &lt;= 0.6221\n]\n\nController Contract for object class:\nInVars: [tp_obj]\nOutVars:[P_obj]\nA: [\n  tp_obj &lt;= 1\n  -tp_obj &lt;= -0.3\n]\nG: [\n  -P_obj + 0.06835 tp_obj &lt;= -0.9289\n]\n\nController Contract for empty class:\nInVars: [tp_emp]\nOutVars:[P_emp]\nA: [\n  tp_emp &lt;= 1\n  -tp_emp &lt;= -0.6\n]\nG: [\n  -P_emp + 0.2005 tp_emp &lt;= -0.7997\n]\n\n</pre> <p>We use the merge operator to. Then, the control contracts are merged as follows to get the full contract describing the assumptions and guarantees of the controller: $$\\mathcal{C}_{control} = \\mathcal{C}_{ped} \\bullet \\mathcal{C}_{obj} \\bullet \\mathcal{C}_{emp}$$</p> In\u00a0[8]: Copied! <pre># Construct merger of contracts:\nC_controller = Cped.merge(Cobj)\nC_controller = C_controller.merge(Cemp)\n\nprint(\"Merged Controller Contract for all object classes:\\n\" + str(C_controller) + \"\\n\")\n</pre> # Construct merger of contracts: C_controller = Cped.merge(Cobj) C_controller = C_controller.merge(Cemp)  print(\"Merged Controller Contract for all object classes:\\n\" + str(C_controller) + \"\\n\") <pre>Merged Controller Contract for all object classes:\nInVars: [tp_ped, tp_obj, tp_emp]\nOutVars:[P_ped, P_obj, P_emp]\nA: [\n  tp_ped &lt;= 1\n  -tp_ped &lt;= -0.6\n  tp_obj &lt;= 1\n  -tp_obj &lt;= -0.3\n  tp_emp &lt;= 1\n  -tp_emp &lt;= -0.6\n]\nG: [\n  -P_ped + 1.58 tp_ped &lt;= 0.6221\n  -P_obj + 0.06835 tp_obj &lt;= -0.9289\n  -P_emp + 0.2005 tp_emp &lt;= -0.7997\n]\n\n</pre> <p>The overall system level contract is return takes an input distance and returns the desired system-level probability is lower bounded by an affine function of distance. Thus, we encode the following is contract form: $$\\mathbb{P}_{ped}(s_0 \\models \\varphi_{ped}) \\geq m_{ped}d + c_{ped},$$ $$\\mathbb{P}_{obj}(s_0 \\models \\varphi_{obj}) \\geq m_{obj}d + c_{obj},$$ $$\\mathbb{P}_{emp}(s_0 \\models \\varphi_{emp}) \\geq m_{emp}d + c_{emp},$$</p> <p>where $m_{ped} = -0.099$, $c_{ped}=0.99$, $m_{obj} = -0.08$, $c_{obj}=0.8$, $m_{emp} = -0.09$, $c_{emp}=0.9$. For this case study example, these lower bounds were arbitrarily chosen.</p> In\u00a0[9]: Copied! <pre>## System contract: P &gt;= 0.99\ndef system_contract_dist():\n    a1, a2, a3 = 0.99, 0.8, 0.95\n    d = \"d\"\n    P_emp = \"P_emp\"\n    P_obj = \"P_obj\"\n    P_ped = \"P_ped\"\n    input_vars = [d]\n    output_vars = [P_ped, P_obj, P_emp]\n    assumptions = [\n        f\"-{d} &lt;= 0\",\n        f\"{d} &lt;= 10\",\n        ]\n\n    guarantees = [\n        f\"-{P_ped} - 0.099{d} &lt;= \"+str(-a1),\n        f\"-{P_obj} - 0.08{d} &lt;= \"+str(-a2),\n        f\"-{P_emp} - 0.095{d} &lt;= \"+str(-a3),\n        ]\n    system_contract = PolyhedralContract.from_string(input_vars=input_vars, output_vars=output_vars, assumptions=assumptions, guarantees=guarantees)\n    return system_contract\n\nCsys_dist = system_contract_dist()\nprint(\"System Contract (distance bounds):\\n\" + str(Csys_dist) + \"\\n\")\n</pre> ## System contract: P &gt;= 0.99 def system_contract_dist():     a1, a2, a3 = 0.99, 0.8, 0.95     d = \"d\"     P_emp = \"P_emp\"     P_obj = \"P_obj\"     P_ped = \"P_ped\"     input_vars = [d]     output_vars = [P_ped, P_obj, P_emp]     assumptions = [         f\"-{d} &lt;= 0\",         f\"{d} &lt;= 10\",         ]      guarantees = [         f\"-{P_ped} - 0.099{d} &lt;= \"+str(-a1),         f\"-{P_obj} - 0.08{d} &lt;= \"+str(-a2),         f\"-{P_emp} - 0.095{d} &lt;= \"+str(-a3),         ]     system_contract = PolyhedralContract.from_string(input_vars=input_vars, output_vars=output_vars, assumptions=assumptions, guarantees=guarantees)     return system_contract  Csys_dist = system_contract_dist() print(\"System Contract (distance bounds):\\n\" + str(Csys_dist) + \"\\n\") <pre>System Contract (distance bounds):\nInVars: [d]\nOutVars:[P_ped, P_obj, P_emp]\nA: [\n  -d &lt;= 0\n  d &lt;= 10\n]\nG: [\n  -P_ped - 0.099 d &lt;= -0.99\n  -P_obj - 0.08 d &lt;= -0.8\n  -P_emp - 0.095 d &lt;= -0.95\n]\n\n</pre> <p>Finally, to derive specifications on the object detection module, we derive lower bounds on the required $\\textit{true positive rate}$ for each class. To do this, we take the quotient of the merged controller contract from the overall system contract, $$\\mathcal{C}_{det} = \\mathcal{C}_{sys}/\\mathcal{C}_{control}$$</p> In\u00a0[10]: Copied! <pre># Computing quotient contract:\nC_det = Csys_dist.quotient(C_controller)\nprint(\"Quotient Contract with distance bounds on true positive rates:\\n\" + str(C_det) + \"\\n\")\n</pre> # Computing quotient contract: C_det = Csys_dist.quotient(C_controller) print(\"Quotient Contract with distance bounds on true positive rates:\\n\" + str(C_det) + \"\\n\") <pre>Quotient Contract with distance bounds on true positive rates:\nInVars: [d]\nOutVars:[tp_ped, tp_obj, tp_emp]\nA: [\n  -d &lt;= 0\n  d &lt;= 10\n]\nG: [\n  -0.099 d - 1.58 tp_ped &lt;= -1.612\n  tp_ped &lt;= 1\n  -tp_ped &lt;= -0.6\n  tp_obj &lt;= 1\n  -tp_obj &lt;= -0.3\n  tp_emp &lt;= 1\n  -tp_emp &lt;= -0.6\n]\n\n</pre> <p>Let's see how contract $\\mathcal{C}_{det}$ varies with distance to ego for the pedestrian specification.</p> In\u00a0[11]: Copied! <pre>_= plots.plot_guarantees(C_det, Var('d'), Var('tp_ped'), var_values={Var('tp_obj'):0.4, Var('tp_emp'):0.7}, x_lims=[1,10],y_lims=[0.5,1])\n</pre> _= plots.plot_guarantees(C_det, Var('d'), Var('tp_ped'), var_values={Var('tp_obj'):0.4, Var('tp_emp'):0.7}, x_lims=[1,10],y_lims=[0.5,1])"},{"location":"_case_studies/cs-vehicle-perception/evaluate_perception/#evaluating-perception-with-respect-to-system-level-specifications","title":"Evaluating Perception with respect to System-level Specifications\u00b6","text":"<p>Consider the following example of an autonomous car driving on a road with an obstacle $d$ m away from the car. We require the car to be safe, with the quantitative metric of safety increasing as the distance to the obstacle $d$ decreases. Given that the car's controller chooses actions based on observations passed by the perception module, can we quantitatively characterize the desired performance of the perception module to ensure safe behavior? In this case study, we address this question using assume-guarantee contract operators in Pacti. In particular, we focus on the object detection and classification tasks of perception, and use confusion matrices to represent the statistically average performance of the detection model. In this notebook, we derive lower bounds on the elements of the confusion matrix given the system-level specifications and a discrete state abstraction of the controllers. Any learned detection model that respects these constraints together with the controller will satisfy the system-level quantitative requirements.</p>"},{"location":"_case_studies/cs-vehicle-perception/evaluate_perception/#motivation","title":"Motivation\u00b6","text":"<p>Temporal logic has been an effective formalism for specifying system-level requirements that correspond to safe operation of autonomous vehicles (Baier &amp; Katoen, Piterman et al.). Formally specifying these requirements in temporal logic has led to an effective paradigm for synthesizing correct controllers at a high-level of abstraction (as seen in Wongpiromsarn et al. 2012, Kress-Gazit et al. 2009,Lahijanian et al. 2009, Kloetzer et al. 2008). However, most of these control synthesis techniques assume perfect perception and do not account for perception errors. Consider the object detection task of the perception component---it is not possible to train a neural network that correctly detects every object due to the well-known precision-recall tradeoff (see Geron 2019, Koyejo et al. 2015, Wang et al. 2019, Narasimhan et al. 2015). Thus, the correctness guarantees of the synthesized controller, which are predicated on the correctness of object detection, will not always hold.</p> <p>In BWM 21, the authors presented the of use of the confusion matrix, a popular metric for evaluating object detection performance in the computer vision community, to quantitatively evaluate the end-to-end detection and planning stack with respect to system-level temporal logic requirements.</p> <p>To reduce conservativeness in this probabilistic analysis, the canonical confusion matrix was adapted to formally define new evaluation metrics for object detection by accounting for the structure of the downstream controller BWM 22.</p> <p>Since the confusion matrix can be seen as an evaluation metric for object detection, characterizing the elements of the confusion matrix (such as true positive rates for each class) can be a way to formally specify requirements on the object detection module.</p>"},{"location":"_case_studies/cs-vehicle-perception/evaluate_perception/#part-1-example","title":"Part 1: Example\u00b6","text":""},{"location":"_case_studies/cs-vehicle-perception/evaluate_perception/#part-2-controller-contracts","title":"Part 2: Controller Contracts\u00b6","text":""},{"location":"_case_studies/cs-vehicle-perception/evaluate_perception/#part-3-system-contract","title":"Part 3: System Contract\u00b6","text":""},{"location":"_case_studies/cs-vehicle-perception/evaluate_perception/#part-4-object-detection-contract-found-using-quotient","title":"Part 4: Object Detection Contract found using quotient\u00b6","text":""},{"location":"_case_studies/cs-vehicle-perception/evaluate_perception/#references","title":"References\u00b6","text":"<p> Baier and Katoen. 2008</p> <p>Baier, Christel, and Joost-Pieter Katoen.  Principles of Model Checking.</p> <p> Piterman et al. 2006</p> <p>Piterman, N., Pnueli, A., Sa\u2019ar, Y. Synthesis of reactive (1) designs. In: International Workshop on Verification, Model Checking, and Abstract Interpretation. pp. 364\u2013380. Springer (2006)</p> <p> Wongpiromsarn et al. 2012</p> <p>Wongpiromsarn, T., Topcu, U., Murray, R.M. Receding horizon temporal logic planning IEEE Transactions on Automatic Control 57(11), 2817\u20132830 (2012)</p> <p> Kress-Gazit et al. 2009</p> <p>Kress-Gazit, H., Fainekos, G.E., Pappas, G.J.:  Temporal-logic-based reactive mission and motion planning. IEEE Transactions on Robotics 25(6), 1370\u20131381 (2009) 26.</p> <p> Lahijanian et al. 2009</p> <p>Lahijanian, M., Andersson, S.B., Belta, C. A probabilistic approach for control of a stochastic system from LTL specifications. In: Proceedings of the 48h IEEE Conference on Decision and Control (CDC) held jointly with 2009 28th Chinese Control Conference. pp. 2236\u20132241. IEEE (2009)</p> <p> Koyejo et al. 2015</p> <p>Koyejo, O., Natarajan, N., Ravikumar, P., Dhillon, I.S. Consistent multilabel classification. In: NeurIPS. vol. 29, pp. 3321\u20133329 (2015)</p> <p> Kloetzer et al. 2008</p> <p>Kloetzer, M., Belta, C. A fully automated framework for control of linear systems from temporal logic specifications. IEEE Transactions on Automatic Control 53(1), 287\u2013297 (2008)</p> <p> Geron et al. 2019</p> <p>G\u00e9ron, A.: Hands-on machine learning with Scikit-Learn, Keras, and TensorFlow: Concepts, Tools, and Techniques to Build Intelligent Systems. O\u2019Reilly Media (2019)</p> <p> BWM 2021</p> <p>Badithela, A., Wongpiromsarn, T., Murray, R.M.: Leveraging classification metrics for quantitative system-level analysis with temporal logic specifications. In: 2021 60th IEEE Conference on Decision and Control (CDC). pp. 564\u2013571. IEEE (2021)</p> <p> BWM 2022</p> <p>Badithela, A., Wongpiromsarn, T., Murray, R.M.: Evaluation metrics for object detection for autonomous systems. arXiv preprint arXiv:2210.10298 (2022)</p> <p> Narasimhan et al. 2015 Narasimhan, H., Ramaswamy, H., Saha, A., Agarwal, S.</p> <p>Consistent multiclass algorithms for complex performance measures. In: International Conference on Machine Learning. pp. 2398\u20132407. PMLR (2015)</p> <p> Topan et al. 2022</p> <p>Topan, S., Leung, K., Chen, Y., Tupekar, P., Schmerling, E., Nilsson, J., Cox, M., Pavone, M.</p> <p>Interaction-dynamics-aware perception zones for obstacle detection safety evaluation.</p> <p>In: 2022 IEEE Intelligent Vehicles Symposium (IV). pp. 1201\u20131210. IEEE (2022)</p> <p> Wang et al. 2019</p> <p>Wang, X., Li, R., Yan, B., Koyejo, O. Consistent classification with generalized metrics. arXiv preprint arXiv:1908.09057 (2019)</p>"},{"location":"_docs/getting_started/","title":"Getting Started","text":"<p>Pacti helps designers to reason about specifications and to manipulate them. These specifications are given to Pacti as assume-guarantee contracts, which are requirements of the form (assumptions, guarantees).</p> <p>For Pacti, every contract has four elements:</p> <ul> <li>Input variables</li> <li>Output variables</li> <li>Assumptions: constraints whose satisfaction requires the object under specification to deliver the contract's guarantees. In Pacti, assumptions can only refer to the input variables of the contract.</li> <li>Guarantees: constraints that the object under specification can be expected to deliver when the contract's assumptions are met. In Pacti, guarantees can only refer to the input or output variables of the contract.</li> </ul> <p>The interface of a contract is the set of its input and output variables.</p> <p>The algebra of contracts has been extensively researched and peer-reviewed by experts\u2014see Benveniste et al. 2018, Incer 2022, and references therein. Contracts provide mathematical rigor to several tasks of relevance to system design. The algebra of contracts contains operations that generate new contracts from existing ones, i.e., the algebra is closed under these operations. We can use the algebra of contracts to address the following tasks:</p> <ul> <li>Building systems. Suppose that we have specified contracts for a set of subsystems. We can define a system as the assembly of such subsystems. The operation of composition allows us to compute the contract of such a system from the contracts of the assembled subsystems. In other words, composition provides a mechanism for computing system contracts from subsystem contracts.</li> <li>Patching systems. The operation of quotient allows us to compute the contract of a subsystem that needs to be composed with an existing subsystem so that the resulting system composition meets a top-level contract. In other words, the quotient finds contracts of missing subsystems from contracts for the system and a partial implementation.</li> <li>Validity of decompositions. Refinement allows us to tell when a contract is more relaxed, or less demanding than another. When a subsystem satisfies a contract, it is guaranteed to satisfy a more relaxed contract. When a system contract is broken into an assembly of subsystem contracts, refinement allows us to tell whether this decomposition is a valid refinement of the system-level contract.</li> <li>Fusing viewpoints. The operation of merging allows us to generate a single contract whose assumptions and guarantees require the satisfaction of the assumptions and guarantees of the merged contracts, respectively. In other words, merging fuses multiple contract viewpoints, a common operation in concurrent design.</li> </ul> In\u00a0[1]: Copied! <pre>from pacti.terms.polyhedra import PolyhedralContract\n\ncontract1 = PolyhedralContract.from_string(\n    input_vars=[\"i\"],\n    output_vars=[\"o\"],\n    assumptions=[\"|i| &lt;= 2\"],\n    guarantees=[\"o - i &lt;= 0\", \"i - 2o &lt;= 2\"]\n)\n\ncontract2 = PolyhedralContract.from_string(\n    input_vars=[\"o\"],\n    output_vars=[\"o_p\"],\n    assumptions=[\"o &lt;= 0.2\", \"-o &lt;= 1\"],\n    guarantees=[\"o_p - o &lt;= 0\"]\n)\n\nsystem_contract = contract1.compose(contract2)\nprint(system_contract)\n</pre> from pacti.terms.polyhedra import PolyhedralContract  contract1 = PolyhedralContract.from_string(     input_vars=[\"i\"],     output_vars=[\"o\"],     assumptions=[\"|i| &lt;= 2\"],     guarantees=[\"o - i &lt;= 0\", \"i - 2o &lt;= 2\"] )  contract2 = PolyhedralContract.from_string(     input_vars=[\"o\"],     output_vars=[\"o_p\"],     assumptions=[\"o &lt;= 0.2\", \"-o &lt;= 1\"],     guarantees=[\"o_p - o &lt;= 0\"] )  system_contract = contract1.compose(contract2) print(system_contract) <pre>InVars: [i]\nOutVars:[o_p]\nA: [\n  i &lt;= 0.19999999999999996\n  -0.5 i &lt;= 0.0\n]\nG: [\n  -i + o_p &lt;= 0.0\n]\n</pre> <p>Pacti gives us the specification of the system. Note that the resulting contract only involves the top-level input and output variables, having eliminated the intermediate variable, <code>o</code>.</p> In\u00a0[2]: Copied! <pre>contract1_n = PolyhedralContract.from_string(\n    input_vars=[\"i\"],\n    output_vars=[\"o\"],\n    assumptions=[\"|i| &lt;= 2\"],\n    guarantees=[\"|o| &lt;= 3\"]\n)\n\n\ntry:\n    new_system_contract = contract1_n.compose(contract2)\nexcept ValueError as e:\n    print(\"Composition error: {0}\".format(e))\n</pre> contract1_n = PolyhedralContract.from_string(     input_vars=[\"i\"],     output_vars=[\"o\"],     assumptions=[\"|i| &lt;= 2\"],     guarantees=[\"|o| &lt;= 3\"] )   try:     new_system_contract = contract1_n.compose(contract2) except ValueError as e:     print(\"Composition error: {0}\".format(e)) <pre>Composition error: Could not eliminate variables ['o']\nby refining the assumptions \n[\n  o &lt;= 0.19999999999999996\n  -o &lt;= 1.0\n]\nusing guarantees \n[\n  |o| &lt;= 3.0\n]\n\n</pre> <p>Pacti is unable to compute a system specification. In this case, this is due to the fact that our guarantee <code>\\|o\\| &lt;= 3</code> for $M_1$ does not satisfy the assumptions of <code>contract2</code>.</p> <p>We wish to implement a system $M$ given an available subsystem $M'$ as described below.</p> Component Contract Inputs Outputs Assumptions Guarantees $M$ <code>contract_top_level</code> <code>i</code> <code>o_p</code> <code>|i| &lt;= 1</code> <code>o_p = 2i + 1</code> $M'$ <code>contract_existing_subsystem</code> <code>i</code> <code>o</code> <code>|i| &lt;= 2</code> <code>o = 2i</code> <p>We use Pacti's quotient operation to obtain the specification of the missing subsystem corresponding to the question mark above so that the resulting object meets the specification <code>contract_top_level</code>. The following codifies this missing subsystem problem:</p> In\u00a0[3]: Copied! <pre>contract_top_level = PolyhedralContract.from_string(\n    input_vars=[\"i\"],\n    output_vars=[\"o_p\"],\n    assumptions=[\"|i| &lt;= 1\"],\n    guarantees=[\"o_p - 2i = 1\"]\n)\n\ncontract_existing_subsystem = PolyhedralContract.from_string(\n    input_vars=[\"i\"],\n    output_vars=[\"o\"],\n    assumptions=[\"|i| &lt;= 2\"],\n    guarantees=[\"o - 2i = 0\"]\n)\n\ncontract_missing_subsystem = contract_top_level.quotient(contract_existing_subsystem)\nprint(contract_missing_subsystem)\n</pre> contract_top_level = PolyhedralContract.from_string(     input_vars=[\"i\"],     output_vars=[\"o_p\"],     assumptions=[\"|i| &lt;= 1\"],     guarantees=[\"o_p - 2i = 1\"] )  contract_existing_subsystem = PolyhedralContract.from_string(     input_vars=[\"i\"],     output_vars=[\"o\"],     assumptions=[\"|i| &lt;= 2\"],     guarantees=[\"o - 2i = 0\"] )  contract_missing_subsystem = contract_top_level.quotient(contract_existing_subsystem) print(contract_missing_subsystem) <pre>InVars: [o]\nOutVars:[o_p]\nA: [\n  |o| &lt;= 2.0\n]\nG: [\n  -o + o_p = 1.0\n]\n</pre> <p>Observe that Pacti tells us that the missing subsystem's specification has input <code>o</code> and output <code>o_p</code>. The resulting specification is guaranteed to implement the top-level system when composed with the contract of the existing subsystem. We can verify this:</p> In\u00a0[4]: Copied! <pre># compose quotient\nnew_system = contract_missing_subsystem.compose(contract_existing_subsystem)\nprint(new_system.refines(contract_top_level))\n</pre> # compose quotient new_system = contract_missing_subsystem.compose(contract_existing_subsystem) print(new_system.refines(contract_top_level)) <pre>True\n</pre> In\u00a0[5]: Copied! <pre>functionality_viewpoint = PolyhedralContract.from_string(\n    input_vars=[\"i\"],\n    output_vars=[\"o\"],\n    assumptions=[\"|i| &lt;= 2\"],\n    guarantees=[\"o - 2i = 1\"]\n)\n\npower_viewpoint = PolyhedralContract.from_string(\n    input_vars=[\"temp\"],\n    output_vars=[\"P\"],\n    assumptions=[\"temp &lt;= 90\"],\n    guarantees=[\"P &lt;= 2.1\"]\n)\n\nsubsystem_contract = functionality_viewpoint.compose(power_viewpoint)\nprint(subsystem_contract)\n</pre> functionality_viewpoint = PolyhedralContract.from_string(     input_vars=[\"i\"],     output_vars=[\"o\"],     assumptions=[\"|i| &lt;= 2\"],     guarantees=[\"o - 2i = 1\"] )  power_viewpoint = PolyhedralContract.from_string(     input_vars=[\"temp\"],     output_vars=[\"P\"],     assumptions=[\"temp &lt;= 90\"],     guarantees=[\"P &lt;= 2.1\"] )  subsystem_contract = functionality_viewpoint.compose(power_viewpoint) print(subsystem_contract) <pre>InVars: [i, temp]\nOutVars:[o, P]\nA: [\n  |i| &lt;= 2.0\n  temp &lt;= 90.0\n]\nG: [\n  -2.0 i + o = 1.0\n  P &lt;= 2.1\n]\n</pre>"},{"location":"_docs/getting_started/#computing-system-specifications","title":"Computing system specifications\u00b6","text":"<p>Consider the following system:</p> Component Contract Inputs Outputs Assumptions Guarantees $M$ <code>contract1</code> <code>i</code> <code>o</code> <code>|i| &lt;= 2</code> <code>o &lt;= i &lt;= 2o + 2</code> $M'$ <code>contract2</code> <code>o</code> <code>o_p</code> <code>-1 &lt;= o &lt;= 1/5</code> <code>o_p &lt;= o</code> <p>We can use Pacti to obtain the contract of the system that assembles these two components as follows:</p>"},{"location":"_docs/getting_started/#system-diagnostics","title":"System diagnostics\u00b6","text":"<p>Suppose that we want to build a system as shown in the figure above, with subsystem $M_1$ replacing $M$, as specified below:</p> Component Contract Inputs Outputs Assumptions Guarantees $M_1$ <code>contract1_n</code> <code>i</code> <code>o</code> <code>|i| &lt;= 2</code> <code>|o| &lt;= 3</code> $M'$ <code>contract2</code> <code>o</code> <code>o_p</code> <code>-1 &lt;= o &lt;= 1/5</code> <code>o_p &lt;= o</code> <p>The Pacti specification then becomes the following:</p>"},{"location":"_docs/getting_started/#specifications-of-missing-subsystems","title":"Specifications of missing subsystems\u00b6","text":"<p>Now consider the situation shown in the following diagram:</p>"},{"location":"_docs/getting_started/#fusing-viewpoints","title":"Fusing viewpoints\u00b6","text":"<p>Suppose that we have two specifications for a subsystem, corresponding to different viewpoints, as shown in the following table:</p> Viewpoint Contract Inputs Outputs Assumptions Guarantees Functionality <code>functionality_viewpoint</code> <code>i</code> <code>o</code> <code>|i| &lt;= 2</code> <code>o = 2i + 1</code> Power <code>power_viewpoint</code> <code>temp</code> <code>P</code> <code>temp &lt;= 90</code> <code>P &lt;= 2.1</code> <p>We can use contract merging to obtain a single specification for the subsystem:</p>"},{"location":"_docs/getting_started/#to-learn-more","title":"To learn more\u00b6","text":"<p>These examples illustrate some analysis tasks we can carry out with Pacti. The <code>case_studies</code> folder contains discussions of the application of Pacti in various design disciplines.</p>"},{"location":"_docs/getting_started/#references","title":"References\u00b6","text":"<p> Benveniste et al. 2018</p> <p>Benveniste, A., Caillaud, B., Nickovic, D., Passerone, R., Raclet, J-B., Reinkemeier, P., Sangiovanni-Vincentelli, A., Damm, W., Henzinger, T. A., and Larsen, K. G. Contracts for system design. Foundations and Trends\u00ae in Electronic Design Automation 12, no. 2-3 (2018): 124-400.</p> <p> Incer 2022</p> <p>Incer, I. The Algebra of Contracts. PhD Thesis. University of California, Berkeley, 2022.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pacti<ul> <li>iocontract<ul> <li>compundiocontract</li> <li>iocontract</li> </ul> </li> <li>terms<ul> <li>polyhedra<ul> <li>plots</li> <li>polyhedra</li> <li>polyhedral_contract</li> <li>serializer</li> </ul> </li> </ul> </li> <li>utils<ul> <li>errors</li> <li>fileio</li> <li>lists</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/pacti/","title":"Index","text":""},{"location":"reference/pacti/iocontract/","title":"Index","text":""},{"location":"reference/pacti/iocontract/compundiocontract/","title":"Compundiocontract","text":"<p>Functionality for IO contracts with assumptions and guarantees expressed as disconnected convex sets.</p>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.IoContractCompound","title":"<code>IoContractCompound</code>","text":"<p>         Bases: <code>Generic[NestedTermlist_t]</code></p> <p>Basic type for a compound IO contract.</p> <p>Attributes:</p> Name Type Description <code>inputvars</code> <p>Variables which are inputs of the implementations of the contract.</p> <code>outputvars</code> <p>Variables which are outputs of the implementations of the contract.</p> <code>a</code> <code>NestedTermlist_t</code> <p>Contract assumptions.</p> <code>g</code> <code>NestedTermlist_t</code> <p>Contract guarantees.</p> Source code in <code>pacti\\iocontract\\compundiocontract.py</code> <pre><code>class IoContractCompound(Generic[NestedTermlist_t]):\n\"\"\"\n    Basic type for a compound IO contract.\n\n    Attributes:\n        inputvars:\n            Variables which are inputs of the implementations of the contract.\n\n        outputvars:\n            Variables which are outputs of the implementations of the contract.\n\n        a: Contract assumptions.\n\n        g: Contract guarantees.\n    \"\"\"\n\n    def __init__(\n        self, assumptions: NestedTermlist_t, guarantees: NestedTermlist_t, input_vars: List[Var], output_vars: List[Var]\n    ):\n\"\"\"\n        Class constructor.\n\n        Args:\n            assumptions: The assumptions of the contract.\n            guarantees: The guarantees of the contract.\n            input_vars: The input variables of the contract.\n            output_vars: The output variables of the contract.\n\n        Raises:\n            ValueError: Arguments provided does not produce a valid IO contract.\n        \"\"\"\n        logging.debug(\"Constructor assumptions\")\n        logging.debug(assumptions)\n        logging.debug(\"Constructor guarantees\")\n        logging.debug(guarantees)\n        # make sure the input and output variables have no repeated entries\n        if len(input_vars) != len(set(input_vars)):\n            raise ValueError(\n                \"The following input variables appear multiple times in argument %s\"\n                % (set(list_diff(input_vars, list(set(input_vars)))))\n            )\n        if len(output_vars) != len(set(output_vars)):\n            raise ValueError(\n                \"The following output variables appear multiple times in argument %s\"\n                % (set(list_diff(output_vars, list(set(output_vars)))))\n            )\n        # make sure the input &amp; output variables are disjoint\n        if list_intersection(input_vars, output_vars):\n            raise ValueError(\n                \"The following variables appear in inputs and outputs: %s\"\n                % (list_intersection(input_vars, output_vars))\n            )\n        # make sure the assumptions only contain input variables\n        if list_diff(assumptions.vars, input_vars):\n            raise ValueError(\n                \"The following variables appear in the assumptions but are not inputs: %s\"\n                % (list_diff(assumptions.vars, input_vars))\n            )\n        # make sure the guarantees only contain input or output variables\n        if list_diff(guarantees.vars, list_union(input_vars, output_vars)):\n            raise ValueError(\n                \"The guarantees contain the following variables which are neither\"\n                \"inputs nor outputs: %s. Inputs: %s. Outputs: %s. Guarantees: %s\"\n                % (list_diff(guarantees.vars, list_union(input_vars, output_vars)), input_vars, output_vars, guarantees)\n            )\n\n        self.a: NestedTermlist_t = assumptions.copy(True)\n        self.g: NestedTermlist_t = guarantees.copy(False)\n        self.inputvars = input_vars.copy()\n        self.outputvars = output_vars.copy()\n        # simplify the guarantees with the assumptions\n        # self.g = self.g.simplify(self.a)\n\n    def __str__(self) -&gt; str:\n        return (\n            \"InVars: \"\n            + \"[\"\n            + \", \".join([v.name for v in self.inputvars])\n            + \"]\"\n            + \"\\nOutVars:\"\n            + \"[\"\n            + \", \".join([v.name for v in self.outputvars])\n            + \"]\"\n            + \"\\nA: \"\n            + str(self.a)\n            + \"\\n\"\n            + \"G: \"\n            + str(self.g)\n        )\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            raise ValueError\n        return (\n            self.inputvars == other.inputvars\n            and self.outputvars == self.outputvars\n            and self.a == other.a\n            and self.g == other.g\n        )\n\n    def merge(self: IoContractCompound_t, other: IoContractCompound_t) -&gt; IoContractCompound_t:\n\"\"\"\n        Compute the merging operation for two contracts.\n\n        Compute the merging operation of the two given contracts. No\n        abstraction/refinement is applied.\n\n        Args:\n            other: The contract with which we are merging self.\n\n        Returns:\n            The result of merging.\n        \"\"\"\n        input_vars = list_union(self.inputvars, other.inputvars)\n        output_vars = list_union(self.outputvars, other.outputvars)\n        assumptions = self.a.intersect(other.a, force_empty_intersection=True)\n        guarantees = self.g.intersect(other.g, force_empty_intersection=False)\n        return type(self)(assumptions, guarantees, input_vars, output_vars)\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.IoContractCompound.__init__","title":"<code>__init__(assumptions, guarantees, input_vars, output_vars)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>NestedTermlist_t</code> <p>The assumptions of the contract.</p> required <code>guarantees</code> <code>NestedTermlist_t</code> <p>The guarantees of the contract.</p> required <code>input_vars</code> <code>List[Var]</code> <p>The input variables of the contract.</p> required <code>output_vars</code> <code>List[Var]</code> <p>The output variables of the contract.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Arguments provided does not produce a valid IO contract.</p> Source code in <code>pacti\\iocontract\\compundiocontract.py</code> <pre><code>def __init__(\n    self, assumptions: NestedTermlist_t, guarantees: NestedTermlist_t, input_vars: List[Var], output_vars: List[Var]\n):\n\"\"\"\n    Class constructor.\n\n    Args:\n        assumptions: The assumptions of the contract.\n        guarantees: The guarantees of the contract.\n        input_vars: The input variables of the contract.\n        output_vars: The output variables of the contract.\n\n    Raises:\n        ValueError: Arguments provided does not produce a valid IO contract.\n    \"\"\"\n    logging.debug(\"Constructor assumptions\")\n    logging.debug(assumptions)\n    logging.debug(\"Constructor guarantees\")\n    logging.debug(guarantees)\n    # make sure the input and output variables have no repeated entries\n    if len(input_vars) != len(set(input_vars)):\n        raise ValueError(\n            \"The following input variables appear multiple times in argument %s\"\n            % (set(list_diff(input_vars, list(set(input_vars)))))\n        )\n    if len(output_vars) != len(set(output_vars)):\n        raise ValueError(\n            \"The following output variables appear multiple times in argument %s\"\n            % (set(list_diff(output_vars, list(set(output_vars)))))\n        )\n    # make sure the input &amp; output variables are disjoint\n    if list_intersection(input_vars, output_vars):\n        raise ValueError(\n            \"The following variables appear in inputs and outputs: %s\"\n            % (list_intersection(input_vars, output_vars))\n        )\n    # make sure the assumptions only contain input variables\n    if list_diff(assumptions.vars, input_vars):\n        raise ValueError(\n            \"The following variables appear in the assumptions but are not inputs: %s\"\n            % (list_diff(assumptions.vars, input_vars))\n        )\n    # make sure the guarantees only contain input or output variables\n    if list_diff(guarantees.vars, list_union(input_vars, output_vars)):\n        raise ValueError(\n            \"The guarantees contain the following variables which are neither\"\n            \"inputs nor outputs: %s. Inputs: %s. Outputs: %s. Guarantees: %s\"\n            % (list_diff(guarantees.vars, list_union(input_vars, output_vars)), input_vars, output_vars, guarantees)\n        )\n\n    self.a: NestedTermlist_t = assumptions.copy(True)\n    self.g: NestedTermlist_t = guarantees.copy(False)\n    self.inputvars = input_vars.copy()\n    self.outputvars = output_vars.copy()\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.IoContractCompound.merge","title":"<code>merge(other)</code>","text":"<p>Compute the merging operation for two contracts.</p> <p>Compute the merging operation of the two given contracts. No abstraction/refinement is applied.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContractCompound_t</code> <p>The contract with which we are merging self.</p> required <p>Returns:</p> Type Description <code>IoContractCompound_t</code> <p>The result of merging.</p> Source code in <code>pacti\\iocontract\\compundiocontract.py</code> <pre><code>def merge(self: IoContractCompound_t, other: IoContractCompound_t) -&gt; IoContractCompound_t:\n\"\"\"\n    Compute the merging operation for two contracts.\n\n    Compute the merging operation of the two given contracts. No\n    abstraction/refinement is applied.\n\n    Args:\n        other: The contract with which we are merging self.\n\n    Returns:\n        The result of merging.\n    \"\"\"\n    input_vars = list_union(self.inputvars, other.inputvars)\n    output_vars = list_union(self.outputvars, other.outputvars)\n    assumptions = self.a.intersect(other.a, force_empty_intersection=True)\n    guarantees = self.g.intersect(other.g, force_empty_intersection=False)\n    return type(self)(assumptions, guarantees, input_vars, output_vars)\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList","title":"<code>NestedTermList</code>","text":"<p>A collection of termlists interpreted as their disjunction.</p> Source code in <code>pacti\\iocontract\\compundiocontract.py</code> <pre><code>class NestedTermList:\n\"\"\"A collection of termlists interpreted as their disjunction.\"\"\"\n\n    def __init__(  # noqa: WPS231 too much cognitive complexity\n        self, nested_termlist: List[TermList_t], force_empty_intersection: bool\n    ):\n\"\"\"\n        Class constructor.\n\n        Args:\n            nested_termlist: A list of terms contained by TermList.\n            force_empty_intersection: Raise error if the termlists are not disjoint.\n\n        Raises:\n            ValueError: argument has separate termlists with nonempty intersection.\n        \"\"\"\n        # make sure the elements of the argument don't intersect\n        if force_empty_intersection:\n            for i, tli in enumerate(nested_termlist):\n                for j, tlj in enumerate(nested_termlist):\n                    if j &gt; i:\n                        intersection = tli | tlj\n                        if not intersection.is_empty():\n                            raise ValueError(\"Terms %s and %s have nonempty intersection\" % (tli, tlj))\n        self.nested_termlist: List[TermList_t] = []\n        for tl in nested_termlist:\n            self.nested_termlist.append(tl.copy())\n\n    def __str__(self) -&gt; str:\n        if self.nested_termlist:\n            res = [str(tl) for tl in self.nested_termlist]\n            return \"\\nor \\n\".join(res)\n        return \"true\"\n\n    def __le__(self, other: object) -&gt; bool:  # noqa: WPS231 too much cognitive complexity\n        if not isinstance(other, type(self)):\n            raise ValueError()\n        for this_tl in self.nested_termlist:\n            found = False\n            for that_tl in other.nested_termlist:\n                if this_tl &lt;= that_tl:\n                    found = True\n                    break\n            if not found:\n                return False\n        return True\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            raise ValueError()\n        return self &lt;= other &lt;= self\n\n    def simplify(self: NestedTermlist_t, context: NestedTermlist_t, force_empty_intersection: bool) -&gt; NestedTermlist_t:\n\"\"\"\n        Remove redundant terms in nested termlist.\n\n        Args:\n            context: Nested termlist serving as context for simplification.\n            force_empty_intersection: Make sure the resulting termlists have empty intersection.\n\n        Returns:\n            A contract with redundant terms removed in nested termlist.\n        \"\"\"\n        new_nested_tl = []\n        for self_tl in self.nested_termlist:\n            for context_tl in context.nested_termlist:\n                try:\n                    new_tl = self_tl.simplify(context_tl)\n                except ValueError:\n                    new_tl = self_tl.copy()\n                    continue\n                new_nested_tl.append(new_tl)\n        return type(self)(new_nested_tl, force_empty_intersection)\n\n    def intersect(self: NestedTermlist_t, other: NestedTermlist_t, force_empty_intersection: bool) -&gt; NestedTermlist_t:\n\"\"\"\n        Semantically intersect two nested termlists.\n\n        Args:\n            other: second argument to intersection.\n            force_empty_intersection: Raise error if termlists are not disjoint.\n\n        Returns:\n            The nested termlist for the intersection.\n        \"\"\"\n        new_nested_tl = []\n        for self_tl in self.nested_termlist:\n            for other_tl in other.nested_termlist:\n                new_tl = self_tl | other_tl\n                if not new_tl.is_empty():\n                    new_nested_tl.append(new_tl)\n        return type(self)(new_nested_tl, force_empty_intersection)\n\n    @property\n    def vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"The list of variables contained in this nested termlist.\n\n        Returns:\n            List of variables referenced in nested termlist.\n        \"\"\"\n        varlist: List[Var] = []\n        for tl in self.nested_termlist:\n            varlist = list_union(varlist, tl.vars)\n        return varlist\n\n    def copy(self: NestedTermlist_t, force_empty_intersection: bool) -&gt; NestedTermlist_t:\n\"\"\"\n        Makes copy of nested termlist.\n\n        Args:\n            force_empty_intersection: Raise error if the termlists are not disjoint.\n\n        Returns:\n            Copy of nested termlist.\n        \"\"\"\n        return type(self)([tl.copy() for tl in self.nested_termlist], force_empty_intersection)\n\n    def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n        Tell whether constraints contain the given behavior.\n\n        Args:\n            behavior:\n                The behavior in question.\n\n        Returns:\n            True if the behavior satisfies the constraints; false otherwise.\n\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\n        for tl in self.nested_termlist:\n            try:\n                if tl.contains_behavior(behavior):\n                    return True\n            except ValueError as e:\n                raise ValueError from e\n        return False\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList.vars","title":"<code>vars: List[Var]</code>  <code>property</code>","text":"<p>The list of variables contained in this nested termlist.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>List of variables referenced in nested termlist.</p>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList.__init__","title":"<code>__init__(nested_termlist, force_empty_intersection)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>nested_termlist</code> <code>List[TermList_t]</code> <p>A list of terms contained by TermList.</p> required <code>force_empty_intersection</code> <code>bool</code> <p>Raise error if the termlists are not disjoint.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>argument has separate termlists with nonempty intersection.</p> Source code in <code>pacti\\iocontract\\compundiocontract.py</code> <pre><code>def __init__(  # noqa: WPS231 too much cognitive complexity\n    self, nested_termlist: List[TermList_t], force_empty_intersection: bool\n):\n\"\"\"\n    Class constructor.\n\n    Args:\n        nested_termlist: A list of terms contained by TermList.\n        force_empty_intersection: Raise error if the termlists are not disjoint.\n\n    Raises:\n        ValueError: argument has separate termlists with nonempty intersection.\n    \"\"\"\n    # make sure the elements of the argument don't intersect\n    if force_empty_intersection:\n        for i, tli in enumerate(nested_termlist):\n            for j, tlj in enumerate(nested_termlist):\n                if j &gt; i:\n                    intersection = tli | tlj\n                    if not intersection.is_empty():\n                        raise ValueError(\"Terms %s and %s have nonempty intersection\" % (tli, tlj))\n    self.nested_termlist: List[TermList_t] = []\n    for tl in nested_termlist:\n        self.nested_termlist.append(tl.copy())\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList.contains_behavior","title":"<code>contains_behavior(behavior)</code>","text":"<p>Tell whether constraints contain the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Dict[Var, numeric]</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraints; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\iocontract\\compundiocontract.py</code> <pre><code>def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n    Tell whether constraints contain the given behavior.\n\n    Args:\n        behavior:\n            The behavior in question.\n\n    Returns:\n        True if the behavior satisfies the constraints; false otherwise.\n\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\n    for tl in self.nested_termlist:\n        try:\n            if tl.contains_behavior(behavior):\n                return True\n        except ValueError as e:\n            raise ValueError from e\n    return False\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList.copy","title":"<code>copy(force_empty_intersection)</code>","text":"<p>Makes copy of nested termlist.</p> <p>Parameters:</p> Name Type Description Default <code>force_empty_intersection</code> <code>bool</code> <p>Raise error if the termlists are not disjoint.</p> required <p>Returns:</p> Type Description <code>NestedTermlist_t</code> <p>Copy of nested termlist.</p> Source code in <code>pacti\\iocontract\\compundiocontract.py</code> <pre><code>def copy(self: NestedTermlist_t, force_empty_intersection: bool) -&gt; NestedTermlist_t:\n\"\"\"\n    Makes copy of nested termlist.\n\n    Args:\n        force_empty_intersection: Raise error if the termlists are not disjoint.\n\n    Returns:\n        Copy of nested termlist.\n    \"\"\"\n    return type(self)([tl.copy() for tl in self.nested_termlist], force_empty_intersection)\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList.intersect","title":"<code>intersect(other, force_empty_intersection)</code>","text":"<p>Semantically intersect two nested termlists.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>NestedTermlist_t</code> <p>second argument to intersection.</p> required <code>force_empty_intersection</code> <code>bool</code> <p>Raise error if termlists are not disjoint.</p> required <p>Returns:</p> Type Description <code>NestedTermlist_t</code> <p>The nested termlist for the intersection.</p> Source code in <code>pacti\\iocontract\\compundiocontract.py</code> <pre><code>def intersect(self: NestedTermlist_t, other: NestedTermlist_t, force_empty_intersection: bool) -&gt; NestedTermlist_t:\n\"\"\"\n    Semantically intersect two nested termlists.\n\n    Args:\n        other: second argument to intersection.\n        force_empty_intersection: Raise error if termlists are not disjoint.\n\n    Returns:\n        The nested termlist for the intersection.\n    \"\"\"\n    new_nested_tl = []\n    for self_tl in self.nested_termlist:\n        for other_tl in other.nested_termlist:\n            new_tl = self_tl | other_tl\n            if not new_tl.is_empty():\n                new_nested_tl.append(new_tl)\n    return type(self)(new_nested_tl, force_empty_intersection)\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList.simplify","title":"<code>simplify(context, force_empty_intersection)</code>","text":"<p>Remove redundant terms in nested termlist.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>NestedTermlist_t</code> <p>Nested termlist serving as context for simplification.</p> required <code>force_empty_intersection</code> <code>bool</code> <p>Make sure the resulting termlists have empty intersection.</p> required <p>Returns:</p> Type Description <code>NestedTermlist_t</code> <p>A contract with redundant terms removed in nested termlist.</p> Source code in <code>pacti\\iocontract\\compundiocontract.py</code> <pre><code>def simplify(self: NestedTermlist_t, context: NestedTermlist_t, force_empty_intersection: bool) -&gt; NestedTermlist_t:\n\"\"\"\n    Remove redundant terms in nested termlist.\n\n    Args:\n        context: Nested termlist serving as context for simplification.\n        force_empty_intersection: Make sure the resulting termlists have empty intersection.\n\n    Returns:\n        A contract with redundant terms removed in nested termlist.\n    \"\"\"\n    new_nested_tl = []\n    for self_tl in self.nested_termlist:\n        for context_tl in context.nested_termlist:\n            try:\n                new_tl = self_tl.simplify(context_tl)\n            except ValueError:\n                new_tl = self_tl.copy()\n                continue\n            new_nested_tl.append(new_tl)\n    return type(self)(new_nested_tl, force_empty_intersection)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/","title":"Iocontract","text":"<p>IoContracts definitions.</p> <p>IoContracts contains Pacti's basic definitions: Var, Term, TemList, and IoContract. Var creates variables; Term is an abstract class representing constraints; a TermList (also an abstract class) is a collection of terms semantically equivalent to the term which is the conjunction of all terms contained in the TermList; IoContract is an assume-guarantee specification consisting of assumptions, guarantees, and input and output variables. The assumptions and guarantees are given by TermLists. Assumptions make predicates only on inputs, and guarantees on both input and outputs (and no other variable).</p> <p>This module implements all supported contract operations and relations. In order to instantiate contracts and perform this operations, it is necessary to extend Term and TermList with specific constraint formalisms.</p>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract","title":"<code>IoContract</code>","text":"<p>         Bases: <code>Generic[TermList_t]</code></p> <p>Basic type for an IO contract.</p> <p>Attributes:</p> Name Type Description <code>inputvars</code> <p>Variables which are inputs of the implementations of the contract.</p> <code>outputvars</code> <p>Variables which are outputs of the implementations of the contract.</p> <code>a(TermList)</code> <p>Contract assumptions.</p> <code>g(TermList)</code> <p>Contract guarantees.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>class IoContract(Generic[TermList_t]):\n\"\"\"\n    Basic type for an IO contract.\n\n    Attributes:\n        inputvars:\n            Variables which are inputs of the implementations of the contract.\n\n        outputvars:\n            Variables which are outputs of the implementations of the contract.\n\n        a(TermList): Contract assumptions.\n\n        g(TermList): Contract guarantees.\n    \"\"\"\n\n    def __init__(\n        self, assumptions: TermList_t, guarantees: TermList_t, input_vars: List[Var], output_vars: List[Var]\n    ) -&gt; None:\n\"\"\"\n        Class constructor.\n\n        Args:\n            assumptions: The assumptions of the contract.\n            guarantees: The guarantees of the contract.\n            input_vars: The input variables of the contract.\n            output_vars: The output variables of the contract.\n\n        Raises:\n            IncompatibleArgsError: Arguments provided does not produce a valid IO contract.\n        \"\"\"\n        # make sure the input and output variables have no repeated entries\n        if len(input_vars) != len(set(input_vars)):\n            raise IncompatibleArgsError(\n                \"The following input variables appear multiple times in argument %s\"\n                % (set(list_diff(input_vars, list(set(input_vars)))))\n            )\n        if len(output_vars) != len(set(output_vars)):\n            raise IncompatibleArgsError(\n                \"The following output variables appear multiple times in argument %s\"\n                % (set(list_diff(output_vars, list(set(output_vars)))))\n            )\n        # make sure the input &amp; output variables are disjoint\n        if list_intersection(input_vars, output_vars):\n            raise IncompatibleArgsError(\n                \"The following variables appear in inputs and outputs: %s\"\n                % (list_intersection(input_vars, output_vars))\n            )\n        # make sure the assumptions only contain input variables\n        if list_diff(assumptions.vars, input_vars):\n            raise IncompatibleArgsError(\n                \"The following variables appear in the assumptions but are not inputs: %s\"\n                % (list_diff(assumptions.vars, input_vars))\n            )\n        # make sure the guarantees only contain input or output variables\n        if list_diff(guarantees.vars, list_union(input_vars, output_vars)):\n            raise IncompatibleArgsError(\n                \"The guarantees contain the following variables which are neither\"\n                \"inputs nor outputs: %s. Inputs: %s. Outputs: %s. Guarantees: %s\"\n                % (list_diff(guarantees.vars, list_union(input_vars, output_vars)), input_vars, output_vars, guarantees)\n            )\n\n        self.a: TermList_t = assumptions.copy()\n        self.inputvars = input_vars.copy()\n        self.outputvars = output_vars.copy()\n        # simplify the guarantees with the assumptions\n        self.g = guarantees.simplify(self.a)\n\n    @property\n    def vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"\n        The list of variables in the interface of the contract.\n\n        Returns:\n            Input and output variables of the contract.\n        \"\"\"\n        return list_union(self.inputvars, self.outputvars)\n\n    def __str__(self) -&gt; str:\n        return (\n            \"InVars: \"\n            + \"[\"\n            + \", \".join([v.name for v in self.inputvars])\n            + \"]\"\n            + \"\\nOutVars:\"\n            + \"[\"\n            + \", \".join([v.name for v in self.outputvars])\n            + \"]\"\n            + \"\\nA: \"\n            + str(self.a)\n            + \"\\n\"\n            + \"G: \"\n            + str(self.g)\n        )\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            raise ValueError\n        return (\n            self.inputvars == other.inputvars\n            and self.outputvars == self.outputvars\n            and self.a == other.a\n            and self.g == other.g\n        )\n\n    def __hash__(self) -&gt; int:\n        return hash((tuple(self.inputvars), tuple(self.outputvars), self.a, self.g))\n\n    def rename_variable(  # noqa: WPS231 too much cognitive complexity\n        self: IoContract_t, source_var: Var, target_var: Var\n    ) -&gt; IoContract_t:\n\"\"\"\n        Rename a variable in a contract.\n\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n\n        Returns:\n            A contract with `source_var` replaced by `target_var`.\n\n        Raises:\n            IncompatibleArgsError: The new variable is both an input and output of the resulting contract.\n        \"\"\"\n        inputvars = self.inputvars.copy()\n        outputvars = self.outputvars.copy()\n        assumptions = self.a.copy()\n        guarantees = self.g.copy()\n        if source_var != target_var:\n            if source_var in inputvars:\n                if target_var in outputvars:\n                    raise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\n                elif target_var not in inputvars:\n                    inputvars.append(target_var)\n                inputvars.remove(source_var)\n                assumptions = assumptions.rename_variable(source_var, target_var)\n                guarantees = guarantees.rename_variable(source_var, target_var)\n            elif source_var in outputvars:\n                if target_var in inputvars:\n                    raise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\n                elif target_var not in outputvars:\n                    outputvars.append(target_var)\n                outputvars.remove(source_var)\n                assumptions = assumptions.rename_variable(source_var, target_var)\n                guarantees = guarantees.rename_variable(source_var, target_var)\n        return type(self)(assumptions, guarantees, inputvars, outputvars)\n\n    def copy(self: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n        Makes copy of contract.\n\n        Returns:\n            Copy of contract.\n        \"\"\"\n        inputvars = self.inputvars.copy()\n        outputvars = self.outputvars.copy()\n        assumptions = self.a.copy()\n        guarantees = self.g.copy()\n        return type(self)(assumptions, guarantees, inputvars, outputvars)\n\n    def __le__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            raise ValueError()\n        return self.refines(other)\n\n    def __repr__(self) -&gt; str:\n        return \"&lt;Var {0}&gt;\".format(self)\n\n    def can_compose_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether the contract can be composed with another contract.\n\n        Args:\n            other:\n                Contract whose possibility to compose with self we are\n                verifying.\n\n        Returns:\n            True if the contracts can be composed. False otherwise.\n        \"\"\"\n        # make sure lists of output variables don't intersect\n        return len(list_intersection(self.outputvars, other.outputvars)) == 0\n\n    def can_quotient_by(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether the contract can quotiented by another contract.\n\n        Args:\n            other: potential quotient by which self would be quotiented.\n\n        Returns:\n            True if the IO profiles of the contracts allow the quotient to\n            exist. False otherwise.\n        \"\"\"\n        # make sure the top level outputs not contained in outputs of the\n        # existing component do not intersect with the inputs of the existing\n        # component\n        return len(list_intersection(list_diff(self.outputvars, other.outputvars), other.inputvars)) == 0\n\n    def shares_io_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether two contracts have the same IO signature.\n\n        Args:\n            other: contract whose IO signature is compared with self.\n\n        Returns:\n            True if the contracts have the same IO profile.\n        \"\"\"\n        return lists_equal(self.inputvars, other.inputvars) &amp; lists_equal(self.outputvars, other.outputvars)\n\n    def refines(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether the given contract is a refinement of another.\n\n        Return self &lt;= other.\n\n        Args:\n            other: contract being compared with self.\n\n        Returns:\n            True if the calling contract refines the argument.\n\n        Raises:\n            IncompatibleArgsError: Refinement cannot be computed.\n        \"\"\"\n        if not self.shares_io_with(other):\n            raise IncompatibleArgsError(\"Contracts do not share IO\")\n        assumptions_check: bool = other.a &lt;= self.a\n        guarantees_check: bool = (self.g | other.a) &lt;= (other.g | other.a)\n        return assumptions_check and guarantees_check\n\n    def compose(self: IoContract_t, other: IoContract_t, vars_to_keep: Any = None) -&gt; IoContract_t:  # noqa: WPS231\n\"\"\"Compose IO contracts.\n\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n\n        Returns:\n            The abstracted composition of the two contracts.\n\n        Raises:\n            IncompatibleArgsError: An error occurred during composition.\n        \"\"\"\n        if vars_to_keep is None:\n            vars_to_keep = []\n        conflict_vars = list_diff(vars_to_keep, list_union(self.outputvars, other.outputvars))\n        if conflict_vars:\n            raise IncompatibleArgsError(\"Asked to keep variables %s, which are not outputs\" % (conflict_vars))\n\n        logging.debug(\"Composing contracts \\n%s and \\n%s\", self, other)\n        intvars = list_union(\n            list_intersection(self.outputvars, other.inputvars), list_intersection(self.inputvars, other.outputvars)\n        )\n        inputvars = list_diff(list_union(self.inputvars, other.inputvars), intvars)\n        outputvars = list_diff(list_union(self.outputvars, other.outputvars), intvars)\n        # remove requested variables\n        intvars = list_diff(intvars, vars_to_keep)\n        outputvars = list_union(outputvars, vars_to_keep)\n\n        selfinputconst = self.a.vars\n        otherinputconst = other.a.vars\n        cycle_present = (\n            len(list_intersection(self.inputvars, other.outputvars)) &gt; 0\n            and len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\n        )\n\n        assumptions_forbidden_vars = list_union(intvars, outputvars)\n        if not self.can_compose_with(other):\n            raise IncompatibleArgsError(\n                \"Cannot compose the following contracts due to incompatible IO profiles:\\n %s \\n %s\" % (self, other)\n            )\n        other_helps_self = len(list_intersection(other.outputvars, self.inputvars)) &gt; 0\n        self_helps_other = len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\n        other_drives_const_inputs = len(list_intersection(other.outputvars, selfinputconst)) &gt; 0\n        self_drives_const_inputs = len(list_intersection(self.outputvars, otherinputconst)) &gt; 0\n        # process assumptions\n        if cycle_present and (other_drives_const_inputs or self_drives_const_inputs):\n            raise IncompatibleArgsError(\"Cannot compose contracts due to feedback\")\n        elif self_helps_other and not other_helps_self:\n            logging.debug(\"Assumption computation: self provides context for other\")\n            new_a: TermList_t = other.a.elim_vars_by_refining(self.a | self.g, assumptions_forbidden_vars)\n            conflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\n            if conflict_variables:\n                raise IncompatibleArgsError(\n                    \"Could not eliminate variables {}\\n\".format([str(x) for x in assumptions_forbidden_vars])\n                    + \"by refining the assumptions \\n{}\\n\".format(new_a.get_terms_with_vars(assumptions_forbidden_vars))\n                    + \"using guarantees \\n{}\\n\".format(self.a | self.g)\n                )\n            assumptions = new_a | self.a\n        elif other_helps_self and not self_helps_other:\n            logging.debug(\"****** Assumption computation: other provides context for self\")\n            new_a = self.a.elim_vars_by_refining(other.a | other.g, assumptions_forbidden_vars)\n            conflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\n            if conflict_variables:\n                raise IncompatibleArgsError(\n                    \"Could not eliminate variables {}\".format([str(x) for x in assumptions_forbidden_vars])\n                    + \" by refining the assumptions \\n{}\\n\".format(\n                        new_a.get_terms_with_vars(assumptions_forbidden_vars)\n                    )\n                    + \"using guarantees \\n{}\\n\".format(other.a | other.g)\n                )\n            assumptions = new_a | other.a\n        # contracts can't help each other\n        else:\n            logging.debug(\"****** Assumption computation: other provides context for self\")\n            assumptions = self.a | other.a\n        logging.debug(\"Assumption computation: computed assumptions:\\n%s\", assumptions)\n        assumptions = assumptions.simplify()\n\n        # process guarantees\n        logging.debug(\"****** Computing guarantees\")\n        g1_t = self.g.copy()\n        g2_t = other.g.copy()\n        g1 = g1_t.elim_vars_by_relaxing(g2_t, intvars)\n        g2 = g2_t.elim_vars_by_relaxing(g1_t, intvars)\n        allguarantees = g1 | g2\n        allguarantees = allguarantees.elim_vars_by_relaxing(assumptions, intvars)\n\n        # eliminate terms with forbidden vars\n        terms_to_elim = allguarantees.get_terms_with_vars(intvars)\n        allguarantees -= terms_to_elim\n\n        return type(self)(assumptions, allguarantees, inputvars, outputvars)\n\n    def quotient(\n        self: IoContract_t, other: IoContract_t, additional_inputs: Optional[List[Var]] = None\n    ) -&gt; IoContract_t:\n\"\"\"Compute the contract quotient.\n\n        Compute the quotient self/other of the two given contracts and refine\n        the result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n\n        Returns:\n            The refined quotient self/other.\n\n        Raises:\n            IncompatibleArgsError: Arguments provided are incompatible with computation of the quotient.\n        \"\"\"\n        if not additional_inputs:\n            additional_inputs = []\n        if not self.can_quotient_by(other):\n            raise IncompatibleArgsError(\"Contracts cannot be quotiented due to incompatible IO\")\n        if list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)):\n            raise IncompatibleArgsError(\n                \"The additional inputs %s are neither top level inputs nor existing component outputs\"\n                % (list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)))\n            )\n        outputvars = list_union(\n            list_diff(self.outputvars, other.outputvars), list_diff(other.inputvars, self.inputvars)\n        )\n        inputvars = list_union(list_diff(self.inputvars, other.inputvars), list_diff(other.outputvars, self.outputvars))\n        inputvars = list_union(inputvars, additional_inputs)\n        intvars = list_union(\n            list_intersection(self.outputvars, other.outputvars), list_intersection(self.inputvars, other.inputvars)\n        )\n        intvars = list_diff(intvars, additional_inputs)\n\n        # get assumptions\n        logging.debug(\"Computing quotient assumptions\")\n        assumptions = copy.deepcopy(self.a)\n        empty_context = type(assumptions)([])\n        if assumptions.refines(other.a):\n            logging.debug(\"Extending top-level assumptions with divisor's guarantees\")\n            assumptions = assumptions | other.g\n        assumptions = assumptions.elim_vars_by_relaxing(empty_context, list_union(intvars, outputvars))\n        logging.debug(\"Assumptions after processing: %s\", assumptions)\n\n        # get guarantees\n        logging.debug(\"Computing quotient guarantees\")\n        guarantees: TermList_t = self.g\n        logging.debug(\"Using existing guarantees to aid system-level guarantees\")\n        try:\n            guarantees = guarantees.elim_vars_by_refining(other.g | other.a, intvars)\n        except ValueError:\n            guarantees = self.g\n        logging.debug(\"Guarantees are %s\" % (guarantees))\n        logging.debug(\"Using system-level assumptions to aid quotient guarantees\")\n        guarantees = guarantees | other.a\n        try:\n            guarantees = guarantees.elim_vars_by_refining(self.a, intvars)\n        except ValueError:\n            ...\n        logging.debug(\"Guarantees after processing: %s\", guarantees)\n        conflict_variables = list_intersection(guarantees.vars, intvars)\n        if conflict_variables:\n            raise IncompatibleArgsError(\n                \"Could not eliminate variables \\n{}\".format([str(x) for x in conflict_variables])\n                + \"by refining the guarantees \\n{}\\n\".format(guarantees.get_terms_with_vars(intvars))\n            )\n\n        return type(self)(assumptions, guarantees, inputvars, outputvars)\n\n    def merge(self: IoContract_t, other: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n        Compute the merging operation for two contracts.\n\n        Compute the merging operation of the two given contracts. No\n        abstraction/refinement is applied.\n\n        Args:\n            other: The contract with which we are merging self.\n\n        Returns:\n            The result of merging.\n\n        Raises:\n            IncompatibleArgsError: trying to merge different contract types.\n        \"\"\"\n        if not isinstance(self, type(other)):\n            raise IncompatibleArgsError(\"Asked to merge incompatible contracts\")\n        input_vars = list_union(self.inputvars, other.inputvars)\n        output_vars = list_union(self.outputvars, other.outputvars)\n        assumptions = self.a | other.a\n        guarantees = self.g | other.g\n        return type(self)(assumptions, guarantees, input_vars, output_vars)\n\n    def contains_environment(self, component: TermList) -&gt; bool:\n\"\"\"\n        Tell whether a component is a valid environment for the contract.\n\n        Args:\n            component: The component in question.\n\n        Returns:\n            True if the component is a valid environment; false otherwise.\n        \"\"\"\n        return component &lt;= self.a\n\n    def contains_implementation(self, component: TermList) -&gt; bool:\n\"\"\"\n        Tell whether a component is a valid implementation for the contract.\n\n        Args:\n            component:\n                The component in question.\n\n        Returns:\n            True if the component is a valid implementation; false otherwise.\n        \"\"\"\n        return (component | self.a) &lt;= (self.g | self.a)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.vars","title":"<code>vars: List[Var]</code>  <code>property</code>","text":"<p>The list of variables in the interface of the contract.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>Input and output variables of the contract.</p>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.__init__","title":"<code>__init__(assumptions, guarantees, input_vars, output_vars)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>TermList_t</code> <p>The assumptions of the contract.</p> required <code>guarantees</code> <code>TermList_t</code> <p>The guarantees of the contract.</p> required <code>input_vars</code> <code>List[Var]</code> <p>The input variables of the contract.</p> required <code>output_vars</code> <code>List[Var]</code> <p>The output variables of the contract.</p> required <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>Arguments provided does not produce a valid IO contract.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def __init__(\n    self, assumptions: TermList_t, guarantees: TermList_t, input_vars: List[Var], output_vars: List[Var]\n) -&gt; None:\n\"\"\"\n    Class constructor.\n\n    Args:\n        assumptions: The assumptions of the contract.\n        guarantees: The guarantees of the contract.\n        input_vars: The input variables of the contract.\n        output_vars: The output variables of the contract.\n\n    Raises:\n        IncompatibleArgsError: Arguments provided does not produce a valid IO contract.\n    \"\"\"\n    # make sure the input and output variables have no repeated entries\n    if len(input_vars) != len(set(input_vars)):\n        raise IncompatibleArgsError(\n            \"The following input variables appear multiple times in argument %s\"\n            % (set(list_diff(input_vars, list(set(input_vars)))))\n        )\n    if len(output_vars) != len(set(output_vars)):\n        raise IncompatibleArgsError(\n            \"The following output variables appear multiple times in argument %s\"\n            % (set(list_diff(output_vars, list(set(output_vars)))))\n        )\n    # make sure the input &amp; output variables are disjoint\n    if list_intersection(input_vars, output_vars):\n        raise IncompatibleArgsError(\n            \"The following variables appear in inputs and outputs: %s\"\n            % (list_intersection(input_vars, output_vars))\n        )\n    # make sure the assumptions only contain input variables\n    if list_diff(assumptions.vars, input_vars):\n        raise IncompatibleArgsError(\n            \"The following variables appear in the assumptions but are not inputs: %s\"\n            % (list_diff(assumptions.vars, input_vars))\n        )\n    # make sure the guarantees only contain input or output variables\n    if list_diff(guarantees.vars, list_union(input_vars, output_vars)):\n        raise IncompatibleArgsError(\n            \"The guarantees contain the following variables which are neither\"\n            \"inputs nor outputs: %s. Inputs: %s. Outputs: %s. Guarantees: %s\"\n            % (list_diff(guarantees.vars, list_union(input_vars, output_vars)), input_vars, output_vars, guarantees)\n        )\n\n    self.a: TermList_t = assumptions.copy()\n    self.inputvars = input_vars.copy()\n    self.outputvars = output_vars.copy()\n    # simplify the guarantees with the assumptions\n    self.g = guarantees.simplify(self.a)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.can_compose_with","title":"<code>can_compose_with(other)</code>","text":"<p>Tell whether the contract can be composed with another contract.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>Contract whose possibility to compose with self we are verifying.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the contracts can be composed. False otherwise.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def can_compose_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether the contract can be composed with another contract.\n\n    Args:\n        other:\n            Contract whose possibility to compose with self we are\n            verifying.\n\n    Returns:\n        True if the contracts can be composed. False otherwise.\n    \"\"\"\n    # make sure lists of output variables don't intersect\n    return len(list_intersection(self.outputvars, other.outputvars)) == 0\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.can_quotient_by","title":"<code>can_quotient_by(other)</code>","text":"<p>Tell whether the contract can quotiented by another contract.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>potential quotient by which self would be quotiented.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the IO profiles of the contracts allow the quotient to</p> <code>bool</code> <p>exist. False otherwise.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def can_quotient_by(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether the contract can quotiented by another contract.\n\n    Args:\n        other: potential quotient by which self would be quotiented.\n\n    Returns:\n        True if the IO profiles of the contracts allow the quotient to\n        exist. False otherwise.\n    \"\"\"\n    # make sure the top level outputs not contained in outputs of the\n    # existing component do not intersect with the inputs of the existing\n    # component\n    return len(list_intersection(list_diff(self.outputvars, other.outputvars), other.inputvars)) == 0\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.compose","title":"<code>compose(other, vars_to_keep=None)</code>","text":"<p>Compose IO contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Any</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <p>Returns:</p> Type Description <code>IoContract_t</code> <p>The abstracted composition of the two contracts.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>An error occurred during composition.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def compose(self: IoContract_t, other: IoContract_t, vars_to_keep: Any = None) -&gt; IoContract_t:  # noqa: WPS231\n\"\"\"Compose IO contracts.\n\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n\n    Returns:\n        The abstracted composition of the two contracts.\n\n    Raises:\n        IncompatibleArgsError: An error occurred during composition.\n    \"\"\"\n    if vars_to_keep is None:\n        vars_to_keep = []\n    conflict_vars = list_diff(vars_to_keep, list_union(self.outputvars, other.outputvars))\n    if conflict_vars:\n        raise IncompatibleArgsError(\"Asked to keep variables %s, which are not outputs\" % (conflict_vars))\n\n    logging.debug(\"Composing contracts \\n%s and \\n%s\", self, other)\n    intvars = list_union(\n        list_intersection(self.outputvars, other.inputvars), list_intersection(self.inputvars, other.outputvars)\n    )\n    inputvars = list_diff(list_union(self.inputvars, other.inputvars), intvars)\n    outputvars = list_diff(list_union(self.outputvars, other.outputvars), intvars)\n    # remove requested variables\n    intvars = list_diff(intvars, vars_to_keep)\n    outputvars = list_union(outputvars, vars_to_keep)\n\n    selfinputconst = self.a.vars\n    otherinputconst = other.a.vars\n    cycle_present = (\n        len(list_intersection(self.inputvars, other.outputvars)) &gt; 0\n        and len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\n    )\n\n    assumptions_forbidden_vars = list_union(intvars, outputvars)\n    if not self.can_compose_with(other):\n        raise IncompatibleArgsError(\n            \"Cannot compose the following contracts due to incompatible IO profiles:\\n %s \\n %s\" % (self, other)\n        )\n    other_helps_self = len(list_intersection(other.outputvars, self.inputvars)) &gt; 0\n    self_helps_other = len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\n    other_drives_const_inputs = len(list_intersection(other.outputvars, selfinputconst)) &gt; 0\n    self_drives_const_inputs = len(list_intersection(self.outputvars, otherinputconst)) &gt; 0\n    # process assumptions\n    if cycle_present and (other_drives_const_inputs or self_drives_const_inputs):\n        raise IncompatibleArgsError(\"Cannot compose contracts due to feedback\")\n    elif self_helps_other and not other_helps_self:\n        logging.debug(\"Assumption computation: self provides context for other\")\n        new_a: TermList_t = other.a.elim_vars_by_refining(self.a | self.g, assumptions_forbidden_vars)\n        conflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\n        if conflict_variables:\n            raise IncompatibleArgsError(\n                \"Could not eliminate variables {}\\n\".format([str(x) for x in assumptions_forbidden_vars])\n                + \"by refining the assumptions \\n{}\\n\".format(new_a.get_terms_with_vars(assumptions_forbidden_vars))\n                + \"using guarantees \\n{}\\n\".format(self.a | self.g)\n            )\n        assumptions = new_a | self.a\n    elif other_helps_self and not self_helps_other:\n        logging.debug(\"****** Assumption computation: other provides context for self\")\n        new_a = self.a.elim_vars_by_refining(other.a | other.g, assumptions_forbidden_vars)\n        conflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\n        if conflict_variables:\n            raise IncompatibleArgsError(\n                \"Could not eliminate variables {}\".format([str(x) for x in assumptions_forbidden_vars])\n                + \" by refining the assumptions \\n{}\\n\".format(\n                    new_a.get_terms_with_vars(assumptions_forbidden_vars)\n                )\n                + \"using guarantees \\n{}\\n\".format(other.a | other.g)\n            )\n        assumptions = new_a | other.a\n    # contracts can't help each other\n    else:\n        logging.debug(\"****** Assumption computation: other provides context for self\")\n        assumptions = self.a | other.a\n    logging.debug(\"Assumption computation: computed assumptions:\\n%s\", assumptions)\n    assumptions = assumptions.simplify()\n\n    # process guarantees\n    logging.debug(\"****** Computing guarantees\")\n    g1_t = self.g.copy()\n    g2_t = other.g.copy()\n    g1 = g1_t.elim_vars_by_relaxing(g2_t, intvars)\n    g2 = g2_t.elim_vars_by_relaxing(g1_t, intvars)\n    allguarantees = g1 | g2\n    allguarantees = allguarantees.elim_vars_by_relaxing(assumptions, intvars)\n\n    # eliminate terms with forbidden vars\n    terms_to_elim = allguarantees.get_terms_with_vars(intvars)\n    allguarantees -= terms_to_elim\n\n    return type(self)(assumptions, allguarantees, inputvars, outputvars)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.contains_environment","title":"<code>contains_environment(component)</code>","text":"<p>Tell whether a component is a valid environment for the contract.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>TermList</code> <p>The component in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the component is a valid environment; false otherwise.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def contains_environment(self, component: TermList) -&gt; bool:\n\"\"\"\n    Tell whether a component is a valid environment for the contract.\n\n    Args:\n        component: The component in question.\n\n    Returns:\n        True if the component is a valid environment; false otherwise.\n    \"\"\"\n    return component &lt;= self.a\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.contains_implementation","title":"<code>contains_implementation(component)</code>","text":"<p>Tell whether a component is a valid implementation for the contract.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>TermList</code> <p>The component in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the component is a valid implementation; false otherwise.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def contains_implementation(self, component: TermList) -&gt; bool:\n\"\"\"\n    Tell whether a component is a valid implementation for the contract.\n\n    Args:\n        component:\n            The component in question.\n\n    Returns:\n        True if the component is a valid implementation; false otherwise.\n    \"\"\"\n    return (component | self.a) &lt;= (self.g | self.a)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.copy","title":"<code>copy()</code>","text":"<p>Makes copy of contract.</p> <p>Returns:</p> Type Description <code>IoContract_t</code> <p>Copy of contract.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def copy(self: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n    Makes copy of contract.\n\n    Returns:\n        Copy of contract.\n    \"\"\"\n    inputvars = self.inputvars.copy()\n    outputvars = self.outputvars.copy()\n    assumptions = self.a.copy()\n    guarantees = self.g.copy()\n    return type(self)(assumptions, guarantees, inputvars, outputvars)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.merge","title":"<code>merge(other)</code>","text":"<p>Compute the merging operation for two contracts.</p> <p>Compute the merging operation of the two given contracts. No abstraction/refinement is applied.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The contract with which we are merging self.</p> required <p>Returns:</p> Type Description <code>IoContract_t</code> <p>The result of merging.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>trying to merge different contract types.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def merge(self: IoContract_t, other: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n    Compute the merging operation for two contracts.\n\n    Compute the merging operation of the two given contracts. No\n    abstraction/refinement is applied.\n\n    Args:\n        other: The contract with which we are merging self.\n\n    Returns:\n        The result of merging.\n\n    Raises:\n        IncompatibleArgsError: trying to merge different contract types.\n    \"\"\"\n    if not isinstance(self, type(other)):\n        raise IncompatibleArgsError(\"Asked to merge incompatible contracts\")\n    input_vars = list_union(self.inputvars, other.inputvars)\n    output_vars = list_union(self.outputvars, other.outputvars)\n    assumptions = self.a | other.a\n    guarantees = self.g | other.g\n    return type(self)(assumptions, guarantees, input_vars, output_vars)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.quotient","title":"<code>quotient(other, additional_inputs=None)</code>","text":"<p>Compute the contract quotient.</p> <p>Compute the quotient self/other of the two given contracts and refine the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <p>Returns:</p> Type Description <code>IoContract_t</code> <p>The refined quotient self/other.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>Arguments provided are incompatible with computation of the quotient.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def quotient(\n    self: IoContract_t, other: IoContract_t, additional_inputs: Optional[List[Var]] = None\n) -&gt; IoContract_t:\n\"\"\"Compute the contract quotient.\n\n    Compute the quotient self/other of the two given contracts and refine\n    the result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n\n    Returns:\n        The refined quotient self/other.\n\n    Raises:\n        IncompatibleArgsError: Arguments provided are incompatible with computation of the quotient.\n    \"\"\"\n    if not additional_inputs:\n        additional_inputs = []\n    if not self.can_quotient_by(other):\n        raise IncompatibleArgsError(\"Contracts cannot be quotiented due to incompatible IO\")\n    if list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)):\n        raise IncompatibleArgsError(\n            \"The additional inputs %s are neither top level inputs nor existing component outputs\"\n            % (list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)))\n        )\n    outputvars = list_union(\n        list_diff(self.outputvars, other.outputvars), list_diff(other.inputvars, self.inputvars)\n    )\n    inputvars = list_union(list_diff(self.inputvars, other.inputvars), list_diff(other.outputvars, self.outputvars))\n    inputvars = list_union(inputvars, additional_inputs)\n    intvars = list_union(\n        list_intersection(self.outputvars, other.outputvars), list_intersection(self.inputvars, other.inputvars)\n    )\n    intvars = list_diff(intvars, additional_inputs)\n\n    # get assumptions\n    logging.debug(\"Computing quotient assumptions\")\n    assumptions = copy.deepcopy(self.a)\n    empty_context = type(assumptions)([])\n    if assumptions.refines(other.a):\n        logging.debug(\"Extending top-level assumptions with divisor's guarantees\")\n        assumptions = assumptions | other.g\n    assumptions = assumptions.elim_vars_by_relaxing(empty_context, list_union(intvars, outputvars))\n    logging.debug(\"Assumptions after processing: %s\", assumptions)\n\n    # get guarantees\n    logging.debug(\"Computing quotient guarantees\")\n    guarantees: TermList_t = self.g\n    logging.debug(\"Using existing guarantees to aid system-level guarantees\")\n    try:\n        guarantees = guarantees.elim_vars_by_refining(other.g | other.a, intvars)\n    except ValueError:\n        guarantees = self.g\n    logging.debug(\"Guarantees are %s\" % (guarantees))\n    logging.debug(\"Using system-level assumptions to aid quotient guarantees\")\n    guarantees = guarantees | other.a\n    try:\n        guarantees = guarantees.elim_vars_by_refining(self.a, intvars)\n    except ValueError:\n        ...\n    logging.debug(\"Guarantees after processing: %s\", guarantees)\n    conflict_variables = list_intersection(guarantees.vars, intvars)\n    if conflict_variables:\n        raise IncompatibleArgsError(\n            \"Could not eliminate variables \\n{}\".format([str(x) for x in conflict_variables])\n            + \"by refining the guarantees \\n{}\\n\".format(guarantees.get_terms_with_vars(intvars))\n        )\n\n    return type(self)(assumptions, guarantees, inputvars, outputvars)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.refines","title":"<code>refines(other)</code>","text":"<p>Tell whether the given contract is a refinement of another.</p> <p>Return self &lt;= other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>contract being compared with self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the calling contract refines the argument.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>Refinement cannot be computed.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def refines(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether the given contract is a refinement of another.\n\n    Return self &lt;= other.\n\n    Args:\n        other: contract being compared with self.\n\n    Returns:\n        True if the calling contract refines the argument.\n\n    Raises:\n        IncompatibleArgsError: Refinement cannot be computed.\n    \"\"\"\n    if not self.shares_io_with(other):\n        raise IncompatibleArgsError(\"Contracts do not share IO\")\n    assumptions_check: bool = other.a &lt;= self.a\n    guarantees_check: bool = (self.g | other.a) &lt;= (other.g | other.a)\n    return assumptions_check and guarantees_check\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a contract.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>IoContract_t</code> <p>A contract with <code>source_var</code> replaced by <code>target_var</code>.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>The new variable is both an input and output of the resulting contract.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def rename_variable(  # noqa: WPS231 too much cognitive complexity\n    self: IoContract_t, source_var: Var, target_var: Var\n) -&gt; IoContract_t:\n\"\"\"\n    Rename a variable in a contract.\n\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n\n    Returns:\n        A contract with `source_var` replaced by `target_var`.\n\n    Raises:\n        IncompatibleArgsError: The new variable is both an input and output of the resulting contract.\n    \"\"\"\n    inputvars = self.inputvars.copy()\n    outputvars = self.outputvars.copy()\n    assumptions = self.a.copy()\n    guarantees = self.g.copy()\n    if source_var != target_var:\n        if source_var in inputvars:\n            if target_var in outputvars:\n                raise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\n            elif target_var not in inputvars:\n                inputvars.append(target_var)\n            inputvars.remove(source_var)\n            assumptions = assumptions.rename_variable(source_var, target_var)\n            guarantees = guarantees.rename_variable(source_var, target_var)\n        elif source_var in outputvars:\n            if target_var in inputvars:\n                raise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\n            elif target_var not in outputvars:\n                outputvars.append(target_var)\n            outputvars.remove(source_var)\n            assumptions = assumptions.rename_variable(source_var, target_var)\n            guarantees = guarantees.rename_variable(source_var, target_var)\n    return type(self)(assumptions, guarantees, inputvars, outputvars)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.shares_io_with","title":"<code>shares_io_with(other)</code>","text":"<p>Tell whether two contracts have the same IO signature.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>contract whose IO signature is compared with self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the contracts have the same IO profile.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def shares_io_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether two contracts have the same IO signature.\n\n    Args:\n        other: contract whose IO signature is compared with self.\n\n    Returns:\n        True if the contracts have the same IO profile.\n    \"\"\"\n    return lists_equal(self.inputvars, other.inputvars) &amp; lists_equal(self.outputvars, other.outputvars)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term","title":"<code>Term</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Terms, or constraints, to be imposed on the system or components.</p> <p>Term is an abstract class that must be extended in order to support specific constraint languages.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>class Term(ABC):\n\"\"\"\n    Terms, or constraints, to be imposed on the system or components.\n\n    Term is an abstract class that must be extended in order to support specific\n    constraint languages.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"Variables contained in the syntax of the term.\"\"\"\n\n    @abstractmethod\n    def contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n        Tell whether term contains a given variable.\n\n        Args:\n            var_to_seek: The variable that we are seeking in the current term.\n        \"\"\"\n\n    @abstractmethod\n    def __eq__(self, other: object) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def __str__(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def __hash__(self) -&gt; int:\n        pass\n\n    @abstractmethod\n    def __repr__(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def copy(self: Term_t) -&gt; Term_t:\n\"\"\"Returns a copy of term.\"\"\"\n\n    @abstractmethod\n    def rename_variable(self: Term_t, source_var: Var, target_var: Var) -&gt; Term_t:\n\"\"\"\n        Rename a variable in a term.\n\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n\n        Returns:\n            A term with `source_var` replaced by `target_var`.\n        \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term.vars","title":"<code>vars: List[Var]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Variables contained in the syntax of the term.</p>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term.contains_var","title":"<code>contains_var(var_to_seek)</code>  <code>abstractmethod</code>","text":"<p>Tell whether term contains a given variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_to_seek</code> <code>Var</code> <p>The variable that we are seeking in the current term.</p> required Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n    Tell whether term contains a given variable.\n\n    Args:\n        var_to_seek: The variable that we are seeking in the current term.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term.copy","title":"<code>copy()</code>  <code>abstractmethod</code>","text":"<p>Returns a copy of term.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef copy(self: Term_t) -&gt; Term_t:\n\"\"\"Returns a copy of term.\"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>  <code>abstractmethod</code>","text":"<p>Rename a variable in a term.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>Term_t</code> <p>A term with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef rename_variable(self: Term_t, source_var: Var, target_var: Var) -&gt; Term_t:\n\"\"\"\n    Rename a variable in a term.\n\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n\n    Returns:\n        A term with `source_var` replaced by `target_var`.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList","title":"<code>TermList</code>","text":"<p>         Bases: <code>ABC</code></p> <p>A collection of terms, or constraints.</p> <p>A TermList is semantically equivalent to a single term which is the conjunction of all terms contained in the TermList. TermList is an abstract class that must be extended to support a specific constraint formalism.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>class TermList(ABC):\n\"\"\"\n    A collection of terms, or constraints.\n\n    A TermList is semantically equivalent to a single term which is the\n    conjunction of all terms contained in the TermList. TermList is an abstract\n    class that must be extended to support a specific constraint formalism.\n    \"\"\"\n\n    def __init__(self, term_list: Optional[List] = None):\n\"\"\"\n        Class constructor.\n\n        Args:\n            term_list: A list of terms contained by TermList.\n        \"\"\"\n        if term_list:\n            self.terms = term_list.copy()\n        else:\n            self.terms = []\n\n    @property\n    def vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"The list of variables contained in this list of terms.\n\n        Returns:\n            List of variables referenced in the term.\n        \"\"\"\n        varlist: List[Var] = []\n        for t in self.terms:\n            varlist = list_union(varlist, t.vars)\n        return varlist\n\n    def __str__(self) -&gt; str:\n        if self.terms:\n            res = [str(el) for el in self.terms]\n            return \", \".join(res)\n        return \"true\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            raise ValueError()\n        return self.terms == other.terms\n\n    def get_terms_with_vars(self: TermList_t, variable_list: List[Var]) -&gt; TermList_t:\n\"\"\"\n        Returns the list of terms which contain any of the variables indicated.\n\n        Args:\n            variable_list: a list of variables being sought in current TermList.\n\n        Returns:\n            The list of terms which contain any of the variables indicated.\n        \"\"\"\n        terms = []\n        for t in self.terms:\n            if list_intersection(t.vars, variable_list):\n                terms.append(t)\n        return type(self)(terms)\n\n    def __and__(self: TermList_t, other: TermList_t) -&gt; TermList_t:\n        return type(self)(list_intersection(self.copy().terms, other.copy().terms))\n\n    def __or__(self: TermList_t, other: TermList_t) -&gt; TermList_t:\n        return type(self)(list_union(self.copy().terms, other.copy().terms))\n\n    def __sub__(self: TermList_t, other: TermList_t) -&gt; TermList_t:\n        return type(self)(list_diff(self.copy().terms, other.copy().terms))\n\n    def __le__(self: TermList_t, other: TermList_t) -&gt; bool:\n        return self.refines(other)\n\n    @abstractmethod\n    def __hash__(self) -&gt; int:\n        ...\n\n    def copy(self: TermList_t) -&gt; TermList_t:\n\"\"\"\n        Makes copy of termlist.\n\n        Returns:\n            Copy of termlist.\n        \"\"\"\n        return type(self)([term.copy() for term in self.terms])\n\n    def rename_variable(self: TermList_t, source_var: Var, target_var: Var) -&gt; TermList_t:\n\"\"\"\n        Rename a variable in a termlist.\n\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n\n        Returns:\n            A termlist with `source_var` replaced by `target_var`.\n        \"\"\"\n        return type(self)([term.rename_variable(source_var, target_var) for term in self.terms])\n\n    @abstractmethod\n    def contains_behavior(self, behavior: Any) -&gt; bool:\n\"\"\"\n        Tell whether TermList contains the given behavior.\n\n        Args:\n            behavior:\n                The behavior in question.\n\n        Returns:\n            True if the behavior satisfies the constraints; false otherwise.\n\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\n\n    @abstractmethod\n    def elim_vars_by_refining(self: TermList_t, context: TermList_t, vars_to_elim: List[Var]) -&gt; TermList_t:\n\"\"\"\n        Eliminate variables from termlist by refining it in a context.\n\n        Given a context $\\\\Gamma$, and the list of terms contained in self,\n        $s$, this routine identifies a TermList $x$ lacking variables\n        vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; x}{\\\\Gamma: \\\\;\n        s}$.\n\n        Args:\n            context:\n                List of context terms that will be used to refine the TermList.\n            vars_to_elim:\n                Variables to be eliminated.\n\n        Returns:\n            A list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, imply the terms contained in the\n            calling termlist.\n        \"\"\"\n\n    @abstractmethod\n    def elim_vars_by_relaxing(self: TermList_t, context: TermList_t, vars_to_elim: List[Var]) -&gt; TermList_t:\n\"\"\"\n        Eliminate variables from termlist by relaxing it in a context\n\n        Given a context $\\\\Gamma$, and the list of terms contained in self,\n        $s$, this routine identifies a formula $x$ lacking variables\n        vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; s}{\\\\Gamma: \\\\;\n        x}$.\n\n        Args:\n            context:\n                List of context terms that will be used to abstract the TermList.\n            vars_to_elim:\n                Variables that cannot be present in TermList after relaxation.\n\n        Returns:\n            A list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, are implied by the terms\n            contained in the calling termlist.\n        \"\"\"\n\n    @abstractmethod\n    def simplify(self: TermList_t, context: Optional[TermList_t] = None) -&gt; TermList_t:\n\"\"\"Remove redundant terms in TermList.\n\n        Args:\n            context:\n                List of context terms that will be used to remove redundancies in\n                the TermList.\n\n        Returns:\n            Let $S$ be this TermList. Simplify will return $S_T = S \\\\setminus T$\n            where $T \\\\subseteq S$ is a maximal subset such that $\\\\frac{\\\\Gamma, S_T\\\\colon \\\\;\n            \\\\top}{\\\\Gamma, S_T\\\\colon \\\\; \\\\wedge_{t \\\\in T} t}$.\n        \"\"\"\n\n    @abstractmethod\n    def refines(self: TermList_t, other: TermList_t) -&gt; bool:\n\"\"\"\n        Tell whether the argument is a larger specification.\n\n        Args:\n            other:\n                TermList against which we are comparing self.\n\n        Returns:\n            self &lt;= other.\n        \"\"\"\n\n    @abstractmethod\n    def is_empty(self) -&gt; bool:\n\"\"\"\n        Tell whether the termlist has no satisfying assignments.\n\n        Returns:\n            True if termlist constraints cannot be satisfied.\n        \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.vars","title":"<code>vars: List[Var]</code>  <code>property</code>","text":"<p>The list of variables contained in this list of terms.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>List of variables referenced in the term.</p>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.__init__","title":"<code>__init__(term_list=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>term_list</code> <code>Optional[List]</code> <p>A list of terms contained by TermList.</p> <code>None</code> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def __init__(self, term_list: Optional[List] = None):\n\"\"\"\n    Class constructor.\n\n    Args:\n        term_list: A list of terms contained by TermList.\n    \"\"\"\n    if term_list:\n        self.terms = term_list.copy()\n    else:\n        self.terms = []\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.contains_behavior","title":"<code>contains_behavior(behavior)</code>  <code>abstractmethod</code>","text":"<p>Tell whether TermList contains the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Any</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraints; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef contains_behavior(self, behavior: Any) -&gt; bool:\n\"\"\"\n    Tell whether TermList contains the given behavior.\n\n    Args:\n        behavior:\n            The behavior in question.\n\n    Returns:\n        True if the behavior satisfies the constraints; false otherwise.\n\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.copy","title":"<code>copy()</code>","text":"<p>Makes copy of termlist.</p> <p>Returns:</p> Type Description <code>TermList_t</code> <p>Copy of termlist.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def copy(self: TermList_t) -&gt; TermList_t:\n\"\"\"\n    Makes copy of termlist.\n\n    Returns:\n        Copy of termlist.\n    \"\"\"\n    return type(self)([term.copy() for term in self.terms])\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.elim_vars_by_refining","title":"<code>elim_vars_by_refining(context, vars_to_elim)</code>  <code>abstractmethod</code>","text":"<p>Eliminate variables from termlist by refining it in a context.</p> <p>Given a context \\(\\Gamma\\), and the list of terms contained in self, \\(s\\), this routine identifies a TermList \\(x\\) lacking variables vars_to_elim such that \\(\\frac{\\Gamma\\colon \\; x}{\\Gamma: \\; s}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>TermList_t</code> <p>List of context terms that will be used to refine the TermList.</p> required <code>vars_to_elim</code> <code>List[Var]</code> <p>Variables to be eliminated.</p> required <p>Returns:</p> Type Description <code>TermList_t</code> <p>A list of terms not containing any variables in <code>vars_to_elim</code></p> <code>TermList_t</code> <p>and which, in the context provided, imply the terms contained in the</p> <code>TermList_t</code> <p>calling termlist.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef elim_vars_by_refining(self: TermList_t, context: TermList_t, vars_to_elim: List[Var]) -&gt; TermList_t:\n\"\"\"\n    Eliminate variables from termlist by refining it in a context.\n\n    Given a context $\\\\Gamma$, and the list of terms contained in self,\n    $s$, this routine identifies a TermList $x$ lacking variables\n    vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; x}{\\\\Gamma: \\\\;\n    s}$.\n\n    Args:\n        context:\n            List of context terms that will be used to refine the TermList.\n        vars_to_elim:\n            Variables to be eliminated.\n\n    Returns:\n        A list of terms not containing any variables in `vars_to_elim`\n        and which, in the context provided, imply the terms contained in the\n        calling termlist.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.elim_vars_by_relaxing","title":"<code>elim_vars_by_relaxing(context, vars_to_elim)</code>  <code>abstractmethod</code>","text":"<p>Eliminate variables from termlist by relaxing it in a context</p> <p>Given a context \\(\\Gamma\\), and the list of terms contained in self, \\(s\\), this routine identifies a formula \\(x\\) lacking variables vars_to_elim such that \\(\\frac{\\Gamma\\colon \\; s}{\\Gamma: \\; x}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>TermList_t</code> <p>List of context terms that will be used to abstract the TermList.</p> required <code>vars_to_elim</code> <code>List[Var]</code> <p>Variables that cannot be present in TermList after relaxation.</p> required <p>Returns:</p> Type Description <code>TermList_t</code> <p>A list of terms not containing any variables in <code>vars_to_elim</code></p> <code>TermList_t</code> <p>and which, in the context provided, are implied by the terms</p> <code>TermList_t</code> <p>contained in the calling termlist.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef elim_vars_by_relaxing(self: TermList_t, context: TermList_t, vars_to_elim: List[Var]) -&gt; TermList_t:\n\"\"\"\n    Eliminate variables from termlist by relaxing it in a context\n\n    Given a context $\\\\Gamma$, and the list of terms contained in self,\n    $s$, this routine identifies a formula $x$ lacking variables\n    vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; s}{\\\\Gamma: \\\\;\n    x}$.\n\n    Args:\n        context:\n            List of context terms that will be used to abstract the TermList.\n        vars_to_elim:\n            Variables that cannot be present in TermList after relaxation.\n\n    Returns:\n        A list of terms not containing any variables in `vars_to_elim`\n        and which, in the context provided, are implied by the terms\n        contained in the calling termlist.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.get_terms_with_vars","title":"<code>get_terms_with_vars(variable_list)</code>","text":"<p>Returns the list of terms which contain any of the variables indicated.</p> <p>Parameters:</p> Name Type Description Default <code>variable_list</code> <code>List[Var]</code> <p>a list of variables being sought in current TermList.</p> required <p>Returns:</p> Type Description <code>TermList_t</code> <p>The list of terms which contain any of the variables indicated.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def get_terms_with_vars(self: TermList_t, variable_list: List[Var]) -&gt; TermList_t:\n\"\"\"\n    Returns the list of terms which contain any of the variables indicated.\n\n    Args:\n        variable_list: a list of variables being sought in current TermList.\n\n    Returns:\n        The list of terms which contain any of the variables indicated.\n    \"\"\"\n    terms = []\n    for t in self.terms:\n        if list_intersection(t.vars, variable_list):\n            terms.append(t)\n    return type(self)(terms)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.is_empty","title":"<code>is_empty()</code>  <code>abstractmethod</code>","text":"<p>Tell whether the termlist has no satisfying assignments.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if termlist constraints cannot be satisfied.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef is_empty(self) -&gt; bool:\n\"\"\"\n    Tell whether the termlist has no satisfying assignments.\n\n    Returns:\n        True if termlist constraints cannot be satisfied.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.refines","title":"<code>refines(other)</code>  <code>abstractmethod</code>","text":"<p>Tell whether the argument is a larger specification.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>TermList_t</code> <p>TermList against which we are comparing self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>self &lt;= other.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef refines(self: TermList_t, other: TermList_t) -&gt; bool:\n\"\"\"\n    Tell whether the argument is a larger specification.\n\n    Args:\n        other:\n            TermList against which we are comparing self.\n\n    Returns:\n        self &lt;= other.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a termlist.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>TermList_t</code> <p>A termlist with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def rename_variable(self: TermList_t, source_var: Var, target_var: Var) -&gt; TermList_t:\n\"\"\"\n    Rename a variable in a termlist.\n\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n\n    Returns:\n        A termlist with `source_var` replaced by `target_var`.\n    \"\"\"\n    return type(self)([term.rename_variable(source_var, target_var) for term in self.terms])\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.simplify","title":"<code>simplify(context=None)</code>  <code>abstractmethod</code>","text":"<p>Remove redundant terms in TermList.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Optional[TermList_t]</code> <p>List of context terms that will be used to remove redundancies in the TermList.</p> <code>None</code> <p>Returns:</p> Type Description <code>TermList_t</code> <p>Let \\(S\\) be this TermList. Simplify will return \\(S_T = S \\setminus T\\)</p> <code>TermList_t</code> <p>where \\(T \\subseteq S\\) is a maximal subset such that $\\frac{\\Gamma, S_T\\colon \\;</p> <code>TermList_t</code> <p>\\top}{\\Gamma, S_T\\colon \\; \\wedge_{t \\in T} t}$.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef simplify(self: TermList_t, context: Optional[TermList_t] = None) -&gt; TermList_t:\n\"\"\"Remove redundant terms in TermList.\n\n    Args:\n        context:\n            List of context terms that will be used to remove redundancies in\n            the TermList.\n\n    Returns:\n        Let $S$ be this TermList. Simplify will return $S_T = S \\\\setminus T$\n        where $T \\\\subseteq S$ is a maximal subset such that $\\\\frac{\\\\Gamma, S_T\\\\colon \\\\;\n        \\\\top}{\\\\Gamma, S_T\\\\colon \\\\; \\\\wedge_{t \\\\in T} t}$.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Var","title":"<code>Var</code>","text":"<p>Variables used in system modeling.</p> <p>Variables allow us to name an entity for which we want to write constraints.</p> Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>class Var:\n\"\"\"\n    Variables used in system modeling.\n\n    Variables allow us to name an entity for which we want to write constraints.\n    \"\"\"\n\n    def __init__(self, varname: str):\n\"\"\"\n        Constructor for Var.\n\n        Args:\n            varname: The name of the variable.\n        \"\"\"\n        self._name = str(varname)\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"The name of the variable.\n\n        Returns:\n            The name of the variable.\n        \"\"\"\n        return self._name\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            raise ValueError()\n        return self.name == other.name\n\n    def __str__(self) -&gt; str:\n        return self.name\n\n    def __hash__(self) -&gt; int:\n        return hash(self.name)\n\n    def __repr__(self) -&gt; str:\n        return \"&lt;Var {0}&gt;\".format(self.name)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Var.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The name of the variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the variable.</p>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Var.__init__","title":"<code>__init__(varname)</code>","text":"<p>Constructor for Var.</p> <p>Parameters:</p> Name Type Description Default <code>varname</code> <code>str</code> <p>The name of the variable.</p> required Source code in <code>pacti\\iocontract\\iocontract.py</code> <pre><code>def __init__(self, varname: str):\n\"\"\"\n    Constructor for Var.\n\n    Args:\n        varname: The name of the variable.\n    \"\"\"\n    self._name = str(varname)\n</code></pre>"},{"location":"reference/pacti/terms/","title":"Index","text":""},{"location":"reference/pacti/terms/polyhedra/","title":"Index","text":""},{"location":"reference/pacti/terms/polyhedra/plots/","title":"Plots","text":"<p>Plotting functionality for polyhedral contracts.</p>"},{"location":"reference/pacti/terms/polyhedra/plots/#pacti.terms.polyhedra.plots.plot_assumptions","title":"<code>plot_assumptions(contract, x_var, y_var, var_values, x_lims, y_lims)</code>","text":"<p>Plots the assumptions of an IoContract with polyhedral terms.</p> <p>Parameters:</p> Name Type Description Default <code>contract</code> <code>PolyhedralContract</code> <p>the contract whose assumptions will be plotted.</p> required <code>x_var</code> <code>Var</code> <p>variable mapped to the x-axis.</p> required <code>y_var</code> <code>Var</code> <p>variable mapped to the y-axis.</p> required <code>var_values</code> <code>Dict[Var, numeric]</code> <p>values of other variables appearing in the assumptions.</p> required <code>x_lims</code> <code>Tuple[numeric, numeric]</code> <p>range of values in the x-axis.</p> required <code>y_lims</code> <code>Tuple[numeric, numeric]</code> <p>range of values in the y-axis.</p> required <p>Returns:</p> Type Description <code>MplFigure</code> <p>Figure element with a single \"axes\" object showing the feasible region for the assumptions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>arguments provided failed sanity checks.</p> Source code in <code>pacti\\terms\\polyhedra\\plots.py</code> <pre><code>def plot_assumptions(\n    contract: PolyhedralContract,\n    x_var: Var,\n    y_var: Var,\n    var_values: Dict[Var, numeric],\n    x_lims: Tuple[numeric, numeric],\n    y_lims: Tuple[numeric, numeric],\n) -&gt; MplFigure:\n\"\"\"\n    Plots the assumptions of an IoContract with polyhedral terms.\n\n    Args:\n        contract: the contract whose assumptions will be plotted.\n        x_var: variable mapped to the x-axis.\n        y_var: variable mapped to the y-axis.\n        var_values: values of other variables appearing in the assumptions.\n        x_lims: range of values in the x-axis.\n        y_lims: range of values in the y-axis.\n\n    Returns:\n        Figure element with a single \"axes\" object showing the feasible region for the assumptions.\n\n    Raises:\n        ValueError: arguments provided failed sanity checks.\n    \"\"\"\n    if x_var not in contract.vars:\n        raise ValueError(\"Variable %s is not in an input or output variable of contract.\" % (x_var))\n    if y_var not in contract.vars:\n        raise ValueError(\"Variable %s is not in an input or output variable of contract.\" % (y_var))\n    for var in var_values.keys():  # noqa: VNE002\n        if var not in contract.vars:\n            raise ValueError(\"Var %s from var_values is not in the interface of the contract.\" % (var))\n    fig = _plot_constraints(contract.a, x_var, y_var, var_values, x_lims, y_lims)\n    ax = fig.axes[0]\n    ax.set_title(\"Assumptions\")\n    return fig\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/plots/#pacti.terms.polyhedra.plots.plot_guarantees","title":"<code>plot_guarantees(contract, x_var, y_var, var_values, x_lims, y_lims)</code>","text":"<p>Plots the guarantees and assumptions of an IoContract with polyhedral terms.</p> <p>Parameters:</p> Name Type Description Default <code>contract</code> <code>PolyhedralContract</code> <p>the contract whose assumptions &amp; guarantees will be plotted.</p> required <code>x_var</code> <code>Var</code> <p>variable mapped to the x-axis.</p> required <code>y_var</code> <code>Var</code> <p>variable mapped to the y-axis.</p> required <code>var_values</code> <code>Dict[Var, numeric]</code> <p>values of other variables appearing in the assumptions &amp; guarantees.</p> required <code>x_lims</code> <code>Tuple[numeric, numeric]</code> <p>range of values in the x-axis.</p> required <code>y_lims</code> <code>Tuple[numeric, numeric]</code> <p>range of values in the y-axis.</p> required <p>Returns:</p> Type Description <code>MplFigure</code> <p>Figure element with a single \"axes\" object showing the feasible region for the assumptions &amp; guarantees.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>arguments provided failed sanity checks.</p> Source code in <code>pacti\\terms\\polyhedra\\plots.py</code> <pre><code>def plot_guarantees(\n    contract: PolyhedralContract,\n    x_var: Var,\n    y_var: Var,\n    var_values: Dict[Var, numeric],\n    x_lims: Tuple[numeric, numeric],\n    y_lims: Tuple[numeric, numeric],\n) -&gt; MplFigure:\n\"\"\"\n    Plots the guarantees and assumptions of an IoContract with polyhedral terms.\n\n    Args:\n        contract: the contract whose assumptions &amp; guarantees will be plotted.\n        x_var: variable mapped to the x-axis.\n        y_var: variable mapped to the y-axis.\n        var_values: values of other variables appearing in the assumptions &amp; guarantees.\n        x_lims: range of values in the x-axis.\n        y_lims: range of values in the y-axis.\n\n    Returns:\n        Figure element with a single \"axes\" object showing the feasible region for the assumptions &amp; guarantees.\n\n    Raises:\n        ValueError: arguments provided failed sanity checks.\n    \"\"\"\n    if x_var not in contract.vars:\n        raise ValueError(\"Variable %s is not in an input or output variable of contract.\" % (x_var))\n    if y_var not in contract.vars:\n        raise ValueError(\"Variable %s is not in an input or output variable of contract.\" % (y_var))\n    for var in var_values.keys():  # noqa: VNE002\n        if var not in contract.vars:\n            raise ValueError(\"Var %s from var_values is not in the interface of the contract.\" % (var))\n    fig = _plot_constraints(contract.a | contract.g, x_var, y_var, var_values, x_lims, y_lims)\n    ax = fig.axes[0]\n    ax.set_title(\"Guarantees\")\n    return fig\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/","title":"Polyhedra","text":"<p>Support for linear inequality constraints, i.e., polyhedra.</p> <p>Module provides support for linear inequalities as constraints, i.e., the constraints are of the form \\(\\sum_{i} a_i x_i \\le c\\), where the \\(x_i\\) are variables and the \\(a_i\\) and \\(c\\) are constants.</p>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm","title":"<code>PolyhedralTerm</code>","text":"<p>         Bases: <code>Term</code></p> <p>Polyhedral terms are linear inequalities over a list of variables.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>class PolyhedralTerm(Term):\n\"\"\"Polyhedral terms are linear inequalities over a list of variables.\"\"\"\n\n    # Constructor: get (i) a dictionary whose keys are variables and whose\n    # values are the coefficients of those variables in the term, and (b) a\n    # constant. The term is assumed to be in the form \\Sigma_i a_i v_i +\n    # constant &lt;= 0\n    def __init__(self, variables: Dict[Var, numeric], constant: numeric):\n\"\"\"\n        Constructor for PolyhedralTerm.\n\n        Usage:\n            Polyhedral terms are initialized as follows:\n\n            ```\n                variables = {Var('x'):2, Var('y'):3}\n                constant = 3\n                term = PolyhedralTerm(variables, constant)\n            ```\n\n            `variables` is a dictionary whose keys are `Var` instances,\n            and `constant` is a number. Thus, our example represents the\n            expression $2x + 3y \\\\le 3$.\n\n        Args:\n            variables: A dictionary mapping Var keys to numeric values.\n            constant: A numeric value on the right of the inequality.\n\n        Raises:\n            ValueError: Unsupported argument type.\n        \"\"\"\n        variable_dict = {}\n        for key, value in variables.items():\n            if value != 0:\n                if isinstance(key, str):\n                    raise ValueError(\"Unsupported argument type\")\n                else:\n                    variable_dict[key] = float(value)\n        self.variables = variable_dict\n        self.constant = float(constant)\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            raise ValueError()\n        match = self.variables.keys() == other.variables.keys()\n        if match:\n            for k, v in self.variables.items():\n                match = match and (v == other.variables[k])\n        return match and self.constant == other.constant\n\n    def __str__(self) -&gt; str:\n        varlist = list(self.variables.items())\n        varlist.sort(key=lambda x: str(x[0]))\n        res = \" + \".join([str(coeff) + \"*\" + var.name for var, coeff in varlist])\n        res += \" &lt;= \" + str(self.constant)\n        return res\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __repr__(self) -&gt; str:\n        return \"&lt;Term {0}&gt;\".format(self)\n\n    def __add__(self, other: object) -&gt; PolyhedralTerm:\n        if not isinstance(other, type(self)):\n            raise ValueError()\n        varlist = list_union(self.vars, other.vars)\n        variables = {}\n        for var in varlist:  # noqa: VNE002\n            variables[var] = self.get_coefficient(var) + other.get_coefficient(var)\n        return PolyhedralTerm(variables, self.constant + other.constant)\n\n    def copy(self) -&gt; PolyhedralTerm:\n\"\"\"\n        Generates copy of polyhedral term.\n\n        Returns:\n            Copy of term.\n        \"\"\"\n        return PolyhedralTerm(self.variables, self.constant)\n\n    def rename_variable(self, source_var: Var, target_var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n        Rename a variable in a term.\n\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n\n        Returns:\n            A term with `source_var` replaced by `target_var`.\n        \"\"\"\n        new_term = self.copy()\n        if source_var in self.vars:\n            if target_var not in self.vars:\n                new_term.variables[target_var] = 0\n            new_term.variables[target_var] += new_term.variables[source_var]\n            new_term = new_term.remove_variable(source_var)\n        return new_term\n\n    @property\n    def vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"\n        Variables appearing in term with a nonzero coefficient.\n\n        Example:\n            For the term $ax + by \\\\le c$ with variables $x$ and\n            $y$, this function returns the list $\\\\{x, y\\\\}$ if\n            $a$ and $b$ are nonzero.\n\n        Returns:\n            List of variables referenced in term.\n        \"\"\"\n        varlist = self.variables.keys()\n        return list(varlist)\n\n    def contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n        Tell whether term contains a given variable.\n\n        Args:\n            var_to_seek: The variable that we are seeking in the current term.\n\n        Returns:\n            `True` if the syntax of the term refers to the given variable;\n            `False` otherwise.\n        \"\"\"\n        return var_to_seek in self.vars\n\n    def get_coefficient(self, var: Var) -&gt; numeric:  # noqa: VNE002\n\"\"\"\n        Output the coefficient multiplying the given variable in the term.\n\n        Args:\n            var: The variable whose coefficient we are seeking.\n\n        Returns:\n            The coefficient corresponding to variable in the term.\n        \"\"\"\n        if self.contains_var(var):\n            return self.variables[var]\n        return 0\n\n    def get_polarity(self, var: Var, polarity: bool = True) -&gt; bool:  # noqa: VNE002\n\"\"\"\n        Check if variable matches given polarity\n\n        The polarity of a variable in a term is defined as the polarity of the\n        coefficient that multiplies it in a term, e.g., the variables $x$\n        and $y$ in the term $-2x + y \\\\le 3$ have negative and\n        positive polarities respectively.\n\n        Args:\n            var: The variable whose polarity in the term we are seeking.\n            polarity: The polarity that we are comparing against the variable's polarity.\n\n        Returns:\n            `True` if the variable's polarity matches `polarity` and\n            `False` otherwise. If the variable's coefficient in the term\n            is zero, return `True`.\n        \"\"\"\n        if polarity:\n            return self.variables[var] &gt;= 0\n        return self.variables[var] &lt;= 0\n\n    def get_sign(self, var: Var) -&gt; int:  # noqa: VNE002\n\"\"\"\n        Get the sign of the variable in term.\n\n        The sign of a variable in a term is defined as the sign of the\n        coefficient that multiplies it in a term, e.g., the variables $x$\n        and $y$ in the term $-2x + y \\\\le 3$ have $-1$ and\n        $+1$ polarities respectively. $0$ has $+1$ sign.\n\n        Args:\n            var: The variable whose polarity in the term we are seeking.\n\n        Returns:\n            The sign of the variable in the term.\n        \"\"\"\n        if self.get_polarity(var=var, polarity=True):\n            return 1\n        return -1\n\n    def get_matching_vars(self, variable_polarity: Dict[Var, bool]) -&gt; List[Var]:\n\"\"\"\n        Get list of variables whose polarities match the polarities requested.\n\n        Example:\n\n        ```\n            x = Var('x')\n            y = Var('y')\n            z = Var('z')\n            variables = {x:-2, y:3}\n            constant  = 4\n            term = PolyhedralTerm(variables, constant)\n            polarities = {y:True}\n            term.get_matching_vars(polarities)\n        ```\n\n        The last call returns `{y, z}` because the variable y matches the\n        requested polarity in the term, and the variable z has a zero\n        coefficient.\n\n        Args:\n            variable_polarity: A dictionary mapping Var instances to Boolean\n                values indicating the polarity of the given variable.\n\n        Returns:\n            If all variables in the term match the polarities specified in the\n            argument, the routine returns the matching variables.  Otherwise,\n            it returns an empty list.\n        \"\"\"\n        variable_list = []\n        for var in variable_polarity.keys():  # noqa: VNE002\n            if self.contains_var(var):\n                if (self.get_polarity(var=var, polarity=True) == variable_polarity[var]) or (  # noqa: WPS337\n                    self.get_coefficient(var) == 0\n                ):\n                    variable_list.append(var)\n                else:\n                    variable_list = []\n                    break\n        return variable_list\n\n    def remove_variable(self, var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n        Eliminates a variable from a term.\n\n        Args:\n            var: variable to be eliminated.\n\n        Returns:\n            A new term with the variable eliminated.\n        \"\"\"\n        if self.contains_var(var):\n            that = self.copy()\n            that.variables.pop(var)\n            return that\n        return self.copy()\n\n    def multiply(self, factor: numeric) -&gt; PolyhedralTerm:\n\"\"\"Multiplies a term by a constant factor.\n\n        For example, multiplying the term $2x + 3y \\\\le 4$ by the factor 2\n        yields $4x + 6y \\\\le 8$.\n\n        Args:\n            factor: element by which the term is multiplied.\n\n        Returns:\n            A new term which is the result of the given term multiplied by\n            `factor`.\n        \"\"\"\n        variables = {key: factor * val for key, val in self.variables.items()}\n        return PolyhedralTerm(variables, factor * self.constant)\n\n    def substitute_variable(self, var: Var, subst_with_term: PolyhedralTerm) -&gt; PolyhedralTerm:  # noqa: VNE002\n\"\"\"\n        Substitutes a specified variable in a term with a given term.\n\n        Example:\n            In the term $2x - y \\\\le 6$, substituting y by the term\n            $x + z \\\\le 5$ yields $x - z \\\\le 1$. Observe that the\n            substituting term is understood as an equality.\n\n        Args:\n            var: The term variable to be substituted.\n            subst_with_term: The term used to replace var.\n\n        Returns:\n            A new term in which the variable is substituted with the given term\n            understood as an equality.\n        \"\"\"\n        if self.contains_var(var):\n            term = subst_with_term.multiply(self.get_coefficient(var))\n            logging.debug(\"Term is %s\", term)\n            that = self.remove_variable(var)\n            logging.debug(that)\n            return that + term\n        return self.copy()\n\n    def isolate_variable(self, var_to_isolate: Var) -&gt; PolyhedralTerm:\n\"\"\"\n        Isolate a variable in a term.\n\n        Example:\n            In the term $-2x + y \\\\le 6$ understood as equality, isolating the\n            variable $x$ yields $x = 0.5 y - 3$, which in PolyhedralTerm\n            notation we express as $0.5 y &lt;= -3$.\n\n        Args:\n            var_to_isolate: The variable to be isolated.\n\n        Returns:\n            A new term which corresponds to the isolation of the indicated\n            variable.\n\n        Raises:\n            ValueError: the indicated variable is not contained in the term.\n        \"\"\"\n        if var_to_isolate not in self.vars:\n            raise ValueError(\"Variable %s is not a term variable\" % (var_to_isolate))\n        return PolyhedralTerm(\n            variables={\n                k: -v / self.get_coefficient(var_to_isolate) for k, v in self.variables.items() if k != var_to_isolate\n            },\n            constant=self.constant / self.get_coefficient(var_to_isolate),\n        )\n\n    @staticmethod\n    def to_symbolic(term: PolyhedralTerm) -&gt; Any:\n\"\"\"\n        Translates the variable terms of a PolyhedralTerm into a sympy expression.\n\n        Example:\n            The code\n\n            ```\n                x = Var('x') y = Var('y') variables = {x:-2, y:3} constant  = 4\n                term = PolyhedralTerm(variables, constant) expression =\n                PolyhedralTerm.to_symbolic(term)\n            ```\n\n            yields the expression $-2x + 3y$.\n\n        Args:\n            term:\n                The term whose coefficients and variables are to be translated\n                to sympy's data structure.\n\n        Returns:\n            Sympy expression corresponding to PolyhedralTerm.\n        \"\"\"\n        ex = -term.constant\n        for var in term.vars:  # noqa: VNE002\n            sv = sympy.symbols(var.name)\n            ex += sv * term.get_coefficient(var)\n        return ex\n\n    @staticmethod\n    def to_term(expression: sympy.core.expr.Expr) -&gt; PolyhedralTerm:\n\"\"\"\n        Translates a sympy expression into a PolyhedralTerm.\n\n        Example:\n            The expression $2x + 3y - 1$ is translated into\n            `PolyhedralTerm(variables={x:2, y:3}, constant=1)`.\n\n        Args:\n            expression: The symbolic expression to be translated.\n\n        Returns:\n            PolyhedralTerm corresponding to sympy expression.\n        \"\"\"\n        expression_coefficients: dict = expression.as_coefficients_dict()\n        logging.debug(expression_coefficients)\n        keys = list(expression_coefficients.keys())\n        variable_dict = {}\n        constant = 0\n        for key in keys:\n            logging.debug(type(key))\n            if isinstance(key, (str, sympy.core.symbol.Symbol)):\n                var = Var(str(key))  # noqa: VNE002\n                variable_dict[var] = expression_coefficients[key]\n            else:\n                constant = constant - expression_coefficients[key] * key\n        return PolyhedralTerm(variable_dict, constant)\n\n    @staticmethod\n    def term_to_polytope(term: PolyhedralTerm, variable_list: List[Var]) -&gt; Tuple[List[numeric], numeric]:\n\"\"\"\n        Transform a term into a vector according to the given order.\n\n        Example:\n            The term $3x + 5y -2z \\\\le 7$ with `variable_list = [y,\n            x, w, z]` yields the tuple `[5, 3, 0, -2], 7`.\n\n        Args:\n            term: The term to be transformed.\n            variable_list:\n                A list of variables indicating the order of appearance of\n                variable coefficients.\n\n        Returns:\n            A tuple consisting of (i) the ordered list of coefficients and (ii)\n            the term's constant.\n        \"\"\"\n        coeffs = []\n        for var in variable_list:  # noqa: VNE002\n            coeffs.append(term.get_coefficient(var))\n        return coeffs, term.constant\n\n    @staticmethod\n    def polytope_to_term(poly: List[numeric], const: numeric, variables: List[Var]) -&gt; PolyhedralTerm:\n\"\"\"\n        Transform a list of coefficients and variables into a PolyhedralTerm.\n\n        Args:\n            poly: An ordered list of coefficients.\n            const: The term's coefficient.\n            variables: The variables corresponding to the list of coefficients.\n\n        Returns:\n            A PolyhedralTerm corresponding to the provided data.\n        \"\"\"\n        assert len(poly) == len(variables)\n        variable_dict = {}\n        for i, var in enumerate(variables):  # noqa: VNE002\n            variable_dict[var] = poly[i]\n        return PolyhedralTerm(variable_dict, const)\n\n    @staticmethod\n    def solve_for_variables(context: PolyhedralTermList, vars_to_elim: List[Var]) -&gt; dict:\n\"\"\"\n        Interpret termlist as equality and solve system of equations.\n\n        Args:\n            context:\n                The list of terms to be solved. Each term will be interpreted as\n                an equality.\n            vars_to_elim:\n                The list of variables whose solutions will be sought.\n\n        Assumptions: the number of equations matches the number of vars_to_elim\n        contained in the terms.\n\n        Returns:\n            A dictionary mapping variables to their solutions. The solutions are\n            expressed as PolyhedralTerm instances.\n        \"\"\"\n        logging.debug(\"GetVals: %s Vars: %s\", context, vars_to_elim)\n        vars_to_solve = list_intersection(context.vars, vars_to_elim)\n        assert len(context.terms) == len(vars_to_solve)\n        exprs = [PolyhedralTerm.to_symbolic(term) for term in context.terms]\n        logging.debug(\"Solving %s\", exprs)\n        vars_to_solve_symb = [sympy.symbols(var.name) for var in vars_to_solve]\n        sols = sympy.solve(exprs, *vars_to_solve_symb)\n        logging.debug(sols)\n        if len(sols) &gt; 0:\n            return {Var(str(key)): PolyhedralTerm.to_term(sols[key]) for key in sols.keys()}\n        return {}\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.vars","title":"<code>vars: List[Var]</code>  <code>property</code>","text":"<p>Variables appearing in term with a nonzero coefficient.</p> Example <p>For the term \\(ax + by \\le c\\) with variables \\(x\\) and \\(y\\), this function returns the list \\(\\{x, y\\}\\) if \\(a\\) and \\(b\\) are nonzero.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>List of variables referenced in term.</p>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.__init__","title":"<code>__init__(variables, constant)</code>","text":"<p>Constructor for PolyhedralTerm.</p> Usage <p>Polyhedral terms are initialized as follows:</p> <pre><code>    variables = {Var('x'):2, Var('y'):3}\n    constant = 3\n    term = PolyhedralTerm(variables, constant)\n</code></pre> <p><code>variables</code> is a dictionary whose keys are <code>Var</code> instances, and <code>constant</code> is a number. Thus, our example represents the expression \\(2x + 3y \\le 3\\).</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>Dict[Var, numeric]</code> <p>A dictionary mapping Var keys to numeric values.</p> required <code>constant</code> <code>numeric</code> <p>A numeric value on the right of the inequality.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Unsupported argument type.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def __init__(self, variables: Dict[Var, numeric], constant: numeric):\n\"\"\"\n    Constructor for PolyhedralTerm.\n\n    Usage:\n        Polyhedral terms are initialized as follows:\n\n        ```\n            variables = {Var('x'):2, Var('y'):3}\n            constant = 3\n            term = PolyhedralTerm(variables, constant)\n        ```\n\n        `variables` is a dictionary whose keys are `Var` instances,\n        and `constant` is a number. Thus, our example represents the\n        expression $2x + 3y \\\\le 3$.\n\n    Args:\n        variables: A dictionary mapping Var keys to numeric values.\n        constant: A numeric value on the right of the inequality.\n\n    Raises:\n        ValueError: Unsupported argument type.\n    \"\"\"\n    variable_dict = {}\n    for key, value in variables.items():\n        if value != 0:\n            if isinstance(key, str):\n                raise ValueError(\"Unsupported argument type\")\n            else:\n                variable_dict[key] = float(value)\n    self.variables = variable_dict\n    self.constant = float(constant)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.contains_var","title":"<code>contains_var(var_to_seek)</code>","text":"<p>Tell whether term contains a given variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_to_seek</code> <code>Var</code> <p>The variable that we are seeking in the current term.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the syntax of the term refers to the given variable;</p> <code>bool</code> <p><code>False</code> otherwise.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n    Tell whether term contains a given variable.\n\n    Args:\n        var_to_seek: The variable that we are seeking in the current term.\n\n    Returns:\n        `True` if the syntax of the term refers to the given variable;\n        `False` otherwise.\n    \"\"\"\n    return var_to_seek in self.vars\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.copy","title":"<code>copy()</code>","text":"<p>Generates copy of polyhedral term.</p> <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>Copy of term.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def copy(self) -&gt; PolyhedralTerm:\n\"\"\"\n    Generates copy of polyhedral term.\n\n    Returns:\n        Copy of term.\n    \"\"\"\n    return PolyhedralTerm(self.variables, self.constant)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_coefficient","title":"<code>get_coefficient(var)</code>","text":"<p>Output the coefficient multiplying the given variable in the term.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The variable whose coefficient we are seeking.</p> required <p>Returns:</p> Type Description <code>numeric</code> <p>The coefficient corresponding to variable in the term.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_coefficient(self, var: Var) -&gt; numeric:  # noqa: VNE002\n\"\"\"\n    Output the coefficient multiplying the given variable in the term.\n\n    Args:\n        var: The variable whose coefficient we are seeking.\n\n    Returns:\n        The coefficient corresponding to variable in the term.\n    \"\"\"\n    if self.contains_var(var):\n        return self.variables[var]\n    return 0\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_matching_vars","title":"<code>get_matching_vars(variable_polarity)</code>","text":"<p>Get list of variables whose polarities match the polarities requested.</p> <p>Example:</p> <pre><code>    x = Var('x')\n    y = Var('y')\n    z = Var('z')\n    variables = {x:-2, y:3}\n    constant  = 4\n    term = PolyhedralTerm(variables, constant)\n    polarities = {y:True}\n    term.get_matching_vars(polarities)\n</code></pre> <p>The last call returns <code>{y, z}</code> because the variable y matches the requested polarity in the term, and the variable z has a zero coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>variable_polarity</code> <code>Dict[Var, bool]</code> <p>A dictionary mapping Var instances to Boolean values indicating the polarity of the given variable.</p> required <p>Returns:</p> Type Description <code>List[Var]</code> <p>If all variables in the term match the polarities specified in the</p> <code>List[Var]</code> <p>argument, the routine returns the matching variables.  Otherwise,</p> <code>List[Var]</code> <p>it returns an empty list.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_matching_vars(self, variable_polarity: Dict[Var, bool]) -&gt; List[Var]:\n\"\"\"\n    Get list of variables whose polarities match the polarities requested.\n\n    Example:\n\n    ```\n        x = Var('x')\n        y = Var('y')\n        z = Var('z')\n        variables = {x:-2, y:3}\n        constant  = 4\n        term = PolyhedralTerm(variables, constant)\n        polarities = {y:True}\n        term.get_matching_vars(polarities)\n    ```\n\n    The last call returns `{y, z}` because the variable y matches the\n    requested polarity in the term, and the variable z has a zero\n    coefficient.\n\n    Args:\n        variable_polarity: A dictionary mapping Var instances to Boolean\n            values indicating the polarity of the given variable.\n\n    Returns:\n        If all variables in the term match the polarities specified in the\n        argument, the routine returns the matching variables.  Otherwise,\n        it returns an empty list.\n    \"\"\"\n    variable_list = []\n    for var in variable_polarity.keys():  # noqa: VNE002\n        if self.contains_var(var):\n            if (self.get_polarity(var=var, polarity=True) == variable_polarity[var]) or (  # noqa: WPS337\n                self.get_coefficient(var) == 0\n            ):\n                variable_list.append(var)\n            else:\n                variable_list = []\n                break\n    return variable_list\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_polarity","title":"<code>get_polarity(var, polarity=True)</code>","text":"<p>Check if variable matches given polarity</p> <p>The polarity of a variable in a term is defined as the polarity of the coefficient that multiplies it in a term, e.g., the variables \\(x\\) and \\(y\\) in the term \\(-2x + y \\le 3\\) have negative and positive polarities respectively.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The variable whose polarity in the term we are seeking.</p> required <code>polarity</code> <code>bool</code> <p>The polarity that we are comparing against the variable's polarity.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the variable's polarity matches <code>polarity</code> and</p> <code>bool</code> <p><code>False</code> otherwise. If the variable's coefficient in the term</p> <code>bool</code> <p>is zero, return <code>True</code>.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_polarity(self, var: Var, polarity: bool = True) -&gt; bool:  # noqa: VNE002\n\"\"\"\n    Check if variable matches given polarity\n\n    The polarity of a variable in a term is defined as the polarity of the\n    coefficient that multiplies it in a term, e.g., the variables $x$\n    and $y$ in the term $-2x + y \\\\le 3$ have negative and\n    positive polarities respectively.\n\n    Args:\n        var: The variable whose polarity in the term we are seeking.\n        polarity: The polarity that we are comparing against the variable's polarity.\n\n    Returns:\n        `True` if the variable's polarity matches `polarity` and\n        `False` otherwise. If the variable's coefficient in the term\n        is zero, return `True`.\n    \"\"\"\n    if polarity:\n        return self.variables[var] &gt;= 0\n    return self.variables[var] &lt;= 0\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_sign","title":"<code>get_sign(var)</code>","text":"<p>Get the sign of the variable in term.</p> <p>The sign of a variable in a term is defined as the sign of the coefficient that multiplies it in a term, e.g., the variables \\(x\\) and \\(y\\) in the term \\(-2x + y \\le 3\\) have \\(-1\\) and \\(+1\\) polarities respectively. \\(0\\) has \\(+1\\) sign.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The variable whose polarity in the term we are seeking.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sign of the variable in the term.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_sign(self, var: Var) -&gt; int:  # noqa: VNE002\n\"\"\"\n    Get the sign of the variable in term.\n\n    The sign of a variable in a term is defined as the sign of the\n    coefficient that multiplies it in a term, e.g., the variables $x$\n    and $y$ in the term $-2x + y \\\\le 3$ have $-1$ and\n    $+1$ polarities respectively. $0$ has $+1$ sign.\n\n    Args:\n        var: The variable whose polarity in the term we are seeking.\n\n    Returns:\n        The sign of the variable in the term.\n    \"\"\"\n    if self.get_polarity(var=var, polarity=True):\n        return 1\n    return -1\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.isolate_variable","title":"<code>isolate_variable(var_to_isolate)</code>","text":"<p>Isolate a variable in a term.</p> Example <p>In the term \\(-2x + y \\le 6\\) understood as equality, isolating the variable \\(x\\) yields \\(x = 0.5 y - 3\\), which in PolyhedralTerm notation we express as \\(0.5 y &lt;= -3\\).</p> <p>Parameters:</p> Name Type Description Default <code>var_to_isolate</code> <code>Var</code> <p>The variable to be isolated.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term which corresponds to the isolation of the indicated</p> <code>PolyhedralTerm</code> <p>variable.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>the indicated variable is not contained in the term.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def isolate_variable(self, var_to_isolate: Var) -&gt; PolyhedralTerm:\n\"\"\"\n    Isolate a variable in a term.\n\n    Example:\n        In the term $-2x + y \\\\le 6$ understood as equality, isolating the\n        variable $x$ yields $x = 0.5 y - 3$, which in PolyhedralTerm\n        notation we express as $0.5 y &lt;= -3$.\n\n    Args:\n        var_to_isolate: The variable to be isolated.\n\n    Returns:\n        A new term which corresponds to the isolation of the indicated\n        variable.\n\n    Raises:\n        ValueError: the indicated variable is not contained in the term.\n    \"\"\"\n    if var_to_isolate not in self.vars:\n        raise ValueError(\"Variable %s is not a term variable\" % (var_to_isolate))\n    return PolyhedralTerm(\n        variables={\n            k: -v / self.get_coefficient(var_to_isolate) for k, v in self.variables.items() if k != var_to_isolate\n        },\n        constant=self.constant / self.get_coefficient(var_to_isolate),\n    )\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.multiply","title":"<code>multiply(factor)</code>","text":"<p>Multiplies a term by a constant factor.</p> <p>For example, multiplying the term \\(2x + 3y \\le 4\\) by the factor 2 yields \\(4x + 6y \\le 8\\).</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>numeric</code> <p>element by which the term is multiplied.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term which is the result of the given term multiplied by</p> <code>PolyhedralTerm</code> <p><code>factor</code>.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def multiply(self, factor: numeric) -&gt; PolyhedralTerm:\n\"\"\"Multiplies a term by a constant factor.\n\n    For example, multiplying the term $2x + 3y \\\\le 4$ by the factor 2\n    yields $4x + 6y \\\\le 8$.\n\n    Args:\n        factor: element by which the term is multiplied.\n\n    Returns:\n        A new term which is the result of the given term multiplied by\n        `factor`.\n    \"\"\"\n    variables = {key: factor * val for key, val in self.variables.items()}\n    return PolyhedralTerm(variables, factor * self.constant)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.polytope_to_term","title":"<code>polytope_to_term(poly, const, variables)</code>  <code>staticmethod</code>","text":"<p>Transform a list of coefficients and variables into a PolyhedralTerm.</p> <p>Parameters:</p> Name Type Description Default <code>poly</code> <code>List[numeric]</code> <p>An ordered list of coefficients.</p> required <code>const</code> <code>numeric</code> <p>The term's coefficient.</p> required <code>variables</code> <code>List[Var]</code> <p>The variables corresponding to the list of coefficients.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A PolyhedralTerm corresponding to the provided data.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef polytope_to_term(poly: List[numeric], const: numeric, variables: List[Var]) -&gt; PolyhedralTerm:\n\"\"\"\n    Transform a list of coefficients and variables into a PolyhedralTerm.\n\n    Args:\n        poly: An ordered list of coefficients.\n        const: The term's coefficient.\n        variables: The variables corresponding to the list of coefficients.\n\n    Returns:\n        A PolyhedralTerm corresponding to the provided data.\n    \"\"\"\n    assert len(poly) == len(variables)\n    variable_dict = {}\n    for i, var in enumerate(variables):  # noqa: VNE002\n        variable_dict[var] = poly[i]\n    return PolyhedralTerm(variable_dict, const)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.remove_variable","title":"<code>remove_variable(var)</code>","text":"<p>Eliminates a variable from a term.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>variable to be eliminated.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term with the variable eliminated.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def remove_variable(self, var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n    Eliminates a variable from a term.\n\n    Args:\n        var: variable to be eliminated.\n\n    Returns:\n        A new term with the variable eliminated.\n    \"\"\"\n    if self.contains_var(var):\n        that = self.copy()\n        that.variables.pop(var)\n        return that\n    return self.copy()\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a term.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A term with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def rename_variable(self, source_var: Var, target_var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n    Rename a variable in a term.\n\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n\n    Returns:\n        A term with `source_var` replaced by `target_var`.\n    \"\"\"\n    new_term = self.copy()\n    if source_var in self.vars:\n        if target_var not in self.vars:\n            new_term.variables[target_var] = 0\n        new_term.variables[target_var] += new_term.variables[source_var]\n        new_term = new_term.remove_variable(source_var)\n    return new_term\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.solve_for_variables","title":"<code>solve_for_variables(context, vars_to_elim)</code>  <code>staticmethod</code>","text":"<p>Interpret termlist as equality and solve system of equations.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PolyhedralTermList</code> <p>The list of terms to be solved. Each term will be interpreted as an equality.</p> required <code>vars_to_elim</code> <code>List[Var]</code> <p>The list of variables whose solutions will be sought.</p> required <p>Assumptions: the number of equations matches the number of vars_to_elim contained in the terms.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary mapping variables to their solutions. The solutions are</p> <code>dict</code> <p>expressed as PolyhedralTerm instances.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef solve_for_variables(context: PolyhedralTermList, vars_to_elim: List[Var]) -&gt; dict:\n\"\"\"\n    Interpret termlist as equality and solve system of equations.\n\n    Args:\n        context:\n            The list of terms to be solved. Each term will be interpreted as\n            an equality.\n        vars_to_elim:\n            The list of variables whose solutions will be sought.\n\n    Assumptions: the number of equations matches the number of vars_to_elim\n    contained in the terms.\n\n    Returns:\n        A dictionary mapping variables to their solutions. The solutions are\n        expressed as PolyhedralTerm instances.\n    \"\"\"\n    logging.debug(\"GetVals: %s Vars: %s\", context, vars_to_elim)\n    vars_to_solve = list_intersection(context.vars, vars_to_elim)\n    assert len(context.terms) == len(vars_to_solve)\n    exprs = [PolyhedralTerm.to_symbolic(term) for term in context.terms]\n    logging.debug(\"Solving %s\", exprs)\n    vars_to_solve_symb = [sympy.symbols(var.name) for var in vars_to_solve]\n    sols = sympy.solve(exprs, *vars_to_solve_symb)\n    logging.debug(sols)\n    if len(sols) &gt; 0:\n        return {Var(str(key)): PolyhedralTerm.to_term(sols[key]) for key in sols.keys()}\n    return {}\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.substitute_variable","title":"<code>substitute_variable(var, subst_with_term)</code>","text":"<p>Substitutes a specified variable in a term with a given term.</p> Example <p>In the term \\(2x - y \\le 6\\), substituting y by the term \\(x + z \\le 5\\) yields \\(x - z \\le 1\\). Observe that the substituting term is understood as an equality.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The term variable to be substituted.</p> required <code>subst_with_term</code> <code>PolyhedralTerm</code> <p>The term used to replace var.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term in which the variable is substituted with the given term</p> <code>PolyhedralTerm</code> <p>understood as an equality.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def substitute_variable(self, var: Var, subst_with_term: PolyhedralTerm) -&gt; PolyhedralTerm:  # noqa: VNE002\n\"\"\"\n    Substitutes a specified variable in a term with a given term.\n\n    Example:\n        In the term $2x - y \\\\le 6$, substituting y by the term\n        $x + z \\\\le 5$ yields $x - z \\\\le 1$. Observe that the\n        substituting term is understood as an equality.\n\n    Args:\n        var: The term variable to be substituted.\n        subst_with_term: The term used to replace var.\n\n    Returns:\n        A new term in which the variable is substituted with the given term\n        understood as an equality.\n    \"\"\"\n    if self.contains_var(var):\n        term = subst_with_term.multiply(self.get_coefficient(var))\n        logging.debug(\"Term is %s\", term)\n        that = self.remove_variable(var)\n        logging.debug(that)\n        return that + term\n    return self.copy()\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.term_to_polytope","title":"<code>term_to_polytope(term, variable_list)</code>  <code>staticmethod</code>","text":"<p>Transform a term into a vector according to the given order.</p> Example <p>The term \\(3x + 5y -2z \\le 7\\) with <code>variable_list = [y, x, w, z]</code> yields the tuple <code>[5, 3, 0, -2], 7</code>.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>PolyhedralTerm</code> <p>The term to be transformed.</p> required <code>variable_list</code> <code>List[Var]</code> <p>A list of variables indicating the order of appearance of variable coefficients.</p> required <p>Returns:</p> Type Description <code>List[numeric]</code> <p>A tuple consisting of (i) the ordered list of coefficients and (ii)</p> <code>numeric</code> <p>the term's constant.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef term_to_polytope(term: PolyhedralTerm, variable_list: List[Var]) -&gt; Tuple[List[numeric], numeric]:\n\"\"\"\n    Transform a term into a vector according to the given order.\n\n    Example:\n        The term $3x + 5y -2z \\\\le 7$ with `variable_list = [y,\n        x, w, z]` yields the tuple `[5, 3, 0, -2], 7`.\n\n    Args:\n        term: The term to be transformed.\n        variable_list:\n            A list of variables indicating the order of appearance of\n            variable coefficients.\n\n    Returns:\n        A tuple consisting of (i) the ordered list of coefficients and (ii)\n        the term's constant.\n    \"\"\"\n    coeffs = []\n    for var in variable_list:  # noqa: VNE002\n        coeffs.append(term.get_coefficient(var))\n    return coeffs, term.constant\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.to_symbolic","title":"<code>to_symbolic(term)</code>  <code>staticmethod</code>","text":"<p>Translates the variable terms of a PolyhedralTerm into a sympy expression.</p> Example <p>The code</p> <pre><code>    x = Var('x') y = Var('y') variables = {x:-2, y:3} constant  = 4\n    term = PolyhedralTerm(variables, constant) expression =\n    PolyhedralTerm.to_symbolic(term)\n</code></pre> <p>yields the expression \\(-2x + 3y\\).</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>PolyhedralTerm</code> <p>The term whose coefficients and variables are to be translated to sympy's data structure.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Sympy expression corresponding to PolyhedralTerm.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef to_symbolic(term: PolyhedralTerm) -&gt; Any:\n\"\"\"\n    Translates the variable terms of a PolyhedralTerm into a sympy expression.\n\n    Example:\n        The code\n\n        ```\n            x = Var('x') y = Var('y') variables = {x:-2, y:3} constant  = 4\n            term = PolyhedralTerm(variables, constant) expression =\n            PolyhedralTerm.to_symbolic(term)\n        ```\n\n        yields the expression $-2x + 3y$.\n\n    Args:\n        term:\n            The term whose coefficients and variables are to be translated\n            to sympy's data structure.\n\n    Returns:\n        Sympy expression corresponding to PolyhedralTerm.\n    \"\"\"\n    ex = -term.constant\n    for var in term.vars:  # noqa: VNE002\n        sv = sympy.symbols(var.name)\n        ex += sv * term.get_coefficient(var)\n    return ex\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.to_term","title":"<code>to_term(expression)</code>  <code>staticmethod</code>","text":"<p>Translates a sympy expression into a PolyhedralTerm.</p> Example <p>The expression \\(2x + 3y - 1\\) is translated into <code>PolyhedralTerm(variables={x:2, y:3}, constant=1)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>sympy.core.expr.Expr</code> <p>The symbolic expression to be translated.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>PolyhedralTerm corresponding to sympy expression.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef to_term(expression: sympy.core.expr.Expr) -&gt; PolyhedralTerm:\n\"\"\"\n    Translates a sympy expression into a PolyhedralTerm.\n\n    Example:\n        The expression $2x + 3y - 1$ is translated into\n        `PolyhedralTerm(variables={x:2, y:3}, constant=1)`.\n\n    Args:\n        expression: The symbolic expression to be translated.\n\n    Returns:\n        PolyhedralTerm corresponding to sympy expression.\n    \"\"\"\n    expression_coefficients: dict = expression.as_coefficients_dict()\n    logging.debug(expression_coefficients)\n    keys = list(expression_coefficients.keys())\n    variable_dict = {}\n    constant = 0\n    for key in keys:\n        logging.debug(type(key))\n        if isinstance(key, (str, sympy.core.symbol.Symbol)):\n            var = Var(str(key))  # noqa: VNE002\n            variable_dict[var] = expression_coefficients[key]\n        else:\n            constant = constant - expression_coefficients[key] * key\n    return PolyhedralTerm(variable_dict, constant)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList","title":"<code>PolyhedralTermList</code>","text":"<p>         Bases: <code>TermList</code></p> <p>A TermList of PolyhedralTerm instances.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>class PolyhedralTermList(TermList):  # noqa: WPS338\n\"\"\"A TermList of PolyhedralTerm instances.\"\"\"\n\n    def __init__(self, terms: Optional[List[PolyhedralTerm]] = None):\n\"\"\"\n        Constructor for PolyhedralTermList.\n\n        Usage:\n            PolyhedralTermList objects are initialized as follows:\n\n            ```\n                term1 = PolyhedralTerm({Var('x'):2, Var('y'):3}, 3)\n                term2 = PolyhedralTerm({Var('x'):-1, Var('y'):2}, 4)\n                pt_list = [term1, term2]\n                termlist = PolyhedralTermList(pt_list)\n            ```\n\n            Our example represents the constraints $\\\\{2x + 3y \\\\le 3, -x + 2y \\\\le 4\\\\}$.\n\n        Args:\n            terms: A list of PolyhedralTerm objects.\n\n        Raises:\n            ValueError: incorrect argument type provided.\n        \"\"\"\n        if terms is None:\n            self.terms = []\n        elif all(isinstance(t, PolyhedralTerm) for t in terms):\n            self.terms = terms.copy()\n        else:\n            raise ValueError(\"PolyhedralTermList constructor argument must be a list of PolyhedralTerms.\")\n\n    def __str__(self) -&gt; str:\n        res = \"[\\n  \"\n        res += \"\\n  \".join(self.to_str_list())\n        res += \"\\n]\"\n        return res\n\n    def __hash__(self) -&gt; int:\n        return hash(tuple(self.terms))\n\n    def to_str_list(self) -&gt; List[str]:\n\"\"\"\n        Convert termlist into a list of strings.\n\n        Returns:\n            A list of strings corresponding to the terms of the termlist.\n        \"\"\"\n        str_list = []\n        ts = self.terms.copy()\n        while ts:\n            s, rest = serializer.polyhedral_term_list_to_strings(ts)\n            str_list.append(s)\n            ts = rest\n        return str_list\n\n    def evaluate(self, var_values: Dict[Var, numeric]) -&gt; PolyhedralTermList:  # noqa: WPS231\n\"\"\"\n        Replace variables in termlist with given values.\n\n        Args:\n            var_values:\n                The values that variables will take.\n\n        Returns:\n            A new PolyhedralTermList in which the variables have been\n            substituted with the values provided.\n\n        Raises:\n            ValueError: constraints are unsatisfiable under these valuation of variables.\n        \"\"\"\n        new_list = []\n        for term in self.terms:\n            new_term = term.copy()\n            for var, val in var_values.items():  # noqa: VNE002\n                new_term = new_term.substitute_variable(\n                    var=var, subst_with_term=PolyhedralTerm(variables={}, constant=-val)\n                )\n            # we may have eliminated all variables after substitution\n            if not new_term.vars:\n                if new_term.constant &lt; 0:\n                    raise ValueError(\"Term %s not satisfied\" % (term))\n                else:\n                    continue  # noqa: WPS503\n            new_list.append(new_term)\n        return PolyhedralTermList(new_list)\n\n    def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n        Tell whether TermList contains the given behavior.\n\n        Args:\n            behavior:\n                The behavior in question.\n\n        Returns:\n            True if the behavior satisfies the constraints; false otherwise.\n\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\n        excess_vars = list_diff(self.vars, list(behavior.keys()))\n        if excess_vars:\n            raise ValueError(\"The variables %s were not assigned values\" % (excess_vars))\n        retval = True\n        try:\n            self.evaluate(behavior)\n        except ValueError:\n            retval = False\n        return retval\n\n    def elim_vars_by_refining(self, context: PolyhedralTermList, vars_to_elim: list) -&gt; PolyhedralTermList:\n\"\"\"\n        Eliminate variables from PolyhedralTermList by refining it in context.\n\n        Example:\n            Suppose the current list of terms is $\\\\{x + y \\\\le 6\\\\}$, the\n            context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n            contain variable $y$. Then the current TermList could be\n            refined to $\\\\{x \\\\le 1\\\\}$ because $x \\\\le 1\n            \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x + y \\\\le 6$.\n\n        Args:\n            context:\n                The TermList providing the context for the refinement.\n            vars_to_elim:\n                Variables that should not appear in the resulting term.\n\n        Returns:\n            A list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, imply the terms contained in the\n            calling termlist.\n\n        Raises:\n            ValueError: Self has empty intersection with its context.\n        \"\"\"\n        logging.debug(\"Refining from terms: %s\", self)\n        logging.debug(\"Context: %s\", context)\n        logging.debug(\"Vars to elim: %s\", vars_to_elim)\n        try:\n            termlist = self.simplify(context)\n        except ValueError as e:\n            raise ValueError(\n                \"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n            ) from e\n        try:\n            return termlist._transform(context=context, vars_to_elim=vars_to_elim, refine=True)\n        except ValueError as e:\n            raise ValueError(\n                \"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n                + \"by refining terms \\n{}\\n\".format(self)\n                + \"in context \\n{}\\n\".format(context)\n                + \"was not possible\"\n            ) from e\n\n    def lacks_constraints(self) -&gt; bool:\n\"\"\"\n        Tell whether TermList is empty.\n\n        Returns:\n            True if empty. False otherwise.\n        \"\"\"\n        return len(self.terms) == 0\n\n    def elim_vars_by_relaxing(self, context: PolyhedralTermList, vars_to_elim: list) -&gt; PolyhedralTermList:\n\"\"\"\n        Eliminate variables from PolyhedralTermList by abstracting it in context.\n\n        Example:\n            Suppose the current list of terms is $\\\\{x - y \\\\le 6\\\\}$, the\n            context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n            contain variable $y$. Then the current TermList could be\n            relaxed to $\\\\{x \\\\le 11\\\\}$ because $x - y \\\\le 6\n            \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x \\\\le 11$.\n\n        Args:\n            context:\n                The TermList providing the context for the transformation.\n            vars_to_elim:\n                Variables that should not appear in the relaxed terms.\n\n        Returns:\n            A list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, are implied by the terms\n            contained in the calling termlist.\n\n        Raises:\n            ValueError: Constraints have empty intersection with context.\n        \"\"\"\n        logging.debug(\"Relaxing with context\")\n        logging.debug(\"Relaxing from terms %s\", self)\n        logging.debug(\"Context: %s\", context)\n        logging.debug(\"Vars to elim: %s\", vars_to_elim)\n        try:\n            termlist = self.simplify(context)\n        except ValueError as e:\n            raise ValueError(\n                \"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n            ) from e\n        try:\n            termlist = termlist._transform(context=context, vars_to_elim=vars_to_elim, refine=False)\n        except ValueError as e:\n            raise ValueError(\n                \"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n                + \"by relaxing terms \\n{}\\n\".format(self)\n                + \"in context \\n{}\\n\".format(context)\n                + \"was not possible\"\n            ) from e\n        # eliminate terms containing the variables to be eliminated\n        terms_to_elim = termlist.get_terms_with_vars(vars_to_elim)\n        termlist.terms = list_diff(termlist.terms, terms_to_elim.terms)\n        return termlist\n\n    def simplify(self, context: Optional[PolyhedralTermList] = None) -&gt; PolyhedralTermList:\n\"\"\"\n        Remove redundant terms in the PolyhedralTermList using the provided context.\n\n        Example:\n            Suppose the TermList is $\\\\{x - 2y \\\\le 5, x - y \\\\le 0\\\\}$ and\n            the context is $\\\\{x + y \\\\le 0\\\\}$. Then the TermList could be\n            simplified to $\\\\{x - y \\\\le 0\\\\}$.\n\n        Args:\n            context:\n                The TermList providing the context for the simplification.\n\n        Returns:\n            A new PolyhedralTermList with redundant terms removed using the provided context.\n\n        Raises:\n            ValueError: The intersection of self and context is empty.\n        \"\"\"\n        logging.debug(\"Starting simplification procedure\")\n        logging.debug(\"Simplifying terms: %s\", self)\n        logging.debug(\"Context: %s\", context)\n        if context:\n            new_self = self - context\n            result = PolyhedralTermList.termlist_to_polytope(new_self, context)\n        else:\n            result = PolyhedralTermList.termlist_to_polytope(self, PolyhedralTermList())\n\n        variables = result[0]\n        self_mat = result[1]\n        self_cons = result[2]\n        ctx_mat = result[3]\n        ctx_cons = result[4]\n        # logging.debug(\"Polytope is \\n%s\", self_mat)\n        try:\n            a_red, b_red = PolyhedralTermList.reduce_polytope(self_mat, self_cons, ctx_mat, ctx_cons)\n        except ValueError as e:\n            raise ValueError(\n                \"The constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n            ) from e\n        logging.debug(\"Reduction: \\n%s\", a_red)\n        simplified = PolyhedralTermList.polytope_to_termlist(a_red, b_red, variables)\n        logging.debug(\"Back to terms: \\n%s\", simplified)\n        return simplified\n\n    def refines(self, other: PolyhedralTermList) -&gt; bool:\n\"\"\"\n        Tells whether the argument is a larger specification.\n\n        Args:\n            other:\n                TermList against which we are comparing self.\n\n        Returns:\n            self &lt;= other\n        \"\"\"\n        logging.debug(\"Verifying refinement\")\n        logging.debug(\"LH term: %s\", self)\n        logging.debug(\"RH term: %s\", other)\n        if other.lacks_constraints():\n            return True\n        if self.lacks_constraints():\n            return False\n        variables, self_mat, self_cons, ctx_mat, ctx_cons = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\n            self, other\n        )\n        logging.debug(\"Polytope is \\n%s\", self_mat)\n        return PolyhedralTermList.verify_polytope_containment(self_mat, self_cons, ctx_mat, ctx_cons)\n\n    def is_empty(self) -&gt; bool:\n\"\"\"\n        Tell whether the argument has no satisfying assignments.\n\n        Returns:\n            True if constraints cannot be satisfied.\n        \"\"\"\n        _, self_mat, self_cons, _, _ = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\n            self, PolyhedralTermList([])\n        )\n        logging.debug(\"Polytope is \\n%s\", self_mat)\n        return PolyhedralTermList.is_polytope_empty(self_mat, self_cons)\n\n    def _transform(self, context: PolyhedralTermList, vars_to_elim: list, refine: bool) -&gt; PolyhedralTermList:\n        logging.debug(\"Transforming: %s\", self)\n        logging.debug(\"Context terms: %s\", context)\n        logging.debug(\"Variables to eliminate: %s\", vars_to_elim)\n        term_list = list(self.terms)\n        new_terms = self.copy()\n        for i, term in enumerate(term_list):\n            copy_new_terms = new_terms.copy()\n            copy_new_terms.terms.remove(term)\n            helpers = context | copy_new_terms\n            try:\n                new_term = PolyhedralTermList._transform_term(term, helpers, vars_to_elim, refine)\n            except ValueError:\n                new_term = term.copy()\n\n            new_terms.terms[i] = new_term.copy()\n\n        that = PolyhedralTermList(new_terms.terms)\n\n        # the last step needs to be a simplification\n        logging.debug(\"Ending transformation with simplification\")\n        return that.simplify(context)\n\n    def optimize(self, objective: Dict[Var, numeric], maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"\n        Optimizes a linear expression in the feasible region of the termlist.\n\n        Args:\n            objective:\n                The objective to optimize.\n            maximize:\n                If true, the routine maximizes; it minimizes otherwise.\n\n        Returns:\n            The optimal value of the objective. If the objective is unbounded, None is returned.\n\n        Raises:\n            ValueError: Constraints are likely unfeasible.\n        \"\"\"\n        obj = PolyhedralTermList([PolyhedralTerm(variables=objective, constant=0)])\n        _, self_mat, self_cons, obj_mat, _ = PolyhedralTermList.termlist_to_polytope(self, obj)  # noqa: WPS236\n        polarity = 1\n        if maximize:\n            polarity = -1\n        res = linprog(c=polarity * obj_mat[0], A_ub=self_mat, b_ub=self_cons, bounds=(None, None))\n        # Linprog's status values\n        # 0 : Optimization proceeding nominally.\n        # 1 : Iteration limit reached.\n        # 2 : Problem appears to be infeasible.\n        # 3 : Problem appears to be unbounded.\n        # 4 : Numerical difficulties encountered.\n        if res[\"status\"] == 3:\n            return None\n        elif res[\"status\"] == 0:\n            fun_val: float = res[\"fun\"]\n            return polarity * fun_val\n        raise ValueError(\"Constraints are unfeasible\")\n\n    @staticmethod\n    def termlist_to_polytope(\n        terms: PolyhedralTermList, context: PolyhedralTermList\n    ) -&gt; Tuple[List[Var], np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n\"\"\"\n        Converts a list of terms with its context into matrix-vector pairs.\n\n        Example:\n            Suppose the list of terms is $\\\\{x+y \\\\le 1, x - y \\\\le 4\\\\}$\n            and the context is $\\\\{x + 4w \\\\le 5\\\\}$. The routine extracts\n            all variables and generates an order for them, say, $[x, w,\n            y]$. Then the routine returns matrix-vector pairs for both the terms\n            TermList and the context. It returns $A = \\\\left(\n            \\\\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\\\\\\\ 1 &amp;0 &amp;-1\n            \\\\end{smallmatrix}\\\\right)$ and $b = \\\\left(\n            \\\\begin{smallmatrix} 1 \\\\\\\\ 4 \\\\end{smallmatrix}\\\\right)$ for the\n            current TermList and $A_{c} = \\\\left( \\\\begin{smallmatrix} 1 &amp;\n            4 &amp; 0 \\\\end{smallmatrix}\\\\right)$ and $b_c = \\\\left(\n            \\\\begin{smallmatrix} 5 \\\\end{smallmatrix}\\\\right)$ for the context.\n\n        Args:\n            terms:\n                list of terms to convert to matrix-vector form.\n            context:\n                Context terms to convert to matrix-vector form.\n\n        Returns:\n            A tuple `variables, A, b, a_h, b_h` consisting of the variable\n            order and the matrix-vector pairs for the terms and the context.\n        \"\"\"\n        variables = list(list_union(terms.vars, context.vars))\n        a = []\n        b = []\n        for term in terms.terms:\n            pol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\n            a.append(pol)\n            b.append(coeff)\n\n        a_h = []\n        b_h = []\n        for term in context.terms:\n            pol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\n            a_h.append(pol)\n            b_h.append(coeff)\n\n        if len(context.terms) == 0:\n            a_h_ret = np.array([[]])\n        else:\n            a_h_ret = np.array(a_h)\n        # logging.debug(\"a is \\n%s\", a)\n        return variables, np.array(a), np.array(b), a_h_ret, np.array(b_h)\n\n    @staticmethod\n    def polytope_to_termlist(matrix: np.ndarray, vector: np.ndarray, variables: List[Var]) -&gt; PolyhedralTermList:\n\"\"\"\n        Transforms a matrix-vector pair into a PolyhedralTermList.\n\n        Args:\n            matrix:\n                The matrix of the pair.\n            vector:\n                The vector of the pair.\n            variables:\n                A list indicating the variable which corresponds to each column\n                of the matrix.\n\n        Returns:\n            The PolyhedralTermList corresponding to the given data.\n        \"\"\"\n        term_list = []\n        # logging.debug(\"Poly is \" + str(polytope))\n        # logging.debug(\"matrix is %s\", matrix)\n        if len(matrix.shape) &gt; 1:\n            n, m = matrix.shape\n            assert m == len(variables)\n        else:\n            n = matrix.shape[0]\n            m = 0\n        for i in range(n):\n            row = list(matrix[i])\n            const = vector[i]\n            term = PolyhedralTerm.polytope_to_term(row, const, variables)\n            term_list.append(term)\n        return PolyhedralTermList(list(term_list))\n\n    @staticmethod\n    def reduce_polytope(  # noqa: WPS231\n        a: np.ndarray, b: np.ndarray, a_help: Optional[np.ndarray] = None, b_help: Optional[np.ndarray] = None\n    ) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"\n        Eliminate redundant constraints from a given polytope.\n\n        Args:\n            a:\n                Matrix of H-representation of polytope to reduce.\n            b:\n                Vector of H-representation of polytope to reduce.\n            a_help:\n                Matrix of H-representation of context polytope.\n            b_help:\n                Vector of H-representation of context polytope.\n\n        Raises:\n            ValueError: The intersection of given polytope with its context is empty.\n\n        Returns:\n            a_temp: Matrix of H-representation of reduced polytope.\n            b_temp: Vector of H-representation of reduced polytope.\n        \"\"\"\n        if not isinstance(a_help, np.ndarray):\n            a_help = np.array([[]])\n        if not isinstance(b_help, np.ndarray):\n            b_help = np.array([])\n        if len(a.shape) &gt; 1:\n            n, m = a.shape\n        else:\n            n = a.shape[0]\n            m = 0\n        n_h, m_h = a_help.shape\n        helper_present = n_h * m_h &gt; 0\n        assert n == len(b), \"n is {} and b is {}\".format(n, b)\n        if helper_present:\n            assert n_h == len(b_help)\n        else:\n            assert len(b_help) == 0\n        if helper_present and m &gt; 0:\n            assert m_h == m\n        if n == 0:\n            return a, b\n        if n == 1 and not helper_present:\n            return a, b\n\n        i = 0\n        a_temp = np.copy(a)\n        b_temp = np.copy(b)\n        while i &lt; n:\n            objective = a_temp[i, :] * -1\n            b_temp[i] += 1\n            if helper_present:\n                a_opt = np.concatenate((a_temp, a_help), axis=0)\n                b_opt = np.concatenate((b_temp, b_help))\n            else:\n                a_opt = a_temp\n                b_opt = b_temp\n            # Linprog's status values\n            # 0 : Optimization proceeding nominally.\n            # 1 : Iteration limit reached.\n            # 2 : Problem appears to be infeasible.\n            # 3 : Problem appears to be unbounded.\n            # 4 : Numerical difficulties encountered.\n            res = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\n            b_temp[i] -= 1\n            if res[\"status\"] == 3 or (res[\"status\"] == 0 and -res[\"fun\"] &lt;= b_temp[i]):  # noqa: WPS309\n                logging.debug(\"Can remove\")\n                a_temp = np.delete(a_temp, i, 0)\n                b_temp = np.delete(b_temp, i)\n                n -= 1\n            else:\n                i += 1\n            if res[\"status\"] == 2:\n                raise ValueError(\"The constraints are unsatisfiable\")\n\n        return a_temp, b_temp\n\n    @staticmethod\n    def verify_polytope_containment(  # noqa: WPS231\n        a_l: Optional[np.ndarray] = None,\n        b_l: Optional[np.ndarray] = None,\n        a_r: Optional[np.ndarray] = None,\n        b_r: Optional[np.ndarray] = None,\n    ) -&gt; bool:\n\"\"\"\n        Tell whether a polytope is contained in another.\n\n        Args:\n            a_l:\n                Matrix of H-representation of polytope on LHS of inequality.\n            b_l:\n                Vector of H-representation of polytope on LHS of inequality.\n            a_r:\n                Matrix of H-representation of polytope on RHS of inequality.\n            b_r:\n                Vector of H-representation of polytope on RHS of inequality.\n\n        Returns:\n            True if left polytope is contained in right polytope. False otherwise.\n        \"\"\"\n        if not isinstance(a_l, np.ndarray):\n            a_l = np.array([[]])\n        if not isinstance(a_r, np.ndarray):\n            a_r = np.array([[]])\n        if not isinstance(b_l, np.ndarray):\n            b_l = np.array([])\n        if not isinstance(b_r, np.ndarray):\n            b_r = np.array([])\n        # If the LHS is empty, it is a refinement\n        if PolyhedralTermList.is_polytope_empty(a_l, b_l):\n            return True\n        # If the RHS is empty, but not the LHS, not a refinement\n        if PolyhedralTermList.is_polytope_empty(a_r, b_r):\n            return False\n        # If no side is empty, check whether the RHS terms are included in the\n        # LHS\n        n_l, m_l = a_l.shape\n        n_r, m_r = a_r.shape\n        assert m_l == m_r\n        assert n_l == len(b_l)\n        assert n_r == len(b_r)\n\n        is_refinement = True\n        for i in range(n_r):\n            constraint = a_r[[i], :]\n            objective = constraint * -1\n            b_temp = b_r[i] + 1\n            logging.debug(\"Optimization objective: \\n%s\", objective)\n            logging.debug(\"a_l is \\n%s\", a_l)\n            logging.debug(\"a_r is \\n%s\", a_r)\n            logging.debug(\"b_l is \\n%s\", b_l)\n            logging.debug(\"b_r is \\n%s\", b_r)\n\n            a_opt = np.concatenate((a_l, constraint), axis=0)\n            b_opt = np.concatenate((b_l, np.array([b_temp])))\n\n            res = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\n            b_temp -= 1\n            if res[\"status\"] == 2:\n                is_refinement = False\n                break\n            else:\n                if -res[\"fun\"] &lt;= b_temp:  # noqa: WPS309\n                    logging.debug(\"Redundant constraint\")\n                else:\n                    is_refinement = False\n                    break\n            logging.debug(\"Optimal value: %s\", -res[\"fun\"])\n            logging.debug(\"Results: %s\", res)\n        return is_refinement\n\n    @staticmethod\n    def is_polytope_empty(a: np.ndarray, b: np.ndarray) -&gt; bool:\n\"\"\"\n        Say whether a polytope is empty.\n\n        Args:\n            a:\n                Matrix of H-representation of polytope to verify.\n            b:\n                Vector of H-representation of polytope to verify.\n\n        Returns:\n            True if empty. False otherwise.\n\n        Raises:\n            ValueError: Numerical difficulties encountered.\n        \"\"\"\n        logging.debug(\"Verifying polytope emptiness: a is %s a.shape is %s, b is %s\", a, a.shape, b)\n        if len(a) == 0:\n            return False\n        n, m = a.shape\n        if n * m == 0:\n            return False\n        assert n == len(b)\n        objective = np.zeros((1, m))\n        res = linprog(c=objective, A_ub=a, b_ub=b, bounds=(None, None))  # ,options={'tol':0.000001})\n        # Linprog's status values\n        # 0 : Optimization proceeding nominally.\n        # 1 : Iteration limit reached.\n        # 2 : Problem appears to be infeasible.\n        # 3 : Problem appears to be unbounded.\n        # 4 : Numerical difficulties encountered.\n        if res[\"status\"] == 2:\n            return True\n        elif res[\"status\"] in {0, 3}:\n            return False\n        raise ValueError(\"Cannot decide emptiness\")\n\n    @staticmethod\n    def _get_kaykobad_context(  # noqa: WPS231\n        term: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n    ) -&gt; Tuple[List[PolyhedralTerm], List[Var]]:\n        forbidden_vars = list_intersection(vars_to_elim, term.vars)\n        other_forbibben_vars = list_diff(vars_to_elim, term.vars)\n        n = len(forbidden_vars)\n        matrix_row_terms = []  # type: List[PolyhedralTerm]\n        partial_sums = [float(0) for i in range(n)]\n        transform_coeff = -1\n        if refine:\n            transform_coeff = 1\n        matrix_contains_others = False\n        # We add a row to the matrix in each iteration\n        for i, i_var in enumerate(forbidden_vars):\n            row_found = False\n            logging.debug(\"Iterating for variable %s\", i_var)\n            for context_term in list_diff(context.terms, matrix_row_terms):\n                logging.debug(\"Analyzing context term %s\", context_term)\n                if context_term == term:\n                    continue\n                term_is_invalid = False\n                # make sure the term does not include other forbidden variables\n                for var in other_forbibben_vars:  # noqa: VNE002\n                    if context_term.get_coefficient(var) != 0:\n                        term_is_invalid = True\n                        logging.debug(\"Term contains other forbidden vars\")\n                        break\n                if term_is_invalid:\n                    continue\n                # 1. Verify Kaykobad pair: sign of nonzero matrix terms\n                for var in forbidden_vars:  # noqa: VNE002\n                    if context_term.get_coefficient(var) != 0:\n                        if transform_coeff * context_term.get_sign(var) != term.get_sign(var):\n                            term_is_invalid = True\n                            # logging.debug(\"Failed first matrix-vector verification\")\n                            break\n                # 2. Verify Kaykobad pair: matrix diagonal terms\n                if context_term.get_coefficient(i_var) == 0 or term_is_invalid:\n                    # logging.debug(\"Failed second matrix-vector verification\")\n                    continue\n                # 3. Verify Kaykobad pair: relation between matrix and vector\n                residuals = [float(0) for i in range(n)]\n                for j, j_var in enumerate(forbidden_vars):\n                    # logging.debug(\"Verifying third condition on variable %s\", j_var)\n                    if j != i:\n                        residuals[j] = (\n                            term.get_sign(j_var)\n                            * context_term.get_coefficient(j_var)\n                            * term.get_coefficient(i_var)\n                            / context_term.get_coefficient(i_var)\n                        )\n                    if np.abs(term.get_coefficient(j_var)) &lt;= partial_sums[j] + residuals[j]:\n                        # logging.debug(\"q coefficient: %s\", term.get_coefficient(j_var))\n                        # logging.debug(\"RHS: %s\", partial_sums[j] + residuals[j])\n                        term_is_invalid = True\n                        # logging.debug(\"Failed third matrix-vector verification\")\n                        break\n                if not term_is_invalid:\n                    matrix_contains_others = (\n                        matrix_contains_others or len(list_diff(context_term.vars, forbidden_vars)) &gt; 0\n                    )\n                    row_found = True\n                    for j in range(n):\n                        partial_sums[j] += residuals[j]\n                    matrix_row_terms.append(context_term)\n                    break\n            if not row_found:\n                raise ValueError(\"Could not find the {}th row of matrix\".format(i))\n        if (not matrix_contains_others) and len(list_diff(term.vars, vars_to_elim)) == 0:\n            raise ValueError(\"Found context will produce empty transformation\")\n        # logging.debug(\"Matrix row terms %s\", matrix_row_terms)\n        return matrix_row_terms, forbidden_vars\n\n    @staticmethod\n    def _tactic_1(\n        term: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n    ) -&gt; PolyhedralTerm:\n        logging.debug(\"********** Tactic 1\")\n        logging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\n        try:\n            matrix_row_terms, forbidden_vars = PolyhedralTermList._get_kaykobad_context(\n                term, context, vars_to_elim, refine\n            )\n        except ValueError:\n            logging.debug(\"Could not transform %s using Tactic 1\", term)\n            raise ValueError(\"Could not transform term {}\".format(term))\n        matrix_row_terms_tl = PolyhedralTermList(list(matrix_row_terms))\n        sols = PolyhedralTerm.solve_for_variables(matrix_row_terms_tl, list(forbidden_vars))\n        # logging.debug(\"Sols %s\", sols)\n\n        result = term.copy()\n        # logging.debug(\"Result is %s\", result)\n        for var in sols.keys():  # noqa: VNE002\n            result = result.substitute_variable(var, sols[var])\n        logging.debug(\"Term %s transformed to %s\", term, result)\n\n        return result\n\n    @staticmethod\n    def _tactic_2(  # noqa: WPS231\n        term: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n    ) -&gt; PolyhedralTerm:\n        logging.debug(\"************ Tactic 2\")\n        logging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\n        conflict_vars = list_intersection(vars_to_elim, term.vars)\n        new_context_list = []\n        # Extract from context the terms that only contain forbidden vars\n        for context_term in context.terms:\n            if not list_diff(context_term.vars, vars_to_elim):\n                if context_term != term:\n                    new_context_list.append(context_term.copy())\n        logging.debug(\"This is what we kept\")\n        for el in new_context_list:\n            logging.debug(el)\n        if not new_context_list:\n            raise ValueError(\"No term contains only irrelevant variables\")\n        if list_diff(conflict_vars, PolyhedralTermList(new_context_list).vars):\n            raise ValueError(\"Tactic 2 unsuccessful\")\n        # now optimize\n        retval = PolyhedralTermList.termlist_to_polytope(PolyhedralTermList(new_context_list), PolyhedralTermList([]))\n        variables = retval[0]\n        new_context_mat = retval[1]\n        new_context_cons = retval[2]\n        polarity = 1\n        if refine:\n            polarity = -1\n        objective = [polarity * term.get_coefficient(var) for var in variables]\n        logging.debug(new_context_mat)\n        logging.debug(new_context_cons)\n        logging.debug(objective)\n        res = linprog(c=objective, A_ub=new_context_mat, b_ub=new_context_cons, bounds=(None, None))\n        if res[\"status\"] == 3:\n            # unbounded\n            # return term.copy()\n            raise ValueError(\"Tactic 2 did not succeed\")\n        replacement = polarity * res[\"fun\"]\n        # replace the irrelevant variables with new findings in term\n        result = term.copy()\n        for var in vars_to_elim:  # noqa: VNE002\n            result = result.remove_variable(var)\n        result.constant -= replacement\n        # check vacuity\n        if not result.vars:\n            return term.copy()\n        return result\n\n    @staticmethod\n    def _tactic_3(\n        term: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n    ) -&gt; PolyhedralTerm:\n        logging.debug(\"************ Tactic 3\")\n        logging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\n        conflict_vars = list_intersection(vars_to_elim, term.vars)\n        conflict_coeff = {var: term.get_coefficient(var) for var in conflict_vars}\n        new_term = term.copy()\n        for var in conflict_vars:  # noqa: VNE002 variable name 'var' should be clarified\n            new_term = new_term.remove_variable(var)\n        new_term.variables[Var(\"_\")] = 1\n        # modify the context\n        subst_term_vars = {Var(\"_\"): 1.0 / conflict_coeff[conflict_vars[0]]}\n        for var in conflict_vars:  # noqa: VNE002 variable name 'var' should be clarified\n            if var != conflict_vars[0]:\n                subst_term_vars[var] = -conflict_coeff[var] / conflict_coeff[conflict_vars[0]]\n        subst_term = PolyhedralTerm(variables=subst_term_vars, constant=0)\n        new_context = PolyhedralTermList(\n            [el.copy().substitute_variable(conflict_vars[0], subst_term) for el in context.terms]\n        )\n        # now we use tactic 1\n        new_elims = list_diff(list_union(vars_to_elim, [Var(\"_\")]), [conflict_vars[0]])\n        try:\n            result = PolyhedralTermList._tactic_1(new_term, new_context, new_elims, refine)\n        except ValueError as e:  # noqa: WPS329 Found useless `except` case\n            raise e\n        logging.debug(\"************ Leaving Tactic 3\")\n        logging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\n        return result\n\n    @staticmethod\n    def _tactic_4(  # noqa: WPS231\n        term: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool, no_vars: List[Var]\n    ) -&gt; PolyhedralTerm:\n        logging.debug(\"************ Tactic 4\")\n        logging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\n        if not refine:\n            raise ValueError(\"Only refinement is supported\")\n        conflict_vars = list_intersection(vars_to_elim, term.vars)\n        if len(conflict_vars) &gt; 1:\n            raise ValueError(\"Tactic 4 unsuccessful\")\n        var_to_elim = conflict_vars[0]\n        goal_context: List[PolyhedralTerm] = []\n        useful_context: List[PolyhedralTerm] = []\n        polarity = -1\n        if refine:\n            polarity = 1\n        for context_term in context.terms:\n            if list_intersection(context_term.vars, no_vars):\n                continue\n            coeff = context_term.get_coefficient(var_to_elim)\n            if coeff != 0 and polarity * coeff * term.get_coefficient(var_to_elim) &gt; 0:\n                temp_conflict_vars = list_intersection(context_term.vars, vars_to_elim)\n                if len(temp_conflict_vars) == 1:\n                    goal_context.append(context_term.copy())\n                if len(temp_conflict_vars) == 2:\n                    useful_context.append(context_term.copy())\n        if not useful_context and not goal_context:\n            raise ValueError(\"Tactic 4 unsuccessful\")\n        if goal_context:\n            return term.substitute_variable(var_to_elim, goal_context[0].isolate_variable(var_to_elim))\n        ############\n        for useful_term in useful_context:\n            new_context = context.copy()\n            new_context.terms.remove(useful_term)\n            new_term = useful_term.isolate_variable(var_to_elim)\n            new_no_vars = no_vars.copy()\n            new_no_vars.append(var_to_elim)\n            try:\n                return_term = PolyhedralTermList._tactic_4(new_term, new_context, vars_to_elim, refine, new_no_vars)\n            except ValueError:\n                continue\n            return term.substitute_variable(var_to_elim, return_term)\n        raise ValueError(\"Tactic 4 unsuccessful\")\n\n    @staticmethod\n    def _transform_term(\n        term: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n    ) -&gt; PolyhedralTerm:\n        if not list_intersection(term.vars, vars_to_elim):\n            return term\n\n        logging.debug(\"Transforming term: %s\", term)\n        logging.debug(\"Context: %s\", context)\n\n        try:\n            result = PolyhedralTermList._tactic_1(term, context, vars_to_elim, refine)\n        except ValueError:\n            try:  # noqa: WPS505\n                result = PolyhedralTermList._tactic_3(term, context, vars_to_elim, refine)\n            except ValueError:\n                try:  # noqa: WPS505 Found nested `try` block\n                    result = PolyhedralTermList._tactic_2(term, context, vars_to_elim, refine)\n                except ValueError:\n                    try:  # noqa: WPS505 Found nested `try` block\n                        result = PolyhedralTermList._tactic_4(term, context, vars_to_elim, refine, [])\n                    except ValueError:\n                        result = term.copy()\n        return result\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.__init__","title":"<code>__init__(terms=None)</code>","text":"<p>Constructor for PolyhedralTermList.</p> Usage <p>PolyhedralTermList objects are initialized as follows:</p> <pre><code>    term1 = PolyhedralTerm({Var('x'):2, Var('y'):3}, 3)\n    term2 = PolyhedralTerm({Var('x'):-1, Var('y'):2}, 4)\n    pt_list = [term1, term2]\n    termlist = PolyhedralTermList(pt_list)\n</code></pre> <p>Our example represents the constraints \\(\\{2x + 3y \\le 3, -x + 2y \\le 4\\}\\).</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>Optional[List[PolyhedralTerm]]</code> <p>A list of PolyhedralTerm objects.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>incorrect argument type provided.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def __init__(self, terms: Optional[List[PolyhedralTerm]] = None):\n\"\"\"\n    Constructor for PolyhedralTermList.\n\n    Usage:\n        PolyhedralTermList objects are initialized as follows:\n\n        ```\n            term1 = PolyhedralTerm({Var('x'):2, Var('y'):3}, 3)\n            term2 = PolyhedralTerm({Var('x'):-1, Var('y'):2}, 4)\n            pt_list = [term1, term2]\n            termlist = PolyhedralTermList(pt_list)\n        ```\n\n        Our example represents the constraints $\\\\{2x + 3y \\\\le 3, -x + 2y \\\\le 4\\\\}$.\n\n    Args:\n        terms: A list of PolyhedralTerm objects.\n\n    Raises:\n        ValueError: incorrect argument type provided.\n    \"\"\"\n    if terms is None:\n        self.terms = []\n    elif all(isinstance(t, PolyhedralTerm) for t in terms):\n        self.terms = terms.copy()\n    else:\n        raise ValueError(\"PolyhedralTermList constructor argument must be a list of PolyhedralTerms.\")\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.contains_behavior","title":"<code>contains_behavior(behavior)</code>","text":"<p>Tell whether TermList contains the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Dict[Var, numeric]</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraints; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n    Tell whether TermList contains the given behavior.\n\n    Args:\n        behavior:\n            The behavior in question.\n\n    Returns:\n        True if the behavior satisfies the constraints; false otherwise.\n\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\n    excess_vars = list_diff(self.vars, list(behavior.keys()))\n    if excess_vars:\n        raise ValueError(\"The variables %s were not assigned values\" % (excess_vars))\n    retval = True\n    try:\n        self.evaluate(behavior)\n    except ValueError:\n        retval = False\n    return retval\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.elim_vars_by_refining","title":"<code>elim_vars_by_refining(context, vars_to_elim)</code>","text":"<p>Eliminate variables from PolyhedralTermList by refining it in context.</p> Example <p>Suppose the current list of terms is \\(\\{x + y \\le 6\\}\\), the context is \\(\\{y \\le 5\\}\\), and the resulting terms should not contain variable \\(y\\). Then the current TermList could be refined to \\(\\{x \\le 1\\}\\) because \\(x \\le 1 \\;\\land\\; y \\le 5 \\Rightarrow x + y \\le 6\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PolyhedralTermList</code> <p>The TermList providing the context for the refinement.</p> required <code>vars_to_elim</code> <code>list</code> <p>Variables that should not appear in the resulting term.</p> required <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>A list of terms not containing any variables in <code>vars_to_elim</code></p> <code>PolyhedralTermList</code> <p>and which, in the context provided, imply the terms contained in the</p> <code>PolyhedralTermList</code> <p>calling termlist.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Self has empty intersection with its context.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def elim_vars_by_refining(self, context: PolyhedralTermList, vars_to_elim: list) -&gt; PolyhedralTermList:\n\"\"\"\n    Eliminate variables from PolyhedralTermList by refining it in context.\n\n    Example:\n        Suppose the current list of terms is $\\\\{x + y \\\\le 6\\\\}$, the\n        context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n        contain variable $y$. Then the current TermList could be\n        refined to $\\\\{x \\\\le 1\\\\}$ because $x \\\\le 1\n        \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x + y \\\\le 6$.\n\n    Args:\n        context:\n            The TermList providing the context for the refinement.\n        vars_to_elim:\n            Variables that should not appear in the resulting term.\n\n    Returns:\n        A list of terms not containing any variables in `vars_to_elim`\n        and which, in the context provided, imply the terms contained in the\n        calling termlist.\n\n    Raises:\n        ValueError: Self has empty intersection with its context.\n    \"\"\"\n    logging.debug(\"Refining from terms: %s\", self)\n    logging.debug(\"Context: %s\", context)\n    logging.debug(\"Vars to elim: %s\", vars_to_elim)\n    try:\n        termlist = self.simplify(context)\n    except ValueError as e:\n        raise ValueError(\n            \"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n        ) from e\n    try:\n        return termlist._transform(context=context, vars_to_elim=vars_to_elim, refine=True)\n    except ValueError as e:\n        raise ValueError(\n            \"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n            + \"by refining terms \\n{}\\n\".format(self)\n            + \"in context \\n{}\\n\".format(context)\n            + \"was not possible\"\n        ) from e\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.elim_vars_by_relaxing","title":"<code>elim_vars_by_relaxing(context, vars_to_elim)</code>","text":"<p>Eliminate variables from PolyhedralTermList by abstracting it in context.</p> Example <p>Suppose the current list of terms is \\(\\{x - y \\le 6\\}\\), the context is \\(\\{y \\le 5\\}\\), and the resulting terms should not contain variable \\(y\\). Then the current TermList could be relaxed to \\(\\{x \\le 11\\}\\) because \\(x - y \\le 6 \\;\\land\\; y \\le 5 \\Rightarrow x \\le 11\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PolyhedralTermList</code> <p>The TermList providing the context for the transformation.</p> required <code>vars_to_elim</code> <code>list</code> <p>Variables that should not appear in the relaxed terms.</p> required <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>A list of terms not containing any variables in <code>vars_to_elim</code></p> <code>PolyhedralTermList</code> <p>and which, in the context provided, are implied by the terms</p> <code>PolyhedralTermList</code> <p>contained in the calling termlist.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Constraints have empty intersection with context.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def elim_vars_by_relaxing(self, context: PolyhedralTermList, vars_to_elim: list) -&gt; PolyhedralTermList:\n\"\"\"\n    Eliminate variables from PolyhedralTermList by abstracting it in context.\n\n    Example:\n        Suppose the current list of terms is $\\\\{x - y \\\\le 6\\\\}$, the\n        context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n        contain variable $y$. Then the current TermList could be\n        relaxed to $\\\\{x \\\\le 11\\\\}$ because $x - y \\\\le 6\n        \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x \\\\le 11$.\n\n    Args:\n        context:\n            The TermList providing the context for the transformation.\n        vars_to_elim:\n            Variables that should not appear in the relaxed terms.\n\n    Returns:\n        A list of terms not containing any variables in `vars_to_elim`\n        and which, in the context provided, are implied by the terms\n        contained in the calling termlist.\n\n    Raises:\n        ValueError: Constraints have empty intersection with context.\n    \"\"\"\n    logging.debug(\"Relaxing with context\")\n    logging.debug(\"Relaxing from terms %s\", self)\n    logging.debug(\"Context: %s\", context)\n    logging.debug(\"Vars to elim: %s\", vars_to_elim)\n    try:\n        termlist = self.simplify(context)\n    except ValueError as e:\n        raise ValueError(\n            \"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n        ) from e\n    try:\n        termlist = termlist._transform(context=context, vars_to_elim=vars_to_elim, refine=False)\n    except ValueError as e:\n        raise ValueError(\n            \"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n            + \"by relaxing terms \\n{}\\n\".format(self)\n            + \"in context \\n{}\\n\".format(context)\n            + \"was not possible\"\n        ) from e\n    # eliminate terms containing the variables to be eliminated\n    terms_to_elim = termlist.get_terms_with_vars(vars_to_elim)\n    termlist.terms = list_diff(termlist.terms, terms_to_elim.terms)\n    return termlist\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.evaluate","title":"<code>evaluate(var_values)</code>","text":"<p>Replace variables in termlist with given values.</p> <p>Parameters:</p> Name Type Description Default <code>var_values</code> <code>Dict[Var, numeric]</code> <p>The values that variables will take.</p> required <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>A new PolyhedralTermList in which the variables have been</p> <code>PolyhedralTermList</code> <p>substituted with the values provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>constraints are unsatisfiable under these valuation of variables.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def evaluate(self, var_values: Dict[Var, numeric]) -&gt; PolyhedralTermList:  # noqa: WPS231\n\"\"\"\n    Replace variables in termlist with given values.\n\n    Args:\n        var_values:\n            The values that variables will take.\n\n    Returns:\n        A new PolyhedralTermList in which the variables have been\n        substituted with the values provided.\n\n    Raises:\n        ValueError: constraints are unsatisfiable under these valuation of variables.\n    \"\"\"\n    new_list = []\n    for term in self.terms:\n        new_term = term.copy()\n        for var, val in var_values.items():  # noqa: VNE002\n            new_term = new_term.substitute_variable(\n                var=var, subst_with_term=PolyhedralTerm(variables={}, constant=-val)\n            )\n        # we may have eliminated all variables after substitution\n        if not new_term.vars:\n            if new_term.constant &lt; 0:\n                raise ValueError(\"Term %s not satisfied\" % (term))\n            else:\n                continue  # noqa: WPS503\n        new_list.append(new_term)\n    return PolyhedralTermList(new_list)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.is_empty","title":"<code>is_empty()</code>","text":"<p>Tell whether the argument has no satisfying assignments.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if constraints cannot be satisfied.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def is_empty(self) -&gt; bool:\n\"\"\"\n    Tell whether the argument has no satisfying assignments.\n\n    Returns:\n        True if constraints cannot be satisfied.\n    \"\"\"\n    _, self_mat, self_cons, _, _ = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\n        self, PolyhedralTermList([])\n    )\n    logging.debug(\"Polytope is \\n%s\", self_mat)\n    return PolyhedralTermList.is_polytope_empty(self_mat, self_cons)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.is_polytope_empty","title":"<code>is_polytope_empty(a, b)</code>  <code>staticmethod</code>","text":"<p>Say whether a polytope is empty.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>np.ndarray</code> <p>Matrix of H-representation of polytope to verify.</p> required <code>b</code> <code>np.ndarray</code> <p>Vector of H-representation of polytope to verify.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if empty. False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Numerical difficulties encountered.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef is_polytope_empty(a: np.ndarray, b: np.ndarray) -&gt; bool:\n\"\"\"\n    Say whether a polytope is empty.\n\n    Args:\n        a:\n            Matrix of H-representation of polytope to verify.\n        b:\n            Vector of H-representation of polytope to verify.\n\n    Returns:\n        True if empty. False otherwise.\n\n    Raises:\n        ValueError: Numerical difficulties encountered.\n    \"\"\"\n    logging.debug(\"Verifying polytope emptiness: a is %s a.shape is %s, b is %s\", a, a.shape, b)\n    if len(a) == 0:\n        return False\n    n, m = a.shape\n    if n * m == 0:\n        return False\n    assert n == len(b)\n    objective = np.zeros((1, m))\n    res = linprog(c=objective, A_ub=a, b_ub=b, bounds=(None, None))  # ,options={'tol':0.000001})\n    # Linprog's status values\n    # 0 : Optimization proceeding nominally.\n    # 1 : Iteration limit reached.\n    # 2 : Problem appears to be infeasible.\n    # 3 : Problem appears to be unbounded.\n    # 4 : Numerical difficulties encountered.\n    if res[\"status\"] == 2:\n        return True\n    elif res[\"status\"] in {0, 3}:\n        return False\n    raise ValueError(\"Cannot decide emptiness\")\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.lacks_constraints","title":"<code>lacks_constraints()</code>","text":"<p>Tell whether TermList is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if empty. False otherwise.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def lacks_constraints(self) -&gt; bool:\n\"\"\"\n    Tell whether TermList is empty.\n\n    Returns:\n        True if empty. False otherwise.\n    \"\"\"\n    return len(self.terms) == 0\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.optimize","title":"<code>optimize(objective, maximize=True)</code>","text":"<p>Optimizes a linear expression in the feasible region of the termlist.</p> <p>Parameters:</p> Name Type Description Default <code>objective</code> <code>Dict[Var, numeric]</code> <p>The objective to optimize.</p> required <code>maximize</code> <code>bool</code> <p>If true, the routine maximizes; it minimizes otherwise.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[numeric]</code> <p>The optimal value of the objective. If the objective is unbounded, None is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Constraints are likely unfeasible.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def optimize(self, objective: Dict[Var, numeric], maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"\n    Optimizes a linear expression in the feasible region of the termlist.\n\n    Args:\n        objective:\n            The objective to optimize.\n        maximize:\n            If true, the routine maximizes; it minimizes otherwise.\n\n    Returns:\n        The optimal value of the objective. If the objective is unbounded, None is returned.\n\n    Raises:\n        ValueError: Constraints are likely unfeasible.\n    \"\"\"\n    obj = PolyhedralTermList([PolyhedralTerm(variables=objective, constant=0)])\n    _, self_mat, self_cons, obj_mat, _ = PolyhedralTermList.termlist_to_polytope(self, obj)  # noqa: WPS236\n    polarity = 1\n    if maximize:\n        polarity = -1\n    res = linprog(c=polarity * obj_mat[0], A_ub=self_mat, b_ub=self_cons, bounds=(None, None))\n    # Linprog's status values\n    # 0 : Optimization proceeding nominally.\n    # 1 : Iteration limit reached.\n    # 2 : Problem appears to be infeasible.\n    # 3 : Problem appears to be unbounded.\n    # 4 : Numerical difficulties encountered.\n    if res[\"status\"] == 3:\n        return None\n    elif res[\"status\"] == 0:\n        fun_val: float = res[\"fun\"]\n        return polarity * fun_val\n    raise ValueError(\"Constraints are unfeasible\")\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.polytope_to_termlist","title":"<code>polytope_to_termlist(matrix, vector, variables)</code>  <code>staticmethod</code>","text":"<p>Transforms a matrix-vector pair into a PolyhedralTermList.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>np.ndarray</code> <p>The matrix of the pair.</p> required <code>vector</code> <code>np.ndarray</code> <p>The vector of the pair.</p> required <code>variables</code> <code>List[Var]</code> <p>A list indicating the variable which corresponds to each column of the matrix.</p> required <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>The PolyhedralTermList corresponding to the given data.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef polytope_to_termlist(matrix: np.ndarray, vector: np.ndarray, variables: List[Var]) -&gt; PolyhedralTermList:\n\"\"\"\n    Transforms a matrix-vector pair into a PolyhedralTermList.\n\n    Args:\n        matrix:\n            The matrix of the pair.\n        vector:\n            The vector of the pair.\n        variables:\n            A list indicating the variable which corresponds to each column\n            of the matrix.\n\n    Returns:\n        The PolyhedralTermList corresponding to the given data.\n    \"\"\"\n    term_list = []\n    # logging.debug(\"Poly is \" + str(polytope))\n    # logging.debug(\"matrix is %s\", matrix)\n    if len(matrix.shape) &gt; 1:\n        n, m = matrix.shape\n        assert m == len(variables)\n    else:\n        n = matrix.shape[0]\n        m = 0\n    for i in range(n):\n        row = list(matrix[i])\n        const = vector[i]\n        term = PolyhedralTerm.polytope_to_term(row, const, variables)\n        term_list.append(term)\n    return PolyhedralTermList(list(term_list))\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.reduce_polytope","title":"<code>reduce_polytope(a, b, a_help=None, b_help=None)</code>  <code>staticmethod</code>","text":"<p>Eliminate redundant constraints from a given polytope.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>np.ndarray</code> <p>Matrix of H-representation of polytope to reduce.</p> required <code>b</code> <code>np.ndarray</code> <p>Vector of H-representation of polytope to reduce.</p> required <code>a_help</code> <code>Optional[np.ndarray]</code> <p>Matrix of H-representation of context polytope.</p> <code>None</code> <code>b_help</code> <code>Optional[np.ndarray]</code> <p>Vector of H-representation of context polytope.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>The intersection of given polytope with its context is empty.</p> <p>Returns:</p> Name Type Description <code>a_temp</code> <code>np.ndarray</code> <p>Matrix of H-representation of reduced polytope.</p> <code>b_temp</code> <code>np.ndarray</code> <p>Vector of H-representation of reduced polytope.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef reduce_polytope(  # noqa: WPS231\n    a: np.ndarray, b: np.ndarray, a_help: Optional[np.ndarray] = None, b_help: Optional[np.ndarray] = None\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"\n    Eliminate redundant constraints from a given polytope.\n\n    Args:\n        a:\n            Matrix of H-representation of polytope to reduce.\n        b:\n            Vector of H-representation of polytope to reduce.\n        a_help:\n            Matrix of H-representation of context polytope.\n        b_help:\n            Vector of H-representation of context polytope.\n\n    Raises:\n        ValueError: The intersection of given polytope with its context is empty.\n\n    Returns:\n        a_temp: Matrix of H-representation of reduced polytope.\n        b_temp: Vector of H-representation of reduced polytope.\n    \"\"\"\n    if not isinstance(a_help, np.ndarray):\n        a_help = np.array([[]])\n    if not isinstance(b_help, np.ndarray):\n        b_help = np.array([])\n    if len(a.shape) &gt; 1:\n        n, m = a.shape\n    else:\n        n = a.shape[0]\n        m = 0\n    n_h, m_h = a_help.shape\n    helper_present = n_h * m_h &gt; 0\n    assert n == len(b), \"n is {} and b is {}\".format(n, b)\n    if helper_present:\n        assert n_h == len(b_help)\n    else:\n        assert len(b_help) == 0\n    if helper_present and m &gt; 0:\n        assert m_h == m\n    if n == 0:\n        return a, b\n    if n == 1 and not helper_present:\n        return a, b\n\n    i = 0\n    a_temp = np.copy(a)\n    b_temp = np.copy(b)\n    while i &lt; n:\n        objective = a_temp[i, :] * -1\n        b_temp[i] += 1\n        if helper_present:\n            a_opt = np.concatenate((a_temp, a_help), axis=0)\n            b_opt = np.concatenate((b_temp, b_help))\n        else:\n            a_opt = a_temp\n            b_opt = b_temp\n        # Linprog's status values\n        # 0 : Optimization proceeding nominally.\n        # 1 : Iteration limit reached.\n        # 2 : Problem appears to be infeasible.\n        # 3 : Problem appears to be unbounded.\n        # 4 : Numerical difficulties encountered.\n        res = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\n        b_temp[i] -= 1\n        if res[\"status\"] == 3 or (res[\"status\"] == 0 and -res[\"fun\"] &lt;= b_temp[i]):  # noqa: WPS309\n            logging.debug(\"Can remove\")\n            a_temp = np.delete(a_temp, i, 0)\n            b_temp = np.delete(b_temp, i)\n            n -= 1\n        else:\n            i += 1\n        if res[\"status\"] == 2:\n            raise ValueError(\"The constraints are unsatisfiable\")\n\n    return a_temp, b_temp\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.refines","title":"<code>refines(other)</code>","text":"<p>Tells whether the argument is a larger specification.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralTermList</code> <p>TermList against which we are comparing self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>self &lt;= other</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def refines(self, other: PolyhedralTermList) -&gt; bool:\n\"\"\"\n    Tells whether the argument is a larger specification.\n\n    Args:\n        other:\n            TermList against which we are comparing self.\n\n    Returns:\n        self &lt;= other\n    \"\"\"\n    logging.debug(\"Verifying refinement\")\n    logging.debug(\"LH term: %s\", self)\n    logging.debug(\"RH term: %s\", other)\n    if other.lacks_constraints():\n        return True\n    if self.lacks_constraints():\n        return False\n    variables, self_mat, self_cons, ctx_mat, ctx_cons = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\n        self, other\n    )\n    logging.debug(\"Polytope is \\n%s\", self_mat)\n    return PolyhedralTermList.verify_polytope_containment(self_mat, self_cons, ctx_mat, ctx_cons)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.simplify","title":"<code>simplify(context=None)</code>","text":"<p>Remove redundant terms in the PolyhedralTermList using the provided context.</p> Example <p>Suppose the TermList is \\(\\{x - 2y \\le 5, x - y \\le 0\\}\\) and the context is \\(\\{x + y \\le 0\\}\\). Then the TermList could be simplified to \\(\\{x - y \\le 0\\}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Optional[PolyhedralTermList]</code> <p>The TermList providing the context for the simplification.</p> <code>None</code> <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>A new PolyhedralTermList with redundant terms removed using the provided context.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>The intersection of self and context is empty.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def simplify(self, context: Optional[PolyhedralTermList] = None) -&gt; PolyhedralTermList:\n\"\"\"\n    Remove redundant terms in the PolyhedralTermList using the provided context.\n\n    Example:\n        Suppose the TermList is $\\\\{x - 2y \\\\le 5, x - y \\\\le 0\\\\}$ and\n        the context is $\\\\{x + y \\\\le 0\\\\}$. Then the TermList could be\n        simplified to $\\\\{x - y \\\\le 0\\\\}$.\n\n    Args:\n        context:\n            The TermList providing the context for the simplification.\n\n    Returns:\n        A new PolyhedralTermList with redundant terms removed using the provided context.\n\n    Raises:\n        ValueError: The intersection of self and context is empty.\n    \"\"\"\n    logging.debug(\"Starting simplification procedure\")\n    logging.debug(\"Simplifying terms: %s\", self)\n    logging.debug(\"Context: %s\", context)\n    if context:\n        new_self = self - context\n        result = PolyhedralTermList.termlist_to_polytope(new_self, context)\n    else:\n        result = PolyhedralTermList.termlist_to_polytope(self, PolyhedralTermList())\n\n    variables = result[0]\n    self_mat = result[1]\n    self_cons = result[2]\n    ctx_mat = result[3]\n    ctx_cons = result[4]\n    # logging.debug(\"Polytope is \\n%s\", self_mat)\n    try:\n        a_red, b_red = PolyhedralTermList.reduce_polytope(self_mat, self_cons, ctx_mat, ctx_cons)\n    except ValueError as e:\n        raise ValueError(\n            \"The constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n        ) from e\n    logging.debug(\"Reduction: \\n%s\", a_red)\n    simplified = PolyhedralTermList.polytope_to_termlist(a_red, b_red, variables)\n    logging.debug(\"Back to terms: \\n%s\", simplified)\n    return simplified\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.termlist_to_polytope","title":"<code>termlist_to_polytope(terms, context)</code>  <code>staticmethod</code>","text":"<p>Converts a list of terms with its context into matrix-vector pairs.</p> Example <p>Suppose the list of terms is \\(\\{x+y \\le 1, x - y \\le 4\\}\\) and the context is \\(\\{x + 4w \\le 5\\}\\). The routine extracts all variables and generates an order for them, say, \\([x, w, y]\\). Then the routine returns matrix-vector pairs for both the terms TermList and the context. It returns \\(A = \\left( \\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\\\ 1 &amp;0 &amp;-1 \\end{smallmatrix}\\right)\\) and \\(b = \\left( \\begin{smallmatrix} 1 \\\\ 4 \\end{smallmatrix}\\right)\\) for the current TermList and \\(A_{c} = \\left( \\begin{smallmatrix} 1 &amp; 4 &amp; 0 \\end{smallmatrix}\\right)\\) and \\(b_c = \\left( \\begin{smallmatrix} 5 \\end{smallmatrix}\\right)\\) for the context.</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>PolyhedralTermList</code> <p>list of terms to convert to matrix-vector form.</p> required <code>context</code> <code>PolyhedralTermList</code> <p>Context terms to convert to matrix-vector form.</p> required <p>Returns:</p> Type Description <code>List[Var]</code> <p>A tuple <code>variables, A, b, a_h, b_h</code> consisting of the variable</p> <code>np.ndarray</code> <p>order and the matrix-vector pairs for the terms and the context.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef termlist_to_polytope(\n    terms: PolyhedralTermList, context: PolyhedralTermList\n) -&gt; Tuple[List[Var], np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n\"\"\"\n    Converts a list of terms with its context into matrix-vector pairs.\n\n    Example:\n        Suppose the list of terms is $\\\\{x+y \\\\le 1, x - y \\\\le 4\\\\}$\n        and the context is $\\\\{x + 4w \\\\le 5\\\\}$. The routine extracts\n        all variables and generates an order for them, say, $[x, w,\n        y]$. Then the routine returns matrix-vector pairs for both the terms\n        TermList and the context. It returns $A = \\\\left(\n        \\\\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\\\\\\\ 1 &amp;0 &amp;-1\n        \\\\end{smallmatrix}\\\\right)$ and $b = \\\\left(\n        \\\\begin{smallmatrix} 1 \\\\\\\\ 4 \\\\end{smallmatrix}\\\\right)$ for the\n        current TermList and $A_{c} = \\\\left( \\\\begin{smallmatrix} 1 &amp;\n        4 &amp; 0 \\\\end{smallmatrix}\\\\right)$ and $b_c = \\\\left(\n        \\\\begin{smallmatrix} 5 \\\\end{smallmatrix}\\\\right)$ for the context.\n\n    Args:\n        terms:\n            list of terms to convert to matrix-vector form.\n        context:\n            Context terms to convert to matrix-vector form.\n\n    Returns:\n        A tuple `variables, A, b, a_h, b_h` consisting of the variable\n        order and the matrix-vector pairs for the terms and the context.\n    \"\"\"\n    variables = list(list_union(terms.vars, context.vars))\n    a = []\n    b = []\n    for term in terms.terms:\n        pol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\n        a.append(pol)\n        b.append(coeff)\n\n    a_h = []\n    b_h = []\n    for term in context.terms:\n        pol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\n        a_h.append(pol)\n        b_h.append(coeff)\n\n    if len(context.terms) == 0:\n        a_h_ret = np.array([[]])\n    else:\n        a_h_ret = np.array(a_h)\n    # logging.debug(\"a is \\n%s\", a)\n    return variables, np.array(a), np.array(b), a_h_ret, np.array(b_h)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.to_str_list","title":"<code>to_str_list()</code>","text":"<p>Convert termlist into a list of strings.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings corresponding to the terms of the termlist.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def to_str_list(self) -&gt; List[str]:\n\"\"\"\n    Convert termlist into a list of strings.\n\n    Returns:\n        A list of strings corresponding to the terms of the termlist.\n    \"\"\"\n    str_list = []\n    ts = self.terms.copy()\n    while ts:\n        s, rest = serializer.polyhedral_term_list_to_strings(ts)\n        str_list.append(s)\n        ts = rest\n    return str_list\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.verify_polytope_containment","title":"<code>verify_polytope_containment(a_l=None, b_l=None, a_r=None, b_r=None)</code>  <code>staticmethod</code>","text":"<p>Tell whether a polytope is contained in another.</p> <p>Parameters:</p> Name Type Description Default <code>a_l</code> <code>Optional[np.ndarray]</code> <p>Matrix of H-representation of polytope on LHS of inequality.</p> <code>None</code> <code>b_l</code> <code>Optional[np.ndarray]</code> <p>Vector of H-representation of polytope on LHS of inequality.</p> <code>None</code> <code>a_r</code> <code>Optional[np.ndarray]</code> <p>Matrix of H-representation of polytope on RHS of inequality.</p> <code>None</code> <code>b_r</code> <code>Optional[np.ndarray]</code> <p>Vector of H-representation of polytope on RHS of inequality.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if left polytope is contained in right polytope. False otherwise.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef verify_polytope_containment(  # noqa: WPS231\n    a_l: Optional[np.ndarray] = None,\n    b_l: Optional[np.ndarray] = None,\n    a_r: Optional[np.ndarray] = None,\n    b_r: Optional[np.ndarray] = None,\n) -&gt; bool:\n\"\"\"\n    Tell whether a polytope is contained in another.\n\n    Args:\n        a_l:\n            Matrix of H-representation of polytope on LHS of inequality.\n        b_l:\n            Vector of H-representation of polytope on LHS of inequality.\n        a_r:\n            Matrix of H-representation of polytope on RHS of inequality.\n        b_r:\n            Vector of H-representation of polytope on RHS of inequality.\n\n    Returns:\n        True if left polytope is contained in right polytope. False otherwise.\n    \"\"\"\n    if not isinstance(a_l, np.ndarray):\n        a_l = np.array([[]])\n    if not isinstance(a_r, np.ndarray):\n        a_r = np.array([[]])\n    if not isinstance(b_l, np.ndarray):\n        b_l = np.array([])\n    if not isinstance(b_r, np.ndarray):\n        b_r = np.array([])\n    # If the LHS is empty, it is a refinement\n    if PolyhedralTermList.is_polytope_empty(a_l, b_l):\n        return True\n    # If the RHS is empty, but not the LHS, not a refinement\n    if PolyhedralTermList.is_polytope_empty(a_r, b_r):\n        return False\n    # If no side is empty, check whether the RHS terms are included in the\n    # LHS\n    n_l, m_l = a_l.shape\n    n_r, m_r = a_r.shape\n    assert m_l == m_r\n    assert n_l == len(b_l)\n    assert n_r == len(b_r)\n\n    is_refinement = True\n    for i in range(n_r):\n        constraint = a_r[[i], :]\n        objective = constraint * -1\n        b_temp = b_r[i] + 1\n        logging.debug(\"Optimization objective: \\n%s\", objective)\n        logging.debug(\"a_l is \\n%s\", a_l)\n        logging.debug(\"a_r is \\n%s\", a_r)\n        logging.debug(\"b_l is \\n%s\", b_l)\n        logging.debug(\"b_r is \\n%s\", b_r)\n\n        a_opt = np.concatenate((a_l, constraint), axis=0)\n        b_opt = np.concatenate((b_l, np.array([b_temp])))\n\n        res = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\n        b_temp -= 1\n        if res[\"status\"] == 2:\n            is_refinement = False\n            break\n        else:\n            if -res[\"fun\"] &lt;= b_temp:  # noqa: WPS309\n                logging.debug(\"Redundant constraint\")\n            else:\n                is_refinement = False\n                break\n        logging.debug(\"Optimal value: %s\", -res[\"fun\"])\n        logging.debug(\"Results: %s\", res)\n    return is_refinement\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/","title":"Polyhedral contract","text":"<p>Specializes IO contract into contracts with polyhedral assumptions and guarantees.</p>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.NestedPolyhedra","title":"<code>NestedPolyhedra</code>","text":"<p>         Bases: <code>NestedTermList</code></p> <p>A collection of polyhedral termlists interpreted as their disjunction.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>class NestedPolyhedra(NestedTermList):\n\"\"\"A collection of polyhedral termlists interpreted as their disjunction.\"\"\"\n\n    def __init__(  # noqa: WPS612 useless overwritten __init__\n        self, nested_termlist: List[PolyhedralTermList], force_empty_intersection: bool\n    ):\n\"\"\"\n        Class constructor.\n\n        Args:\n            nested_termlist: A list of terms contained by TermList.\n            force_empty_intersection: Raise error if the termlists are not disjoint.\n        \"\"\"\n        super().__init__(nested_termlist, force_empty_intersection)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.NestedPolyhedra.__init__","title":"<code>__init__(nested_termlist, force_empty_intersection)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>nested_termlist</code> <code>List[PolyhedralTermList]</code> <p>A list of terms contained by TermList.</p> required <code>force_empty_intersection</code> <code>bool</code> <p>Raise error if the termlists are not disjoint.</p> required Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>def __init__(  # noqa: WPS612 useless overwritten __init__\n    self, nested_termlist: List[PolyhedralTermList], force_empty_intersection: bool\n):\n\"\"\"\n    Class constructor.\n\n    Args:\n        nested_termlist: A list of terms contained by TermList.\n        force_empty_intersection: Raise error if the termlists are not disjoint.\n    \"\"\"\n    super().__init__(nested_termlist, force_empty_intersection)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.PolyhedralContract","title":"<code>PolyhedralContract</code>","text":"<p>         Bases: <code>IoContract</code></p> <p>IO Contracts with assumptions and guarantees expressed as polyhedral constraints.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>class PolyhedralContract(IoContract):\n\"\"\"IO Contracts with assumptions and guarantees expressed as polyhedral constraints.\"\"\"\n\n    def rename_variables(self, variable_mappings: List[Tuple[str, str]]) -&gt; PolyhedralContract:\n\"\"\"\n        Rename variables in a contract.\n\n        Args:\n            variable_mappings: Variables to be replaced.\n\n        Returns:\n            A contract with `source_var` replaced by `target_var`.\n        \"\"\"\n        new_contract = self.copy()\n        for mapping in variable_mappings:\n            new_contract = new_contract.rename_variable(Var(mapping[0]), Var(mapping[1]))\n        return new_contract\n\n    def to_machine_dict(self) -&gt; ser_contract:\n\"\"\"\n        Map contract into a machine-optimized dictionary.\n\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\n        input_vars = [str(x) for x in self.inputvars]\n        output_vars = [str(x) for x in self.outputvars]\n        assumptions: List[ser_pt] = [\n            {\n                \"constant\": float(term.constant),\n                \"coefficients\": {str(k): float(v) for k, v in term.variables.items()},\n            }\n            for term in self.a.terms\n        ]\n        guarantees: List[ser_pt] = [\n            {\n                \"constant\": float(term.constant),\n                \"coefficients\": {str(k): float(v) for k, v in term.variables.items()},\n            }\n            for term in self.g.terms\n        ]\n\n        return {\n            \"input_vars\": input_vars,\n            \"output_vars\": output_vars,\n            \"assumptions\": assumptions,\n            \"guarantees\": guarantees,\n        }\n\n    def to_dict(self) -&gt; dict:\n\"\"\"\n        Map contract into a user-readable dictionary.\n\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\n        c_temp = {}\n        c_temp[\"input_vars\"] = [str(x) for x in self.inputvars]\n        c_temp[\"output_vars\"] = [str(x) for x in self.outputvars]\n        c_temp[\"assumptions\"] = self.a.to_str_list()\n        c_temp[\"guarantees\"] = self.g.to_str_list()\n        return c_temp\n\n    @staticmethod\n    def from_string(\n        assumptions: List[str],\n        guarantees: List[str],\n        input_vars: List[str],\n        output_vars: List[str],\n    ) -&gt; PolyhedralContract:\n\"\"\"\n        Create contract from several lists of strings.\n\n        Args:\n            assumptions: contract's assumptions.\n            guarantees: contract's guarantees.\n            input_vars: input variables of contract.\n            output_vars: output variables of contract.\n\n        Returns:\n            A polyhedral contract built from the arguments provided.\n        \"\"\"\n        a: List[PolyhedralTerm] = []\n        if assumptions:\n            a = [item for x in assumptions for item in serializer.polyhedral_termlist_from_string(x)]\n\n        g: List[PolyhedralTerm] = []\n        if guarantees:\n            g = [item for x in guarantees for item in serializer.polyhedral_termlist_from_string(x)]\n\n        return PolyhedralContract(\n            input_vars=[Var(x) for x in input_vars],\n            output_vars=[Var(x) for x in output_vars],\n            assumptions=PolyhedralTermList(a),\n            guarantees=PolyhedralTermList(g),\n        )\n\n    @staticmethod\n    def from_dict(contract: dict) -&gt; PolyhedralContract:\n\"\"\"\n        Create contract from a dictionary.\n\n        Args:\n            contract: a dictionary containing the contract's data.\n\n        Returns:\n            A polyhedral contract built from the arguments provided.\n\n        Raises:\n            ValueError: dictionary provided was not well-formed.\n        \"\"\"\n        if not isinstance(contract, dict):\n            raise ValueError(\"A dict type contract is expected.\")\n        for kw in (\"assumptions\", \"guarantees\", \"input_vars\", \"output_vars\"):\n            if kw not in contract:\n                raise ValueError(f\"Passed dictionary does not have key {kw}.\")\n\n        if all(isinstance(x, dict) for x in contract[\"assumptions\"]):\n            a = PolyhedralTermList(\n                [\n                    PolyhedralTerm({Var(k): v for k, v in x[\"coefficients\"].items()}, float(x[\"constant\"]))\n                    for x in contract[\"assumptions\"]\n                ]\n            )\n        else:\n            raise ValueError(\"Assumptions must be a list of dicts.\")\n\n        if all(isinstance(x, dict) for x in contract[\"guarantees\"]):\n            g = PolyhedralTermList(\n                [\n                    PolyhedralTerm({Var(k): v for k, v in x[\"coefficients\"].items()}, float(x[\"constant\"]))\n                    for x in contract[\"guarantees\"]\n                ]\n            )\n        else:\n            raise ValueError(\"Guarantees must be a list of dicts.\")\n\n        return PolyhedralContract(\n            input_vars=[Var(x) for x in contract[\"input_vars\"]],\n            output_vars=[Var(x) for x in contract[\"output_vars\"]],\n            assumptions=a,\n            guarantees=g,\n        )\n\n    def compose(self, other: PolyhedralContract, vars_to_keep: Optional[List[str]] = None) -&gt; PolyhedralContract:\n\"\"\"Compose polyhedral contracts.\n\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n\n        Returns:\n            The abstracted composition of the two contracts.\n        \"\"\"\n        if vars_to_keep is None:\n            vars_to_keep = []\n        return super().compose(other, [Var(x) for x in vars_to_keep])\n\n    def optimize(self, expr: str, maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"Optimize linear objective over the contract.\n\n        Compute the optima of a linear objective over the assumptions and\n        guarantees of the contract.\n\n        Args:\n            expr:\n                linear objective being optimized.\n            maximize:\n                Maximize if True; minimize if False.\n\n        Returns:\n            The optimal value of the objective in the context of the contract.\n        \"\"\"\n        new_expr = expr + \" &lt;= 0\"\n        variables = serializer.polyhedral_termlist_from_string(new_expr)[0].variables\n        constraints: PolyhedralTermList = self.a | self.g\n        return constraints.optimize(objective=variables, maximize=maximize)\n\n    def get_variable_bounds(\n        self, var: str\n    ) -&gt; Tuple[Optional[numeric], Optional[numeric]]:  # noqa: VNE002 variable 'var' should be clarified\n\"\"\"Obtain bounds for a variable in the context of a contract.\n\n        Args:\n            var:\n                variable whose bounds are sought.\n\n        Returns:\n            The minimum and maximum values for the variable in the context of the contract.\n        \"\"\"\n        maximum = self.optimize(var, maximize=True)\n        minimum = self.optimize(var, maximize=False)\n        return minimum, maximum\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.PolyhedralContract.compose","title":"<code>compose(other, vars_to_keep=None)</code>","text":"<p>Compose polyhedral contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralContract</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Optional[List[str]]</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <p>Returns:</p> Type Description <code>PolyhedralContract</code> <p>The abstracted composition of the two contracts.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>def compose(self, other: PolyhedralContract, vars_to_keep: Optional[List[str]] = None) -&gt; PolyhedralContract:\n\"\"\"Compose polyhedral contracts.\n\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n\n    Returns:\n        The abstracted composition of the two contracts.\n    \"\"\"\n    if vars_to_keep is None:\n        vars_to_keep = []\n    return super().compose(other, [Var(x) for x in vars_to_keep])\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.PolyhedralContract.from_dict","title":"<code>from_dict(contract)</code>  <code>staticmethod</code>","text":"<p>Create contract from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>contract</code> <code>dict</code> <p>a dictionary containing the contract's data.</p> required <p>Returns:</p> Type Description <code>PolyhedralContract</code> <p>A polyhedral contract built from the arguments provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>dictionary provided was not well-formed.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>@staticmethod\ndef from_dict(contract: dict) -&gt; PolyhedralContract:\n\"\"\"\n    Create contract from a dictionary.\n\n    Args:\n        contract: a dictionary containing the contract's data.\n\n    Returns:\n        A polyhedral contract built from the arguments provided.\n\n    Raises:\n        ValueError: dictionary provided was not well-formed.\n    \"\"\"\n    if not isinstance(contract, dict):\n        raise ValueError(\"A dict type contract is expected.\")\n    for kw in (\"assumptions\", \"guarantees\", \"input_vars\", \"output_vars\"):\n        if kw not in contract:\n            raise ValueError(f\"Passed dictionary does not have key {kw}.\")\n\n    if all(isinstance(x, dict) for x in contract[\"assumptions\"]):\n        a = PolyhedralTermList(\n            [\n                PolyhedralTerm({Var(k): v for k, v in x[\"coefficients\"].items()}, float(x[\"constant\"]))\n                for x in contract[\"assumptions\"]\n            ]\n        )\n    else:\n        raise ValueError(\"Assumptions must be a list of dicts.\")\n\n    if all(isinstance(x, dict) for x in contract[\"guarantees\"]):\n        g = PolyhedralTermList(\n            [\n                PolyhedralTerm({Var(k): v for k, v in x[\"coefficients\"].items()}, float(x[\"constant\"]))\n                for x in contract[\"guarantees\"]\n            ]\n        )\n    else:\n        raise ValueError(\"Guarantees must be a list of dicts.\")\n\n    return PolyhedralContract(\n        input_vars=[Var(x) for x in contract[\"input_vars\"]],\n        output_vars=[Var(x) for x in contract[\"output_vars\"]],\n        assumptions=a,\n        guarantees=g,\n    )\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.PolyhedralContract.from_string","title":"<code>from_string(assumptions, guarantees, input_vars, output_vars)</code>  <code>staticmethod</code>","text":"<p>Create contract from several lists of strings.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>List[str]</code> <p>contract's assumptions.</p> required <code>guarantees</code> <code>List[str]</code> <p>contract's guarantees.</p> required <code>input_vars</code> <code>List[str]</code> <p>input variables of contract.</p> required <code>output_vars</code> <code>List[str]</code> <p>output variables of contract.</p> required <p>Returns:</p> Type Description <code>PolyhedralContract</code> <p>A polyhedral contract built from the arguments provided.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>@staticmethod\ndef from_string(\n    assumptions: List[str],\n    guarantees: List[str],\n    input_vars: List[str],\n    output_vars: List[str],\n) -&gt; PolyhedralContract:\n\"\"\"\n    Create contract from several lists of strings.\n\n    Args:\n        assumptions: contract's assumptions.\n        guarantees: contract's guarantees.\n        input_vars: input variables of contract.\n        output_vars: output variables of contract.\n\n    Returns:\n        A polyhedral contract built from the arguments provided.\n    \"\"\"\n    a: List[PolyhedralTerm] = []\n    if assumptions:\n        a = [item for x in assumptions for item in serializer.polyhedral_termlist_from_string(x)]\n\n    g: List[PolyhedralTerm] = []\n    if guarantees:\n        g = [item for x in guarantees for item in serializer.polyhedral_termlist_from_string(x)]\n\n    return PolyhedralContract(\n        input_vars=[Var(x) for x in input_vars],\n        output_vars=[Var(x) for x in output_vars],\n        assumptions=PolyhedralTermList(a),\n        guarantees=PolyhedralTermList(g),\n    )\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.PolyhedralContract.get_variable_bounds","title":"<code>get_variable_bounds(var)</code>","text":"<p>Obtain bounds for a variable in the context of a contract.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>variable whose bounds are sought.</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[numeric], Optional[numeric]]</code> <p>The minimum and maximum values for the variable in the context of the contract.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>def get_variable_bounds(\n    self, var: str\n) -&gt; Tuple[Optional[numeric], Optional[numeric]]:  # noqa: VNE002 variable 'var' should be clarified\n\"\"\"Obtain bounds for a variable in the context of a contract.\n\n    Args:\n        var:\n            variable whose bounds are sought.\n\n    Returns:\n        The minimum and maximum values for the variable in the context of the contract.\n    \"\"\"\n    maximum = self.optimize(var, maximize=True)\n    minimum = self.optimize(var, maximize=False)\n    return minimum, maximum\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.PolyhedralContract.optimize","title":"<code>optimize(expr, maximize=True)</code>","text":"<p>Optimize linear objective over the contract.</p> <p>Compute the optima of a linear objective over the assumptions and guarantees of the contract.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>linear objective being optimized.</p> required <code>maximize</code> <code>bool</code> <p>Maximize if True; minimize if False.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[numeric]</code> <p>The optimal value of the objective in the context of the contract.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>def optimize(self, expr: str, maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"Optimize linear objective over the contract.\n\n    Compute the optima of a linear objective over the assumptions and\n    guarantees of the contract.\n\n    Args:\n        expr:\n            linear objective being optimized.\n        maximize:\n            Maximize if True; minimize if False.\n\n    Returns:\n        The optimal value of the objective in the context of the contract.\n    \"\"\"\n    new_expr = expr + \" &lt;= 0\"\n    variables = serializer.polyhedral_termlist_from_string(new_expr)[0].variables\n    constraints: PolyhedralTermList = self.a | self.g\n    return constraints.optimize(objective=variables, maximize=maximize)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.PolyhedralContract.rename_variables","title":"<code>rename_variables(variable_mappings)</code>","text":"<p>Rename variables in a contract.</p> <p>Parameters:</p> Name Type Description Default <code>variable_mappings</code> <code>List[Tuple[str, str]]</code> <p>Variables to be replaced.</p> required <p>Returns:</p> Type Description <code>PolyhedralContract</code> <p>A contract with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>def rename_variables(self, variable_mappings: List[Tuple[str, str]]) -&gt; PolyhedralContract:\n\"\"\"\n    Rename variables in a contract.\n\n    Args:\n        variable_mappings: Variables to be replaced.\n\n    Returns:\n        A contract with `source_var` replaced by `target_var`.\n    \"\"\"\n    new_contract = self.copy()\n    for mapping in variable_mappings:\n        new_contract = new_contract.rename_variable(Var(mapping[0]), Var(mapping[1]))\n    return new_contract\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.PolyhedralContract.to_dict","title":"<code>to_dict()</code>","text":"<p>Map contract into a user-readable dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>def to_dict(self) -&gt; dict:\n\"\"\"\n    Map contract into a user-readable dictionary.\n\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\n    c_temp = {}\n    c_temp[\"input_vars\"] = [str(x) for x in self.inputvars]\n    c_temp[\"output_vars\"] = [str(x) for x in self.outputvars]\n    c_temp[\"assumptions\"] = self.a.to_str_list()\n    c_temp[\"guarantees\"] = self.g.to_str_list()\n    return c_temp\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.PolyhedralContract.to_machine_dict","title":"<code>to_machine_dict()</code>","text":"<p>Map contract into a machine-optimized dictionary.</p> <p>Returns:</p> Type Description <code>ser_contract</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>def to_machine_dict(self) -&gt; ser_contract:\n\"\"\"\n    Map contract into a machine-optimized dictionary.\n\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\n    input_vars = [str(x) for x in self.inputvars]\n    output_vars = [str(x) for x in self.outputvars]\n    assumptions: List[ser_pt] = [\n        {\n            \"constant\": float(term.constant),\n            \"coefficients\": {str(k): float(v) for k, v in term.variables.items()},\n        }\n        for term in self.a.terms\n    ]\n    guarantees: List[ser_pt] = [\n        {\n            \"constant\": float(term.constant),\n            \"coefficients\": {str(k): float(v) for k, v in term.variables.items()},\n        }\n        for term in self.g.terms\n    ]\n\n    return {\n        \"input_vars\": input_vars,\n        \"output_vars\": output_vars,\n        \"assumptions\": assumptions,\n        \"guarantees\": guarantees,\n    }\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.PolyhedralContractCompound","title":"<code>PolyhedralContractCompound</code>","text":"<p>         Bases: <code>IoContractCompound</code></p> <p>Compound IO contract with polyhedral assumptions and guarantees.</p> <p>Attributes:</p> Name Type Description <code>inputvars</code> <p>Variables which are inputs of the implementations of the contract.</p> <code>outputvars</code> <p>Variables which are outputs of the implementations of the contract.</p> <code>a</code> <p>Contract assumptions.</p> <code>g</code> <p>Contract guarantees.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>class PolyhedralContractCompound(IoContractCompound):\n\"\"\"\n    Compound IO contract with polyhedral assumptions and guarantees.\n\n    Attributes:\n        inputvars:\n            Variables which are inputs of the implementations of the contract.\n\n        outputvars:\n            Variables which are outputs of the implementations of the contract.\n\n        a: Contract assumptions.\n\n        g: Contract guarantees.\n    \"\"\"\n\n    @staticmethod\n    def from_string(\n        assumptions: List[list[str]],\n        guarantees: List[list[str]],\n        input_vars: List[str],\n        output_vars: List[str],\n    ) -&gt; PolyhedralContractCompound:\n\"\"\"\n        Create contract from several lists of strings.\n\n        Args:\n            assumptions: contract's assumptions.\n            guarantees: contract's guarantees.\n            input_vars: input variables of contract.\n            output_vars: output variables of contract.\n\n        Returns:\n            A polyhedral contract built from the arguments provided.\n        \"\"\"\n        a: List[PolyhedralTermList] = []\n        if assumptions:\n            for termlist_str in assumptions:\n                a_termlist = [item for x in termlist_str for item in serializer.polyhedral_termlist_from_string(x)]\n                a.append(PolyhedralTermList(a_termlist))\n\n        g: List[PolyhedralTermList] = []\n        if guarantees:\n            for termlist_str in guarantees:\n                g_termlist = [item for x in termlist_str for item in serializer.polyhedral_termlist_from_string(x)]\n                g.append(PolyhedralTermList(g_termlist))\n\n        return PolyhedralContractCompound(\n            input_vars=[Var(x) for x in input_vars],\n            output_vars=[Var(x) for x in output_vars],\n            assumptions=NestedPolyhedra(a, force_empty_intersection=True),\n            guarantees=NestedPolyhedra(g, force_empty_intersection=False),\n        )\n\n    def to_dict(self) -&gt; dict:\n\"\"\"\n        Map contract into a user-readable dictionary.\n\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\n        c_temp = {}\n        c_temp[\"input_vars\"] = [str(x) for x in self.inputvars]\n        c_temp[\"output_vars\"] = [str(x) for x in self.outputvars]\n        c_temp[\"assumptions\"] = [x.to_str_list() for x in self.a.nested_termlist]\n        c_temp[\"guarantees\"] = [x.to_str_list() for x in self.g.nested_termlist]\n        return c_temp\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.PolyhedralContractCompound.from_string","title":"<code>from_string(assumptions, guarantees, input_vars, output_vars)</code>  <code>staticmethod</code>","text":"<p>Create contract from several lists of strings.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>List[list[str]]</code> <p>contract's assumptions.</p> required <code>guarantees</code> <code>List[list[str]]</code> <p>contract's guarantees.</p> required <code>input_vars</code> <code>List[str]</code> <p>input variables of contract.</p> required <code>output_vars</code> <code>List[str]</code> <p>output variables of contract.</p> required <p>Returns:</p> Type Description <code>PolyhedralContractCompound</code> <p>A polyhedral contract built from the arguments provided.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>@staticmethod\ndef from_string(\n    assumptions: List[list[str]],\n    guarantees: List[list[str]],\n    input_vars: List[str],\n    output_vars: List[str],\n) -&gt; PolyhedralContractCompound:\n\"\"\"\n    Create contract from several lists of strings.\n\n    Args:\n        assumptions: contract's assumptions.\n        guarantees: contract's guarantees.\n        input_vars: input variables of contract.\n        output_vars: output variables of contract.\n\n    Returns:\n        A polyhedral contract built from the arguments provided.\n    \"\"\"\n    a: List[PolyhedralTermList] = []\n    if assumptions:\n        for termlist_str in assumptions:\n            a_termlist = [item for x in termlist_str for item in serializer.polyhedral_termlist_from_string(x)]\n            a.append(PolyhedralTermList(a_termlist))\n\n    g: List[PolyhedralTermList] = []\n    if guarantees:\n        for termlist_str in guarantees:\n            g_termlist = [item for x in termlist_str for item in serializer.polyhedral_termlist_from_string(x)]\n            g.append(PolyhedralTermList(g_termlist))\n\n    return PolyhedralContractCompound(\n        input_vars=[Var(x) for x in input_vars],\n        output_vars=[Var(x) for x in output_vars],\n        assumptions=NestedPolyhedra(a, force_empty_intersection=True),\n        guarantees=NestedPolyhedra(g, force_empty_intersection=False),\n    )\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedral_contract/#pacti.terms.polyhedra.polyhedral_contract.PolyhedralContractCompound.to_dict","title":"<code>to_dict()</code>","text":"<p>Map contract into a user-readable dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\terms\\polyhedra\\polyhedral_contract.py</code> <pre><code>def to_dict(self) -&gt; dict:\n\"\"\"\n    Map contract into a user-readable dictionary.\n\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\n    c_temp = {}\n    c_temp[\"input_vars\"] = [str(x) for x in self.inputvars]\n    c_temp[\"output_vars\"] = [str(x) for x in self.outputvars]\n    c_temp[\"assumptions\"] = [x.to_str_list() for x in self.a.nested_termlist]\n    c_temp[\"guarantees\"] = [x.to_str_list() for x in self.g.nested_termlist]\n    return c_temp\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/serializer/","title":"Serializer","text":"<p>Transformations between polyhedral structures and strings.</p>"},{"location":"reference/pacti/terms/polyhedra/serializer/#pacti.terms.polyhedra.serializer.polyhedral_term_list_to_strings","title":"<code>polyhedral_term_list_to_strings(terms)</code>","text":"<p>Convert a list of polyhedral terms into a list of strings, one term at a time.</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>List[PolyhedralTerm]</code> <p>the list of terms.</p> required <p>Returns:</p> Type Description <code>Tuple[str, List[PolyhedralTerm]]</code> <p>String representation of the first constraint and list of items not yet serialized.</p> Source code in <code>pacti\\terms\\polyhedra\\serializer.py</code> <pre><code>def polyhedral_term_list_to_strings(  # noqa: WPS231 too much cognitive complexity\n    terms: List[PolyhedralTerm],\n) -&gt; Tuple[str, List[PolyhedralTerm]]:\n\"\"\"\n    Convert a list of polyhedral terms into a list of strings, one term at a time.\n\n    Args:\n        terms: the list of terms.\n\n    Returns:\n        String representation of the first constraint and list of items not yet serialized.\n    \"\"\"\n    if not terms:\n        return \"\", []\n\n    tp = terms[0]\n\n    ts = terms[1:]\n    for tn in ts:\n        if _are_polyhedral_terms_opposite(tp, tn):\n            # tp has the form: LHS\n            # tn has the form: -(LHS)\n            if _are_numbers_approximatively_equal(tp.constant, -tn.constant):\n                # inverse of rule 4\n                # rewrite as 2 terms given input match: LHS = RHS\n                # pos: LHS &lt;= RHS\n                # neg: -(LHS) &lt;= -(RHS)\n                s = _lhs_str(tp) + \" = \" + _number_to_string(tp.constant)\n                ts.remove(tn)\n                return s, ts\n\n            else:\n                condition = _are_numbers_approximatively_equal(\n                    tp.constant, float(0)\n                ) and _are_numbers_approximatively_equal(tn.constant, float(0))\n                if condition:\n                    # inverse of rule 3\n                    # rewrite as 2 terms given input match: | LHS | = 0\n                    # pos: LHS &lt;= 0\n                    # neg: -(LHS) &lt;= 0\n                    s = \"|\" + _lhs_str(tp) + \"| = 0\"\n                    ts.remove(tn)\n                    return s, ts\n                elif _are_numbers_approximatively_equal(tp.constant, tn.constant):\n                    # inverse of rule 2\n                    # rewrite as 2 terms given input match: | LHS | &lt;= RHS\n                    # pos: LHS &lt;= RHS\n                    # neg: -(LHS) &lt;= RHS\n                    s = \"|\" + _lhs_str(tp) + \"| &lt;= \" + _number_to_string(tp.constant)\n                    ts.remove(tn)\n                    return s, ts\n\n    s = _lhs_str(tp) + \" &lt;= \" + _number_to_string(tp.constant)\n    return s, ts\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/serializer/#pacti.terms.polyhedra.serializer.polyhedral_termlist_from_string","title":"<code>polyhedral_termlist_from_string(str_rep)</code>","text":"<p>Transform a linear expression into a polyhedral termlist.</p> <p>Parameters:</p> Name Type Description Default <code>str_rep</code> <code>str</code> <p>The linear expression passed as a string.</p> required <p>Returns:</p> Type Description <code>List[PolyhedralTerm]</code> <p>A PolyhedralTermList representing the input expression.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>constraint syntax invalid.</p> Source code in <code>pacti\\terms\\polyhedra\\serializer.py</code> <pre><code>def polyhedral_termlist_from_string(str_rep: str) -&gt; List[PolyhedralTerm]:\n\"\"\"\n    Transform a linear expression into a polyhedral termlist.\n\n    Args:\n        str_rep: The linear expression passed as a string.\n\n    Returns:\n        A PolyhedralTermList representing the input expression.\n\n    Raises:\n        ValueError: constraint syntax invalid.\n    \"\"\"\n    m1 = internal_polyhedral_term_canonical_pattern.match(str_rep)\n    m2 = internal_polyhedral_term_absolute_less_than_pattern.match(str_rep)\n    m3 = internal_polyhedral_term_absolute_zero_pattern.match(str_rep)\n    m4 = internal_polyhedral_term_equality_pattern.match(str_rep)\n    if m1:\n        return [_internal_pt_from_canonical_match(m1)]\n\n    elif m2:\n        return _internal_pt_from_absolute_less_than_match(m2)\n\n    elif m3:\n        return _internal_pt_from_absolute_zero_match(m3)\n\n    elif m4:\n        return _internal_pt_from_equality_match(m4)\n\n    raise ValueError(f\"Polyhedral term syntax mismatch: {str_rep}\")\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/serializer/#pacti.terms.polyhedra.serializer.validate_contract_dict","title":"<code>validate_contract_dict(contract, contract_name, machine_representation)</code>","text":"<p>Tell whether a contract dictionary can be read as a polyhedral contract.</p> <p>Parameters:</p> Name Type Description Default <code>contract</code> <code>Dict</code> <p>a dictionary to be analyzed.</p> required <code>contract_name</code> <code>str</code> <p>a name for the contract (used for error reporting).</p> required <code>machine_representation</code> <code>bool</code> <p>the provided dictionary is machine-optimized.</p> required <p>Raises:</p> Type Description <code>ContractFormatError</code> <p>the provided contract is not well-formed.</p> Source code in <code>pacti\\terms\\polyhedra\\serializer.py</code> <pre><code>def validate_contract_dict(  # noqa: WPS231 too much cognitive complexity\n    contract: Dict, contract_name: str, machine_representation: bool\n) -&gt; None:\n\"\"\"\n    Tell whether a contract dictionary can be read as a polyhedral contract.\n\n    Args:\n        contract: a dictionary to be analyzed.\n        contract_name: a name for the contract (used for error reporting).\n        machine_representation: the provided dictionary is machine-optimized.\n\n    Raises:\n        ContractFormatError: the provided contract is not well-formed.\n    \"\"\"\n    if not isinstance(contract, dict):\n        print(contract)\n        raise ContractFormatError(\"Each contract should be a dictionary\")\n    keywords = [\"assumptions\", \"guarantees\", \"input_vars\", \"output_vars\"]\n    str_list_kw = [\"input_vars\", \"output_vars\"]\n    if not machine_representation:\n        str_list_kw += [\"assumptions\", \"guarantees\"]\n    for kw in keywords:\n        if kw not in contract:\n            raise ContractFormatError(f'Keyword \"{kw}\" not found in contract {contract_name}')\n        value = contract[kw]\n        if not isinstance(value, list):\n            raise ContractFormatError(f'The \"{kw}\" in contract {contract_name} should be a list')\n        if kw in str_list_kw:\n            for str_item in value:\n                if not isinstance(str_item, str):\n                    raise ContractFormatError(f\"The {kw} in contract {contract_name} should be defined as strings\")\n        elif machine_representation:\n            for index, clause in enumerate(value):\n                _check_clause(clause, f\"{contract_name}:{kw}{index}\")\n</code></pre>"},{"location":"reference/pacti/utils/","title":"Index","text":""},{"location":"reference/pacti/utils/errors/","title":"Errors","text":"<p>Global error classes.</p>"},{"location":"reference/pacti/utils/errors/#pacti.utils.errors.ContractFormatError","title":"<code>ContractFormatError</code>","text":"<p>         Bases: <code>FileDataFormatError</code></p> <p>Incorrect format</p> Source code in <code>pacti\\utils\\errors.py</code> <pre><code>class ContractFormatError(FileDataFormatError):\n\"\"\"Incorrect format\"\"\"\n</code></pre>"},{"location":"reference/pacti/utils/errors/#pacti.utils.errors.FileDataFormatError","title":"<code>FileDataFormatError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Incorrect format</p> Source code in <code>pacti\\utils\\errors.py</code> <pre><code>class FileDataFormatError(Exception):\n\"\"\"Incorrect format\"\"\"\n</code></pre>"},{"location":"reference/pacti/utils/errors/#pacti.utils.errors.IncompatibleArgsError","title":"<code>IncompatibleArgsError</code>","text":"<p>         Bases: <code>ValueError</code></p> <p>Argument validation errors.</p> Source code in <code>pacti\\utils\\errors.py</code> <pre><code>class IncompatibleArgsError(ValueError):\n\"\"\"Argument validation errors.\"\"\"\n</code></pre>"},{"location":"reference/pacti/utils/fileio/","title":"Fileio","text":"<p>File IO for Pacti.</p>"},{"location":"reference/pacti/utils/fileio/#pacti.utils.fileio.read_contracts_from_file","title":"<code>read_contracts_from_file(file_name)</code>","text":"<p>Read contracts from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Name of file to read.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Unsupported contract attempted to be read.</p> <p>Returns:</p> Type Description <code>Tuple[List[polyhedra.PolyhedralContract], List[str]]</code> <p>A list of contracts with the elements of the file.</p> Source code in <code>pacti\\utils\\fileio.py</code> <pre><code>def read_contracts_from_file(  # noqa: WPS231 too much cognitive complexity\n    file_name: str,\n) -&gt; Tuple[List[polyhedra.PolyhedralContract], List[str]]:\n\"\"\"\n    Read contracts from a file.\n\n    Args:\n        file_name: Name of file to read.\n\n    Raises:\n        ValueError: Unsupported contract attempted to be read.\n\n    Returns:\n        A list of contracts with the elements of the file.\n    \"\"\"\n    if not os.path.isfile(file_name):\n        raise ValueError(f\"The path {file_name} is not a file.\")\n    with open(file_name) as f:\n        file_data = json.load(f)\n    # make sure that data is an array of dictionaries\n    assert isinstance(file_data, list)\n    for entry in file_data:\n        assert isinstance(entry, dict)\n        assert \"type\" in entry\n    # we load each contract according to the type\n    contracts: List[Any] = []\n    names = []\n    for entry in file_data:\n        if entry[\"type\"] == \"PolyhedralContract_machine\":\n            polyhedra.serializer.validate_contract_dict(entry[\"data\"], entry[\"name\"], machine_representation=True)\n            contracts.append(polyhedra.PolyhedralContract.from_dict(entry[\"data\"]))\n            names.append(entry[\"name\"])\n        elif entry[\"type\"] == \"PolyhedralContract\":\n            polyhedra.serializer.validate_contract_dict(entry[\"data\"], entry[\"name\"], machine_representation=False)\n            contracts.append(polyhedra.PolyhedralContract.from_string(**entry[\"data\"]))\n        elif entry[\"type\"] == \"PolyhedralContractCompound\":\n            contracts.append(polyhedra.PolyhedralContractCompound.from_string(**entry[\"data\"]))\n        else:\n            raise ValueError()\n\n    return contracts, names\n</code></pre>"},{"location":"reference/pacti/utils/fileio/#pacti.utils.fileio.write_contracts_to_file","title":"<code>write_contracts_to_file(contracts, names, file_name, machine_representation=False)</code>","text":"<p>Write contracts to a file.</p> <p>Parameters:</p> Name Type Description Default <code>contracts</code> <code>List[polyhedra.PolyhedralContract]</code> <p>The contracts to write.</p> required <code>names</code> <code>List[str]</code> <p>The names of the contracts to keep in written file.</p> required <code>file_name</code> <code>str</code> <p>Name of file to write.</p> required <code>machine_representation</code> <code>bool</code> <p>Whether the resulting file should be optimized for machine processing.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unsupported contract type.</p> Source code in <code>pacti\\utils\\fileio.py</code> <pre><code>def write_contracts_to_file(  # noqa: WPS231 too much cognitive complexity\n    contracts: List[polyhedra.PolyhedralContract],\n    names: List[str],\n    file_name: str,\n    machine_representation: bool = False,\n) -&gt; None:\n\"\"\"\n    Write contracts to a file.\n\n    Args:\n        contracts: The contracts to write.\n        names: The names of the contracts to keep in written file.\n        file_name: Name of file to write.\n        machine_representation: Whether the resulting file should be optimized for machine processing.\n\n    Raises:\n        ValueError: Unsupported contract type.\n    \"\"\"\n    data = []\n    assert len(contracts) == len(names)\n    for i, c in enumerate(contracts):\n        entry: Dict[str, Any] = {}\n        if isinstance(c, polyhedra.PolyhedralContract):\n            entry[\"name\"] = names[i]\n            if machine_representation:\n                entry[\"type\"] = \"PolyhedralContract_machine\"\n                entry[\"data\"] = c.to_machine_dict()\n\n            else:\n                entry[\"type\"] = \"PolyhedralContract\"\n                entry[\"data\"] = c.to_dict()\n        elif isinstance(c, polyhedra.PolyhedralContractCompound):\n            entry[\"name\"] = names[i]\n            if machine_representation:\n                raise ValueError(\"Unsupported representation\")\n            entry[\"type\"] = \"PolyhedralContractCompound\"\n            entry[\"data\"] = c.to_dict()\n\n        else:\n            raise ValueError(\"Unsupported argument type\")\n        data.append(entry)\n\n    with open(file_name, \"w\") as f:\n        f.write(json.dumps(data, indent=2))\n</code></pre>"},{"location":"reference/pacti/utils/lists/","title":"Lists","text":"<p>Some list operations.</p>"},{"location":"reference/pacti/utils/lists/#pacti.utils.lists.list_diff","title":"<code>list_diff(list1, list2)</code>","text":"<p>Compute difference between lists.</p> <p>Parameters:</p> Name Type Description Default <code>list1</code> <code>List[Any]</code> <p>First argument.</p> required <code>list2</code> <code>List[Any]</code> <p>Second argument.</p> required <p>Returns:</p> Type Description <code>List[Any]</code> <p>A list containing the elements of the first argument which do not belong to the second.</p> Source code in <code>pacti\\utils\\lists.py</code> <pre><code>def list_diff(list1: List[Any], list2: List[Any]) -&gt; List[Any]:\n\"\"\"\n    Compute difference between lists.\n\n    Args:\n        list1: First argument.\n        list2: Second argument.\n\n    Returns:\n        A list containing the elements of the first argument which do not belong to the second.\n    \"\"\"\n    return [el for el in list1 if (el not in list2)]\n</code></pre>"},{"location":"reference/pacti/utils/lists/#pacti.utils.lists.list_intersection","title":"<code>list_intersection(list1, list2)</code>","text":"<p>Intersect two lists.</p> <p>Parameters:</p> Name Type Description Default <code>list1</code> <code>List[Any]</code> <p>First argument.</p> required <code>list2</code> <code>List[Any]</code> <p>Second argument.</p> required <p>Returns:</p> Type Description <code>List[Any]</code> <p>A list containing the intersection of both lists.</p> Source code in <code>pacti\\utils\\lists.py</code> <pre><code>def list_intersection(list1: List[Any], list2: List[Any]) -&gt; List[Any]:\n\"\"\"\n    Intersect two lists.\n\n    Args:\n        list1: First argument.\n        list2: Second argument.\n\n    Returns:\n        A list containing the intersection of both lists.\n    \"\"\"\n    return [el for el in list1 if el in list2]\n</code></pre>"},{"location":"reference/pacti/utils/lists/#pacti.utils.lists.list_union","title":"<code>list_union(list1, list2)</code>","text":"<p>Compute the union of two lists.</p> <p>Parameters:</p> Name Type Description Default <code>list1</code> <code>List[Any]</code> <p>First argument.</p> required <code>list2</code> <code>List[Any]</code> <p>Second argument.</p> required <p>Returns:</p> Type Description <code>List[Any]</code> <p>A list containing the elements that at least one list contains.</p> Source code in <code>pacti\\utils\\lists.py</code> <pre><code>def list_union(list1: List[Any], list2: List[Any]) -&gt; List[Any]:\n\"\"\"\n    Compute the union of two lists.\n\n    Args:\n        list1: First argument.\n        list2: Second argument.\n\n    Returns:\n        A list containing the elements that at least one list contains.\n    \"\"\"\n    return list1 + [el for el in list2 if (el not in list1)]\n</code></pre>"},{"location":"reference/pacti/utils/lists/#pacti.utils.lists.lists_equal","title":"<code>lists_equal(list1, list2)</code>","text":"<p>Tells whether two lists have the same elements.</p> <p>Parameters:</p> Name Type Description Default <code>list1</code> <code>List[Any]</code> <p>First argument.</p> required <code>list2</code> <code>List[Any]</code> <p>Second argument.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the lists are equal element-wise.</p> Source code in <code>pacti\\utils\\lists.py</code> <pre><code>def lists_equal(list1: List[Any], list2: List[Any]) -&gt; bool:\n\"\"\"\n    Tells whether two lists have the same elements.\n\n    Args:\n        list1: First argument.\n        list2: Second argument.\n\n    Returns:\n        True if the lists are equal element-wise.\n    \"\"\"\n    return (len(list_diff(list1, list2)) == 0) and (len(list_diff(list2, list1)) == 0)\n</code></pre>"}]}