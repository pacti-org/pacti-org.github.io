{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"Getting Started Installing Pacti <p>Pacti is an open-source Python package for carrying out compositional system analysis and design. Pacti represents components in a system using assume-guarantee specifications, or contracts. Pacti's capabilities, among others, include the following:</p> <ul> <li>Obtaining sensible system specifications from the specifications of the constituent subsystems.</li> <li>Computing specifications of subsystems that need to be added to a design in order to meet an objective.</li> <li>Diagnosing incompatibilities when interconnecting components.</li> </ul> <p>For questions about Pacti and to interact with the community, please go to the organization's GitHub Discussions page. Pacti's developers can be reached at info@pacti.org.</p> <p>The Pacti project can be acknowledged by citing</p> <p>Inigo Incer, Apurva Badithela, Josefine Graebener, Piergiuseppe Mallozzi, Ayush Pandey, Nicolas Rouquette, Sheng-Jung Yu, Albert Benveniste, Benoit Caillaud, Richard M. Murray, Alberto Sangiovanni-Vincentelli, and Sanjit A. Seshia.  \"Pacti: Assume-Guarantee Contracts for Efficient Compositional Analysis and Design.\" ACM Transactions on Cyber-Physical Systems 9, no. 1 (2025): 1-35.</p>"},{"location":"Polyhedral/","title":"PolyhedralTerms","text":"<p>Support for linear inequality constraints, i.e., polyhedra.</p> <p>Module provides support for linear inequalities as constraints, i.e., the constraints are of the form \\(\\sum_{i} a_i x_i \\le c\\), where the \\(x_i\\) are variables and the \\(a_i\\) and \\(c\\) are constants.</p>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm","title":"<code>PolyhedralTerm</code>","text":"<p>               Bases: <code>Term</code></p> <p>Polyhedral terms are linear inequalities over a list of variables.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>class PolyhedralTerm(Term):\n\"\"\"Polyhedral terms are linear inequalities over a list of variables.\"\"\"\n# Constructor: get (i) a dictionary whose keys are variables and whose\n# values are the coefficients of those variables in the term, and (b) a\n# constant. The term is assumed to be in the form \\Sigma_i a_i v_i +\n# constant &lt;= 0\ndef __init__(self, variables: Dict[Var, numeric], constant: numeric):\n\"\"\"\n        Constructor for PolyhedralTerm.\n        Usage:\n            Polyhedral terms are initialized as follows:\n            ```\n                variables = {Var('x'):2, Var('y'):3}\n                constant = 3\n                term = PolyhedralTerm(variables, constant)\n            ```\n            `variables` is a dictionary whose keys are `Var` instances,\n            and `constant` is a number. Thus, our example represents the\n            expression $2x + 3y \\\\le 3$.\n        Args:\n            variables: A dictionary mapping Var keys to numeric values.\n            constant: A numeric value on the right of the inequality.\n        Raises:\n            ValueError: Unsupported argument type.\n        \"\"\"\nvariable_dict = {}\nfor key, value in variables.items():\nif value != 0:\nif isinstance(key, str):\nraise ValueError(\"Unsupported argument type\")\nelse:\nvariable_dict[key] = float(value)\nself.variables = variable_dict\nself.constant = float(constant)\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError()\nmatch = self.variables.keys() == other.variables.keys()\nif match:\nfor k, v in self.variables.items():\nmatch = match and np.equal(v, other.variables[k])\nreturn match and np.equal(self.constant, other.constant)\ndef __str__(self) -&gt; str:\nvarlist = list(self.variables.items())\nvarlist.sort(key=lambda x: str(x[0]))\nres = \" + \".join([str(coeff) + \"*\" + var.name for var, coeff in varlist])\nres += \" &lt;= \" + str(self.constant)\nreturn res\ndef __hash__(self) -&gt; int:\nreturn hash(str(self))\ndef __repr__(self) -&gt; str:\nreturn \"&lt;Term {0}&gt;\".format(self)\ndef __add__(self, other: object) -&gt; PolyhedralTerm:\nif not isinstance(other, type(self)):\nraise ValueError()\nvarlist = list_union(self.vars, other.vars)\nvariables = {}\nfor var in varlist:  # noqa: VNE002\nvariables[var] = self.get_coefficient(var) + other.get_coefficient(var)\nreturn PolyhedralTerm(variables, self.constant + other.constant)\ndef copy(self) -&gt; PolyhedralTerm:\n\"\"\"\n        Generates copy of polyhedral term.\n        Returns:\n            Copy of term.\n        \"\"\"\nreturn PolyhedralTerm(self.variables, self.constant)\ndef rename_variable(self, source_var: Var, target_var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n        Rename a variable in a term.\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n        Returns:\n            A term with `source_var` replaced by `target_var`.\n        \"\"\"\nnew_term = self.copy()\nif source_var in self.vars:\nif target_var not in self.vars:\nnew_term.variables[target_var] = 0\nnew_term.variables[target_var] += new_term.variables[source_var]\nnew_term = new_term.remove_variable(source_var)\nreturn new_term\n@property\ndef vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"\n        Variables appearing in term with a nonzero coefficient.\n        Example:\n            For the term $ax + by \\\\le c$ with variables $x$ and\n            $y$, this function returns the list $\\\\{x, y\\\\}$ if\n            $a$ and $b$ are nonzero.\n        Returns:\n            List of variables referenced in term.\n        \"\"\"\nvarlist = self.variables.keys()\nreturn list(varlist)\ndef contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n        Tell whether term contains a given variable.\n        Args:\n            var_to_seek: The variable that we are seeking in the current term.\n        Returns:\n            `True` if the syntax of the term refers to the given variable;\n                `False` otherwise.\n        \"\"\"\nreturn var_to_seek in self.vars\ndef get_coefficient(self, var: Var) -&gt; numeric:  # noqa: VNE002\n\"\"\"\n        Output the coefficient multiplying the given variable in the term.\n        Args:\n            var: The variable whose coefficient we are seeking.\n        Returns:\n            The coefficient corresponding to variable in the term.\n        \"\"\"\nif self.contains_var(var):\nreturn self.variables[var]\nreturn 0\ndef get_polarity(self, var: Var, polarity: bool = True) -&gt; bool:  # noqa: VNE002\n\"\"\"\n        Check if variable matches given polarity\n        The polarity of a variable in a term is defined as the polarity of the\n        coefficient that multiplies it in a term, e.g., the variables $x$\n        and $y$ in the term $-2x + y \\\\le 3$ have negative and\n        positive polarities respectively.\n        Args:\n            var: The variable whose polarity in the term we are seeking.\n            polarity: The polarity that we are comparing against the variable's polarity.\n        Returns:\n            `True` if the variable's polarity matches `polarity` and\n                `False` otherwise. If the variable's coefficient in the term\n                is zero, return `True`.\n        \"\"\"\nif polarity:\nreturn self.variables[var] &gt;= 0\nreturn self.variables[var] &lt;= 0\ndef get_sign(self, var: Var) -&gt; int:  # noqa: VNE002\n\"\"\"\n        Get the sign of the variable in term.\n        The sign of a variable in a term is defined as the sign of the\n        coefficient that multiplies it in a term, e.g., the variables $x$\n        and $y$ in the term $-2x + y \\\\le 3$ have $-1$ and\n        $+1$ polarities respectively. $0$ has $+1$ sign.\n        Args:\n            var: The variable whose polarity in the term we are seeking.\n        Returns:\n            The sign of the variable in the term.\n        \"\"\"\nif self.get_polarity(var=var, polarity=True):\nreturn 1\nreturn -1\ndef get_matching_vars(self, variable_polarity: Dict[Var, bool]) -&gt; List[Var]:\n\"\"\"\n        Get list of variables whose polarities match the polarities requested.\n        Example:\n        ```\n            x = Var('x')\n            y = Var('y')\n            z = Var('z')\n            variables = {x:-2, y:3}\n            constant  = 4\n            term = PolyhedralTerm(variables, constant)\n            polarities = {y:True}\n            term.get_matching_vars(polarities)\n        ```\n        The last call returns `{y, z}` because the variable y matches the\n        requested polarity in the term, and the variable z has a zero\n        coefficient.\n        Args:\n            variable_polarity: A dictionary mapping Var instances to Boolean\n                values indicating the polarity of the given variable.\n        Returns:\n            If all variables in the term match the polarities specified in the\n                argument, the routine returns the matching variables.  Otherwise,\n                it returns an empty list.\n        \"\"\"\nvariable_list = []\nfor var in variable_polarity.keys():  # noqa: VNE002\nif self.contains_var(var):\nif (self.get_polarity(var=var, polarity=True) == variable_polarity[var]) or (  # noqa: WPS337\nself.get_coefficient(var) == 0\n):\nvariable_list.append(var)\nelse:\nvariable_list = []\nbreak\nreturn variable_list\ndef remove_variable(self, var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n        Eliminates a variable from a term.\n        Args:\n            var: variable to be eliminated.\n        Returns:\n            A new term with the variable eliminated.\n        \"\"\"\nif self.contains_var(var):\nthat = self.copy()\nthat.variables.pop(var)\nreturn that\nreturn self.copy()\ndef multiply(self, factor: numeric) -&gt; PolyhedralTerm:\n\"\"\"Multiplies a term by a constant factor.\n        For example, multiplying the term $2x + 3y \\\\le 4$ by the factor 2\n        yields $4x + 6y \\\\le 8$.\n        Args:\n            factor: element by which the term is multiplied.\n        Returns:\n            A new term which is the result of the given term multiplied by\n            `factor`.\n        \"\"\"\nvariables = {key: factor * val for key, val in self.variables.items()}\nreturn PolyhedralTerm(variables, factor * self.constant)\ndef substitute_variable(self, var: Var, subst_with_term: PolyhedralTerm) -&gt; PolyhedralTerm:  # noqa: VNE002\n\"\"\"\n        Substitutes a specified variable in a term with a given term.\n        Example:\n            In the term $2x - y \\\\le 6$, substituting y by the term\n            $x + z \\\\le 5$ yields $x - z \\\\le 1$. Observe that the\n            substituting term is understood as an equality.\n        Args:\n            var: The term variable to be substituted.\n            subst_with_term: The term used to replace var.\n        Returns:\n            A new term in which the variable is substituted with the given term\n                understood as an equality.\n        \"\"\"\nif self.contains_var(var):\nlogging.debug(f\"Substituting var {var} in term {self} with {subst_with_term}\")\nterm = subst_with_term.multiply(self.get_coefficient(var))\nthat = self.remove_variable(var)\nlogging.debug(that)\nreturn that + term\nreturn self.copy()\ndef isolate_variable(self, var_to_isolate: Var) -&gt; PolyhedralTerm:\n\"\"\"\n        Isolate a variable in a term.\n        Example:\n            In the term $-2x + y \\\\le 6$ understood as equality, isolating the\n            variable $x$ yields $x = 0.5 y - 3$, which in PolyhedralTerm\n            notation we express as $0.5 y &lt;= -3$.\n        Args:\n            var_to_isolate: The variable to be isolated.\n        Returns:\n            A new term which corresponds to the isolation of the indicated\n                variable.\n        Raises:\n            ValueError: the indicated variable is not contained in the term.\n        \"\"\"\nif var_to_isolate not in self.vars:\nraise ValueError(\"Variable %s is not a term variable\" % (var_to_isolate))\nreturn PolyhedralTerm(\nvariables={\nk: -v / self.get_coefficient(var_to_isolate) for k, v in self.variables.items() if k != var_to_isolate\n},\nconstant=-self.constant / self.get_coefficient(var_to_isolate),\n)\n@staticmethod\ndef to_symbolic(term: PolyhedralTerm) -&gt; Any:\n\"\"\"\n        Translates the variable terms of a PolyhedralTerm into a sympy expression.\n        Example:\n            The code\n            ```\n                x = Var('x') y = Var('y') variables = {x:-2, y:3} constant  = 4\n                term = PolyhedralTerm(variables, constant) expression =\n                PolyhedralTerm.to_symbolic(term)\n            ```\n            yields the expression $-2x + 3y - 4$.\n        Args:\n            term:\n                The term whose coefficients and variables are to be translated\n                to sympy's data structure.\n        Returns:\n            Sympy expression corresponding to PolyhedralTerm.\n        \"\"\"\nex = -term.constant\nfor var in term.vars:  # noqa: VNE002\nsv = sympy.symbols(var.name)\nex += sv * term.get_coefficient(var)\nreturn ex\n@staticmethod\ndef to_term(expression: sympy.core.expr.Expr) -&gt; PolyhedralTerm:\n\"\"\"\n        Translates a sympy expression into a PolyhedralTerm.\n        Example:\n            The expression $2x + 3y - 1$ is translated into\n            `PolyhedralTerm(variables={x:2, y:3}, constant=1)`.\n        Args:\n            expression: The symbolic expression to be translated.\n        Returns:\n            PolyhedralTerm corresponding to sympy expression.\n        \"\"\"\nexpression_coefficients: dict = expression.as_coefficients_dict()\nlogging.debug(expression_coefficients)\nkeys = list(expression_coefficients.keys())\nvariable_dict = {}\nconstant = 0\nfor key in keys:\nlogging.debug(type(key))\nif isinstance(key, (str, sympy.core.symbol.Symbol)):\nvar = Var(str(key))  # noqa: VNE002\nvariable_dict[var] = expression_coefficients[key]\nelse:\nconstant = constant - expression_coefficients[key] * key\nreturn PolyhedralTerm(variable_dict, constant)\n@staticmethod\ndef term_to_polytope(term: PolyhedralTerm, variable_list: List[Var]) -&gt; Tuple[List[numeric], numeric]:\n\"\"\"\n        Transform a term into a vector according to the given order.\n        Example:\n            The term $3x + 5y -2z \\\\le 7$ with `variable_list = [y,\n            x, w, z]` yields the tuple `[5, 3, 0, -2], 7`.\n        Args:\n            term: The term to be transformed.\n            variable_list:\n                A list of variables indicating the order of appearance of\n                variable coefficients.\n        Returns:\n            A tuple consisting of (i) the ordered list of coefficients and (ii)\n                the term's constant.\n        \"\"\"\ncoeffs = []\nfor var in variable_list:  # noqa: VNE002\ncoeffs.append(term.get_coefficient(var))\nreturn coeffs, term.constant\n@staticmethod\ndef polytope_to_term(poly: List[numeric], const: numeric, variables: List[Var]) -&gt; PolyhedralTerm:\n\"\"\"\n        Transform a list of coefficients and variables into a PolyhedralTerm.\n        Args:\n            poly: An ordered list of coefficients.\n            const: The term's coefficient.\n            variables: The variables corresponding to the list of coefficients.\n        Returns:\n            A PolyhedralTerm corresponding to the provided data.\n        \"\"\"\nassert len(poly) == len(variables)\nvariable_dict = {}\nfor i, var in enumerate(variables):  # noqa: VNE002\nvariable_dict[var] = poly[i]\nreturn PolyhedralTerm(variable_dict, const)\n@staticmethod\ndef solve_for_variables(context: PolyhedralTermList, vars_to_elim: List[Var]) -&gt; dict:\n\"\"\"\n        Interpret termlist as equality and solve system of equations.\n        Args:\n            context:\n                The list of terms to be solved. Each term will be interpreted as\n                an equality.\n            vars_to_elim:\n                The list of variables whose solutions will be sought.\n        Assumptions: the number of equations matches the number of vars_to_elim\n        contained in the terms.\n        Returns:\n            A dictionary mapping variables to their solutions. The solutions are\n                expressed as PolyhedralTerm instances.\n        \"\"\"\nlogging.debug(\"GetVals: %s Vars: %s\", context, vars_to_elim)\nvars_to_solve = list_intersection(context.vars, vars_to_elim)\nassert len(context.terms) == len(vars_to_solve)\nexprs = [PolyhedralTerm.to_symbolic(term) for term in context.terms]\nlogging.debug(\"Solving %s\", exprs)\nvars_to_solve_symb = [sympy.symbols(var.name) for var in vars_to_solve]\nsols = sympy.solve(exprs, *vars_to_solve_symb)\nlogging.debug(sols)\nif len(sols) &gt; 0:\nreturn {Var(str(key)): PolyhedralTerm.to_term(sols[key]) for key in sols.keys()}\nreturn {}\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.vars","title":"<code>vars</code>  <code>property</code>","text":"<p>Variables appearing in term with a nonzero coefficient.</p> Example <p>For the term \\(ax + by \\le c\\) with variables \\(x\\) and \\(y\\), this function returns the list \\(\\{x, y\\}\\) if \\(a\\) and \\(b\\) are nonzero.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>List of variables referenced in term.</p>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.__init__","title":"<code>__init__(variables, constant)</code>","text":"<p>Constructor for PolyhedralTerm.</p> Usage <p>Polyhedral terms are initialized as follows:</p> <pre><code>    variables = {Var('x'):2, Var('y'):3}\n    constant = 3\n    term = PolyhedralTerm(variables, constant)\n</code></pre> <p><code>variables</code> is a dictionary whose keys are <code>Var</code> instances, and <code>constant</code> is a number. Thus, our example represents the expression \\(2x + 3y \\le 3\\).</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>Dict[Var, numeric]</code> <p>A dictionary mapping Var keys to numeric values.</p> required <code>constant</code> <code>numeric</code> <p>A numeric value on the right of the inequality.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Unsupported argument type.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def __init__(self, variables: Dict[Var, numeric], constant: numeric):\n\"\"\"\n    Constructor for PolyhedralTerm.\n    Usage:\n        Polyhedral terms are initialized as follows:\n        ```\n            variables = {Var('x'):2, Var('y'):3}\n            constant = 3\n            term = PolyhedralTerm(variables, constant)\n        ```\n        `variables` is a dictionary whose keys are `Var` instances,\n        and `constant` is a number. Thus, our example represents the\n        expression $2x + 3y \\\\le 3$.\n    Args:\n        variables: A dictionary mapping Var keys to numeric values.\n        constant: A numeric value on the right of the inequality.\n    Raises:\n        ValueError: Unsupported argument type.\n    \"\"\"\nvariable_dict = {}\nfor key, value in variables.items():\nif value != 0:\nif isinstance(key, str):\nraise ValueError(\"Unsupported argument type\")\nelse:\nvariable_dict[key] = float(value)\nself.variables = variable_dict\nself.constant = float(constant)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.contains_var","title":"<code>contains_var(var_to_seek)</code>","text":"<p>Tell whether term contains a given variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_to_seek</code> <code>Var</code> <p>The variable that we are seeking in the current term.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the syntax of the term refers to the given variable; <code>False</code> otherwise.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n    Tell whether term contains a given variable.\n    Args:\n        var_to_seek: The variable that we are seeking in the current term.\n    Returns:\n        `True` if the syntax of the term refers to the given variable;\n            `False` otherwise.\n    \"\"\"\nreturn var_to_seek in self.vars\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.copy","title":"<code>copy()</code>","text":"<p>Generates copy of polyhedral term.</p> <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>Copy of term.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def copy(self) -&gt; PolyhedralTerm:\n\"\"\"\n    Generates copy of polyhedral term.\n    Returns:\n        Copy of term.\n    \"\"\"\nreturn PolyhedralTerm(self.variables, self.constant)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_coefficient","title":"<code>get_coefficient(var)</code>","text":"<p>Output the coefficient multiplying the given variable in the term.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The variable whose coefficient we are seeking.</p> required <p>Returns:</p> Type Description <code>numeric</code> <p>The coefficient corresponding to variable in the term.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_coefficient(self, var: Var) -&gt; numeric:  # noqa: VNE002\n\"\"\"\n    Output the coefficient multiplying the given variable in the term.\n    Args:\n        var: The variable whose coefficient we are seeking.\n    Returns:\n        The coefficient corresponding to variable in the term.\n    \"\"\"\nif self.contains_var(var):\nreturn self.variables[var]\nreturn 0\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_matching_vars","title":"<code>get_matching_vars(variable_polarity)</code>","text":"<p>Get list of variables whose polarities match the polarities requested.</p> <p>Example:</p> <pre><code>    x = Var('x')\n    y = Var('y')\n    z = Var('z')\n    variables = {x:-2, y:3}\n    constant  = 4\n    term = PolyhedralTerm(variables, constant)\n    polarities = {y:True}\n    term.get_matching_vars(polarities)\n</code></pre> <p>The last call returns <code>{y, z}</code> because the variable y matches the requested polarity in the term, and the variable z has a zero coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>variable_polarity</code> <code>Dict[Var, bool]</code> <p>A dictionary mapping Var instances to Boolean values indicating the polarity of the given variable.</p> required <p>Returns:</p> Type Description <code>List[Var]</code> <p>If all variables in the term match the polarities specified in the argument, the routine returns the matching variables.  Otherwise, it returns an empty list.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_matching_vars(self, variable_polarity: Dict[Var, bool]) -&gt; List[Var]:\n\"\"\"\n    Get list of variables whose polarities match the polarities requested.\n    Example:\n    ```\n        x = Var('x')\n        y = Var('y')\n        z = Var('z')\n        variables = {x:-2, y:3}\n        constant  = 4\n        term = PolyhedralTerm(variables, constant)\n        polarities = {y:True}\n        term.get_matching_vars(polarities)\n    ```\n    The last call returns `{y, z}` because the variable y matches the\n    requested polarity in the term, and the variable z has a zero\n    coefficient.\n    Args:\n        variable_polarity: A dictionary mapping Var instances to Boolean\n            values indicating the polarity of the given variable.\n    Returns:\n        If all variables in the term match the polarities specified in the\n            argument, the routine returns the matching variables.  Otherwise,\n            it returns an empty list.\n    \"\"\"\nvariable_list = []\nfor var in variable_polarity.keys():  # noqa: VNE002\nif self.contains_var(var):\nif (self.get_polarity(var=var, polarity=True) == variable_polarity[var]) or (  # noqa: WPS337\nself.get_coefficient(var) == 0\n):\nvariable_list.append(var)\nelse:\nvariable_list = []\nbreak\nreturn variable_list\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_polarity","title":"<code>get_polarity(var, polarity=True)</code>","text":"<p>Check if variable matches given polarity</p> <p>The polarity of a variable in a term is defined as the polarity of the coefficient that multiplies it in a term, e.g., the variables \\(x\\) and \\(y\\) in the term \\(-2x + y \\le 3\\) have negative and positive polarities respectively.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The variable whose polarity in the term we are seeking.</p> required <code>polarity</code> <code>bool</code> <p>The polarity that we are comparing against the variable's polarity.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the variable's polarity matches <code>polarity</code> and <code>False</code> otherwise. If the variable's coefficient in the term is zero, return <code>True</code>.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_polarity(self, var: Var, polarity: bool = True) -&gt; bool:  # noqa: VNE002\n\"\"\"\n    Check if variable matches given polarity\n    The polarity of a variable in a term is defined as the polarity of the\n    coefficient that multiplies it in a term, e.g., the variables $x$\n    and $y$ in the term $-2x + y \\\\le 3$ have negative and\n    positive polarities respectively.\n    Args:\n        var: The variable whose polarity in the term we are seeking.\n        polarity: The polarity that we are comparing against the variable's polarity.\n    Returns:\n        `True` if the variable's polarity matches `polarity` and\n            `False` otherwise. If the variable's coefficient in the term\n            is zero, return `True`.\n    \"\"\"\nif polarity:\nreturn self.variables[var] &gt;= 0\nreturn self.variables[var] &lt;= 0\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_sign","title":"<code>get_sign(var)</code>","text":"<p>Get the sign of the variable in term.</p> <p>The sign of a variable in a term is defined as the sign of the coefficient that multiplies it in a term, e.g., the variables \\(x\\) and \\(y\\) in the term \\(-2x + y \\le 3\\) have \\(-1\\) and \\(+1\\) polarities respectively. \\(0\\) has \\(+1\\) sign.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The variable whose polarity in the term we are seeking.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sign of the variable in the term.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_sign(self, var: Var) -&gt; int:  # noqa: VNE002\n\"\"\"\n    Get the sign of the variable in term.\n    The sign of a variable in a term is defined as the sign of the\n    coefficient that multiplies it in a term, e.g., the variables $x$\n    and $y$ in the term $-2x + y \\\\le 3$ have $-1$ and\n    $+1$ polarities respectively. $0$ has $+1$ sign.\n    Args:\n        var: The variable whose polarity in the term we are seeking.\n    Returns:\n        The sign of the variable in the term.\n    \"\"\"\nif self.get_polarity(var=var, polarity=True):\nreturn 1\nreturn -1\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.isolate_variable","title":"<code>isolate_variable(var_to_isolate)</code>","text":"<p>Isolate a variable in a term.</p> Example <p>In the term \\(-2x + y \\le 6\\) understood as equality, isolating the variable \\(x\\) yields \\(x = 0.5 y - 3\\), which in PolyhedralTerm notation we express as \\(0.5 y &lt;= -3\\).</p> <p>Parameters:</p> Name Type Description Default <code>var_to_isolate</code> <code>Var</code> <p>The variable to be isolated.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term which corresponds to the isolation of the indicated variable.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>the indicated variable is not contained in the term.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def isolate_variable(self, var_to_isolate: Var) -&gt; PolyhedralTerm:\n\"\"\"\n    Isolate a variable in a term.\n    Example:\n        In the term $-2x + y \\\\le 6$ understood as equality, isolating the\n        variable $x$ yields $x = 0.5 y - 3$, which in PolyhedralTerm\n        notation we express as $0.5 y &lt;= -3$.\n    Args:\n        var_to_isolate: The variable to be isolated.\n    Returns:\n        A new term which corresponds to the isolation of the indicated\n            variable.\n    Raises:\n        ValueError: the indicated variable is not contained in the term.\n    \"\"\"\nif var_to_isolate not in self.vars:\nraise ValueError(\"Variable %s is not a term variable\" % (var_to_isolate))\nreturn PolyhedralTerm(\nvariables={\nk: -v / self.get_coefficient(var_to_isolate) for k, v in self.variables.items() if k != var_to_isolate\n},\nconstant=-self.constant / self.get_coefficient(var_to_isolate),\n)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.multiply","title":"<code>multiply(factor)</code>","text":"<p>Multiplies a term by a constant factor.</p> <p>For example, multiplying the term \\(2x + 3y \\le 4\\) by the factor 2 yields \\(4x + 6y \\le 8\\).</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>numeric</code> <p>element by which the term is multiplied.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term which is the result of the given term multiplied by</p> <code>PolyhedralTerm</code> <p><code>factor</code>.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def multiply(self, factor: numeric) -&gt; PolyhedralTerm:\n\"\"\"Multiplies a term by a constant factor.\n    For example, multiplying the term $2x + 3y \\\\le 4$ by the factor 2\n    yields $4x + 6y \\\\le 8$.\n    Args:\n        factor: element by which the term is multiplied.\n    Returns:\n        A new term which is the result of the given term multiplied by\n        `factor`.\n    \"\"\"\nvariables = {key: factor * val for key, val in self.variables.items()}\nreturn PolyhedralTerm(variables, factor * self.constant)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.polytope_to_term","title":"<code>polytope_to_term(poly, const, variables)</code>  <code>staticmethod</code>","text":"<p>Transform a list of coefficients and variables into a PolyhedralTerm.</p> <p>Parameters:</p> Name Type Description Default <code>poly</code> <code>List[numeric]</code> <p>An ordered list of coefficients.</p> required <code>const</code> <code>numeric</code> <p>The term's coefficient.</p> required <code>variables</code> <code>List[Var]</code> <p>The variables corresponding to the list of coefficients.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A PolyhedralTerm corresponding to the provided data.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef polytope_to_term(poly: List[numeric], const: numeric, variables: List[Var]) -&gt; PolyhedralTerm:\n\"\"\"\n    Transform a list of coefficients and variables into a PolyhedralTerm.\n    Args:\n        poly: An ordered list of coefficients.\n        const: The term's coefficient.\n        variables: The variables corresponding to the list of coefficients.\n    Returns:\n        A PolyhedralTerm corresponding to the provided data.\n    \"\"\"\nassert len(poly) == len(variables)\nvariable_dict = {}\nfor i, var in enumerate(variables):  # noqa: VNE002\nvariable_dict[var] = poly[i]\nreturn PolyhedralTerm(variable_dict, const)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.remove_variable","title":"<code>remove_variable(var)</code>","text":"<p>Eliminates a variable from a term.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>variable to be eliminated.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term with the variable eliminated.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def remove_variable(self, var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n    Eliminates a variable from a term.\n    Args:\n        var: variable to be eliminated.\n    Returns:\n        A new term with the variable eliminated.\n    \"\"\"\nif self.contains_var(var):\nthat = self.copy()\nthat.variables.pop(var)\nreturn that\nreturn self.copy()\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a term.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A term with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def rename_variable(self, source_var: Var, target_var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n    Rename a variable in a term.\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n    Returns:\n        A term with `source_var` replaced by `target_var`.\n    \"\"\"\nnew_term = self.copy()\nif source_var in self.vars:\nif target_var not in self.vars:\nnew_term.variables[target_var] = 0\nnew_term.variables[target_var] += new_term.variables[source_var]\nnew_term = new_term.remove_variable(source_var)\nreturn new_term\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.solve_for_variables","title":"<code>solve_for_variables(context, vars_to_elim)</code>  <code>staticmethod</code>","text":"<p>Interpret termlist as equality and solve system of equations.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PolyhedralTermList</code> <p>The list of terms to be solved. Each term will be interpreted as an equality.</p> required <code>vars_to_elim</code> <code>List[Var]</code> <p>The list of variables whose solutions will be sought.</p> required <p>Assumptions: the number of equations matches the number of vars_to_elim contained in the terms.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary mapping variables to their solutions. The solutions are expressed as PolyhedralTerm instances.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef solve_for_variables(context: PolyhedralTermList, vars_to_elim: List[Var]) -&gt; dict:\n\"\"\"\n    Interpret termlist as equality and solve system of equations.\n    Args:\n        context:\n            The list of terms to be solved. Each term will be interpreted as\n            an equality.\n        vars_to_elim:\n            The list of variables whose solutions will be sought.\n    Assumptions: the number of equations matches the number of vars_to_elim\n    contained in the terms.\n    Returns:\n        A dictionary mapping variables to their solutions. The solutions are\n            expressed as PolyhedralTerm instances.\n    \"\"\"\nlogging.debug(\"GetVals: %s Vars: %s\", context, vars_to_elim)\nvars_to_solve = list_intersection(context.vars, vars_to_elim)\nassert len(context.terms) == len(vars_to_solve)\nexprs = [PolyhedralTerm.to_symbolic(term) for term in context.terms]\nlogging.debug(\"Solving %s\", exprs)\nvars_to_solve_symb = [sympy.symbols(var.name) for var in vars_to_solve]\nsols = sympy.solve(exprs, *vars_to_solve_symb)\nlogging.debug(sols)\nif len(sols) &gt; 0:\nreturn {Var(str(key)): PolyhedralTerm.to_term(sols[key]) for key in sols.keys()}\nreturn {}\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.substitute_variable","title":"<code>substitute_variable(var, subst_with_term)</code>","text":"<p>Substitutes a specified variable in a term with a given term.</p> Example <p>In the term \\(2x - y \\le 6\\), substituting y by the term \\(x + z \\le 5\\) yields \\(x - z \\le 1\\). Observe that the substituting term is understood as an equality.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The term variable to be substituted.</p> required <code>subst_with_term</code> <code>PolyhedralTerm</code> <p>The term used to replace var.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term in which the variable is substituted with the given term understood as an equality.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def substitute_variable(self, var: Var, subst_with_term: PolyhedralTerm) -&gt; PolyhedralTerm:  # noqa: VNE002\n\"\"\"\n    Substitutes a specified variable in a term with a given term.\n    Example:\n        In the term $2x - y \\\\le 6$, substituting y by the term\n        $x + z \\\\le 5$ yields $x - z \\\\le 1$. Observe that the\n        substituting term is understood as an equality.\n    Args:\n        var: The term variable to be substituted.\n        subst_with_term: The term used to replace var.\n    Returns:\n        A new term in which the variable is substituted with the given term\n            understood as an equality.\n    \"\"\"\nif self.contains_var(var):\nlogging.debug(f\"Substituting var {var} in term {self} with {subst_with_term}\")\nterm = subst_with_term.multiply(self.get_coefficient(var))\nthat = self.remove_variable(var)\nlogging.debug(that)\nreturn that + term\nreturn self.copy()\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.term_to_polytope","title":"<code>term_to_polytope(term, variable_list)</code>  <code>staticmethod</code>","text":"<p>Transform a term into a vector according to the given order.</p> Example <p>The term \\(3x + 5y -2z \\le 7\\) with <code>variable_list = [y, x, w, z]</code> yields the tuple <code>[5, 3, 0, -2], 7</code>.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>PolyhedralTerm</code> <p>The term to be transformed.</p> required <code>variable_list</code> <code>List[Var]</code> <p>A list of variables indicating the order of appearance of variable coefficients.</p> required <p>Returns:</p> Type Description <code>Tuple[List[numeric], numeric]</code> <p>A tuple consisting of (i) the ordered list of coefficients and (ii) the term's constant.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef term_to_polytope(term: PolyhedralTerm, variable_list: List[Var]) -&gt; Tuple[List[numeric], numeric]:\n\"\"\"\n    Transform a term into a vector according to the given order.\n    Example:\n        The term $3x + 5y -2z \\\\le 7$ with `variable_list = [y,\n        x, w, z]` yields the tuple `[5, 3, 0, -2], 7`.\n    Args:\n        term: The term to be transformed.\n        variable_list:\n            A list of variables indicating the order of appearance of\n            variable coefficients.\n    Returns:\n        A tuple consisting of (i) the ordered list of coefficients and (ii)\n            the term's constant.\n    \"\"\"\ncoeffs = []\nfor var in variable_list:  # noqa: VNE002\ncoeffs.append(term.get_coefficient(var))\nreturn coeffs, term.constant\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.to_symbolic","title":"<code>to_symbolic(term)</code>  <code>staticmethod</code>","text":"<p>Translates the variable terms of a PolyhedralTerm into a sympy expression.</p> Example <p>The code</p> <pre><code>    x = Var('x') y = Var('y') variables = {x:-2, y:3} constant  = 4\n    term = PolyhedralTerm(variables, constant) expression =\n    PolyhedralTerm.to_symbolic(term)\n</code></pre> <p>yields the expression \\(-2x + 3y - 4\\).</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>PolyhedralTerm</code> <p>The term whose coefficients and variables are to be translated to sympy's data structure.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Sympy expression corresponding to PolyhedralTerm.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef to_symbolic(term: PolyhedralTerm) -&gt; Any:\n\"\"\"\n    Translates the variable terms of a PolyhedralTerm into a sympy expression.\n    Example:\n        The code\n        ```\n            x = Var('x') y = Var('y') variables = {x:-2, y:3} constant  = 4\n            term = PolyhedralTerm(variables, constant) expression =\n            PolyhedralTerm.to_symbolic(term)\n        ```\n        yields the expression $-2x + 3y - 4$.\n    Args:\n        term:\n            The term whose coefficients and variables are to be translated\n            to sympy's data structure.\n    Returns:\n        Sympy expression corresponding to PolyhedralTerm.\n    \"\"\"\nex = -term.constant\nfor var in term.vars:  # noqa: VNE002\nsv = sympy.symbols(var.name)\nex += sv * term.get_coefficient(var)\nreturn ex\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.to_term","title":"<code>to_term(expression)</code>  <code>staticmethod</code>","text":"<p>Translates a sympy expression into a PolyhedralTerm.</p> Example <p>The expression \\(2x + 3y - 1\\) is translated into <code>PolyhedralTerm(variables={x:2, y:3}, constant=1)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>Expr</code> <p>The symbolic expression to be translated.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>PolyhedralTerm corresponding to sympy expression.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef to_term(expression: sympy.core.expr.Expr) -&gt; PolyhedralTerm:\n\"\"\"\n    Translates a sympy expression into a PolyhedralTerm.\n    Example:\n        The expression $2x + 3y - 1$ is translated into\n        `PolyhedralTerm(variables={x:2, y:3}, constant=1)`.\n    Args:\n        expression: The symbolic expression to be translated.\n    Returns:\n        PolyhedralTerm corresponding to sympy expression.\n    \"\"\"\nexpression_coefficients: dict = expression.as_coefficients_dict()\nlogging.debug(expression_coefficients)\nkeys = list(expression_coefficients.keys())\nvariable_dict = {}\nconstant = 0\nfor key in keys:\nlogging.debug(type(key))\nif isinstance(key, (str, sympy.core.symbol.Symbol)):\nvar = Var(str(key))  # noqa: VNE002\nvariable_dict[var] = expression_coefficients[key]\nelse:\nconstant = constant - expression_coefficients[key] * key\nreturn PolyhedralTerm(variable_dict, constant)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList","title":"<code>PolyhedralTermList</code>","text":"<p>               Bases: <code>TermList</code></p> <p>A TermList of PolyhedralTerm instances.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>class PolyhedralTermList(TermList):  # noqa: WPS338\n\"\"\"A TermList of PolyhedralTerm instances.\"\"\"\ndef __init__(self, terms: Optional[List[PolyhedralTerm]] = None):\n\"\"\"\n        Constructor for PolyhedralTermList.\n        Usage:\n            PolyhedralTermList objects are initialized as follows:\n            ```\n                term1 = PolyhedralTerm({Var('x'):2, Var('y'):3}, 3)\n                term2 = PolyhedralTerm({Var('x'):-1, Var('y'):2}, 4)\n                pt_list = [term1, term2]\n                termlist = PolyhedralTermList(pt_list)\n            ```\n            Our example represents the constraints $\\\\{2x + 3y \\\\le 3, -x + 2y \\\\le 4\\\\}$.\n        Args:\n            terms: A list of PolyhedralTerm objects.\n        Raises:\n            ValueError: incorrect argument type provided.\n        \"\"\"\nif terms is None:\nself.terms = []\nelif all(isinstance(t, PolyhedralTerm) for t in terms):\nself.terms = terms.copy()\nelse:\nraise ValueError(\"PolyhedralTermList constructor argument must be a list of PolyhedralTerms.\")\ndef __str__(self) -&gt; str:\nres = \"[\\n  \"\nres += \"\\n  \".join(self.to_str_list())\nres += \"\\n]\"\nreturn res\ndef __hash__(self) -&gt; int:\nreturn hash(tuple(self.terms))\ndef to_str_list(self) -&gt; List[str]:\n\"\"\"\n        Convert termlist into a list of strings.\n        Returns:\n            A list of strings corresponding to the terms of the termlist.\n        \"\"\"\nstr_list = []\nts = self.terms.copy()\nwhile ts:\ns, rest = serializer.polyhedral_term_list_to_strings(ts)\nstr_list.append(s)\nts = rest\nreturn str_list\ndef evaluate(self, var_values: Dict[Var, numeric]) -&gt; PolyhedralTermList:  # noqa: WPS231\n\"\"\"\n        Replace variables in termlist with given values.\n        Args:\n            var_values:\n                The values that variables will take.\n        Returns:\n            A new PolyhedralTermList in which the variables have been\n                substituted with the values provided.\n        Raises:\n            ValueError: constraints are unsatisfiable under these valuation of variables.\n        \"\"\"\nnew_list = []\nfor term in self.terms:\nnew_term = term.copy()\nfor var, val in var_values.items():  # noqa: VNE002\nnew_term = new_term.substitute_variable(\nvar=var, subst_with_term=PolyhedralTerm(variables={}, constant=-val)\n)\n# we may have eliminated all variables after substitution\nif not new_term.vars:\nif new_term.constant &lt; 0:\nraise ValueError(\"Term %s not satisfied\" % (term))\nelse:\ncontinue  # noqa: WPS503\nnew_list.append(new_term)\nreturn PolyhedralTermList(new_list)\ndef contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n        Tell whether TermList contains the given behavior.\n        Args:\n            behavior:\n                The behavior in question.\n        Returns:\n            True if the behavior satisfies the constraints; false otherwise.\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\nexcess_vars = list_diff(self.vars, list(behavior.keys()))\nif excess_vars:\nraise ValueError(\"The variables %s were not assigned values\" % (excess_vars))\nretval = True\ntry:\nself.evaluate(behavior)\nexcept ValueError:\nretval = False\nreturn retval\ndef elim_vars_by_refining(\nself,\ncontext: PolyhedralTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralTermList, TacticStatistics]:\n\"\"\"\n        Eliminate variables from PolyhedralTermList by refining it in context.\n        Example:\n            Suppose the current list of terms is $\\\\{x + y \\\\le 6\\\\}$, the\n            context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n            contain variable $y$. Then the current TermList could be\n            refined to $\\\\{x \\\\le 1\\\\}$ because $x \\\\le 1\n            \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x + y \\\\le 6$.\n        Args:\n            context:\n                The TermList providing the context for the refinement.\n            vars_to_elim:\n                Variables that should not appear in the resulting term.\n            simplify:\n                Whether to perform simplifications.\n            tactics_order:\n                Optionally, the order of tactics to invoke during transformation.\n        Returns:\n            A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n                and which, in the context provided, imply the terms contained in the\n                calling termlist; and (b) the list of tuples, for each processed term, of\n                the tactic used, time spend, and tactic invocation count.\n        Raises:\n            ValueError: Self has empty intersection with its context.\n        \"\"\"\nlogging.debug(\"Refining from terms: %s\", self)\nlogging.debug(\"Context: %s\", context)\nlogging.debug(\"Vars to elim: %s\", vars_to_elim)\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif simplify:\ntry:\ntermlist = self.simplify(context)\nexcept ValueError as e:\nraise ValueError(\n\"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n) from e\nelse:\ntermlist = self\ntry:\nreturn termlist._transform(\ncontext=context, vars_to_elim=vars_to_elim, refine=True, simplify=simplify, tactics_order=tactics_order\n)\nexcept ValueError as e:\nraise ValueError(\n\"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n+ \"by refining terms \\n{}\\n\".format(self)\n+ \"in context \\n{}\\n\".format(context)\n+ \"was not possible\"\n) from e\ndef lacks_constraints(self) -&gt; bool:\n\"\"\"\n        Tell whether TermList is empty.\n        Returns:\n            True if empty. False otherwise.\n        \"\"\"\nreturn len(self.terms) == 0\ndef elim_vars_by_relaxing(\nself,\ncontext: PolyhedralTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralTermList, TacticStatistics]:\n\"\"\"\n        Eliminate variables from PolyhedralTermList by abstracting it in context.\n        Example:\n            Suppose the current list of terms is $\\\\{x - y \\\\le 6\\\\}$, the\n            context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n            contain variable $y$. Then the current TermList could be\n            relaxed to $\\\\{x \\\\le 11\\\\}$ because $x - y \\\\le 6\n            \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x \\\\le 11$.\n        Args:\n            context:\n                The TermList providing the context for the transformation.\n            vars_to_elim:\n                Variables that should not appear in the relaxed terms.\n            simplify:\n                Whether to perform simplifications.\n            tactics_order:\n                Optionally, the order of tactics to invoke during transformation.\n        Returns:\n            A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n                and which, in the context provided, are implied by the terms\n                contained in the calling termlist; and (b) the list of tuples, for each\n                processed term, of the tactic used, time spend, and tactic invocation count.\n        Raises:\n            ValueError: Constraints have empty intersection with context.\n        \"\"\"\nlogging.debug(\"Relaxing with context\")\nlogging.debug(\"Relaxing from terms %s\", self)\nlogging.debug(\"Context: %s\", context)\nlogging.debug(\"Vars to elim: %s\", vars_to_elim)\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif simplify:\ntry:\ntermlist = self.simplify(context)\nexcept ValueError as e:\nraise ValueError(\n\"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n) from e\nelse:\ntermlist = self.copy()\ntry:\n(termlist, tactics_data) = termlist._transform(\ncontext=context, vars_to_elim=vars_to_elim, refine=False, simplify=simplify, tactics_order=tactics_order\n)\nexcept ValueError as e:\nraise ValueError(\n\"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n+ \"by relaxing terms \\n{}\\n\".format(self)\n+ \"in context \\n{}\\n\".format(context)\n+ \"was not possible\"\n) from e\n# eliminate terms containing the variables to be eliminated\nterms_to_elim = termlist.get_terms_with_vars(vars_to_elim)\ntermlist.terms = list_diff(termlist.terms, terms_to_elim.terms)\nreturn termlist, tactics_data\ndef simplify(self, context: Optional[PolyhedralTermList] = None) -&gt; PolyhedralTermList:\n\"\"\"\n        Remove redundant terms in the PolyhedralTermList using the provided context.\n        Example:\n            Suppose the TermList is $\\\\{x - 2y \\\\le 5, x - y \\\\le 0\\\\}$ and\n            the context is $\\\\{x + y \\\\le 0\\\\}$. Then the TermList could be\n            simplified to $\\\\{x - y \\\\le 0\\\\}$.\n        Args:\n            context:\n                The TermList providing the context for the simplification.\n        Returns:\n            A new PolyhedralTermList with redundant terms removed using the provided context.\n        Raises:\n            ValueError: The intersection of self and context is empty.\n        \"\"\"\nlogging.debug(\"Starting simplification procedure\")\nlogging.debug(\"Simplifying terms: %s\", self)\nlogging.debug(\"Context: %s\", context)\nif context:\nnew_self = self - context\nresult = PolyhedralTermList.termlist_to_polytope(new_self, context)\nelse:\nresult = PolyhedralTermList.termlist_to_polytope(self, PolyhedralTermList())\nvariables = result[0]\nself_mat = result[1]\nself_cons = result[2]\nctx_mat = result[3]\nctx_cons = result[4]\n# logging.debug(\"Polytope is \\n%s\", self_mat)\ntry:\na_red, b_red = PolyhedralTermList.reduce_polytope(self_mat, self_cons, ctx_mat, ctx_cons)\nexcept ValueError as e:\nraise ValueError(\n\"The constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n) from e\nlogging.debug(\"Reduction: \\n%s\", a_red)\nsimplified = PolyhedralTermList.polytope_to_termlist(a_red, b_red, variables)\nlogging.debug(\"Back to terms: \\n%s\", simplified)\nreturn simplified\ndef refines(self, other: PolyhedralTermList) -&gt; bool:\n\"\"\"\n        Tells whether the argument is a larger specification.\n        Args:\n            other:\n                TermList against which we are comparing self.\n        Returns:\n            self &lt;= other\n        \"\"\"\nlogging.debug(\"Verifying refinement\")\nlogging.debug(\"LH term: %s\", self)\nlogging.debug(\"RH term: %s\", other)\nif other.lacks_constraints():\nreturn True\nif self.lacks_constraints():\nreturn False\nvariables, self_mat, self_cons, ctx_mat, ctx_cons = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\nself, other\n)\nlogging.debug(\"Polytope is \\n%s\", self_mat)\nreturn PolyhedralTermList.verify_polytope_containment(self_mat, self_cons, ctx_mat, ctx_cons)\ndef is_empty(self) -&gt; bool:\n\"\"\"\n        Tell whether the argument has no satisfying assignments.\n        Returns:\n            True if constraints cannot be satisfied.\n        \"\"\"\n_, self_mat, self_cons, _, _ = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\nself, PolyhedralTermList([])\n)\nlogging.debug(\"Polytope is \\n%s\", self_mat)\nreturn PolyhedralTermList.is_polytope_empty(self_mat, self_cons)\n# Returns:\n# - transformed term list\n# - a list of tuples of the tactic used, time spent, and invocation count\ndef _transform(\nself,\ncontext: PolyhedralTermList,\nvars_to_elim: list,\nrefine: bool,\nsimplify: bool,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralTermList, TacticStatistics]:\nlogging.debug(\"Transforming: %s\", self)\nlogging.debug(\"Context terms: %s\", context)\nlogging.debug(\"Variables to eliminate: %s\", vars_to_elim)\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nterm_list = list(self.terms)\nnew_terms = self.copy()\n# List to store the tuples of the tactic used, time spent, and invocation count\ntactics_used: TacticStatistics = []\nfor i, term in enumerate(term_list):\nif list_intersection(term.vars, vars_to_elim):\ncopy_new_terms = new_terms.copy()\ncopy_new_terms.terms.remove(term)\nhelpers = context | copy_new_terms\ntry:\n(new_term, tactic_num, tactic_time, tactic_count) = PolyhedralTermList._transform_term(\nterm, helpers, vars_to_elim, refine, tactics_order\n)\nexcept ValueError:\nnew_term = term.copy()\ntactic_num = 0\ntactic_time = 0\ntactic_count = 0\ntactics_used.append((tactic_num, tactic_time, tactic_count))\nelse:\nnew_term = term.copy()\nnew_terms.terms[i] = new_term\nthat = PolyhedralTermList(new_terms.terms)\n# the last step needs to be a simplification\nlogging.debug(\"Ending transformation with simplification\")\nif simplify:\nreturn that.simplify(context), tactics_used\nreturn that, tactics_used\ndef optimize(self, objective: Dict[Var, numeric], maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"\n        Optimizes a linear expression in the feasible region of the termlist.\n        Args:\n            objective:\n                The objective to optimize.\n            maximize:\n                If true, the routine maximizes; it minimizes otherwise.\n        Returns:\n            The optimal value of the objective. If the objective is unbounded, None is returned.\n        Raises:\n            ValueError: Constraints are likely unfeasible.\n        \"\"\"\nobj = PolyhedralTermList([PolyhedralTerm(variables=objective, constant=0)])\n_, self_mat, self_cons, obj_mat, _ = PolyhedralTermList.termlist_to_polytope(self, obj)  # noqa: WPS236\npolarity = 1\nif maximize:\npolarity = -1\nres = linprog(c=polarity * obj_mat[0], A_ub=self_mat, b_ub=self_cons, bounds=(None, None))\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nif res[\"status\"] == 3:\nreturn None\nelif res[\"status\"] == 0:\nfun_val: float = res[\"fun\"]\nreturn polarity * fun_val\nraise ValueError(\"Constraints are unfeasible\")\n@staticmethod\ndef termlist_to_polytope(\nterms: PolyhedralTermList, context: PolyhedralTermList\n) -&gt; Tuple[List[Var], np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n\"\"\"\n        Converts a list of terms with its context into matrix-vector pairs.\n        Example:\n            Suppose the list of terms is $\\\\{x+y \\\\le 1, x - y \\\\le 4\\\\}$\n            and the context is $\\\\{x + 4w \\\\le 5\\\\}$. The routine extracts\n            all variables and generates an order for them, say, $[x, w,\n            y]$. Then the routine returns matrix-vector pairs for both the terms\n            TermList and the context. It returns $A = \\\\left(\n            \\\\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\\\\\\\ 1 &amp;0 &amp;-1\n            \\\\end{smallmatrix}\\\\right)$ and $b = \\\\left(\n            \\\\begin{smallmatrix} 1 \\\\\\\\ 4 \\\\end{smallmatrix}\\\\right)$ for the\n            current TermList and $A_{c} = \\\\left( \\\\begin{smallmatrix} 1 &amp;\n            4 &amp; 0 \\\\end{smallmatrix}\\\\right)$ and $b_c = \\\\left(\n            \\\\begin{smallmatrix} 5 \\\\end{smallmatrix}\\\\right)$ for the context.\n        Args:\n            terms:\n                list of terms to convert to matrix-vector form.\n            context:\n                Context terms to convert to matrix-vector form.\n        Returns:\n            A tuple `variables, A, b, a_h, b_h` consisting of the variable\n                order and the matrix-vector pairs for the terms and the context.\n        \"\"\"\nvariables = list(list_union(terms.vars, context.vars))\na = []\nb = []\nfor term in terms.terms:\npol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\na.append(pol)\nb.append(coeff)\na_h = []\nb_h = []\nfor term in context.terms:\npol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\na_h.append(pol)\nb_h.append(coeff)\nif len(context.terms) == 0:\na_h_ret = np.array([[]])\nelse:\na_h_ret = np.array(a_h)\n# logging.debug(\"a is \\n%s\", a)\nreturn variables, np.array(a), np.array(b), a_h_ret, np.array(b_h)\n@staticmethod\ndef polytope_to_termlist(matrix: np.ndarray, vector: np.ndarray, variables: List[Var]) -&gt; PolyhedralTermList:\n\"\"\"\n        Transforms a matrix-vector pair into a PolyhedralTermList.\n        Args:\n            matrix:\n                The matrix of the pair.\n            vector:\n                The vector of the pair.\n            variables:\n                A list indicating the variable which corresponds to each column\n                of the matrix.\n        Returns:\n            The PolyhedralTermList corresponding to the given data.\n        \"\"\"\nterm_list = []\n# logging.debug(\"Poly is \" + str(polytope))\n# logging.debug(\"matrix is %s\", matrix)\nif len(matrix.shape) &gt; 1:\nn, m = matrix.shape\nassert m == len(variables)\nelse:\nn = matrix.shape[0]\nm = 0\nfor i in range(n):\nrow = list(matrix[i])\nconst = vector[i]\nterm = PolyhedralTerm.polytope_to_term(row, const, variables)\nterm_list.append(term)\nreturn PolyhedralTermList(list(term_list))\n@staticmethod\ndef reduce_polytope(  # noqa: WPS231\na: np.ndarray, b: np.ndarray, a_help: Optional[np.ndarray] = None, b_help: Optional[np.ndarray] = None\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"\n        Eliminate redundant constraints from a given polytope.\n        Args:\n            a:\n                Matrix of H-representation of polytope to reduce.\n            b:\n                Vector of H-representation of polytope to reduce.\n            a_help:\n                Matrix of H-representation of context polytope.\n            b_help:\n                Vector of H-representation of context polytope.\n        Raises:\n            ValueError: The intersection of given polytope with its context is empty.\n        Returns:\n            a_temp: Matrix of H-representation of reduced polytope.\n            b_temp: Vector of H-representation of reduced polytope.\n        \"\"\"\nif not isinstance(a_help, np.ndarray):\na_help = np.array([[]])\nif not isinstance(b_help, np.ndarray):\nb_help = np.array([])\nif len(a.shape) &gt; 1:\nn, m = a.shape\nelse:\nn = a.shape[0]\nm = 0\nn_h, m_h = a_help.shape\nhelper_present = n_h * m_h &gt; 0\nassert n == len(b), \"n is {} and b is {}\".format(n, b)\nif helper_present:\nassert n_h == len(b_help)\nelse:\nassert len(b_help) == 0\nif helper_present and m &gt; 0:\nassert m_h == m\nif n == 0:\nreturn a, b\nif n == 1 and not helper_present:\nreturn a, b\ni = 0\na_temp = np.copy(a)\nb_temp = np.copy(b)\nwhile i &lt; n:\nobjective = a_temp[i, :] * -1\nb_temp[i] += 1\nif helper_present:\na_opt = np.concatenate((a_temp, a_help), axis=0)\nb_opt = np.concatenate((b_temp, b_help))\nelse:\na_opt = a_temp\nb_opt = b_temp\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nres = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\nb_temp[i] -= 1\nif res[\"status\"] == 3 or (res[\"status\"] == 0 and -res[\"fun\"] &lt;= b_temp[i]):  # noqa: WPS309\nlogging.debug(\"Can remove\")\na_temp = np.delete(a_temp, i, 0)\nb_temp = np.delete(b_temp, i)\nn -= 1\nelse:\ni += 1\nif res[\"status\"] == 2:\nraise ValueError(\"The constraints are unsatisfiable\")\nreturn a_temp, b_temp\n@staticmethod\ndef verify_polytope_containment(  # noqa: WPS231\na_l: Optional[np.ndarray] = None,\nb_l: Optional[np.ndarray] = None,\na_r: Optional[np.ndarray] = None,\nb_r: Optional[np.ndarray] = None,\n) -&gt; bool:\n\"\"\"\n        Tell whether a polytope is contained in another.\n        Args:\n            a_l:\n                Matrix of H-representation of polytope on LHS of inequality.\n            b_l:\n                Vector of H-representation of polytope on LHS of inequality.\n            a_r:\n                Matrix of H-representation of polytope on RHS of inequality.\n            b_r:\n                Vector of H-representation of polytope on RHS of inequality.\n        Returns:\n            True if left polytope is contained in right polytope. False otherwise.\n        \"\"\"\nif not isinstance(a_l, np.ndarray):\na_l = np.array([[]])\nif not isinstance(a_r, np.ndarray):\na_r = np.array([[]])\nif not isinstance(b_l, np.ndarray):\nb_l = np.array([])\nif not isinstance(b_r, np.ndarray):\nb_r = np.array([])\n# If the LHS is empty, it is a refinement\nif PolyhedralTermList.is_polytope_empty(a_l, b_l):\nreturn True\n# If the RHS is empty, but not the LHS, not a refinement\nif PolyhedralTermList.is_polytope_empty(a_r, b_r):\nreturn False\n# If no side is empty, check whether the RHS terms are included in the\n# LHS\nn_l, m_l = a_l.shape\nn_r, m_r = a_r.shape\nassert m_l == m_r\nassert n_l == len(b_l)\nassert n_r == len(b_r)\nis_refinement = True\nfor i in range(n_r):\nconstraint = a_r[[i], :]\nobjective = constraint * -1\nb_temp = b_r[i] + 1\nlogging.debug(\"Optimization objective: \\n%s\", objective)\nlogging.debug(\"a_l is \\n%s\", a_l)\nlogging.debug(\"a_r is \\n%s\", a_r)\nlogging.debug(\"b_l is \\n%s\", b_l)\nlogging.debug(\"b_r is \\n%s\", b_r)\na_opt = np.concatenate((a_l, constraint), axis=0)\nb_opt = np.concatenate((b_l, np.array([b_temp])))\nres = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\nb_temp -= 1\nif res[\"status\"] == 2:\nis_refinement = False\nbreak\nelse:\nif -res[\"fun\"] &lt;= b_temp:  # noqa: WPS309\nlogging.debug(\"Redundant constraint\")\nelse:\nis_refinement = False\nbreak\nlogging.debug(\"Optimal value: %s\", -res[\"fun\"])\nlogging.debug(\"Results: %s\", res)\nreturn is_refinement\n@staticmethod\ndef is_polytope_empty(a: np.ndarray, b: np.ndarray) -&gt; bool:\n\"\"\"\n        Say whether a polytope is empty.\n        Args:\n            a:\n                Matrix of H-representation of polytope to verify.\n            b:\n                Vector of H-representation of polytope to verify.\n        Returns:\n            True if empty. False otherwise.\n        Raises:\n            ValueError: Numerical difficulties encountered.\n        \"\"\"\nlogging.debug(\"Verifying polytope emptiness: a is %s a.shape is %s, b is %s\", a, a.shape, b)\nif len(a) == 0:\nreturn False\nn, m = a.shape\nif n * m == 0:\nreturn False\nassert n == len(b)\nobjective = np.zeros((1, m))\nres = linprog(c=objective, A_ub=a, b_ub=b, bounds=(None, None))  # ,options={'tol':0.000001})\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nif res[\"status\"] == 2:\nreturn True\nelif res[\"status\"] in {0, 3}:\nreturn False\nraise ValueError(\"Cannot decide emptiness\")\n@staticmethod\ndef _get_kaykobad_context(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[List[PolyhedralTerm], List[Var]]:\nforbidden_vars = list_intersection(vars_to_elim, term.vars)\nother_forbibben_vars = list_diff(vars_to_elim, term.vars)\nn = len(forbidden_vars)\nmatrix_row_terms = []  # type: List[PolyhedralTerm]\npartial_sums = [float(0) for i in range(n)]\ntransform_coeff = -1\nif refine:\ntransform_coeff = 1\nmatrix_contains_others = False\n# We add a row to the matrix in each iteration\nfor i, i_var in enumerate(forbidden_vars):\nrow_found = False\nlogging.debug(\"Iterating for variable %s\", i_var)\nfor context_term in list_diff(context.terms, matrix_row_terms):\nlogging.debug(\"Analyzing context term %s\", context_term)\nif context_term == term:\ncontinue\nterm_is_invalid = False\n# make sure the term does not include other forbidden variables\nfor var in other_forbibben_vars:  # noqa: VNE002\nif context_term.get_coefficient(var) != 0:\nterm_is_invalid = True\nlogging.debug(\"Term contains other forbidden vars\")\nbreak\nif term_is_invalid:\ncontinue\n# 1. Verify Kaykobad pair: sign of nonzero matrix terms\nfor var in forbidden_vars:  # noqa: VNE002\nif context_term.get_coefficient(var) != 0:\nif transform_coeff * context_term.get_sign(var) != term.get_sign(var):\nterm_is_invalid = True\n# logging.debug(\"Failed first matrix-vector verification\")\nbreak\n# 2. Verify Kaykobad pair: matrix diagonal terms\nif context_term.get_coefficient(i_var) == 0 or term_is_invalid:\n# logging.debug(\"Failed second matrix-vector verification\")\ncontinue\n# 3. Verify Kaykobad pair: relation between matrix and vector\nresiduals = [float(0) for i in range(n)]\nfor j, j_var in enumerate(forbidden_vars):\n# logging.debug(\"Verifying third condition on variable %s\", j_var)\nif j != i:\nresiduals[j] = (\nterm.get_sign(j_var)\n* context_term.get_coefficient(j_var)\n* term.get_coefficient(i_var)\n/ context_term.get_coefficient(i_var)\n)\nif np.abs(term.get_coefficient(j_var)) &lt;= partial_sums[j] + residuals[j]:\n# logging.debug(\"q coefficient: %s\", term.get_coefficient(j_var))\n# logging.debug(\"RHS: %s\", partial_sums[j] + residuals[j])\nterm_is_invalid = True\n# logging.debug(\"Failed third matrix-vector verification\")\nbreak\nif not term_is_invalid:\nmatrix_contains_others = (\nmatrix_contains_others or len(list_diff(context_term.vars, forbidden_vars)) &gt; 0\n)\nrow_found = True\nfor j in range(n):\npartial_sums[j] += residuals[j]\nmatrix_row_terms.append(context_term)\nbreak\nif not row_found:\nraise ValueError(\"Could not find the {}th row of matrix\".format(i))\nif (not matrix_contains_others) and len(list_diff(term.vars, vars_to_elim)) == 0:\nraise ValueError(\"Found context will produce empty transformation\")\n# logging.debug(\"Matrix row terms %s\", matrix_row_terms)\nreturn matrix_row_terms, forbidden_vars\n@staticmethod\ndef _context_reduction(\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool, strategy: int\n) -&gt; PolyhedralTerm:\nlogging.debug(\"********** Context reduction\")\nlogging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\ntry:\nif strategy == 1:\nmatrix_row_terms, forbidden_vars = PolyhedralTermList._get_kaykobad_context(\nterm, context, vars_to_elim, refine\n)\nelif strategy == 5:\nmatrix_row_terms, forbidden_vars = PolyhedralTermList._get_tlp_context(\nterm, context, vars_to_elim, refine\n)\nelse:\nraise ValueError(\"Unknown strategy\")\nexcept ValueError:\nlogging.debug(\"Could not transform %s using Context reduction\", term)\nraise ValueError(\"Could not transform term {}\".format(term))\nmatrix_row_terms_tl = PolyhedralTermList(list(matrix_row_terms))\nsols = PolyhedralTerm.solve_for_variables(matrix_row_terms_tl, list(forbidden_vars))\n# logging.debug(\"Sols %s\", sols)\nresult = term.copy()\n# logging.debug(\"Result is %s\", result)\nfor var in sols.keys():  # noqa: VNE002\nresult = result.substitute_variable(var, sols[var])\nlogging.debug(\"Term %s transformed to %s\", term, result)\nreturn result\n@staticmethod\ndef _tactic_1(\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nlogging.debug(\"********** Tactic 1\")\nreturn PolyhedralTermList._context_reduction(term, context, vars_to_elim, refine, 1), 1\n@staticmethod\ndef _tactic_2(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nlogging.debug(\"************ Tactic 2\")\nlogging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\nconflict_vars = list_intersection(vars_to_elim, term.vars)\nnew_context_list = []\n# Extract from context the terms that only contain forbidden vars\nfor context_term in context.terms:\nif not list_diff(context_term.vars, vars_to_elim):\nif context_term != term:\nnew_context_list.append(context_term.copy())\nlogging.debug(\"This is what we kept\")\nfor el in new_context_list:\nlogging.debug(el)\nif not new_context_list:\nraise ValueError(\"No term contains only irrelevant variables\")\nif list_diff(conflict_vars, PolyhedralTermList(new_context_list).vars):\nraise ValueError(\"Tactic 2 unsuccessful\")\n# now optimize\nretval = PolyhedralTermList.termlist_to_polytope(PolyhedralTermList(new_context_list), PolyhedralTermList([]))\nvariables = retval[0]\nnew_context_mat = retval[1]\nnew_context_cons = retval[2]\npolarity = 1\nif refine:\npolarity = -1\nobjective = [polarity * term.get_coefficient(var) for var in variables]\nlogging.debug(new_context_mat)\nlogging.debug(new_context_cons)\nlogging.debug(objective)\nres = linprog(c=objective, A_ub=new_context_mat, b_ub=new_context_cons, bounds=(None, None))\nif res[\"status\"] in {2, 3}:\n# unbounded\n# return term.copy()\nraise ValueError(\"Tactic 2 did not succeed\")\nreplacement = polarity * res[\"fun\"]\n# replace the irrelevant variables with new findings in term\nresult = term.copy()\nfor var in vars_to_elim:  # noqa: VNE002\nresult = result.remove_variable(var)\nresult.constant -= replacement\n# check vacuity\nif not result.vars:\nreturn term.copy(), 1\nreturn result, 1\n@staticmethod\ndef _tactic_6(\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nlogging.debug(\"************ Tactic 6\")\nlogging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\nconflict_vars = list_intersection(vars_to_elim, term.vars)\nconflict_coeff = {var: term.get_coefficient(var) for var in conflict_vars}\nnew_term = term.copy()\nfor var in conflict_vars:  # noqa: VNE002 variable name 'var' should be clarified\nnew_term = new_term.remove_variable(var)\nnew_term.variables[Var(\"_\")] = 1\n# modify the context\nsubst_term_vars = {Var(\"_\"): 1.0 / conflict_coeff[conflict_vars[0]]}\nfor var in conflict_vars:  # noqa: VNE002 variable name 'var' should be clarified\nif var != conflict_vars[0]:\nsubst_term_vars[var] = -conflict_coeff[var] / conflict_coeff[conflict_vars[0]]\nsubst_term = PolyhedralTerm(variables=subst_term_vars, constant=0)\nnew_context = PolyhedralTermList(\n[el.copy().substitute_variable(conflict_vars[0], subst_term) for el in context.terms]\n)\n# now we use tactic 1\nnew_elims = list_diff(list_union(vars_to_elim, [Var(\"_\")]), [conflict_vars[0]])\ntry:\nresult, count = PolyhedralTermList._tactic_1(new_term, new_context, new_elims, refine)\nexcept ValueError as e:  # noqa: WPS329 Found useless `except` case\nraise e\nlogging.debug(\"************ Leaving Tactic 6\")\nlogging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\nreturn result, count\n@staticmethod\ndef _tactic_4(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool, no_vars: List[Var]\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nlogging.debug(\"************ Tactic 4\")\nlogging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\nif not refine:\nraise ValueError(\"Only refinement is supported\")\nconflict_vars = list_intersection(vars_to_elim, term.vars)\nif len(conflict_vars) &gt; 1:\nraise ValueError(\"Tactic 4 unsuccessful\")\nvar_to_elim = conflict_vars[0]\ngoal_context: List[PolyhedralTerm] = []\nuseful_context: List[PolyhedralTerm] = []\npolarity = -1\nif refine:\npolarity = 1\nfor context_term in context.terms:\nif list_intersection(context_term.vars, no_vars):\ncontinue\ncoeff = context_term.get_coefficient(var_to_elim)\nif coeff != 0 and polarity * coeff * term.get_coefficient(var_to_elim) &gt; 0:\ntemp_conflict_vars = list_intersection(context_term.vars, vars_to_elim)\nif len(temp_conflict_vars) == 1:\ngoal_context.append(context_term.copy())\nif len(temp_conflict_vars) == 2:\nuseful_context.append(context_term.copy())\nif not useful_context and not goal_context:\nraise ValueError(\"Tactic 4 unsuccessful\")\ntotal_calls = 1\nif goal_context:\nreturn term.substitute_variable(var_to_elim, goal_context[0].isolate_variable(var_to_elim)), total_calls\n############\nfor useful_term in useful_context:\nnew_context = context.copy()\nnew_context.terms.remove(useful_term)\nnew_term = useful_term.isolate_variable(var_to_elim)\nnew_no_vars = no_vars.copy()\nnew_no_vars.append(var_to_elim)\ntry:  # noqa: WPS229\nreturn_term, recursive_count = PolyhedralTermList._tactic_4(\nnew_term, new_context, vars_to_elim, refine, new_no_vars\n)\ntotal_calls += recursive_count\nif return_term is None:\ncontinue\nreturn term.substitute_variable(var_to_elim, return_term), total_calls\nexcept ValueError:\ntotal_calls += 1\nreturn None, total_calls\n@staticmethod\ndef _get_tlp_context(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[List[PolyhedralTerm], List[Var]]:\nforbidden_vars = list_intersection(vars_to_elim, term.vars)\nmatrix_row_terms = []\nvar_list, B, b, _, _ = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236, N806\nterms=context, context=PolyhedralTermList([])\n)\nobjective = np.array([term.get_coefficient(var) if var in forbidden_vars else 0 for var in var_list])\nif refine:\nobjective *= -1\nres = linprog(c=objective, A_ub=B, b_ub=b, bounds=(None, None))\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nif res[\"status\"] == 3:\nraise ValueError(\"Unbounded\")\nelif res[\"status\"] != 0:\nraise ValueError(\"Constraints are unfeasible\")\nnum_vars_to_elim = len(forbidden_vars)\nslack = res[\"slack\"]\nindices = np.where(np.isclose(slack, 0))[0]\nassert len(indices) &gt;= num_vars_to_elim\nterms_added = 0\nfor index in indices:\ncontext_term = context.terms[index]\nif list_intersection(context_term.vars, forbidden_vars):\nmatrix_row_terms.append(context_term)\nterms_added += 1\nif terms_added == num_vars_to_elim:\nbreak\nif terms_added &lt; num_vars_to_elim:\nraise ValueError(\"Context has insufficient information\")\nreturn matrix_row_terms, forbidden_vars\n@staticmethod\ndef _tactic_5(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nlogging.debug(\"************ Tactic 5\")\nreturn PolyhedralTermList._context_reduction(term, context, vars_to_elim, refine, 5), 1\n@staticmethod\ndef _tactic_3(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nlogging.debug(\"************ Tactic 3\")\nlogging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\nconflict_vars = list_intersection(vars_to_elim, term.vars)\nif conflict_vars:\nct_var = conflict_vars[0]\nfor index, ct_term in enumerate(context.terms):\nif ct_var in ct_term.vars:\ncoeff_test = refine and (term.get_polarity(ct_var) == ct_term.get_polarity(ct_var))\ncoeff_test = coeff_test or (\n(not refine) and (term.get_polarity(ct_var) != ct_term.get_polarity(ct_var))\n)\nif coeff_test:\nct_conflict_vars = list_intersection(vars_to_elim, ct_term.vars)\nif all(ele in conflict_vars for ele in ct_conflict_vars):\nreplacement_expr = ct_term.isolate_variable(ct_var)\nnew_term = term.substitute_variable(ct_var, replacement_expr)\nnew_context = context.copy()\nnew_context.terms.pop(index)\ntry:\nreturn PolyhedralTermList._tactic_3(new_term, new_context, vars_to_elim, refine)[0], 1\nexcept ValueError:\npass\nraise ValueError(\"Failed\")\nreturn term.copy(), 1\n@staticmethod\ndef _tactic_trivial(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nreturn term.copy(), 1\nTACTICS = {  # noqa: WPS115\n1: _tactic_1.__func__,  # type: ignore\n2: _tactic_2.__func__,  # type: ignore\n3: _tactic_3.__func__,  # type: ignore\n4: lambda term, context, vars_to_elim, refine: PolyhedralTermList._tactic_4(\nterm, context, vars_to_elim, refine, []\n),\n5: _tactic_5.__func__,  # type: ignore\n6: _tactic_6.__func__,  # type: ignore\n7: _tactic_trivial.__func__,  # type: ignore\n}\n# Return:\n# - transformed term\n# - successful tactic number, if &gt; 0; 0 if no applicable tactic, -1 if all tactics failed\n# - count of tactic invocations if successful\n@staticmethod\ndef _transform_term(  # noqa: WPS231\nterm: PolyhedralTerm,\ncontext: PolyhedralTermList,\nvars_to_elim: list,\nrefine: bool,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralTerm, int, float, int]:\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif not list_intersection(term.vars, vars_to_elim):\nraise ValueError(\"Irrelevant transform term call!\")\nlogging.debug(\"Transforming term: %s\", term)\nlogging.debug(\"Context: %s\", context)\nfor tactic_num in tactics_order:  # noqa WPS327\ntry:  # noqa: WPS229\nta = time.time()\nve = vars_to_elim.copy()\nif len(ve) &gt; 2:\nve[1] = vars_to_elim[2]\nve[2] = vars_to_elim[1]\nresult, count = PolyhedralTermList.TACTICS[tactic_num](term, context, ve, refine)\ntb = time.time()\nif result is not None:\nreturn result, tactic_num, tb - ta, count\nexcept ValueError:\ncontinue\nreturn term.copy(), -1, 0, 0\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.__init__","title":"<code>__init__(terms=None)</code>","text":"<p>Constructor for PolyhedralTermList.</p> Usage <p>PolyhedralTermList objects are initialized as follows:</p> <pre><code>    term1 = PolyhedralTerm({Var('x'):2, Var('y'):3}, 3)\n    term2 = PolyhedralTerm({Var('x'):-1, Var('y'):2}, 4)\n    pt_list = [term1, term2]\n    termlist = PolyhedralTermList(pt_list)\n</code></pre> <p>Our example represents the constraints \\(\\{2x + 3y \\le 3, -x + 2y \\le 4\\}\\).</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>Optional[List[PolyhedralTerm]]</code> <p>A list of PolyhedralTerm objects.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>incorrect argument type provided.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def __init__(self, terms: Optional[List[PolyhedralTerm]] = None):\n\"\"\"\n    Constructor for PolyhedralTermList.\n    Usage:\n        PolyhedralTermList objects are initialized as follows:\n        ```\n            term1 = PolyhedralTerm({Var('x'):2, Var('y'):3}, 3)\n            term2 = PolyhedralTerm({Var('x'):-1, Var('y'):2}, 4)\n            pt_list = [term1, term2]\n            termlist = PolyhedralTermList(pt_list)\n        ```\n        Our example represents the constraints $\\\\{2x + 3y \\\\le 3, -x + 2y \\\\le 4\\\\}$.\n    Args:\n        terms: A list of PolyhedralTerm objects.\n    Raises:\n        ValueError: incorrect argument type provided.\n    \"\"\"\nif terms is None:\nself.terms = []\nelif all(isinstance(t, PolyhedralTerm) for t in terms):\nself.terms = terms.copy()\nelse:\nraise ValueError(\"PolyhedralTermList constructor argument must be a list of PolyhedralTerms.\")\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.contains_behavior","title":"<code>contains_behavior(behavior)</code>","text":"<p>Tell whether TermList contains the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Dict[Var, numeric]</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraints; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n    Tell whether TermList contains the given behavior.\n    Args:\n        behavior:\n            The behavior in question.\n    Returns:\n        True if the behavior satisfies the constraints; false otherwise.\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\nexcess_vars = list_diff(self.vars, list(behavior.keys()))\nif excess_vars:\nraise ValueError(\"The variables %s were not assigned values\" % (excess_vars))\nretval = True\ntry:\nself.evaluate(behavior)\nexcept ValueError:\nretval = False\nreturn retval\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.elim_vars_by_refining","title":"<code>elim_vars_by_refining(context, vars_to_elim, simplify=True, tactics_order=None)</code>","text":"<p>Eliminate variables from PolyhedralTermList by refining it in context.</p> Example <p>Suppose the current list of terms is \\(\\{x + y \\le 6\\}\\), the context is \\(\\{y \\le 5\\}\\), and the resulting terms should not contain variable \\(y\\). Then the current TermList could be refined to \\(\\{x \\le 1\\}\\) because \\(x \\le 1 \\;\\land\\; y \\le 5 \\Rightarrow x + y \\le 6\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PolyhedralTermList</code> <p>The TermList providing the context for the refinement.</p> required <code>vars_to_elim</code> <code>list</code> <p>Variables that should not appear in the resulting term.</p> required <code>simplify</code> <code>bool</code> <p>Whether to perform simplifications.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>Optionally, the order of tactics to invoke during transformation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[PolyhedralTermList, TacticStatistics]</code> <p>A tuple of (a) a list of terms not containing any variables in <code>vars_to_elim</code> and which, in the context provided, imply the terms contained in the calling termlist; and (b) the list of tuples, for each processed term, of the tactic used, time spend, and tactic invocation count.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Self has empty intersection with its context.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def elim_vars_by_refining(\nself,\ncontext: PolyhedralTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralTermList, TacticStatistics]:\n\"\"\"\n    Eliminate variables from PolyhedralTermList by refining it in context.\n    Example:\n        Suppose the current list of terms is $\\\\{x + y \\\\le 6\\\\}$, the\n        context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n        contain variable $y$. Then the current TermList could be\n        refined to $\\\\{x \\\\le 1\\\\}$ because $x \\\\le 1\n        \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x + y \\\\le 6$.\n    Args:\n        context:\n            The TermList providing the context for the refinement.\n        vars_to_elim:\n            Variables that should not appear in the resulting term.\n        simplify:\n            Whether to perform simplifications.\n        tactics_order:\n            Optionally, the order of tactics to invoke during transformation.\n    Returns:\n        A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, imply the terms contained in the\n            calling termlist; and (b) the list of tuples, for each processed term, of\n            the tactic used, time spend, and tactic invocation count.\n    Raises:\n        ValueError: Self has empty intersection with its context.\n    \"\"\"\nlogging.debug(\"Refining from terms: %s\", self)\nlogging.debug(\"Context: %s\", context)\nlogging.debug(\"Vars to elim: %s\", vars_to_elim)\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif simplify:\ntry:\ntermlist = self.simplify(context)\nexcept ValueError as e:\nraise ValueError(\n\"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n) from e\nelse:\ntermlist = self\ntry:\nreturn termlist._transform(\ncontext=context, vars_to_elim=vars_to_elim, refine=True, simplify=simplify, tactics_order=tactics_order\n)\nexcept ValueError as e:\nraise ValueError(\n\"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n+ \"by refining terms \\n{}\\n\".format(self)\n+ \"in context \\n{}\\n\".format(context)\n+ \"was not possible\"\n) from e\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.elim_vars_by_relaxing","title":"<code>elim_vars_by_relaxing(context, vars_to_elim, simplify=True, tactics_order=None)</code>","text":"<p>Eliminate variables from PolyhedralTermList by abstracting it in context.</p> Example <p>Suppose the current list of terms is \\(\\{x - y \\le 6\\}\\), the context is \\(\\{y \\le 5\\}\\), and the resulting terms should not contain variable \\(y\\). Then the current TermList could be relaxed to \\(\\{x \\le 11\\}\\) because \\(x - y \\le 6 \\;\\land\\; y \\le 5 \\Rightarrow x \\le 11\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PolyhedralTermList</code> <p>The TermList providing the context for the transformation.</p> required <code>vars_to_elim</code> <code>list</code> <p>Variables that should not appear in the relaxed terms.</p> required <code>simplify</code> <code>bool</code> <p>Whether to perform simplifications.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>Optionally, the order of tactics to invoke during transformation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[PolyhedralTermList, TacticStatistics]</code> <p>A tuple of (a) a list of terms not containing any variables in <code>vars_to_elim</code> and which, in the context provided, are implied by the terms contained in the calling termlist; and (b) the list of tuples, for each processed term, of the tactic used, time spend, and tactic invocation count.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Constraints have empty intersection with context.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def elim_vars_by_relaxing(\nself,\ncontext: PolyhedralTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralTermList, TacticStatistics]:\n\"\"\"\n    Eliminate variables from PolyhedralTermList by abstracting it in context.\n    Example:\n        Suppose the current list of terms is $\\\\{x - y \\\\le 6\\\\}$, the\n        context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n        contain variable $y$. Then the current TermList could be\n        relaxed to $\\\\{x \\\\le 11\\\\}$ because $x - y \\\\le 6\n        \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x \\\\le 11$.\n    Args:\n        context:\n            The TermList providing the context for the transformation.\n        vars_to_elim:\n            Variables that should not appear in the relaxed terms.\n        simplify:\n            Whether to perform simplifications.\n        tactics_order:\n            Optionally, the order of tactics to invoke during transformation.\n    Returns:\n        A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, are implied by the terms\n            contained in the calling termlist; and (b) the list of tuples, for each\n            processed term, of the tactic used, time spend, and tactic invocation count.\n    Raises:\n        ValueError: Constraints have empty intersection with context.\n    \"\"\"\nlogging.debug(\"Relaxing with context\")\nlogging.debug(\"Relaxing from terms %s\", self)\nlogging.debug(\"Context: %s\", context)\nlogging.debug(\"Vars to elim: %s\", vars_to_elim)\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif simplify:\ntry:\ntermlist = self.simplify(context)\nexcept ValueError as e:\nraise ValueError(\n\"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n) from e\nelse:\ntermlist = self.copy()\ntry:\n(termlist, tactics_data) = termlist._transform(\ncontext=context, vars_to_elim=vars_to_elim, refine=False, simplify=simplify, tactics_order=tactics_order\n)\nexcept ValueError as e:\nraise ValueError(\n\"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n+ \"by relaxing terms \\n{}\\n\".format(self)\n+ \"in context \\n{}\\n\".format(context)\n+ \"was not possible\"\n) from e\n# eliminate terms containing the variables to be eliminated\nterms_to_elim = termlist.get_terms_with_vars(vars_to_elim)\ntermlist.terms = list_diff(termlist.terms, terms_to_elim.terms)\nreturn termlist, tactics_data\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.evaluate","title":"<code>evaluate(var_values)</code>","text":"<p>Replace variables in termlist with given values.</p> <p>Parameters:</p> Name Type Description Default <code>var_values</code> <code>Dict[Var, numeric]</code> <p>The values that variables will take.</p> required <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>A new PolyhedralTermList in which the variables have been substituted with the values provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>constraints are unsatisfiable under these valuation of variables.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def evaluate(self, var_values: Dict[Var, numeric]) -&gt; PolyhedralTermList:  # noqa: WPS231\n\"\"\"\n    Replace variables in termlist with given values.\n    Args:\n        var_values:\n            The values that variables will take.\n    Returns:\n        A new PolyhedralTermList in which the variables have been\n            substituted with the values provided.\n    Raises:\n        ValueError: constraints are unsatisfiable under these valuation of variables.\n    \"\"\"\nnew_list = []\nfor term in self.terms:\nnew_term = term.copy()\nfor var, val in var_values.items():  # noqa: VNE002\nnew_term = new_term.substitute_variable(\nvar=var, subst_with_term=PolyhedralTerm(variables={}, constant=-val)\n)\n# we may have eliminated all variables after substitution\nif not new_term.vars:\nif new_term.constant &lt; 0:\nraise ValueError(\"Term %s not satisfied\" % (term))\nelse:\ncontinue  # noqa: WPS503\nnew_list.append(new_term)\nreturn PolyhedralTermList(new_list)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.is_empty","title":"<code>is_empty()</code>","text":"<p>Tell whether the argument has no satisfying assignments.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if constraints cannot be satisfied.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def is_empty(self) -&gt; bool:\n\"\"\"\n    Tell whether the argument has no satisfying assignments.\n    Returns:\n        True if constraints cannot be satisfied.\n    \"\"\"\n_, self_mat, self_cons, _, _ = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\nself, PolyhedralTermList([])\n)\nlogging.debug(\"Polytope is \\n%s\", self_mat)\nreturn PolyhedralTermList.is_polytope_empty(self_mat, self_cons)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.is_polytope_empty","title":"<code>is_polytope_empty(a, b)</code>  <code>staticmethod</code>","text":"<p>Say whether a polytope is empty.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Matrix of H-representation of polytope to verify.</p> required <code>b</code> <code>ndarray</code> <p>Vector of H-representation of polytope to verify.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if empty. False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Numerical difficulties encountered.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef is_polytope_empty(a: np.ndarray, b: np.ndarray) -&gt; bool:\n\"\"\"\n    Say whether a polytope is empty.\n    Args:\n        a:\n            Matrix of H-representation of polytope to verify.\n        b:\n            Vector of H-representation of polytope to verify.\n    Returns:\n        True if empty. False otherwise.\n    Raises:\n        ValueError: Numerical difficulties encountered.\n    \"\"\"\nlogging.debug(\"Verifying polytope emptiness: a is %s a.shape is %s, b is %s\", a, a.shape, b)\nif len(a) == 0:\nreturn False\nn, m = a.shape\nif n * m == 0:\nreturn False\nassert n == len(b)\nobjective = np.zeros((1, m))\nres = linprog(c=objective, A_ub=a, b_ub=b, bounds=(None, None))  # ,options={'tol':0.000001})\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nif res[\"status\"] == 2:\nreturn True\nelif res[\"status\"] in {0, 3}:\nreturn False\nraise ValueError(\"Cannot decide emptiness\")\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.lacks_constraints","title":"<code>lacks_constraints()</code>","text":"<p>Tell whether TermList is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if empty. False otherwise.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def lacks_constraints(self) -&gt; bool:\n\"\"\"\n    Tell whether TermList is empty.\n    Returns:\n        True if empty. False otherwise.\n    \"\"\"\nreturn len(self.terms) == 0\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.optimize","title":"<code>optimize(objective, maximize=True)</code>","text":"<p>Optimizes a linear expression in the feasible region of the termlist.</p> <p>Parameters:</p> Name Type Description Default <code>objective</code> <code>Dict[Var, numeric]</code> <p>The objective to optimize.</p> required <code>maximize</code> <code>bool</code> <p>If true, the routine maximizes; it minimizes otherwise.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[numeric]</code> <p>The optimal value of the objective. If the objective is unbounded, None is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Constraints are likely unfeasible.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def optimize(self, objective: Dict[Var, numeric], maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"\n    Optimizes a linear expression in the feasible region of the termlist.\n    Args:\n        objective:\n            The objective to optimize.\n        maximize:\n            If true, the routine maximizes; it minimizes otherwise.\n    Returns:\n        The optimal value of the objective. If the objective is unbounded, None is returned.\n    Raises:\n        ValueError: Constraints are likely unfeasible.\n    \"\"\"\nobj = PolyhedralTermList([PolyhedralTerm(variables=objective, constant=0)])\n_, self_mat, self_cons, obj_mat, _ = PolyhedralTermList.termlist_to_polytope(self, obj)  # noqa: WPS236\npolarity = 1\nif maximize:\npolarity = -1\nres = linprog(c=polarity * obj_mat[0], A_ub=self_mat, b_ub=self_cons, bounds=(None, None))\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nif res[\"status\"] == 3:\nreturn None\nelif res[\"status\"] == 0:\nfun_val: float = res[\"fun\"]\nreturn polarity * fun_val\nraise ValueError(\"Constraints are unfeasible\")\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.polytope_to_termlist","title":"<code>polytope_to_termlist(matrix, vector, variables)</code>  <code>staticmethod</code>","text":"<p>Transforms a matrix-vector pair into a PolyhedralTermList.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>The matrix of the pair.</p> required <code>vector</code> <code>ndarray</code> <p>The vector of the pair.</p> required <code>variables</code> <code>List[Var]</code> <p>A list indicating the variable which corresponds to each column of the matrix.</p> required <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>The PolyhedralTermList corresponding to the given data.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef polytope_to_termlist(matrix: np.ndarray, vector: np.ndarray, variables: List[Var]) -&gt; PolyhedralTermList:\n\"\"\"\n    Transforms a matrix-vector pair into a PolyhedralTermList.\n    Args:\n        matrix:\n            The matrix of the pair.\n        vector:\n            The vector of the pair.\n        variables:\n            A list indicating the variable which corresponds to each column\n            of the matrix.\n    Returns:\n        The PolyhedralTermList corresponding to the given data.\n    \"\"\"\nterm_list = []\n# logging.debug(\"Poly is \" + str(polytope))\n# logging.debug(\"matrix is %s\", matrix)\nif len(matrix.shape) &gt; 1:\nn, m = matrix.shape\nassert m == len(variables)\nelse:\nn = matrix.shape[0]\nm = 0\nfor i in range(n):\nrow = list(matrix[i])\nconst = vector[i]\nterm = PolyhedralTerm.polytope_to_term(row, const, variables)\nterm_list.append(term)\nreturn PolyhedralTermList(list(term_list))\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.reduce_polytope","title":"<code>reduce_polytope(a, b, a_help=None, b_help=None)</code>  <code>staticmethod</code>","text":"<p>Eliminate redundant constraints from a given polytope.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Matrix of H-representation of polytope to reduce.</p> required <code>b</code> <code>ndarray</code> <p>Vector of H-representation of polytope to reduce.</p> required <code>a_help</code> <code>Optional[ndarray]</code> <p>Matrix of H-representation of context polytope.</p> <code>None</code> <code>b_help</code> <code>Optional[ndarray]</code> <p>Vector of H-representation of context polytope.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>The intersection of given polytope with its context is empty.</p> <p>Returns:</p> Name Type Description <code>a_temp</code> <code>ndarray</code> <p>Matrix of H-representation of reduced polytope.</p> <code>b_temp</code> <code>ndarray</code> <p>Vector of H-representation of reduced polytope.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef reduce_polytope(  # noqa: WPS231\na: np.ndarray, b: np.ndarray, a_help: Optional[np.ndarray] = None, b_help: Optional[np.ndarray] = None\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"\n    Eliminate redundant constraints from a given polytope.\n    Args:\n        a:\n            Matrix of H-representation of polytope to reduce.\n        b:\n            Vector of H-representation of polytope to reduce.\n        a_help:\n            Matrix of H-representation of context polytope.\n        b_help:\n            Vector of H-representation of context polytope.\n    Raises:\n        ValueError: The intersection of given polytope with its context is empty.\n    Returns:\n        a_temp: Matrix of H-representation of reduced polytope.\n        b_temp: Vector of H-representation of reduced polytope.\n    \"\"\"\nif not isinstance(a_help, np.ndarray):\na_help = np.array([[]])\nif not isinstance(b_help, np.ndarray):\nb_help = np.array([])\nif len(a.shape) &gt; 1:\nn, m = a.shape\nelse:\nn = a.shape[0]\nm = 0\nn_h, m_h = a_help.shape\nhelper_present = n_h * m_h &gt; 0\nassert n == len(b), \"n is {} and b is {}\".format(n, b)\nif helper_present:\nassert n_h == len(b_help)\nelse:\nassert len(b_help) == 0\nif helper_present and m &gt; 0:\nassert m_h == m\nif n == 0:\nreturn a, b\nif n == 1 and not helper_present:\nreturn a, b\ni = 0\na_temp = np.copy(a)\nb_temp = np.copy(b)\nwhile i &lt; n:\nobjective = a_temp[i, :] * -1\nb_temp[i] += 1\nif helper_present:\na_opt = np.concatenate((a_temp, a_help), axis=0)\nb_opt = np.concatenate((b_temp, b_help))\nelse:\na_opt = a_temp\nb_opt = b_temp\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nres = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\nb_temp[i] -= 1\nif res[\"status\"] == 3 or (res[\"status\"] == 0 and -res[\"fun\"] &lt;= b_temp[i]):  # noqa: WPS309\nlogging.debug(\"Can remove\")\na_temp = np.delete(a_temp, i, 0)\nb_temp = np.delete(b_temp, i)\nn -= 1\nelse:\ni += 1\nif res[\"status\"] == 2:\nraise ValueError(\"The constraints are unsatisfiable\")\nreturn a_temp, b_temp\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.refines","title":"<code>refines(other)</code>","text":"<p>Tells whether the argument is a larger specification.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralTermList</code> <p>TermList against which we are comparing self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>self &lt;= other</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def refines(self, other: PolyhedralTermList) -&gt; bool:\n\"\"\"\n    Tells whether the argument is a larger specification.\n    Args:\n        other:\n            TermList against which we are comparing self.\n    Returns:\n        self &lt;= other\n    \"\"\"\nlogging.debug(\"Verifying refinement\")\nlogging.debug(\"LH term: %s\", self)\nlogging.debug(\"RH term: %s\", other)\nif other.lacks_constraints():\nreturn True\nif self.lacks_constraints():\nreturn False\nvariables, self_mat, self_cons, ctx_mat, ctx_cons = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\nself, other\n)\nlogging.debug(\"Polytope is \\n%s\", self_mat)\nreturn PolyhedralTermList.verify_polytope_containment(self_mat, self_cons, ctx_mat, ctx_cons)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.simplify","title":"<code>simplify(context=None)</code>","text":"<p>Remove redundant terms in the PolyhedralTermList using the provided context.</p> Example <p>Suppose the TermList is \\(\\{x - 2y \\le 5, x - y \\le 0\\}\\) and the context is \\(\\{x + y \\le 0\\}\\). Then the TermList could be simplified to \\(\\{x - y \\le 0\\}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Optional[PolyhedralTermList]</code> <p>The TermList providing the context for the simplification.</p> <code>None</code> <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>A new PolyhedralTermList with redundant terms removed using the provided context.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>The intersection of self and context is empty.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def simplify(self, context: Optional[PolyhedralTermList] = None) -&gt; PolyhedralTermList:\n\"\"\"\n    Remove redundant terms in the PolyhedralTermList using the provided context.\n    Example:\n        Suppose the TermList is $\\\\{x - 2y \\\\le 5, x - y \\\\le 0\\\\}$ and\n        the context is $\\\\{x + y \\\\le 0\\\\}$. Then the TermList could be\n        simplified to $\\\\{x - y \\\\le 0\\\\}$.\n    Args:\n        context:\n            The TermList providing the context for the simplification.\n    Returns:\n        A new PolyhedralTermList with redundant terms removed using the provided context.\n    Raises:\n        ValueError: The intersection of self and context is empty.\n    \"\"\"\nlogging.debug(\"Starting simplification procedure\")\nlogging.debug(\"Simplifying terms: %s\", self)\nlogging.debug(\"Context: %s\", context)\nif context:\nnew_self = self - context\nresult = PolyhedralTermList.termlist_to_polytope(new_self, context)\nelse:\nresult = PolyhedralTermList.termlist_to_polytope(self, PolyhedralTermList())\nvariables = result[0]\nself_mat = result[1]\nself_cons = result[2]\nctx_mat = result[3]\nctx_cons = result[4]\n# logging.debug(\"Polytope is \\n%s\", self_mat)\ntry:\na_red, b_red = PolyhedralTermList.reduce_polytope(self_mat, self_cons, ctx_mat, ctx_cons)\nexcept ValueError as e:\nraise ValueError(\n\"The constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n) from e\nlogging.debug(\"Reduction: \\n%s\", a_red)\nsimplified = PolyhedralTermList.polytope_to_termlist(a_red, b_red, variables)\nlogging.debug(\"Back to terms: \\n%s\", simplified)\nreturn simplified\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.termlist_to_polytope","title":"<code>termlist_to_polytope(terms, context)</code>  <code>staticmethod</code>","text":"<p>Converts a list of terms with its context into matrix-vector pairs.</p> Example <p>Suppose the list of terms is \\(\\{x+y \\le 1, x - y \\le 4\\}\\) and the context is \\(\\{x + 4w \\le 5\\}\\). The routine extracts all variables and generates an order for them, say, \\([x, w, y]\\). Then the routine returns matrix-vector pairs for both the terms TermList and the context. It returns \\(A = \\left( \\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\\\ 1 &amp;0 &amp;-1 \\end{smallmatrix}\\right)\\) and \\(b = \\left( \\begin{smallmatrix} 1 \\\\ 4 \\end{smallmatrix}\\right)\\) for the current TermList and \\(A_{c} = \\left( \\begin{smallmatrix} 1 &amp; 4 &amp; 0 \\end{smallmatrix}\\right)\\) and \\(b_c = \\left( \\begin{smallmatrix} 5 \\end{smallmatrix}\\right)\\) for the context.</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>PolyhedralTermList</code> <p>list of terms to convert to matrix-vector form.</p> required <code>context</code> <code>PolyhedralTermList</code> <p>Context terms to convert to matrix-vector form.</p> required <p>Returns:</p> Type Description <code>Tuple[List[Var], ndarray, ndarray, ndarray, ndarray]</code> <p>A tuple <code>variables, A, b, a_h, b_h</code> consisting of the variable order and the matrix-vector pairs for the terms and the context.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef termlist_to_polytope(\nterms: PolyhedralTermList, context: PolyhedralTermList\n) -&gt; Tuple[List[Var], np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n\"\"\"\n    Converts a list of terms with its context into matrix-vector pairs.\n    Example:\n        Suppose the list of terms is $\\\\{x+y \\\\le 1, x - y \\\\le 4\\\\}$\n        and the context is $\\\\{x + 4w \\\\le 5\\\\}$. The routine extracts\n        all variables and generates an order for them, say, $[x, w,\n        y]$. Then the routine returns matrix-vector pairs for both the terms\n        TermList and the context. It returns $A = \\\\left(\n        \\\\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\\\\\\\ 1 &amp;0 &amp;-1\n        \\\\end{smallmatrix}\\\\right)$ and $b = \\\\left(\n        \\\\begin{smallmatrix} 1 \\\\\\\\ 4 \\\\end{smallmatrix}\\\\right)$ for the\n        current TermList and $A_{c} = \\\\left( \\\\begin{smallmatrix} 1 &amp;\n        4 &amp; 0 \\\\end{smallmatrix}\\\\right)$ and $b_c = \\\\left(\n        \\\\begin{smallmatrix} 5 \\\\end{smallmatrix}\\\\right)$ for the context.\n    Args:\n        terms:\n            list of terms to convert to matrix-vector form.\n        context:\n            Context terms to convert to matrix-vector form.\n    Returns:\n        A tuple `variables, A, b, a_h, b_h` consisting of the variable\n            order and the matrix-vector pairs for the terms and the context.\n    \"\"\"\nvariables = list(list_union(terms.vars, context.vars))\na = []\nb = []\nfor term in terms.terms:\npol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\na.append(pol)\nb.append(coeff)\na_h = []\nb_h = []\nfor term in context.terms:\npol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\na_h.append(pol)\nb_h.append(coeff)\nif len(context.terms) == 0:\na_h_ret = np.array([[]])\nelse:\na_h_ret = np.array(a_h)\n# logging.debug(\"a is \\n%s\", a)\nreturn variables, np.array(a), np.array(b), a_h_ret, np.array(b_h)\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.to_str_list","title":"<code>to_str_list()</code>","text":"<p>Convert termlist into a list of strings.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings corresponding to the terms of the termlist.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def to_str_list(self) -&gt; List[str]:\n\"\"\"\n    Convert termlist into a list of strings.\n    Returns:\n        A list of strings corresponding to the terms of the termlist.\n    \"\"\"\nstr_list = []\nts = self.terms.copy()\nwhile ts:\ns, rest = serializer.polyhedral_term_list_to_strings(ts)\nstr_list.append(s)\nts = rest\nreturn str_list\n</code></pre>"},{"location":"Polyhedral/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.verify_polytope_containment","title":"<code>verify_polytope_containment(a_l=None, b_l=None, a_r=None, b_r=None)</code>  <code>staticmethod</code>","text":"<p>Tell whether a polytope is contained in another.</p> <p>Parameters:</p> Name Type Description Default <code>a_l</code> <code>Optional[ndarray]</code> <p>Matrix of H-representation of polytope on LHS of inequality.</p> <code>None</code> <code>b_l</code> <code>Optional[ndarray]</code> <p>Vector of H-representation of polytope on LHS of inequality.</p> <code>None</code> <code>a_r</code> <code>Optional[ndarray]</code> <p>Matrix of H-representation of polytope on RHS of inequality.</p> <code>None</code> <code>b_r</code> <code>Optional[ndarray]</code> <p>Vector of H-representation of polytope on RHS of inequality.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if left polytope is contained in right polytope. False otherwise.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef verify_polytope_containment(  # noqa: WPS231\na_l: Optional[np.ndarray] = None,\nb_l: Optional[np.ndarray] = None,\na_r: Optional[np.ndarray] = None,\nb_r: Optional[np.ndarray] = None,\n) -&gt; bool:\n\"\"\"\n    Tell whether a polytope is contained in another.\n    Args:\n        a_l:\n            Matrix of H-representation of polytope on LHS of inequality.\n        b_l:\n            Vector of H-representation of polytope on LHS of inequality.\n        a_r:\n            Matrix of H-representation of polytope on RHS of inequality.\n        b_r:\n            Vector of H-representation of polytope on RHS of inequality.\n    Returns:\n        True if left polytope is contained in right polytope. False otherwise.\n    \"\"\"\nif not isinstance(a_l, np.ndarray):\na_l = np.array([[]])\nif not isinstance(a_r, np.ndarray):\na_r = np.array([[]])\nif not isinstance(b_l, np.ndarray):\nb_l = np.array([])\nif not isinstance(b_r, np.ndarray):\nb_r = np.array([])\n# If the LHS is empty, it is a refinement\nif PolyhedralTermList.is_polytope_empty(a_l, b_l):\nreturn True\n# If the RHS is empty, but not the LHS, not a refinement\nif PolyhedralTermList.is_polytope_empty(a_r, b_r):\nreturn False\n# If no side is empty, check whether the RHS terms are included in the\n# LHS\nn_l, m_l = a_l.shape\nn_r, m_r = a_r.shape\nassert m_l == m_r\nassert n_l == len(b_l)\nassert n_r == len(b_r)\nis_refinement = True\nfor i in range(n_r):\nconstraint = a_r[[i], :]\nobjective = constraint * -1\nb_temp = b_r[i] + 1\nlogging.debug(\"Optimization objective: \\n%s\", objective)\nlogging.debug(\"a_l is \\n%s\", a_l)\nlogging.debug(\"a_r is \\n%s\", a_r)\nlogging.debug(\"b_l is \\n%s\", b_l)\nlogging.debug(\"b_r is \\n%s\", b_r)\na_opt = np.concatenate((a_l, constraint), axis=0)\nb_opt = np.concatenate((b_l, np.array([b_temp])))\nres = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\nb_temp -= 1\nif res[\"status\"] == 2:\nis_refinement = False\nbreak\nelse:\nif -res[\"fun\"] &lt;= b_temp:  # noqa: WPS309\nlogging.debug(\"Redundant constraint\")\nelse:\nis_refinement = False\nbreak\nlogging.debug(\"Optimal value: %s\", -res[\"fun\"])\nlogging.debug(\"Results: %s\", res)\nreturn is_refinement\n</code></pre>"},{"location":"case_studies/","title":"Overview","text":""},{"location":"case_studies/#case-studies","title":"Case Studies","text":"<p>In the following sections we will present case studies that illustrate the use of Pacti for different applications.</p> <p>  Safety of autonomous vehicles  </p> <p> </p> <p>We present a case study to evaluate the perception system of an autonomous car using the quotient operator.</p> <p></p> <p>  Trajectory planning for multi-agent systems  </p> <p> </p> <p>A case study on multi-agent path finding (MAPF) where multiple agents need to reach their target location on a grid world according to a conflict-free strategy. We treat each time step as our viewpoint to find a solution that satisfies the agents' dynamics and collision constraints using the merge operator.</p> <p></p> <p>  Specification-based synthetic biology  </p> <p> </p> <p>A case study on modeling the specifications of a biological circuit and speed up the experimental design process by finding optimal components to use from a library of parts. In the case study, we first build a characterized library of parts as assume-guarantee contracts using existing experimental data from the literature.With the use of Pacti, we demonstrate how scientists may describe the desired top-level behavior as contracts and then computationally choose from a library of available parts to ensure that the components meet the top-level system specification. For the engineered bacteria case study, we find the specification of the sensors that meet the top-level criteria on fold-change of the circuit response. Finally, we also show how we can find the specifications of missing parts in a system. In synthetic biology, it is common to have parts in the system for which no characterization data is available. Using quotient operation on contracts, we can find the constraints that this missing part must satisfy to meet the desired top-level criteria.</p> <p></p> <p>  Signal processing pipelines in digital ICs  </p> <p> </p> <p>A case study on word length analysis and optimization for digital signal processing circuit design.</p> <p></p> <p>  Generating UAV topologies  </p> <p> </p> <p>We demonstrate the application of Pacti in modeling a context-sensitive grammar for generating three-dimensional topologies for Unmanned Aerial Vehicles (UAVs).</p> <p></p> <p>  Space Mission  </p> <p> </p> <p>A case study on modeling the specifications of autonomous tasks for a planning/scheduling onboard of a space mission system.</p> <p></p> <p>  Mars Entry Descent Landing  </p> <p> </p> <p>A case study on modeling a simplified timeline of the Mars 2020 Entry-Descent-Landing.</p> <p></p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#020-2025-06-22","title":"0.2.0 - 2025-06-22","text":"<p>Compare with 0.1.0</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Added user interface for SMT contracts (by Stefan Panjkovic)</li> <li>Added implementation of SMT contracts (by Inigo Incer)</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixing test (204f466 by Inigo Incer).</li> <li>Fixing a bug in variable isolation (c84d086 by Inigo Incer).</li> <li>Fixing spacing (2fd7340 by Inigo Incer).</li> <li>Fixing documentation (it did not build) (022fa89 by Inigo Incer).</li> </ul>"},{"location":"changelog/#010-2023-09-03","title":"0.1.0 - 2023-09-03","text":"<p>Compare with first commit</p>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Added tests for polyhedral contracts (by Apurva Badithela, Josefine Graebener, Inigo Incer, Piergiuseppe Mallozzi, Ayush Pandey, Nicolas Rouquette, and Sheng-Jung Yu)</li> <li>Added methodology for software release (by Apurva Badithela, Josefine Graebener, Inigo Incer, and Ayush Pandey)</li> <li>Added toolchain for software development (by Inigo Incer, Piergiuseppe Mallozzi, Ayush Pandey, and Nicolas Rouquette)</li> <li>Added parser for polyhedral constraints (by Nicolas Rouquette)</li> <li>Added contract support for polyhedral constraints (by Inigo Incer)</li> <li>Added implementation of contract algebra (by Inigo Incer)</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome and greatly appreciated. If you would like to address a bug or add a feature, please first open an issue. If we decide to move forward with the changes, please fork the repo and open a pull request.</p>"},{"location":"contributing/#installation","title":"Installation","text":"<p>Clone the repo and run</p> <pre><code>pdm install\n</code></pre> <p>Running </p><pre><code>make help\n</code></pre> shows all available tasks."},{"location":"contributing/#development","title":"Development","text":"<p>We use pdm to manage dependencies. Use <code>pdm add</code> to install new packages.</p> <p>Add unit tests to make sure the new functionality is covered. If your functionality falls into one of the existing classes, add your tests to the corresponding file under the tests/ directory. Otherwise, create a new file. We use <code>pytest</code> to run our tests. Make sure that your test starts with the name test to ensure that it will be executed when <code>make test</code> is invoked.</p> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>run <code>make check</code> to check everything (types, docs, quality, and dependencies)</li> <li>make sure that all tests pass and the source code coverage meets our criteria</li> </ol> <p>Finally, in your commit message, try to use helpful keywords such as \"add\", \"fix\", \"remove\", \"change\" to describe the changes that you have proposed. This helps in generating change log documentation appropriately. You can read more about writing good commit messages here and here.</p>"},{"location":"contributing/#continuous-integration-and-development","title":"Continuous Integration and Development","text":"<p>Pacti has continuous integration and development setup with Github Actions. Some workflows are automatically run while others are manual. Instructions for all developers:</p> <ol> <li>If you are in the process of developing a feature/fixing a bug in your own development branch: Make sure that the Pacti Development workflow passes. This will automatically be run with every commit, so you should be getting notifications of what Pacti functionality failed (if any).</li> <li>If you are contributing a development feature to any branch (that is, your development has finished): Run the Pacti Development Review workflow. This will test the functionality and also code quality.</li> <li>If you are reviewing a pull-request to the main branch from another developer: Make sure to go to the \"Actions\" tab and run the Pacti Pre-Production workflow manually. This workflow tests the package for functionality and quality on two Python versions.</li> <li>The Pacti Production workflow makes sure that the software works with all OS and all Python versions.</li> </ol>"},{"location":"credits/","title":"Credits","text":"<p>We gratefully acknowledge  ASEE, NSF, DARPA, NASA, and AFOSR for funding parts of this project.</p> <p>We thank Athreyi Badithela for creating the artwork.</p> <p>The following projects were used to build <code>Pacti</code>:</p> <p><code>python</code> | <code>pdm</code> | <code>copier-pdm</code></p>"},{"location":"credits/#exec-1--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>appnope</code> Disable App Nap on macOS &gt;= 10.9 <code>; platform_system == \"Darwin\"</code> <code>0.1.4</code> ? <code>asttokens</code> Annotate AST trees with source code positions <code>&gt;=2.1.0</code> <code>3.0.0</code> Apache 2.0 <code>attrs</code> Classes Without Boilerplate <code>&gt;=22.2.0</code> <code>25.3.0</code> ? <code>beautifulsoup4</code> Screen-scraping library <code>4.13.4</code> MIT License <code>bleach</code> An easy safelist-based HTML-sanitizing tool. <code>[css]!=5.0.0</code> <code>6.2.0</code> Apache Software License <code>cffi</code> Foreign Function Interface for Python calling C code. <code>; implementation_name == \"pypy\"</code> <code>1.17.1</code> ? <code>colorama</code> Cross-platform colored terminal text. <code>; sys_platform == \"win32\"</code> <code>0.4.6</code> BSD License <code>comm</code> Jupyter Python Comm implementation, for usage in ipykernel, xeus-python etc. <code>&gt;=0.1.1</code> <code>0.2.2</code> BSD License <code>contourpy</code> Python library for calculating contours of 2D quadrilateral grids <code>&gt;=1.0.1</code> <code>1.3.0</code> BSD License <code>cycler</code> Composable style cycles <code>&gt;=0.10</code> <code>0.12.1</code> BSD License <code>debugpy</code> An implementation of the Debug Adapter Protocol for Python <code>&gt;=1.6.5</code> <code>1.8.14</code> MIT <code>decorator</code> Decorators for Humans <code>5.2.1</code> BSD-2-Clause <code>defusedxml</code> XML bomb protection for Python stdlib modules <code>0.7.1</code> PSFL <code>exceptiongroup</code> Backport of PEP 654 (exception groups) <code>; python_version &lt; \"3.11\"</code> <code>1.3.0</code> ? <code>executing</code> Get the currently executing AST node of a frame, and other information <code>&gt;=1.2.0</code> <code>2.2.0</code> MIT <code>fastjsonschema</code> Fastest Python implementation of JSON schema <code>&gt;=2.15</code> <code>2.21.1</code> BSD <code>fonttools</code> Tools to manipulate font files <code>&gt;=4.22.0</code> <code>4.58.4</code> MIT <code>importlib-metadata</code> Read metadata from Python packages <code>&gt;=4.8.3; python_version &lt; \"3.10\"</code> <code>8.7.0</code> ? <code>importlib-resources</code> Read resources from Python packages <code>&gt;=3.2.0; python_version &lt; \"3.10\"</code> <code>6.5.2</code> ? <code>ipykernel</code> IPython Kernel for Jupyter <code>&gt;=6.25.0</code> <code>6.29.5</code> BSD License <code>ipython</code> IPython: Productive Interactive Computing <code>&gt;=7.23.1</code> <code>8.18.1</code> BSD-3-Clause <code>jedi</code> An autocompletion tool for Python that can be used for text editors. <code>&gt;=0.16</code> <code>0.19.2</code> MIT <code>jinja2</code> A very fast and expressive template engine. <code>&gt;=3.0</code> <code>3.1.6</code> BSD License <code>jsonschema</code> An implementation of JSON Schema validation for Python <code>&gt;=2.6</code> <code>4.24.0</code> ? <code>jsonschema-specifications</code> The JSON Schema meta-schemas and vocabularies, exposed as a Registry <code>&gt;=2023.03.6</code> <code>2025.4.1</code> ? <code>jupyter-client</code> Jupyter protocol implementation and client libraries <code>&gt;=6.1.12</code> <code>8.6.3</code> BSD License <code>jupyter-core</code> Jupyter core package. A base package on which Jupyter projects rely. <code>!=5.0.*,&gt;=4.12</code> <code>5.8.1</code> ? <code>jupyterlab-pygments</code> Pygments theme using JupyterLab CSS variables <code>0.3.0</code> BSD License <code>kiwisolver</code> A fast implementation of the Cassowary constraint solver <code>&gt;=1.3.1</code> <code>1.4.7</code> BSD License <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0</code> <code>3.0.2</code> BSD License <code>matplotlib</code> Python plotting package <code>&gt;=3.6.2</code> <code>3.9.4</code> Python Software Foundation License <code>matplotlib-inline</code> Inline Matplotlib backend for Jupyter <code>&gt;=0.1</code> <code>0.1.7</code> BSD License <code>mistune</code> A sane and fast Markdown parser with useful plugins and renderers <code>&lt;4,&gt;=2.0.3</code> <code>3.1.3</code> BSD-3-Clause <code>mpmath</code> Python library for arbitrary-precision floating-point arithmetic <code>&lt;1.4,&gt;=1.1.0</code> <code>1.3.0</code> BSD <code>nbclient</code> A client library for executing notebooks. Formerly nbconvert's ExecutePreprocessor. <code>&gt;=0.5.0</code> <code>0.10.2</code> BSD License <code>nbconvert</code> Converting Jupyter Notebooks (.ipynb files) to other formats.  Output formats include asciidoc, html, latex, markdown, pdf, py, rst, script.  nbconvert can be used both as a Python library (<code>import nbconvert</code>) or as a command line tool (invoked as <code>jupyter nbconvert ...</code>). <code>&gt;=7.16.5</code> <code>7.16.6</code> BSD License <code>nbformat</code> The Jupyter Notebook format <code>&gt;=5.7</code> <code>5.10.4</code> BSD License <code>nest-asyncio</code> Patch asyncio to allow nested event loops <code>1.6.0</code> BSD <code>numpy</code> Fundamental package for array computing in Python <code>&gt;=1.24.1</code> <code>2.0.2</code> BSD License <code>packaging</code> Core utilities for Python packages <code>25.0</code> BSD License <code>pandocfilters</code> Utilities for writing pandoc filters in python <code>&gt;=1.4.1</code> <code>1.5.1</code> BSD-3-Clause <code>parso</code> A Python Parser <code>&lt;0.9.0,&gt;=0.8.4</code> <code>0.8.4</code> MIT <code>pexpect</code> Pexpect allows easy control of interactive console applications. <code>&gt;4.3; sys_platform != \"win32\"</code> <code>4.9.0</code> ? <code>pillow</code> Python Imaging Library (Fork) <code>&gt;=8</code> <code>11.2.1</code> ? <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a <code>user data dir</code>. <code>&gt;=2.5</code> <code>4.3.8</code> MIT License <code>prompt-toolkit</code> Library for building powerful interactive command lines in Python <code>&lt;3.1.0,&gt;=3.0.41</code> <code>3.0.51</code> BSD License <code>psutil</code> Cross-platform lib for process and system monitoring in Python.  NOTE: the syntax of this script MUST be kept compatible with Python 2.7. <code>7.0.0</code> BSD-3-Clause <code>ptyprocess</code> Run a subprocess in a pseudo terminal <code>&gt;=0.5</code> <code>0.7.0</code> ? <code>pure-eval</code> Safely evaluate AST nodes without side effects <code>0.2.3</code> MIT <code>pycparser</code> C parser in Python <code>2.22</code> ? <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>&gt;=2.4.0</code> <code>2.19.2</code> BSD-2-Clause <code>pyparsing</code> pyparsing module - Classes and methods to define and execute parsing grammars <code>&gt;=2.3.1</code> <code>3.2.3</code> MIT License <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.2</code> <code>2.9.0.post0</code> Dual License <code>pywin32</code> Python for Window Extensions <code>&gt;=300; sys_platform == \"win32\" and platform_python_implementation != \"PyPy\"</code> <code>310</code> PSF <code>pyzmq</code> Python bindings for 0MQ <code>&gt;=24</code> <code>27.0.0</code> BSD License <code>referencing</code> JSON Referencing + Python <code>&gt;=0.28.4</code> <code>0.36.2</code> ? <code>rpds-py</code> Python bindings to Rust's persistent data structures (rpds) <code>&gt;=0.7.1</code> <code>0.25.1</code> MIT <code>scipy</code> Fundamental algorithms for scientific computing in Python <code>&gt;=1.10.0</code> <code>1.13.1</code> BSD License <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.17.0</code> MIT <code>soupsieve</code> A modern CSS selector implementation for Beautiful Soup. <code>&gt;1.2</code> <code>2.7</code> MIT License <code>stack-data</code> Extract data from python stack frames and tracebacks for informative displays <code>0.6.3</code> MIT <code>sympy</code> Computer algebra system (CAS) in Python <code>&gt;=1.11.1</code> <code>1.14.0</code> BSD <code>tinycss2</code> A tiny CSS parser <code>&lt;1.5,&gt;=1.1.0</code> <code>1.4.0</code> BSD License <code>tornado</code> Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed. <code>&gt;=6.1</code> <code>6.5.1</code> Apache-2.0 <code>traitlets</code> Traitlets Python configuration system <code>&gt;=5.4.0</code> <code>5.14.3</code> BSD License <code>typing-extensions</code> Backported and Experimental Type Hints for Python 3.9+ <code>&gt;=4.5.0</code> <code>4.14.0</code> ? <code>wcwidth</code> Measures the displayed width of unicode strings in a terminal <code>0.2.13</code> MIT <code>webencodings</code> Character encoding aliases for legacy web content <code>&gt;=0.4</code> <code>0.5.1</code> BSD <code>zipp</code> Backport of pathlib-compatible object wrapper for zip files <code>&gt;=3.20</code> <code>3.23.0</code> ?"},{"location":"credits/#exec-1--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>ansimarkup</code> Produce colored terminal text with an xml-like markup <code>~=1.4</code> <code>1.5.0</code> Revised BSD License <code>appdirs</code> A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=1.4</code> <code>1.4.4</code> MIT <code>autoflake</code> Removes unused imports and unused variables <code>&gt;=1.4</code> <code>2.3.1</code> MIT <code>babel</code> Internationalization utilities <code>~=2.12</code> <code>2.17.0</code> BSD-3-Clause <code>black</code> The uncompromising code formatter. <code>&gt;=21.10b0</code> <code>25.1.0</code> MIT License <code>certifi</code> Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2025.6.15</code> MPL-2.0 <code>charset-normalizer</code> The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&lt;4,&gt;=2</code> <code>3.4.2</code> MIT <code>click</code> Composable command line interface toolkit <code>&gt;=8.0.0</code> <code>8.1.8</code> BSD License <code>colorama</code> Cross-platform colored terminal text. <code>; platform_system == \"Windows\"</code> <code>0.4.6</code> BSD License <code>duty</code> A simple task runner. <code>&gt;=0.7</code> <code>1.6.0</code> ISC <code>eval-type-backport</code> Like <code>typing._eval_type</code>, but lets older Python versions use newer typing features. <code>; python_version &lt; \"3.10\"</code> <code>0.2.2</code> ? <code>failprint</code> Run a command, print its output only if it fails. <code>!=1.0.0,&gt;=0.11</code> <code>1.0.3</code> ISC <code>ghp-import</code> Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License <code>git-changelog</code> Automatic Changelog generator using Jinja2 templates. <code>&gt;=0.4</code> <code>2.5.3</code> ISC <code>griffe</code> Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=1.6.2</code> <code>1.7.3</code> ? <code>idna</code> Internationalized Domain Names in Applications (IDNA) <code>&lt;4,&gt;=2.5</code> <code>3.10</code> BSD License <code>importlib-metadata</code> Read metadata from Python packages <code>&gt;=4.4; python_version &lt; \"3.10\"</code> <code>8.7.0</code> ? <code>isort</code> A Python utility / library to sort Python imports. <code>&gt;=5.10</code> <code>6.0.1</code> MIT License <code>jinja2</code> A very fast and expressive template engine. <code>&lt;4,&gt;=2.11</code> <code>3.1.6</code> BSD License <code>lxml</code> Powerful and Pythonic XML processing library combining libxml2/libxslt with the ElementTree API. <code>&gt;=4.7.0</code> <code>5.4.0</code> BSD-3-Clause <code>markdown</code> Python implementation of John Gruber's Markdown. <code>&gt;=3.3.3</code> <code>3.8.2</code> ? <code>markdown-callouts</code> Markdown extension: a classier syntax for admonitions <code>&gt;=0.2</code> <code>0.4.0</code> MIT License <code>markdown-exec</code> Utilities to execute code blocks in Markdown files. <code>&gt;=0.5</code> <code>1.10.3</code> ? <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0</code> <code>3.0.2</code> BSD License <code>mergedeep</code> A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License <code>mkdocs</code> Project documentation with Markdown. <code>&gt;=1.6</code> <code>1.6.1</code> BSD License <code>mkdocs-autorefs</code> Automatically link across pages in MkDocs. <code>&gt;=1.4</code> <code>1.4.2</code> ? <code>mkdocs-coverage</code> MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;=0.2</code> <code>1.1.0</code> ISC <code>mkdocs-gen-files</code> MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;=0.3</code> <code>0.5.0</code> MIT License <code>mkdocs-get-deps</code> MkDocs extension that lists all dependencies according to a mkdocs.yml file <code>&gt;=0.2.0</code> <code>0.2.0</code> MIT License <code>mkdocs-literate-nav</code> MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;=0.4</code> <code>0.6.2</code> MIT License <code>mkdocs-material</code> Documentation that simply works <code>&gt;=9.2,&lt;9.3</code> <code>9.2.8</code> MIT License <code>mkdocs-material-extensions</code> Extension pack for Python Markdown and MkDocs Material. <code>~=1.1</code> <code>1.3.1</code> MIT License <code>mkdocs-section-index</code> MkDocs plugin to allow clickable sections that lead to an index page <code>&gt;=0.3</code> <code>0.3.10</code> MIT License <code>mkdocs-video</code> <code>&gt;=1.3.0</code> <code>1.5.0</code> MIT <code>mkdocstrings</code> Automatic documentation from sources, for MkDocs. <code>[python]&gt;=0.28</code> <code>0.29.1</code> ? <code>mkdocstrings-python</code> A Python handler for mkdocstrings. <code>&gt;=1.16.2</code> <code>1.16.12</code> ? <code>mypy-extensions</code> Type system extensions for programs checked with the mypy type checker. <code>&gt;=0.4.3</code> <code>1.1.0</code> ? <code>packaging</code> Core utilities for Python packages <code>&gt;=22.0</code> <code>25.0</code> BSD License <code>paginate</code> Divides large result sets into pages for easier browsing <code>~=0.5</code> <code>0.5.7</code> MIT <code>pathspec</code> Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.9.0</code> <code>0.12.1</code> Mozilla Public License 2.0 (MPL 2.0) <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a <code>user data dir</code>. <code>&gt;=2</code> <code>4.3.8</code> MIT License <code>ptyprocess</code> Run a subprocess in a pseudo terminal <code>~=0.6; sys_platform != \"win32\"</code> <code>0.7.0</code> ? <code>pyflakes</code> passive checker of Python programs <code>&gt;=3.0.0</code> <code>3.4.0</code> MIT <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>~=2.16</code> <code>2.19.2</code> BSD-2-Clause <code>pymdown-extensions</code> Extension pack for Python Markdown. <code>&gt;=9</code> <code>10.16</code> MIT License <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.9.0.post0</code> Dual License <code>pyyaml</code> YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0.2</code> MIT <code>pyyaml-env-tag</code> A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>1.1</code> ? <code>regex</code> Alternative regular expression module, to replace re. <code>~=2023.8</code> <code>2023.12.25</code> Apache Software License <code>requests</code> Python HTTP for Humans. <code>~=2.31</code> <code>2.32.4</code> Apache-2.0 <code>semver</code> Python helper for Semantic Versioning (https://semver.org) <code>&gt;=2.13</code> <code>3.0.4</code> BSD License <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.17.0</code> MIT <code>toml</code> Python Library for Tom's Obvious, Minimal Language <code>&gt;=0.10</code> <code>0.10.2</code> MIT <code>tomli</code> A lil' TOML parser <code>&gt;=2.0.1; python_version &lt; \"3.11\"</code> <code>2.2.1</code> ? <code>typing-extensions</code> Backported and Experimental Type Hints for Python 3.9+ <code>&gt;=4.0.1; python_version &lt; \"3.11\"</code> <code>4.14.0</code> ? <code>urllib3</code> HTTP library with thread-safe connection pooling, file post, and more. <code>&lt;3,&gt;=1.21.1</code> <code>2.5.0</code> ? <code>urlopen</code> A simple printer of automated lists <code>&gt;=1.0.0</code> <code>1.0.0</code> ? <code>watchdog</code> Filesystem events monitoring <code>&gt;=2.0</code> <code>6.0.0</code> Apache-2.0 <code>zipp</code> Backport of pathlib-compatible object wrapper for zip files <code>&gt;=3.20</code> <code>3.23.0</code> ?"},{"location":"installing/","title":"Installing","text":"<p>Pacti runs on <code>Python &gt;= 3.8</code>. You can verify your Python version by running the command</p> <p><code>python --version</code></p> <p>Pacti is installed as a standard Python package using pip:</p> <p><code>pip install pacti</code></p>"},{"location":"iocontract/","title":"IoContract","text":"<p>IoContracts definitions.</p> <p>IoContracts contains Pacti's basic definitions: Var, Term, TemList, and IoContract. Var creates variables; Term is an abstract class representing constraints; a TermList (also an abstract class) is a collection of terms semantically equivalent to the term which is the conjunction of all terms contained in the TermList; IoContract is an assume-guarantee specification consisting of assumptions, guarantees, and input and output variables. The assumptions and guarantees are given by TermLists. Assumptions make predicates only on inputs, and guarantees on both input and outputs (and no other variable).</p> <p>This module implements all supported contract operations and relations. In order to instantiate contracts and perform this operations, it is necessary to extend Term and TermList with specific constraint formalisms.</p>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract","title":"<code>IoContract</code>","text":"<p>               Bases: <code>Generic[TermList_t]</code></p> <p>Basic type for an IO contract.</p> <p>Attributes:</p> Name Type Description <code>inputvars</code> <p>Variables which are inputs of the implementations of the contract.</p> <code>outputvars</code> <p>Variables which are outputs of the implementations of the contract.</p> <code>a(TermList)</code> <p>Contract assumptions.</p> <code>g(TermList)</code> <p>Contract guarantees.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>class IoContract(Generic[TermList_t]):\n\"\"\"\n    Basic type for an IO contract.\n    Attributes:\n        inputvars:\n            Variables which are inputs of the implementations of the contract.\n        outputvars:\n            Variables which are outputs of the implementations of the contract.\n        a(TermList): Contract assumptions.\n        g(TermList): Contract guarantees.\n    \"\"\"\ndef __init__(\nself,\nassumptions: TermList_t,\nguarantees: TermList_t,\ninput_vars: List[Var],\noutput_vars: List[Var],\nsimplify: bool = True,\n) -&gt; None:\n\"\"\"\n        Class constructor.\n        Args:\n            assumptions: The assumptions of the contract.\n            guarantees: The guarantees of the contract.\n            input_vars: The input variables of the contract.\n            output_vars: The output variables of the contract.\n            simplify: Whether to simplify the guarantees with respect to the assumptions.\n        Raises:\n            IncompatibleArgsError: Arguments provided does not produce a valid IO contract.\n        \"\"\"\n# make sure the input and output variables have no repeated entries\nif len(input_vars) != len(set(input_vars)):\nraise IncompatibleArgsError(\n\"The following input variables appear multiple times in argument %s\"\n% (set(list_diff(input_vars, list(set(input_vars)))))\n)\nif len(output_vars) != len(set(output_vars)):\nraise IncompatibleArgsError(\n\"The following output variables appear multiple times in argument %s\"\n% (set(list_diff(output_vars, list(set(output_vars)))))\n)\n# make sure the input &amp; output variables are disjoint\nif list_intersection(input_vars, output_vars):\nraise IncompatibleArgsError(\n\"The following variables appear in inputs and outputs: %s\"\n% (list_intersection(input_vars, output_vars))\n)\n# make sure the assumptions only contain input variables\nif list_diff(assumptions.vars, input_vars):\nraise IncompatibleArgsError(\n\"The following variables appear in the assumptions but are not inputs: %s\"\n% (list_diff(assumptions.vars, input_vars))\n)\n# make sure the guarantees only contain input or output variables\nif list_diff(guarantees.vars, list_union(input_vars, output_vars)):\nraise IncompatibleArgsError(\n\"The guarantees contain the following variables which are neither\"\n\"inputs nor outputs: %s. Inputs: %s. Outputs: %s. Guarantees: %s\"\n% (list_diff(guarantees.vars, list_union(input_vars, output_vars)), input_vars, output_vars, guarantees)\n)\nself.a: TermList_t = assumptions.copy()\nself.inputvars = input_vars.copy()\nself.outputvars = output_vars.copy()\nif simplify:\nself.g = guarantees.simplify(self.a)\nelse:\nself.g = guarantees.copy()\ndef simplify(self) -&gt; None:\n\"\"\"Simplifies guarantees given assumptions.\"\"\"\nself.g = self.g.simplify(self.a)\n@property\ndef vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"\n        The list of variables in the interface of the contract.\n        Returns:\n            Input and output variables of the contract.\n        \"\"\"\nreturn list_union(self.inputvars, self.outputvars)\ndef __str__(self) -&gt; str:\nreturn (\n\"InVars: \"\n+ \"[\"\n+ \", \".join([v.name for v in self.inputvars])\n+ \"]\"\n+ \"\\nOutVars:\"\n+ \"[\"\n+ \", \".join([v.name for v in self.outputvars])\n+ \"]\"\n+ \"\\nA: \"\n+ str(self.a)\n+ \"\\n\"\n+ \"G: \"\n+ str(self.g)\n)\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError\nreturn (\nself.inputvars == other.inputvars\nand self.outputvars == self.outputvars\nand self.a == other.a\nand self.g == other.g\n)\ndef __hash__(self) -&gt; int:\nreturn hash((tuple(self.inputvars), tuple(self.outputvars), self.a, self.g))\ndef rename_variable(  # noqa: WPS231 too much cognitive complexity\nself: IoContract_t, source_var: Var, target_var: Var\n) -&gt; IoContract_t:\n\"\"\"\n        Rename a variable in a contract.\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n        Returns:\n            A contract with `source_var` replaced by `target_var`.\n        Raises:\n            IncompatibleArgsError: The new variable is both an input and output of the resulting contract.\n        \"\"\"\ninputvars = self.inputvars.copy()\noutputvars = self.outputvars.copy()\nassumptions = self.a.copy()\nguarantees = self.g.copy()\nif source_var != target_var:\nif source_var in inputvars:\nif target_var in outputvars:\nraise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\nelif target_var not in inputvars:\ninputvars[inputvars.index(source_var)] = target_var\nelse:\ninputvars.remove(source_var)\nassumptions = assumptions.rename_variable(source_var, target_var)\nguarantees = guarantees.rename_variable(source_var, target_var)\nelif source_var in outputvars:\nif target_var in inputvars:\nraise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\nelif target_var not in outputvars:\noutputvars[outputvars.index(source_var)] = target_var\nelse:\noutputvars.remove(source_var)\nassumptions = assumptions.rename_variable(source_var, target_var)\nguarantees = guarantees.rename_variable(source_var, target_var)\nreturn type(self)(assumptions, guarantees, inputvars, outputvars)\ndef copy(self: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n        Makes copy of contract.\n        Returns:\n            Copy of contract.\n        \"\"\"\ninputvars = self.inputvars.copy()\noutputvars = self.outputvars.copy()\nassumptions = self.a.copy()\nguarantees = self.g.copy()\nreturn type(self)(assumptions, guarantees, inputvars, outputvars)\ndef __le__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError()\nreturn self.refines(other)\ndef __repr__(self) -&gt; str:\nreturn \"&lt;Var {0}&gt;\".format(self)\ndef can_compose_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether the contract can be composed with another contract.\n        Args:\n            other:\n                Contract whose possibility to compose with self we are\n                verifying.\n        Returns:\n            True if the contracts can be composed. False otherwise.\n        \"\"\"\n# make sure lists of output variables don't intersect\nreturn len(list_intersection(self.outputvars, other.outputvars)) == 0\ndef can_quotient_by(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether the contract can quotiented by another contract.\n        Args:\n            other: potential quotient by which self would be quotiented.\n        Returns:\n            True if the IO profiles of the contracts allow the quotient to\n                exist. False otherwise.\n        \"\"\"\n# make sure the top level outputs not contained in outputs of the\n# existing component do not intersect with the inputs of the existing\n# component\nreturn len(list_intersection(list_diff(self.outputvars, other.outputvars), other.inputvars)) == 0\ndef shares_io_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether two contracts have the same IO signature.\n        Args:\n            other: contract whose IO signature is compared with self.\n        Returns:\n            True if the contracts have the same IO profile.\n        \"\"\"\nreturn lists_equal(self.inputvars, other.inputvars) &amp; lists_equal(self.outputvars, other.outputvars)\ndef refines(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether the given contract is a refinement of another.\n        Return self &lt;= other.\n        Args:\n            other: contract being compared with self.\n        Returns:\n            True if the calling contract refines the argument.\n        Raises:\n            IncompatibleArgsError: Refinement cannot be computed.\n        \"\"\"\nif not self.shares_io_with(other):\nraise IncompatibleArgsError(\"Contracts do not share IO\")\nassumptions_check: bool = other.a &lt;= self.a\nguarantees_check: bool = (self.g | other.a) &lt;= (other.g | other.a)\nreturn assumptions_check and guarantees_check\ndef compose(\nself: IoContract_t,\nother: IoContract_t,\nvars_to_keep: Any = None,\nsimplify: bool = True,\n) -&gt; IoContract_t:\n\"\"\"Compose IO contracts.\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n        Returns:\n            The abstracted composition of the two contracts.\n        \"\"\"\nresult, _ = self.compose_tactics(other, vars_to_keep, simplify)\nreturn result\ndef compose_tactics(  # noqa: WPS231\nself: IoContract_t,\nother: IoContract_t,\nvars_to_keep: Any = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[IoContract_t, List[TacticStatistics]]:  # noqa: WPS231\n\"\"\"Compose IO contracts with support for specifying the order of tactics and measuring their use.\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n            tactics_order:\n                The order of tactics to try for variable term elimination.\n        Returns:\n            A tuple of the abstracted composition of the two contracts and of the list of tactics used.\n        Raises:\n            IncompatibleArgsError: An error occurred during composition.\n        \"\"\"\nif tactics_order is None:\ntactics_order = []\nif vars_to_keep is None:\nvars_to_keep = []\nconflict_vars = list_diff(vars_to_keep, list_union(self.outputvars, other.outputvars))\nif conflict_vars:\nraise IncompatibleArgsError(\"Asked to keep variables %s, which are not outputs\" % (conflict_vars))\nlogging.debug(\"Composing contracts \\n%s and \\n%s\", self, other)\nintvars = list_union(\nlist_intersection(self.outputvars, other.inputvars), list_intersection(self.inputvars, other.outputvars)\n)\ninputvars = list_diff(list_union(self.inputvars, other.inputvars), intvars)\noutputvars = list_diff(list_union(self.outputvars, other.outputvars), intvars)\n# remove requested variables\nintvars = list_diff(intvars, vars_to_keep)\noutputvars = list_union(outputvars, vars_to_keep)\nselfinputconst = self.a.vars\notherinputconst = other.a.vars\ncycle_present = (\nlen(list_intersection(self.inputvars, other.outputvars)) &gt; 0\nand len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\n)\nassumptions_forbidden_vars = list_union(intvars, outputvars)\nif not self.can_compose_with(other):\nraise IncompatibleArgsError(\n\"Cannot compose the following contracts due to incompatible IO profiles:\\n %s \\n %s\" % (self, other)\n)\nother_helps_self = len(list_intersection(other.outputvars, self.inputvars)) &gt; 0\nself_helps_other = len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\nother_drives_const_inputs = len(list_intersection(other.outputvars, selfinputconst)) &gt; 0\nself_drives_const_inputs = len(list_intersection(self.outputvars, otherinputconst)) &gt; 0\ntactics_used: List[TacticStatistics] = []\n# process assumptions\nif cycle_present and (other_drives_const_inputs or self_drives_const_inputs):\nraise IncompatibleArgsError(\"Cannot compose contracts due to feedback\")\nelif self_helps_other and not other_helps_self:\nlogging.debug(\"Assumption computation: self provides context for other\")\n(new_a, used) = other.a.elim_vars_by_refining(\nself.a | self.g, assumptions_forbidden_vars, simplify=True, tactics_order=tactics_order\n)\ntactics_used.append(used)\nconflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\nif conflict_variables:\nraise IncompatibleArgsError(\n\"Could not eliminate variables {}\\n\".format([str(x) for x in assumptions_forbidden_vars])\n+ \"by refining the assumptions \\n{}\\n\".format(new_a.get_terms_with_vars(assumptions_forbidden_vars))\n+ \"using guarantees \\n{}\\n\".format(self.a | self.g)\n)\nassumptions = new_a | self.a\nelif other_helps_self and not self_helps_other:\nlogging.debug(\"****** Assumption computation: other provides context for self\")\n(new_a, used) = self.a.elim_vars_by_refining(\nother.a | other.g, assumptions_forbidden_vars, simplify=True, tactics_order=tactics_order\n)\ntactics_used.append(used)\nconflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\nif conflict_variables:\nraise IncompatibleArgsError(\n\"Could not eliminate variables {}\".format([str(x) for x in assumptions_forbidden_vars])\n+ \" by refining the assumptions \\n{}\\n\".format(\nnew_a.get_terms_with_vars(assumptions_forbidden_vars)\n)\n+ \"using guarantees \\n{}\\n\".format(other.a | other.g)\n)\nassumptions = new_a | other.a\n# contracts can't help each other\nelse:\nlogging.debug(\"****** Assumption computation: other provides context for self\")\nassumptions = self.a | other.a\nlogging.debug(\"Assumption computation: computed assumptions:\\n%s\", assumptions)\nif simplify:\nassumptions = assumptions.simplify()\n# process guarantees\nlogging.debug(\"****** Computing guarantees\")\ng1_t = self.g.copy()\ng2_t = other.g.copy()\n(g1, used) = g1_t.elim_vars_by_relaxing(g2_t, intvars, simplify, tactics_order)\ntactics_used.append(used)\n(g2, used) = g2_t.elim_vars_by_relaxing(g1_t, intvars, simplify, tactics_order)\ntactics_used.append(used)\nallguarantees = g1 | g2\n(allguarantees, used) = allguarantees.elim_vars_by_relaxing(assumptions, intvars, simplify, tactics_order)\ntactics_used.append(used)\n# eliminate terms with forbidden vars\nterms_to_elim = allguarantees.get_terms_with_vars(intvars)\nallguarantees -= terms_to_elim\nreturn type(self)(assumptions, allguarantees, inputvars, outputvars), tactics_used\ndef quotient(\nself: IoContract_t,\nother: IoContract_t,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\n) -&gt; IoContract_t:\n\"\"\"Compute the contract quotient.\n        Compute the quotient self/other of the two given contracts and refine\n        the result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n        Returns:\n            The refined quotient self/other.\n        \"\"\"\nresult, _ = self.quotient_tactics(other, additional_inputs, simplify)\nreturn result\ndef quotient_tactics(  # noqa: WPS231\nself: IoContract_t,\nother: IoContract_t,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[IoContract_t, List[TacticStatistics]]:\n\"\"\"Compute the contract quotient with support for specifying the order of tactics and measuring their use.\n        Compute the quotient self/other of the two given contracts and refine\n        the result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n            tactics_order:\n                The order of tactics to try for variable term elimination.\n        Returns:\n            A tuple of the refined quotient self/other and the list of tactics used.\n        Raises:\n            IncompatibleArgsError: Arguments provided are incompatible with computation of the quotient.\n        \"\"\"\nif tactics_order is None:\ntactics_order = []\nif not additional_inputs:\nadditional_inputs = []\nif not self.can_quotient_by(other):\nraise IncompatibleArgsError(\"Contracts cannot be quotiented due to incompatible IO\")\nif list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)):\nraise IncompatibleArgsError(\n\"The additional inputs %s are neither top level inputs nor existing component outputs\"\n% (list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)))\n)\noutputvars = list_union(\nlist_diff(self.outputvars, other.outputvars), list_diff(other.inputvars, self.inputvars)\n)\ninputvars = list_union(list_diff(self.inputvars, other.inputvars), list_diff(other.outputvars, self.outputvars))\ninputvars = list_union(inputvars, additional_inputs)\nintvars = list_union(\nlist_intersection(self.outputvars, other.outputvars), list_intersection(self.inputvars, other.inputvars)\n)\nintvars = list_diff(intvars, additional_inputs)\ntactics_used: List[TacticStatistics] = []\n# get assumptions\nlogging.debug(\"Computing quotient assumptions\")\nassumptions = copy.deepcopy(self.a)\nempty_context = type(assumptions)([])\nif assumptions.refines(other.a):\nlogging.debug(\"Extending top-level assumptions with divisor's guarantees\")\nassumptions = assumptions | other.g\n(assumptions, used) = assumptions.elim_vars_by_relaxing(\nempty_context, list_union(intvars, outputvars), simplify, tactics_order\n)\ntactics_used.append(used)\nlogging.debug(\"Assumptions after processing: %s\", assumptions)\n# get guarantees\nlogging.debug(\"Computing quotient guarantees\")\nguarantees: TermList_t = self.g\nlogging.debug(\"Using existing guarantees to aid system-level guarantees\")\ntry:  # noqa: WPS229\n(guarantees, used) = guarantees.elim_vars_by_refining(other.g | self.a, intvars, simplify, tactics_order)\ntactics_used.append(used)\nexcept ValueError:\nguarantees = self.g\nlogging.debug(\"Guarantees are %s\" % (guarantees))\nlogging.debug(\"Using system-level assumptions to aid quotient guarantees\")\nguarantees = guarantees | other.a\ntry:  # noqa: WPS229\n(guarantees, used) = guarantees.elim_vars_by_refining(self.a, intvars, simplify, tactics_order)\ntactics_used.append(used)\nexcept ValueError:\n...\nlogging.debug(\"Guarantees after processing: %s\", guarantees)\nconflict_variables = list_intersection(guarantees.vars, intvars)\nif conflict_variables:\nraise IncompatibleArgsError(\n\"Could not eliminate variables \\n{}\".format([str(x) for x in conflict_variables])\n+ \"by refining the guarantees \\n{}\\n\".format(guarantees.get_terms_with_vars(intvars))\n)\nreturn type(self)(assumptions, guarantees, inputvars, outputvars), tactics_used\ndef merge(self: IoContract_t, other: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n        Compute the merging operation for two contracts.\n        Compute the merging operation of the two given contracts. No\n        abstraction/refinement is applied.\n        Args:\n            other: The contract with which we are merging self.\n        Returns:\n            The result of merging.\n        Raises:\n            IncompatibleArgsError: trying to merge different contract types.\n        \"\"\"\nif not isinstance(self, type(other)):\nraise IncompatibleArgsError(\"Asked to merge incompatible contracts\")\ninput_vars = list_union(self.inputvars, other.inputvars)\noutput_vars = list_union(self.outputvars, other.outputvars)\nassumptions = self.a | other.a\nguarantees = self.g | other.g\nreturn type(self)(assumptions, guarantees, input_vars, output_vars)\ndef contains_environment(self, component: TermList) -&gt; bool:\n\"\"\"\n        Tell whether a component is a valid environment for the contract.\n        Args:\n            component: The component in question.\n        Returns:\n            True if the component is a valid environment; false otherwise.\n        \"\"\"\nreturn component &lt;= self.a\ndef contains_implementation(self, component: TermList) -&gt; bool:\n\"\"\"\n        Tell whether a component is a valid implementation for the contract.\n        Args:\n            component:\n                The component in question.\n        Returns:\n            True if the component is a valid implementation; false otherwise.\n        \"\"\"\nreturn (component | self.a) &lt;= (self.g | self.a)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.vars","title":"<code>vars</code>  <code>property</code>","text":"<p>The list of variables in the interface of the contract.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>Input and output variables of the contract.</p>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.__init__","title":"<code>__init__(assumptions, guarantees, input_vars, output_vars, simplify=True)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>TermList_t</code> <p>The assumptions of the contract.</p> required <code>guarantees</code> <code>TermList_t</code> <p>The guarantees of the contract.</p> required <code>input_vars</code> <code>List[Var]</code> <p>The input variables of the contract.</p> required <code>output_vars</code> <code>List[Var]</code> <p>The output variables of the contract.</p> required <code>simplify</code> <code>bool</code> <p>Whether to simplify the guarantees with respect to the assumptions.</p> <code>True</code> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>Arguments provided does not produce a valid IO contract.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def __init__(\nself,\nassumptions: TermList_t,\nguarantees: TermList_t,\ninput_vars: List[Var],\noutput_vars: List[Var],\nsimplify: bool = True,\n) -&gt; None:\n\"\"\"\n    Class constructor.\n    Args:\n        assumptions: The assumptions of the contract.\n        guarantees: The guarantees of the contract.\n        input_vars: The input variables of the contract.\n        output_vars: The output variables of the contract.\n        simplify: Whether to simplify the guarantees with respect to the assumptions.\n    Raises:\n        IncompatibleArgsError: Arguments provided does not produce a valid IO contract.\n    \"\"\"\n# make sure the input and output variables have no repeated entries\nif len(input_vars) != len(set(input_vars)):\nraise IncompatibleArgsError(\n\"The following input variables appear multiple times in argument %s\"\n% (set(list_diff(input_vars, list(set(input_vars)))))\n)\nif len(output_vars) != len(set(output_vars)):\nraise IncompatibleArgsError(\n\"The following output variables appear multiple times in argument %s\"\n% (set(list_diff(output_vars, list(set(output_vars)))))\n)\n# make sure the input &amp; output variables are disjoint\nif list_intersection(input_vars, output_vars):\nraise IncompatibleArgsError(\n\"The following variables appear in inputs and outputs: %s\"\n% (list_intersection(input_vars, output_vars))\n)\n# make sure the assumptions only contain input variables\nif list_diff(assumptions.vars, input_vars):\nraise IncompatibleArgsError(\n\"The following variables appear in the assumptions but are not inputs: %s\"\n% (list_diff(assumptions.vars, input_vars))\n)\n# make sure the guarantees only contain input or output variables\nif list_diff(guarantees.vars, list_union(input_vars, output_vars)):\nraise IncompatibleArgsError(\n\"The guarantees contain the following variables which are neither\"\n\"inputs nor outputs: %s. Inputs: %s. Outputs: %s. Guarantees: %s\"\n% (list_diff(guarantees.vars, list_union(input_vars, output_vars)), input_vars, output_vars, guarantees)\n)\nself.a: TermList_t = assumptions.copy()\nself.inputvars = input_vars.copy()\nself.outputvars = output_vars.copy()\nif simplify:\nself.g = guarantees.simplify(self.a)\nelse:\nself.g = guarantees.copy()\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.can_compose_with","title":"<code>can_compose_with(other)</code>","text":"<p>Tell whether the contract can be composed with another contract.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>Contract whose possibility to compose with self we are verifying.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the contracts can be composed. False otherwise.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def can_compose_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether the contract can be composed with another contract.\n    Args:\n        other:\n            Contract whose possibility to compose with self we are\n            verifying.\n    Returns:\n        True if the contracts can be composed. False otherwise.\n    \"\"\"\n# make sure lists of output variables don't intersect\nreturn len(list_intersection(self.outputvars, other.outputvars)) == 0\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.can_quotient_by","title":"<code>can_quotient_by(other)</code>","text":"<p>Tell whether the contract can quotiented by another contract.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>potential quotient by which self would be quotiented.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the IO profiles of the contracts allow the quotient to exist. False otherwise.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def can_quotient_by(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether the contract can quotiented by another contract.\n    Args:\n        other: potential quotient by which self would be quotiented.\n    Returns:\n        True if the IO profiles of the contracts allow the quotient to\n            exist. False otherwise.\n    \"\"\"\n# make sure the top level outputs not contained in outputs of the\n# existing component do not intersect with the inputs of the existing\n# component\nreturn len(list_intersection(list_diff(self.outputvars, other.outputvars), other.inputvars)) == 0\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.compose","title":"<code>compose(other, vars_to_keep=None, simplify=True)</code>","text":"<p>Compose IO contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Any</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <p>Returns:</p> Type Description <code>IoContract_t</code> <p>The abstracted composition of the two contracts.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def compose(\nself: IoContract_t,\nother: IoContract_t,\nvars_to_keep: Any = None,\nsimplify: bool = True,\n) -&gt; IoContract_t:\n\"\"\"Compose IO contracts.\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n    Returns:\n        The abstracted composition of the two contracts.\n    \"\"\"\nresult, _ = self.compose_tactics(other, vars_to_keep, simplify)\nreturn result\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.compose_tactics","title":"<code>compose_tactics(other, vars_to_keep=None, simplify=True, tactics_order=None)</code>","text":"<p>Compose IO contracts with support for specifying the order of tactics and measuring their use.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Any</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>The order of tactics to try for variable term elimination.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[IoContract_t, List[TacticStatistics]]</code> <p>A tuple of the abstracted composition of the two contracts and of the list of tactics used.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>An error occurred during composition.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def compose_tactics(  # noqa: WPS231\nself: IoContract_t,\nother: IoContract_t,\nvars_to_keep: Any = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[IoContract_t, List[TacticStatistics]]:  # noqa: WPS231\n\"\"\"Compose IO contracts with support for specifying the order of tactics and measuring their use.\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n        tactics_order:\n            The order of tactics to try for variable term elimination.\n    Returns:\n        A tuple of the abstracted composition of the two contracts and of the list of tactics used.\n    Raises:\n        IncompatibleArgsError: An error occurred during composition.\n    \"\"\"\nif tactics_order is None:\ntactics_order = []\nif vars_to_keep is None:\nvars_to_keep = []\nconflict_vars = list_diff(vars_to_keep, list_union(self.outputvars, other.outputvars))\nif conflict_vars:\nraise IncompatibleArgsError(\"Asked to keep variables %s, which are not outputs\" % (conflict_vars))\nlogging.debug(\"Composing contracts \\n%s and \\n%s\", self, other)\nintvars = list_union(\nlist_intersection(self.outputvars, other.inputvars), list_intersection(self.inputvars, other.outputvars)\n)\ninputvars = list_diff(list_union(self.inputvars, other.inputvars), intvars)\noutputvars = list_diff(list_union(self.outputvars, other.outputvars), intvars)\n# remove requested variables\nintvars = list_diff(intvars, vars_to_keep)\noutputvars = list_union(outputvars, vars_to_keep)\nselfinputconst = self.a.vars\notherinputconst = other.a.vars\ncycle_present = (\nlen(list_intersection(self.inputvars, other.outputvars)) &gt; 0\nand len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\n)\nassumptions_forbidden_vars = list_union(intvars, outputvars)\nif not self.can_compose_with(other):\nraise IncompatibleArgsError(\n\"Cannot compose the following contracts due to incompatible IO profiles:\\n %s \\n %s\" % (self, other)\n)\nother_helps_self = len(list_intersection(other.outputvars, self.inputvars)) &gt; 0\nself_helps_other = len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\nother_drives_const_inputs = len(list_intersection(other.outputvars, selfinputconst)) &gt; 0\nself_drives_const_inputs = len(list_intersection(self.outputvars, otherinputconst)) &gt; 0\ntactics_used: List[TacticStatistics] = []\n# process assumptions\nif cycle_present and (other_drives_const_inputs or self_drives_const_inputs):\nraise IncompatibleArgsError(\"Cannot compose contracts due to feedback\")\nelif self_helps_other and not other_helps_self:\nlogging.debug(\"Assumption computation: self provides context for other\")\n(new_a, used) = other.a.elim_vars_by_refining(\nself.a | self.g, assumptions_forbidden_vars, simplify=True, tactics_order=tactics_order\n)\ntactics_used.append(used)\nconflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\nif conflict_variables:\nraise IncompatibleArgsError(\n\"Could not eliminate variables {}\\n\".format([str(x) for x in assumptions_forbidden_vars])\n+ \"by refining the assumptions \\n{}\\n\".format(new_a.get_terms_with_vars(assumptions_forbidden_vars))\n+ \"using guarantees \\n{}\\n\".format(self.a | self.g)\n)\nassumptions = new_a | self.a\nelif other_helps_self and not self_helps_other:\nlogging.debug(\"****** Assumption computation: other provides context for self\")\n(new_a, used) = self.a.elim_vars_by_refining(\nother.a | other.g, assumptions_forbidden_vars, simplify=True, tactics_order=tactics_order\n)\ntactics_used.append(used)\nconflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\nif conflict_variables:\nraise IncompatibleArgsError(\n\"Could not eliminate variables {}\".format([str(x) for x in assumptions_forbidden_vars])\n+ \" by refining the assumptions \\n{}\\n\".format(\nnew_a.get_terms_with_vars(assumptions_forbidden_vars)\n)\n+ \"using guarantees \\n{}\\n\".format(other.a | other.g)\n)\nassumptions = new_a | other.a\n# contracts can't help each other\nelse:\nlogging.debug(\"****** Assumption computation: other provides context for self\")\nassumptions = self.a | other.a\nlogging.debug(\"Assumption computation: computed assumptions:\\n%s\", assumptions)\nif simplify:\nassumptions = assumptions.simplify()\n# process guarantees\nlogging.debug(\"****** Computing guarantees\")\ng1_t = self.g.copy()\ng2_t = other.g.copy()\n(g1, used) = g1_t.elim_vars_by_relaxing(g2_t, intvars, simplify, tactics_order)\ntactics_used.append(used)\n(g2, used) = g2_t.elim_vars_by_relaxing(g1_t, intvars, simplify, tactics_order)\ntactics_used.append(used)\nallguarantees = g1 | g2\n(allguarantees, used) = allguarantees.elim_vars_by_relaxing(assumptions, intvars, simplify, tactics_order)\ntactics_used.append(used)\n# eliminate terms with forbidden vars\nterms_to_elim = allguarantees.get_terms_with_vars(intvars)\nallguarantees -= terms_to_elim\nreturn type(self)(assumptions, allguarantees, inputvars, outputvars), tactics_used\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.contains_environment","title":"<code>contains_environment(component)</code>","text":"<p>Tell whether a component is a valid environment for the contract.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>TermList</code> <p>The component in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the component is a valid environment; false otherwise.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def contains_environment(self, component: TermList) -&gt; bool:\n\"\"\"\n    Tell whether a component is a valid environment for the contract.\n    Args:\n        component: The component in question.\n    Returns:\n        True if the component is a valid environment; false otherwise.\n    \"\"\"\nreturn component &lt;= self.a\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.contains_implementation","title":"<code>contains_implementation(component)</code>","text":"<p>Tell whether a component is a valid implementation for the contract.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>TermList</code> <p>The component in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the component is a valid implementation; false otherwise.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def contains_implementation(self, component: TermList) -&gt; bool:\n\"\"\"\n    Tell whether a component is a valid implementation for the contract.\n    Args:\n        component:\n            The component in question.\n    Returns:\n        True if the component is a valid implementation; false otherwise.\n    \"\"\"\nreturn (component | self.a) &lt;= (self.g | self.a)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.copy","title":"<code>copy()</code>","text":"<p>Makes copy of contract.</p> <p>Returns:</p> Type Description <code>IoContract_t</code> <p>Copy of contract.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def copy(self: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n    Makes copy of contract.\n    Returns:\n        Copy of contract.\n    \"\"\"\ninputvars = self.inputvars.copy()\noutputvars = self.outputvars.copy()\nassumptions = self.a.copy()\nguarantees = self.g.copy()\nreturn type(self)(assumptions, guarantees, inputvars, outputvars)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.merge","title":"<code>merge(other)</code>","text":"<p>Compute the merging operation for two contracts.</p> <p>Compute the merging operation of the two given contracts. No abstraction/refinement is applied.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The contract with which we are merging self.</p> required <p>Returns:</p> Type Description <code>IoContract_t</code> <p>The result of merging.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>trying to merge different contract types.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def merge(self: IoContract_t, other: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n    Compute the merging operation for two contracts.\n    Compute the merging operation of the two given contracts. No\n    abstraction/refinement is applied.\n    Args:\n        other: The contract with which we are merging self.\n    Returns:\n        The result of merging.\n    Raises:\n        IncompatibleArgsError: trying to merge different contract types.\n    \"\"\"\nif not isinstance(self, type(other)):\nraise IncompatibleArgsError(\"Asked to merge incompatible contracts\")\ninput_vars = list_union(self.inputvars, other.inputvars)\noutput_vars = list_union(self.outputvars, other.outputvars)\nassumptions = self.a | other.a\nguarantees = self.g | other.g\nreturn type(self)(assumptions, guarantees, input_vars, output_vars)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.quotient","title":"<code>quotient(other, additional_inputs=None, simplify=True)</code>","text":"<p>Compute the contract quotient.</p> <p>Compute the quotient self/other of the two given contracts and refine the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <p>Returns:</p> Type Description <code>IoContract_t</code> <p>The refined quotient self/other.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def quotient(\nself: IoContract_t,\nother: IoContract_t,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\n) -&gt; IoContract_t:\n\"\"\"Compute the contract quotient.\n    Compute the quotient self/other of the two given contracts and refine\n    the result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n    Returns:\n        The refined quotient self/other.\n    \"\"\"\nresult, _ = self.quotient_tactics(other, additional_inputs, simplify)\nreturn result\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.quotient_tactics","title":"<code>quotient_tactics(other, additional_inputs=None, simplify=True, tactics_order=None)</code>","text":"<p>Compute the contract quotient with support for specifying the order of tactics and measuring their use.</p> <p>Compute the quotient self/other of the two given contracts and refine the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>The order of tactics to try for variable term elimination.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[IoContract_t, List[TacticStatistics]]</code> <p>A tuple of the refined quotient self/other and the list of tactics used.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>Arguments provided are incompatible with computation of the quotient.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def quotient_tactics(  # noqa: WPS231\nself: IoContract_t,\nother: IoContract_t,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[IoContract_t, List[TacticStatistics]]:\n\"\"\"Compute the contract quotient with support for specifying the order of tactics and measuring their use.\n    Compute the quotient self/other of the two given contracts and refine\n    the result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n        tactics_order:\n            The order of tactics to try for variable term elimination.\n    Returns:\n        A tuple of the refined quotient self/other and the list of tactics used.\n    Raises:\n        IncompatibleArgsError: Arguments provided are incompatible with computation of the quotient.\n    \"\"\"\nif tactics_order is None:\ntactics_order = []\nif not additional_inputs:\nadditional_inputs = []\nif not self.can_quotient_by(other):\nraise IncompatibleArgsError(\"Contracts cannot be quotiented due to incompatible IO\")\nif list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)):\nraise IncompatibleArgsError(\n\"The additional inputs %s are neither top level inputs nor existing component outputs\"\n% (list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)))\n)\noutputvars = list_union(\nlist_diff(self.outputvars, other.outputvars), list_diff(other.inputvars, self.inputvars)\n)\ninputvars = list_union(list_diff(self.inputvars, other.inputvars), list_diff(other.outputvars, self.outputvars))\ninputvars = list_union(inputvars, additional_inputs)\nintvars = list_union(\nlist_intersection(self.outputvars, other.outputvars), list_intersection(self.inputvars, other.inputvars)\n)\nintvars = list_diff(intvars, additional_inputs)\ntactics_used: List[TacticStatistics] = []\n# get assumptions\nlogging.debug(\"Computing quotient assumptions\")\nassumptions = copy.deepcopy(self.a)\nempty_context = type(assumptions)([])\nif assumptions.refines(other.a):\nlogging.debug(\"Extending top-level assumptions with divisor's guarantees\")\nassumptions = assumptions | other.g\n(assumptions, used) = assumptions.elim_vars_by_relaxing(\nempty_context, list_union(intvars, outputvars), simplify, tactics_order\n)\ntactics_used.append(used)\nlogging.debug(\"Assumptions after processing: %s\", assumptions)\n# get guarantees\nlogging.debug(\"Computing quotient guarantees\")\nguarantees: TermList_t = self.g\nlogging.debug(\"Using existing guarantees to aid system-level guarantees\")\ntry:  # noqa: WPS229\n(guarantees, used) = guarantees.elim_vars_by_refining(other.g | self.a, intvars, simplify, tactics_order)\ntactics_used.append(used)\nexcept ValueError:\nguarantees = self.g\nlogging.debug(\"Guarantees are %s\" % (guarantees))\nlogging.debug(\"Using system-level assumptions to aid quotient guarantees\")\nguarantees = guarantees | other.a\ntry:  # noqa: WPS229\n(guarantees, used) = guarantees.elim_vars_by_refining(self.a, intvars, simplify, tactics_order)\ntactics_used.append(used)\nexcept ValueError:\n...\nlogging.debug(\"Guarantees after processing: %s\", guarantees)\nconflict_variables = list_intersection(guarantees.vars, intvars)\nif conflict_variables:\nraise IncompatibleArgsError(\n\"Could not eliminate variables \\n{}\".format([str(x) for x in conflict_variables])\n+ \"by refining the guarantees \\n{}\\n\".format(guarantees.get_terms_with_vars(intvars))\n)\nreturn type(self)(assumptions, guarantees, inputvars, outputvars), tactics_used\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.refines","title":"<code>refines(other)</code>","text":"<p>Tell whether the given contract is a refinement of another.</p> <p>Return self &lt;= other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>contract being compared with self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the calling contract refines the argument.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>Refinement cannot be computed.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def refines(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether the given contract is a refinement of another.\n    Return self &lt;= other.\n    Args:\n        other: contract being compared with self.\n    Returns:\n        True if the calling contract refines the argument.\n    Raises:\n        IncompatibleArgsError: Refinement cannot be computed.\n    \"\"\"\nif not self.shares_io_with(other):\nraise IncompatibleArgsError(\"Contracts do not share IO\")\nassumptions_check: bool = other.a &lt;= self.a\nguarantees_check: bool = (self.g | other.a) &lt;= (other.g | other.a)\nreturn assumptions_check and guarantees_check\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a contract.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>IoContract_t</code> <p>A contract with <code>source_var</code> replaced by <code>target_var</code>.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>The new variable is both an input and output of the resulting contract.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def rename_variable(  # noqa: WPS231 too much cognitive complexity\nself: IoContract_t, source_var: Var, target_var: Var\n) -&gt; IoContract_t:\n\"\"\"\n    Rename a variable in a contract.\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n    Returns:\n        A contract with `source_var` replaced by `target_var`.\n    Raises:\n        IncompatibleArgsError: The new variable is both an input and output of the resulting contract.\n    \"\"\"\ninputvars = self.inputvars.copy()\noutputvars = self.outputvars.copy()\nassumptions = self.a.copy()\nguarantees = self.g.copy()\nif source_var != target_var:\nif source_var in inputvars:\nif target_var in outputvars:\nraise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\nelif target_var not in inputvars:\ninputvars[inputvars.index(source_var)] = target_var\nelse:\ninputvars.remove(source_var)\nassumptions = assumptions.rename_variable(source_var, target_var)\nguarantees = guarantees.rename_variable(source_var, target_var)\nelif source_var in outputvars:\nif target_var in inputvars:\nraise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\nelif target_var not in outputvars:\noutputvars[outputvars.index(source_var)] = target_var\nelse:\noutputvars.remove(source_var)\nassumptions = assumptions.rename_variable(source_var, target_var)\nguarantees = guarantees.rename_variable(source_var, target_var)\nreturn type(self)(assumptions, guarantees, inputvars, outputvars)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.shares_io_with","title":"<code>shares_io_with(other)</code>","text":"<p>Tell whether two contracts have the same IO signature.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>contract whose IO signature is compared with self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the contracts have the same IO profile.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def shares_io_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether two contracts have the same IO signature.\n    Args:\n        other: contract whose IO signature is compared with self.\n    Returns:\n        True if the contracts have the same IO profile.\n    \"\"\"\nreturn lists_equal(self.inputvars, other.inputvars) &amp; lists_equal(self.outputvars, other.outputvars)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.IoContract.simplify","title":"<code>simplify()</code>","text":"<p>Simplifies guarantees given assumptions.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def simplify(self) -&gt; None:\n\"\"\"Simplifies guarantees given assumptions.\"\"\"\nself.g = self.g.simplify(self.a)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term","title":"<code>Term</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Terms, or constraints, to be imposed on the system or components.</p> <p>Term is an abstract class that must be extended in order to support specific constraint languages.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>class Term(ABC):\n\"\"\"\n    Terms, or constraints, to be imposed on the system or components.\n    Term is an abstract class that must be extended in order to support specific\n    constraint languages.\n    \"\"\"\n@property\n@abstractmethod\ndef vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"Variables contained in the syntax of the term.\"\"\"\n@abstractmethod\ndef contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n        Tell whether term contains a given variable.\n        Args:\n            var_to_seek: The variable that we are seeking in the current term.\n        \"\"\"\n@abstractmethod\ndef __eq__(self, other: object) -&gt; bool:\n\"\"\"\n        Equality.\n        Args:\n            other: the object against which we are comparing self.\n        \"\"\"\n@abstractmethod\ndef __str__(self) -&gt; str:\n\"\"\"Printing support.\"\"\"\n@abstractmethod\ndef __hash__(self) -&gt; int:\n\"\"\"Hashing.\"\"\"\n@abstractmethod\ndef __repr__(self) -&gt; str:\n\"\"\"Printable representation.\"\"\"\n@abstractmethod\ndef copy(self: Term_t) -&gt; Term_t:\n\"\"\"Returns a copy of term.\"\"\"\n@abstractmethod\ndef rename_variable(self: Term_t, source_var: Var, target_var: Var) -&gt; Term_t:\n\"\"\"\n        Rename a variable in a term.\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n        Returns:\n            A term with `source_var` replaced by `target_var`.\n        \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term.vars","title":"<code>vars</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Variables contained in the syntax of the term.</p>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term.__eq__","title":"<code>__eq__(other)</code>  <code>abstractmethod</code>","text":"<p>Equality.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>the object against which we are comparing self.</p> required Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef __eq__(self, other: object) -&gt; bool:\n\"\"\"\n    Equality.\n    Args:\n        other: the object against which we are comparing self.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term.__hash__","title":"<code>__hash__()</code>  <code>abstractmethod</code>","text":"<p>Hashing.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef __hash__(self) -&gt; int:\n\"\"\"Hashing.\"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term.__repr__","title":"<code>__repr__()</code>  <code>abstractmethod</code>","text":"<p>Printable representation.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef __repr__(self) -&gt; str:\n\"\"\"Printable representation.\"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term.__str__","title":"<code>__str__()</code>  <code>abstractmethod</code>","text":"<p>Printing support.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef __str__(self) -&gt; str:\n\"\"\"Printing support.\"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term.contains_var","title":"<code>contains_var(var_to_seek)</code>  <code>abstractmethod</code>","text":"<p>Tell whether term contains a given variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_to_seek</code> <code>Var</code> <p>The variable that we are seeking in the current term.</p> required Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n    Tell whether term contains a given variable.\n    Args:\n        var_to_seek: The variable that we are seeking in the current term.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term.copy","title":"<code>copy()</code>  <code>abstractmethod</code>","text":"<p>Returns a copy of term.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef copy(self: Term_t) -&gt; Term_t:\n\"\"\"Returns a copy of term.\"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Term.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>  <code>abstractmethod</code>","text":"<p>Rename a variable in a term.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>Term_t</code> <p>A term with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef rename_variable(self: Term_t, source_var: Var, target_var: Var) -&gt; Term_t:\n\"\"\"\n    Rename a variable in a term.\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n    Returns:\n        A term with `source_var` replaced by `target_var`.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList","title":"<code>TermList</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A collection of terms, or constraints.</p> <p>A TermList is semantically equivalent to a single term which is the conjunction of all terms contained in the TermList. TermList is an abstract class that must be extended to support a specific constraint formalism.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>class TermList(ABC):\n\"\"\"\n    A collection of terms, or constraints.\n    A TermList is semantically equivalent to a single term which is the\n    conjunction of all terms contained in the TermList. TermList is an abstract\n    class that must be extended to support a specific constraint formalism.\n    \"\"\"\ndef __init__(self, term_list: Optional[List] = None):\n\"\"\"\n        Class constructor.\n        Args:\n            term_list: A list of terms contained by TermList.\n        \"\"\"\nif term_list:\nself.terms = term_list.copy()\nelse:\nself.terms = []\n@property\ndef vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"The list of variables contained in this list of terms.\n        Returns:\n            List of variables referenced in the term.\n        \"\"\"\nvarlist: List[Var] = []\nfor t in self.terms:\nvarlist = list_union(varlist, t.vars)\nreturn varlist\ndef __str__(self) -&gt; str:\nif self.terms:\nres = [str(el) for el in self.terms]\nreturn \", \".join(res)\nreturn \"true\"\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError()\nreturn self.terms == other.terms\ndef get_terms_with_vars(self: TermList_t, variable_list: List[Var]) -&gt; TermList_t:\n\"\"\"\n        Returns the list of terms which contain any of the variables indicated.\n        Args:\n            variable_list: a list of variables being sought in current TermList.\n        Returns:\n            The list of terms which contain any of the variables indicated.\n        \"\"\"\nterms = []\nfor t in self.terms:\nif list_intersection(t.vars, variable_list):\nterms.append(t)\nreturn type(self)(terms)\ndef __and__(self: TermList_t, other: TermList_t) -&gt; TermList_t:\nreturn type(self)(list_intersection(self.copy().terms, other.copy().terms))\ndef __or__(self: TermList_t, other: TermList_t) -&gt; TermList_t:\nreturn type(self)(list_union(self.copy().terms, other.copy().terms))\ndef __sub__(self: TermList_t, other: TermList_t) -&gt; TermList_t:\nreturn type(self)(list_diff(self.copy().terms, other.copy().terms))\ndef __le__(self: TermList_t, other: TermList_t) -&gt; bool:\nreturn self.refines(other)\n@abstractmethod\ndef __hash__(self) -&gt; int:\n\"\"\"Hashing.\"\"\"\ndef copy(self: TermList_t) -&gt; TermList_t:\n\"\"\"\n        Makes copy of termlist.\n        Returns:\n            Copy of termlist.\n        \"\"\"\nreturn type(self)([term.copy() for term in self.terms])\ndef rename_variable(self: TermList_t, source_var: Var, target_var: Var) -&gt; TermList_t:\n\"\"\"\n        Rename a variable in a termlist.\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n        Returns:\n            A termlist with `source_var` replaced by `target_var`.\n        \"\"\"\nreturn type(self)([term.rename_variable(source_var, target_var) for term in self.terms])\n@abstractmethod\ndef contains_behavior(self, behavior: Any) -&gt; bool:\n\"\"\"\n        Tell whether TermList contains the given behavior.\n        Args:\n            behavior:\n                The behavior in question.\n        Returns:\n            True if the behavior satisfies the constraints; false otherwise.\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\n@abstractmethod\ndef elim_vars_by_refining(\nself: TermList_t, context: TermList_t, vars_to_elim: List[Var], simplify: bool, tactics_order: List[int]\n) -&gt; Tuple[TermList_t, TacticStatistics]:\n\"\"\"\n        Eliminate variables from termlist by refining it in a context.\n        Given a context $\\\\Gamma$, and the list of terms contained in self,\n        $s$, this routine identifies a TermList $x$ lacking variables\n        vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; x}{\\\\Gamma: \\\\;\n        s}$.\n        Args:\n            context:\n                List of context terms that will be used to refine the TermList.\n            vars_to_elim:\n                Variables to be eliminated.\n            simplify:\n                Whether to simplify self in the given context before variable elimination\n            tactics_order:\n                The order of the tactics to use when transforming each term in the list.\n        Returns:\n            A tuple consisting of (a) a list of terms not containing any variables in `vars_to_elim`\n                and which, in the context provided, imply the terms contained in the\n                calling termlist; and (b) the list of tuples, for each term processed, of the tactic used,\n                time spent, and tactic invocation count.\n        \"\"\"\n@abstractmethod\ndef elim_vars_by_relaxing(\nself: TermList_t, context: TermList_t, vars_to_elim: List[Var], simplify: bool, tactics_order: List[int]\n) -&gt; Tuple[TermList_t, TacticStatistics]:\n\"\"\"\n        Eliminate variables from termlist by relaxing it in a context\n        Given a context $\\\\Gamma$, and the list of terms contained in self,\n        $s$, this routine identifies a formula $x$ lacking variables\n        vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; s}{\\\\Gamma: \\\\;\n        x}$.\n        Args:\n            context:\n                List of context terms that will be used to abstract the TermList.\n            vars_to_elim:\n                Variables that cannot be present in TermList after relaxation.\n            simplify:\n                Whether to simplify self in the given context before variable elimination\n            tactics_order:\n                The order of the tactics to use when transforming each term in the list.\n        Returns:\n            A tuple consisting of (a) a list of terms not containing any variables in `vars_to_elim`\n                and which, in the context provided, are implied by the terms\n                contained in the calling termlist; and (b) the list of tuples, for each term processed,\n                of the tactic used, time spent, and tactic invocation count.\n        \"\"\"\n@abstractmethod\ndef simplify(self: TermList_t, context: Optional[TermList_t] = None) -&gt; TermList_t:\n\"\"\"Remove redundant terms in TermList.\n        Args:\n            context:\n                List of context terms that will be used to remove redundancies in\n                the TermList.\n        Returns:\n            Let $S$ be this TermList. Simplify will return\n                $S_T = S \\\\setminus T$, where $T \\\\subseteq S$ is a maximal subset such that\n                $\\\\frac{\\\\Gamma, S_T\\\\colon \\\\; \\\\top}{\\\\Gamma, S_T\\\\colon \\\\; \\\\wedge_{t \\\\in T} t}$.\n        \"\"\"\n@abstractmethod\ndef refines(self: TermList_t, other: TermList_t) -&gt; bool:\n\"\"\"\n        Tell whether the argument is a larger specification.\n        Args:\n            other:\n                TermList against which we are comparing self.\n        Returns:\n            self &lt;= other.\n        \"\"\"\n@abstractmethod\ndef is_empty(self) -&gt; bool:\n\"\"\"\n        Tell whether the termlist has no satisfying assignments.\n        Returns:\n            True if termlist constraints cannot be satisfied.\n        \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.vars","title":"<code>vars</code>  <code>property</code>","text":"<p>The list of variables contained in this list of terms.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>List of variables referenced in the term.</p>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.__hash__","title":"<code>__hash__()</code>  <code>abstractmethod</code>","text":"<p>Hashing.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef __hash__(self) -&gt; int:\n\"\"\"Hashing.\"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.__init__","title":"<code>__init__(term_list=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>term_list</code> <code>Optional[List]</code> <p>A list of terms contained by TermList.</p> <code>None</code> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def __init__(self, term_list: Optional[List] = None):\n\"\"\"\n    Class constructor.\n    Args:\n        term_list: A list of terms contained by TermList.\n    \"\"\"\nif term_list:\nself.terms = term_list.copy()\nelse:\nself.terms = []\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.contains_behavior","title":"<code>contains_behavior(behavior)</code>  <code>abstractmethod</code>","text":"<p>Tell whether TermList contains the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Any</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraints; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef contains_behavior(self, behavior: Any) -&gt; bool:\n\"\"\"\n    Tell whether TermList contains the given behavior.\n    Args:\n        behavior:\n            The behavior in question.\n    Returns:\n        True if the behavior satisfies the constraints; false otherwise.\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.copy","title":"<code>copy()</code>","text":"<p>Makes copy of termlist.</p> <p>Returns:</p> Type Description <code>TermList_t</code> <p>Copy of termlist.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def copy(self: TermList_t) -&gt; TermList_t:\n\"\"\"\n    Makes copy of termlist.\n    Returns:\n        Copy of termlist.\n    \"\"\"\nreturn type(self)([term.copy() for term in self.terms])\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.elim_vars_by_refining","title":"<code>elim_vars_by_refining(context, vars_to_elim, simplify, tactics_order)</code>  <code>abstractmethod</code>","text":"<p>Eliminate variables from termlist by refining it in a context.</p> <p>Given a context \\(\\Gamma\\), and the list of terms contained in self, \\(s\\), this routine identifies a TermList \\(x\\) lacking variables vars_to_elim such that \\(\\frac{\\Gamma\\colon \\; x}{\\Gamma: \\; s}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>TermList_t</code> <p>List of context terms that will be used to refine the TermList.</p> required <code>vars_to_elim</code> <code>List[Var]</code> <p>Variables to be eliminated.</p> required <code>simplify</code> <code>bool</code> <p>Whether to simplify self in the given context before variable elimination</p> required <code>tactics_order</code> <code>List[int]</code> <p>The order of the tactics to use when transforming each term in the list.</p> required <p>Returns:</p> Type Description <code>Tuple[TermList_t, TacticStatistics]</code> <p>A tuple consisting of (a) a list of terms not containing any variables in <code>vars_to_elim</code> and which, in the context provided, imply the terms contained in the calling termlist; and (b) the list of tuples, for each term processed, of the tactic used, time spent, and tactic invocation count.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef elim_vars_by_refining(\nself: TermList_t, context: TermList_t, vars_to_elim: List[Var], simplify: bool, tactics_order: List[int]\n) -&gt; Tuple[TermList_t, TacticStatistics]:\n\"\"\"\n    Eliminate variables from termlist by refining it in a context.\n    Given a context $\\\\Gamma$, and the list of terms contained in self,\n    $s$, this routine identifies a TermList $x$ lacking variables\n    vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; x}{\\\\Gamma: \\\\;\n    s}$.\n    Args:\n        context:\n            List of context terms that will be used to refine the TermList.\n        vars_to_elim:\n            Variables to be eliminated.\n        simplify:\n            Whether to simplify self in the given context before variable elimination\n        tactics_order:\n            The order of the tactics to use when transforming each term in the list.\n    Returns:\n        A tuple consisting of (a) a list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, imply the terms contained in the\n            calling termlist; and (b) the list of tuples, for each term processed, of the tactic used,\n            time spent, and tactic invocation count.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.elim_vars_by_relaxing","title":"<code>elim_vars_by_relaxing(context, vars_to_elim, simplify, tactics_order)</code>  <code>abstractmethod</code>","text":"<p>Eliminate variables from termlist by relaxing it in a context</p> <p>Given a context \\(\\Gamma\\), and the list of terms contained in self, \\(s\\), this routine identifies a formula \\(x\\) lacking variables vars_to_elim such that \\(\\frac{\\Gamma\\colon \\; s}{\\Gamma: \\; x}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>TermList_t</code> <p>List of context terms that will be used to abstract the TermList.</p> required <code>vars_to_elim</code> <code>List[Var]</code> <p>Variables that cannot be present in TermList after relaxation.</p> required <code>simplify</code> <code>bool</code> <p>Whether to simplify self in the given context before variable elimination</p> required <code>tactics_order</code> <code>List[int]</code> <p>The order of the tactics to use when transforming each term in the list.</p> required <p>Returns:</p> Type Description <code>Tuple[TermList_t, TacticStatistics]</code> <p>A tuple consisting of (a) a list of terms not containing any variables in <code>vars_to_elim</code> and which, in the context provided, are implied by the terms contained in the calling termlist; and (b) the list of tuples, for each term processed, of the tactic used, time spent, and tactic invocation count.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef elim_vars_by_relaxing(\nself: TermList_t, context: TermList_t, vars_to_elim: List[Var], simplify: bool, tactics_order: List[int]\n) -&gt; Tuple[TermList_t, TacticStatistics]:\n\"\"\"\n    Eliminate variables from termlist by relaxing it in a context\n    Given a context $\\\\Gamma$, and the list of terms contained in self,\n    $s$, this routine identifies a formula $x$ lacking variables\n    vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; s}{\\\\Gamma: \\\\;\n    x}$.\n    Args:\n        context:\n            List of context terms that will be used to abstract the TermList.\n        vars_to_elim:\n            Variables that cannot be present in TermList after relaxation.\n        simplify:\n            Whether to simplify self in the given context before variable elimination\n        tactics_order:\n            The order of the tactics to use when transforming each term in the list.\n    Returns:\n        A tuple consisting of (a) a list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, are implied by the terms\n            contained in the calling termlist; and (b) the list of tuples, for each term processed,\n            of the tactic used, time spent, and tactic invocation count.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.get_terms_with_vars","title":"<code>get_terms_with_vars(variable_list)</code>","text":"<p>Returns the list of terms which contain any of the variables indicated.</p> <p>Parameters:</p> Name Type Description Default <code>variable_list</code> <code>List[Var]</code> <p>a list of variables being sought in current TermList.</p> required <p>Returns:</p> Type Description <code>TermList_t</code> <p>The list of terms which contain any of the variables indicated.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def get_terms_with_vars(self: TermList_t, variable_list: List[Var]) -&gt; TermList_t:\n\"\"\"\n    Returns the list of terms which contain any of the variables indicated.\n    Args:\n        variable_list: a list of variables being sought in current TermList.\n    Returns:\n        The list of terms which contain any of the variables indicated.\n    \"\"\"\nterms = []\nfor t in self.terms:\nif list_intersection(t.vars, variable_list):\nterms.append(t)\nreturn type(self)(terms)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.is_empty","title":"<code>is_empty()</code>  <code>abstractmethod</code>","text":"<p>Tell whether the termlist has no satisfying assignments.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if termlist constraints cannot be satisfied.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef is_empty(self) -&gt; bool:\n\"\"\"\n    Tell whether the termlist has no satisfying assignments.\n    Returns:\n        True if termlist constraints cannot be satisfied.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.refines","title":"<code>refines(other)</code>  <code>abstractmethod</code>","text":"<p>Tell whether the argument is a larger specification.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>TermList_t</code> <p>TermList against which we are comparing self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>self &lt;= other.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef refines(self: TermList_t, other: TermList_t) -&gt; bool:\n\"\"\"\n    Tell whether the argument is a larger specification.\n    Args:\n        other:\n            TermList against which we are comparing self.\n    Returns:\n        self &lt;= other.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a termlist.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>TermList_t</code> <p>A termlist with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def rename_variable(self: TermList_t, source_var: Var, target_var: Var) -&gt; TermList_t:\n\"\"\"\n    Rename a variable in a termlist.\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n    Returns:\n        A termlist with `source_var` replaced by `target_var`.\n    \"\"\"\nreturn type(self)([term.rename_variable(source_var, target_var) for term in self.terms])\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.TermList.simplify","title":"<code>simplify(context=None)</code>  <code>abstractmethod</code>","text":"<p>Remove redundant terms in TermList.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Optional[TermList_t]</code> <p>List of context terms that will be used to remove redundancies in the TermList.</p> <code>None</code> <p>Returns:</p> Type Description <code>TermList_t</code> <p>Let \\(S\\) be this TermList. Simplify will return \\(S_T = S \\setminus T\\), where \\(T \\subseteq S\\) is a maximal subset such that \\(\\frac{\\Gamma, S_T\\colon \\; \\top}{\\Gamma, S_T\\colon \\; \\wedge_{t \\in T} t}\\).</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef simplify(self: TermList_t, context: Optional[TermList_t] = None) -&gt; TermList_t:\n\"\"\"Remove redundant terms in TermList.\n    Args:\n        context:\n            List of context terms that will be used to remove redundancies in\n            the TermList.\n    Returns:\n        Let $S$ be this TermList. Simplify will return\n            $S_T = S \\\\setminus T$, where $T \\\\subseteq S$ is a maximal subset such that\n            $\\\\frac{\\\\Gamma, S_T\\\\colon \\\\; \\\\top}{\\\\Gamma, S_T\\\\colon \\\\; \\\\wedge_{t \\\\in T} t}$.\n    \"\"\"\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Var","title":"<code>Var</code>","text":"<p>Variables used in system modeling.</p> <p>Variables allow us to name an entity for which we want to write constraints.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>class Var:\n\"\"\"\n    Variables used in system modeling.\n    Variables allow us to name an entity for which we want to write constraints.\n    \"\"\"\ndef __init__(self, varname: str):\n\"\"\"\n        Constructor for Var.\n        Args:\n            varname: The name of the variable.\n        \"\"\"\nself._name = str(varname)\n@property\ndef name(self) -&gt; str:\n\"\"\"The name of the variable.\n        Returns:\n            The name of the variable.\n        \"\"\"\nreturn self._name\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError()\nreturn self.name == other.name\ndef __str__(self) -&gt; str:\nreturn self.name\ndef __hash__(self) -&gt; int:\nreturn hash(self.name)\ndef __repr__(self) -&gt; str:\nreturn \"&lt;Var {0}&gt;\".format(self.name)\n</code></pre>"},{"location":"iocontract/#pacti.iocontract.iocontract.Var.name","title":"<code>name</code>  <code>property</code>","text":"<p>The name of the variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the variable.</p>"},{"location":"iocontract/#pacti.iocontract.iocontract.Var.__init__","title":"<code>__init__(varname)</code>","text":"<p>Constructor for Var.</p> <p>Parameters:</p> Name Type Description Default <code>varname</code> <code>str</code> <p>The name of the variable.</p> required Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def __init__(self, varname: str):\n\"\"\"\n    Constructor for Var.\n    Args:\n        varname: The name of the variable.\n    \"\"\"\nself._name = str(varname)\n</code></pre>"},{"location":"license/","title":"License","text":"<pre><code>BSD 3-Clause License\n\nCopyright (c) 2023, California Institute of Technology\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</code></pre>"},{"location":"polyhedral-contracts/","title":"PolyhedralContracts","text":"<p>Specializes IO contract into contracts with polyhedral assumptions and guarantees.</p>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.NestedPolyhedra","title":"<code>NestedPolyhedra</code>","text":"<p>               Bases: <code>NestedTermList</code></p> <p>A collection of polyhedral termlists interpreted as their disjunction.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>class NestedPolyhedra(NestedTermList):\n\"\"\"A collection of polyhedral termlists interpreted as their disjunction.\"\"\"\ndef __init__(  # noqa: WPS612 useless overwritten __init__\nself, nested_termlist: List[PolyhedralTermList], force_empty_intersection: bool\n):\n\"\"\"\n        Class constructor.\n        Args:\n            nested_termlist: A list of terms contained by TermList.\n            force_empty_intersection: Raise error if the termlists are not disjoint.\n        \"\"\"\nsuper().__init__(nested_termlist, force_empty_intersection)\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.NestedPolyhedra.__init__","title":"<code>__init__(nested_termlist, force_empty_intersection)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>nested_termlist</code> <code>List[PolyhedralTermList]</code> <p>A list of terms contained by TermList.</p> required <code>force_empty_intersection</code> <code>bool</code> <p>Raise error if the termlists are not disjoint.</p> required Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def __init__(  # noqa: WPS612 useless overwritten __init__\nself, nested_termlist: List[PolyhedralTermList], force_empty_intersection: bool\n):\n\"\"\"\n    Class constructor.\n    Args:\n        nested_termlist: A list of terms contained by TermList.\n        force_empty_intersection: Raise error if the termlists are not disjoint.\n    \"\"\"\nsuper().__init__(nested_termlist, force_empty_intersection)\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract","title":"<code>PolyhedralIoContract</code>","text":"<p>               Bases: <code>IoContract</code></p> <p>IO Contracts with assumptions and guarantees expressed as polyhedral constraints.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>class PolyhedralIoContract(IoContract):\n\"\"\"IO Contracts with assumptions and guarantees expressed as polyhedral constraints.\"\"\"\ndef rename_variables(self, variable_mappings: List[Tuple[str, str]]) -&gt; PolyhedralIoContract:\n\"\"\"\n        Rename variables in a contract.\n        Args:\n            variable_mappings: Variables to be replaced.\n        Returns:\n            A contract with `source_var` replaced by `target_var`.\n        \"\"\"\nnew_contract = self.copy()\nfor mapping in variable_mappings:\nnew_contract = new_contract.rename_variable(Var(mapping[0]), Var(mapping[1]))\nreturn new_contract\ndef to_machine_dict(self) -&gt; ser_contract:\n\"\"\"\n        Map contract into a machine-optimized dictionary.\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\ninput_vars = [str(x) for x in self.inputvars]\noutput_vars = [str(x) for x in self.outputvars]\nassumptions: List[ser_pt] = [\n{\n\"constant\": float(term.constant),\n\"coefficients\": {str(k): float(v) for k, v in term.variables.items()},\n}\nfor term in self.a.terms\n]\nguarantees: List[ser_pt] = [\n{\n\"constant\": float(term.constant),\n\"coefficients\": {str(k): float(v) for k, v in term.variables.items()},\n}\nfor term in self.g.terms\n]\nreturn {\n\"input_vars\": input_vars,\n\"output_vars\": output_vars,\n\"assumptions\": assumptions,\n\"guarantees\": guarantees,\n}\ndef to_dict(self) -&gt; dict:\n\"\"\"\n        Map contract into a user-readable dictionary.\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\nc_temp = {}\nc_temp[\"input_vars\"] = [str(x) for x in self.inputvars]\nc_temp[\"output_vars\"] = [str(x) for x in self.outputvars]\nc_temp[\"assumptions\"] = self.a.to_str_list()\nc_temp[\"guarantees\"] = self.g.to_str_list()\nreturn c_temp\n@staticmethod\ndef from_strings(\nassumptions: List[str],\nguarantees: List[str],\ninput_vars: List[str],\noutput_vars: List[str],\nsimplify: bool = True,\n) -&gt; PolyhedralIoContract:\n\"\"\"\n        Create contract from several lists of strings.\n        Args:\n            assumptions: contract's assumptions.\n            guarantees: contract's guarantees.\n            input_vars: input variables of contract.\n            output_vars: output variables of contract.\n            simplify: whether to simplify the guarantees with respect to the assumptions.\n        Returns:\n            A polyhedral contract built from the arguments provided.\n        \"\"\"\na: List[PolyhedralTerm] = []\nif assumptions:\na = [item for x in assumptions for item in serializer.polyhedral_termlist_from_string(x)]\ng: List[PolyhedralTerm] = []\nif guarantees:\ng = [item for x in guarantees for item in serializer.polyhedral_termlist_from_string(x)]\nreturn PolyhedralIoContract(\ninput_vars=[Var(x) for x in input_vars],\noutput_vars=[Var(x) for x in output_vars],\nassumptions=PolyhedralTermList(a),\nguarantees=PolyhedralTermList(g),\nsimplify=simplify,\n)\n@staticmethod\ndef from_dict(contract: dict, simplify: bool = True) -&gt; PolyhedralIoContract:\n\"\"\"\n        Create contract from a dictionary.\n        Args:\n            contract: a dictionary containing the contract's data.\n            simplify: whether to simplify the guarantees with respect to the assumptions.\n        Returns:\n            A polyhedral contract built from the arguments provided.\n        Raises:\n            ValueError: dictionary provided was not well-formed.\n        \"\"\"\nif not isinstance(contract, dict):\nraise ValueError(\"A dict type contract is expected.\")\nfor kw in (\"assumptions\", \"guarantees\", \"input_vars\", \"output_vars\"):\nif kw not in contract:\nraise ValueError(f\"Passed dictionary does not have key {kw}.\")\nif all(isinstance(x, dict) for x in contract[\"assumptions\"]):\na = PolyhedralTermList(\n[\nPolyhedralTerm({Var(k): v for k, v in x[\"coefficients\"].items()}, float(x[\"constant\"]))\nfor x in contract[\"assumptions\"]\n]\n)\nelse:\nraise ValueError(\"Assumptions must be a list of dicts.\")\nif all(isinstance(x, dict) for x in contract[\"guarantees\"]):\ng = PolyhedralTermList(\n[\nPolyhedralTerm({Var(k): v for k, v in x[\"coefficients\"].items()}, float(x[\"constant\"]))\nfor x in contract[\"guarantees\"]\n]\n)\nelse:\nraise ValueError(\"Guarantees must be a list of dicts.\")\nreturn PolyhedralIoContract(\ninput_vars=[Var(x) for x in contract[\"input_vars\"]],\noutput_vars=[Var(x) for x in contract[\"output_vars\"]],\nassumptions=a,\nguarantees=g,\nsimplify=simplify,\n)\ndef compose(\nself,\nother: PolyhedralIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\n) -&gt; PolyhedralIoContract:\n\"\"\"Compose polyhedral contracts.\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n        Returns:\n            The abstracted composition of the two contracts.\n        \"\"\"\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose(other, [Var(x) for x in vars_to_keep], simplify)\ndef compose_tactics(\nself,\nother: PolyhedralIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralIoContract, List[TacticStatistics]]:\n\"\"\"Compose polyhedral contracts.\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n            tactics_order:\n                The order of tactics to try for variable term elimination.\n        Returns:\n            The tuple of the abstracted composition of the two contracts and of the list of tactics used.\n        \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose_tactics(other, [Var(x) for x in vars_to_keep], simplify, tactics_order)\ndef quotient(  # noqa: WPS612\nself: PolyhedralIoContract,\nother: PolyhedralIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\n) -&gt; PolyhedralIoContract:\n\"\"\"Quotient polyhedral contracts.\n        Compute the quotient of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n        Returns:\n            The abstracted quotient of the two contracts.\n        \"\"\"\nreturn super().quotient(other, additional_inputs, simplify)\ndef quotient_tactics(\nself: PolyhedralIoContract,\nother: PolyhedralIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralIoContract, List[TacticStatistics]]:\n\"\"\"Quotient polyhedral contracts with support for specifying the order of tactics and measuring their use.\n        Compute the quotient of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n            tactics_order:\n                The order of tactics to try for variable term elimination.\n        Returns:\n            The tuple of the abstracted quotient of the two contracts and of the list of tactics used.\n        \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nreturn super().quotient_tactics(other, additional_inputs, simplify, tactics_order)\ndef optimize(self, expr: str, maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"Optimize linear objective over the contract.\n        Compute the optima of a linear objective over the assumptions and\n        guarantees of the contract.\n        Args:\n            expr:\n                linear objective being optimized.\n            maximize:\n                Maximize if True; minimize if False.\n        Returns:\n            The optimal value of the objective in the context of the contract.\n        \"\"\"\nnew_expr = expr + \" &lt;= 0\"\nvariables = serializer.polyhedral_termlist_from_string(new_expr)[0].variables\nconstraints: PolyhedralTermList = self.a | self.g\nreturn constraints.optimize(objective=variables, maximize=maximize)\ndef get_variable_bounds(\nself, var: str\n) -&gt; Tuple[Optional[numeric], Optional[numeric]]:  # noqa: VNE002 variable 'var' should be clarified\n\"\"\"Obtain bounds for a variable in the context of a contract.\n        Args:\n            var:\n                variable whose bounds are sought.\n        Returns:\n            The minimum and maximum values for the variable in the context of the contract.\n        \"\"\"\nmaximum = self.optimize(var, maximize=True)\nminimum = self.optimize(var, maximize=False)\nreturn minimum, maximum\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.compose","title":"<code>compose(other, vars_to_keep=None, simplify=True)</code>","text":"<p>Compose polyhedral contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralIoContract</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Optional[List[str]]</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <p>Returns:</p> Type Description <code>PolyhedralIoContract</code> <p>The abstracted composition of the two contracts.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def compose(\nself,\nother: PolyhedralIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\n) -&gt; PolyhedralIoContract:\n\"\"\"Compose polyhedral contracts.\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n    Returns:\n        The abstracted composition of the two contracts.\n    \"\"\"\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose(other, [Var(x) for x in vars_to_keep], simplify)\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.compose_tactics","title":"<code>compose_tactics(other, vars_to_keep=None, simplify=True, tactics_order=None)</code>","text":"<p>Compose polyhedral contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralIoContract</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Optional[List[str]]</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>The order of tactics to try for variable term elimination.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[PolyhedralIoContract, List[TacticStatistics]]</code> <p>The tuple of the abstracted composition of the two contracts and of the list of tactics used.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def compose_tactics(\nself,\nother: PolyhedralIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralIoContract, List[TacticStatistics]]:\n\"\"\"Compose polyhedral contracts.\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n        tactics_order:\n            The order of tactics to try for variable term elimination.\n    Returns:\n        The tuple of the abstracted composition of the two contracts and of the list of tactics used.\n    \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose_tactics(other, [Var(x) for x in vars_to_keep], simplify, tactics_order)\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.from_dict","title":"<code>from_dict(contract, simplify=True)</code>  <code>staticmethod</code>","text":"<p>Create contract from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>contract</code> <code>dict</code> <p>a dictionary containing the contract's data.</p> required <code>simplify</code> <code>bool</code> <p>whether to simplify the guarantees with respect to the assumptions.</p> <code>True</code> <p>Returns:</p> Type Description <code>PolyhedralIoContract</code> <p>A polyhedral contract built from the arguments provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>dictionary provided was not well-formed.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>@staticmethod\ndef from_dict(contract: dict, simplify: bool = True) -&gt; PolyhedralIoContract:\n\"\"\"\n    Create contract from a dictionary.\n    Args:\n        contract: a dictionary containing the contract's data.\n        simplify: whether to simplify the guarantees with respect to the assumptions.\n    Returns:\n        A polyhedral contract built from the arguments provided.\n    Raises:\n        ValueError: dictionary provided was not well-formed.\n    \"\"\"\nif not isinstance(contract, dict):\nraise ValueError(\"A dict type contract is expected.\")\nfor kw in (\"assumptions\", \"guarantees\", \"input_vars\", \"output_vars\"):\nif kw not in contract:\nraise ValueError(f\"Passed dictionary does not have key {kw}.\")\nif all(isinstance(x, dict) for x in contract[\"assumptions\"]):\na = PolyhedralTermList(\n[\nPolyhedralTerm({Var(k): v for k, v in x[\"coefficients\"].items()}, float(x[\"constant\"]))\nfor x in contract[\"assumptions\"]\n]\n)\nelse:\nraise ValueError(\"Assumptions must be a list of dicts.\")\nif all(isinstance(x, dict) for x in contract[\"guarantees\"]):\ng = PolyhedralTermList(\n[\nPolyhedralTerm({Var(k): v for k, v in x[\"coefficients\"].items()}, float(x[\"constant\"]))\nfor x in contract[\"guarantees\"]\n]\n)\nelse:\nraise ValueError(\"Guarantees must be a list of dicts.\")\nreturn PolyhedralIoContract(\ninput_vars=[Var(x) for x in contract[\"input_vars\"]],\noutput_vars=[Var(x) for x in contract[\"output_vars\"]],\nassumptions=a,\nguarantees=g,\nsimplify=simplify,\n)\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.from_strings","title":"<code>from_strings(assumptions, guarantees, input_vars, output_vars, simplify=True)</code>  <code>staticmethod</code>","text":"<p>Create contract from several lists of strings.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>List[str]</code> <p>contract's assumptions.</p> required <code>guarantees</code> <code>List[str]</code> <p>contract's guarantees.</p> required <code>input_vars</code> <code>List[str]</code> <p>input variables of contract.</p> required <code>output_vars</code> <code>List[str]</code> <p>output variables of contract.</p> required <code>simplify</code> <code>bool</code> <p>whether to simplify the guarantees with respect to the assumptions.</p> <code>True</code> <p>Returns:</p> Type Description <code>PolyhedralIoContract</code> <p>A polyhedral contract built from the arguments provided.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>@staticmethod\ndef from_strings(\nassumptions: List[str],\nguarantees: List[str],\ninput_vars: List[str],\noutput_vars: List[str],\nsimplify: bool = True,\n) -&gt; PolyhedralIoContract:\n\"\"\"\n    Create contract from several lists of strings.\n    Args:\n        assumptions: contract's assumptions.\n        guarantees: contract's guarantees.\n        input_vars: input variables of contract.\n        output_vars: output variables of contract.\n        simplify: whether to simplify the guarantees with respect to the assumptions.\n    Returns:\n        A polyhedral contract built from the arguments provided.\n    \"\"\"\na: List[PolyhedralTerm] = []\nif assumptions:\na = [item for x in assumptions for item in serializer.polyhedral_termlist_from_string(x)]\ng: List[PolyhedralTerm] = []\nif guarantees:\ng = [item for x in guarantees for item in serializer.polyhedral_termlist_from_string(x)]\nreturn PolyhedralIoContract(\ninput_vars=[Var(x) for x in input_vars],\noutput_vars=[Var(x) for x in output_vars],\nassumptions=PolyhedralTermList(a),\nguarantees=PolyhedralTermList(g),\nsimplify=simplify,\n)\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.get_variable_bounds","title":"<code>get_variable_bounds(var)</code>","text":"<p>Obtain bounds for a variable in the context of a contract.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>variable whose bounds are sought.</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[numeric], Optional[numeric]]</code> <p>The minimum and maximum values for the variable in the context of the contract.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def get_variable_bounds(\nself, var: str\n) -&gt; Tuple[Optional[numeric], Optional[numeric]]:  # noqa: VNE002 variable 'var' should be clarified\n\"\"\"Obtain bounds for a variable in the context of a contract.\n    Args:\n        var:\n            variable whose bounds are sought.\n    Returns:\n        The minimum and maximum values for the variable in the context of the contract.\n    \"\"\"\nmaximum = self.optimize(var, maximize=True)\nminimum = self.optimize(var, maximize=False)\nreturn minimum, maximum\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.optimize","title":"<code>optimize(expr, maximize=True)</code>","text":"<p>Optimize linear objective over the contract.</p> <p>Compute the optima of a linear objective over the assumptions and guarantees of the contract.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>linear objective being optimized.</p> required <code>maximize</code> <code>bool</code> <p>Maximize if True; minimize if False.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[numeric]</code> <p>The optimal value of the objective in the context of the contract.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def optimize(self, expr: str, maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"Optimize linear objective over the contract.\n    Compute the optima of a linear objective over the assumptions and\n    guarantees of the contract.\n    Args:\n        expr:\n            linear objective being optimized.\n        maximize:\n            Maximize if True; minimize if False.\n    Returns:\n        The optimal value of the objective in the context of the contract.\n    \"\"\"\nnew_expr = expr + \" &lt;= 0\"\nvariables = serializer.polyhedral_termlist_from_string(new_expr)[0].variables\nconstraints: PolyhedralTermList = self.a | self.g\nreturn constraints.optimize(objective=variables, maximize=maximize)\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.quotient","title":"<code>quotient(other, additional_inputs=None, simplify=True)</code>","text":"<p>Quotient polyhedral contracts.</p> <p>Compute the quotient of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralIoContract</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <p>Returns:</p> Type Description <code>PolyhedralIoContract</code> <p>The abstracted quotient of the two contracts.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def quotient(  # noqa: WPS612\nself: PolyhedralIoContract,\nother: PolyhedralIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\n) -&gt; PolyhedralIoContract:\n\"\"\"Quotient polyhedral contracts.\n    Compute the quotient of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n    Returns:\n        The abstracted quotient of the two contracts.\n    \"\"\"\nreturn super().quotient(other, additional_inputs, simplify)\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.quotient_tactics","title":"<code>quotient_tactics(other, additional_inputs=None, simplify=True, tactics_order=None)</code>","text":"<p>Quotient polyhedral contracts with support for specifying the order of tactics and measuring their use.</p> <p>Compute the quotient of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralIoContract</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>The order of tactics to try for variable term elimination.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[PolyhedralIoContract, List[TacticStatistics]]</code> <p>The tuple of the abstracted quotient of the two contracts and of the list of tactics used.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def quotient_tactics(\nself: PolyhedralIoContract,\nother: PolyhedralIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralIoContract, List[TacticStatistics]]:\n\"\"\"Quotient polyhedral contracts with support for specifying the order of tactics and measuring their use.\n    Compute the quotient of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n        tactics_order:\n            The order of tactics to try for variable term elimination.\n    Returns:\n        The tuple of the abstracted quotient of the two contracts and of the list of tactics used.\n    \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nreturn super().quotient_tactics(other, additional_inputs, simplify, tactics_order)\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.rename_variables","title":"<code>rename_variables(variable_mappings)</code>","text":"<p>Rename variables in a contract.</p> <p>Parameters:</p> Name Type Description Default <code>variable_mappings</code> <code>List[Tuple[str, str]]</code> <p>Variables to be replaced.</p> required <p>Returns:</p> Type Description <code>PolyhedralIoContract</code> <p>A contract with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def rename_variables(self, variable_mappings: List[Tuple[str, str]]) -&gt; PolyhedralIoContract:\n\"\"\"\n    Rename variables in a contract.\n    Args:\n        variable_mappings: Variables to be replaced.\n    Returns:\n        A contract with `source_var` replaced by `target_var`.\n    \"\"\"\nnew_contract = self.copy()\nfor mapping in variable_mappings:\nnew_contract = new_contract.rename_variable(Var(mapping[0]), Var(mapping[1]))\nreturn new_contract\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.to_dict","title":"<code>to_dict()</code>","text":"<p>Map contract into a user-readable dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def to_dict(self) -&gt; dict:\n\"\"\"\n    Map contract into a user-readable dictionary.\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\nc_temp = {}\nc_temp[\"input_vars\"] = [str(x) for x in self.inputvars]\nc_temp[\"output_vars\"] = [str(x) for x in self.outputvars]\nc_temp[\"assumptions\"] = self.a.to_str_list()\nc_temp[\"guarantees\"] = self.g.to_str_list()\nreturn c_temp\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.to_machine_dict","title":"<code>to_machine_dict()</code>","text":"<p>Map contract into a machine-optimized dictionary.</p> <p>Returns:</p> Type Description <code>ser_contract</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def to_machine_dict(self) -&gt; ser_contract:\n\"\"\"\n    Map contract into a machine-optimized dictionary.\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\ninput_vars = [str(x) for x in self.inputvars]\noutput_vars = [str(x) for x in self.outputvars]\nassumptions: List[ser_pt] = [\n{\n\"constant\": float(term.constant),\n\"coefficients\": {str(k): float(v) for k, v in term.variables.items()},\n}\nfor term in self.a.terms\n]\nguarantees: List[ser_pt] = [\n{\n\"constant\": float(term.constant),\n\"coefficients\": {str(k): float(v) for k, v in term.variables.items()},\n}\nfor term in self.g.terms\n]\nreturn {\n\"input_vars\": input_vars,\n\"output_vars\": output_vars,\n\"assumptions\": assumptions,\n\"guarantees\": guarantees,\n}\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContractCompound","title":"<code>PolyhedralIoContractCompound</code>","text":"<p>               Bases: <code>IoContractCompound</code></p> <p>Compound IO contract with polyhedral assumptions and guarantees.</p> <p>Attributes:</p> Name Type Description <code>inputvars</code> <p>Variables which are inputs of the implementations of the contract.</p> <code>outputvars</code> <p>Variables which are outputs of the implementations of the contract.</p> <code>a</code> <code>NestedTermlist_t</code> <p>Contract assumptions.</p> <code>g</code> <code>NestedTermlist_t</code> <p>Contract guarantees.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>class PolyhedralIoContractCompound(IoContractCompound):\n\"\"\"\n    Compound IO contract with polyhedral assumptions and guarantees.\n    Attributes:\n        inputvars:\n            Variables which are inputs of the implementations of the contract.\n        outputvars:\n            Variables which are outputs of the implementations of the contract.\n        a: Contract assumptions.\n        g: Contract guarantees.\n    \"\"\"\n@staticmethod\ndef from_strings(\nassumptions: List[list[str]],\nguarantees: List[list[str]],\ninput_vars: List[str],\noutput_vars: List[str],\n) -&gt; PolyhedralIoContractCompound:\n\"\"\"\n        Create contract from several lists of strings.\n        Args:\n            assumptions: contract's assumptions.\n            guarantees: contract's guarantees.\n            input_vars: input variables of contract.\n            output_vars: output variables of contract.\n        Returns:\n            A polyhedral contract built from the arguments provided.\n        \"\"\"\na: List[PolyhedralTermList] = []\nif assumptions:\nfor termlist_str in assumptions:\na_termlist = [item for x in termlist_str for item in serializer.polyhedral_termlist_from_string(x)]\na.append(PolyhedralTermList(a_termlist))\ng: List[PolyhedralTermList] = []\nif guarantees:\nfor termlist_str in guarantees:\ng_termlist = [item for x in termlist_str for item in serializer.polyhedral_termlist_from_string(x)]\ng.append(PolyhedralTermList(g_termlist))\nreturn PolyhedralIoContractCompound(\ninput_vars=[Var(x) for x in input_vars],\noutput_vars=[Var(x) for x in output_vars],\nassumptions=NestedPolyhedra(a, force_empty_intersection=True),\nguarantees=NestedPolyhedra(g, force_empty_intersection=False),\n)\ndef to_dict(self) -&gt; dict:\n\"\"\"\n        Map contract into a user-readable dictionary.\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\nc_temp = {}\nc_temp[\"input_vars\"] = [str(x) for x in self.inputvars]\nc_temp[\"output_vars\"] = [str(x) for x in self.outputvars]\nc_temp[\"assumptions\"] = [x.to_str_list() for x in self.a.nested_termlist]\nc_temp[\"guarantees\"] = [x.to_str_list() for x in self.g.nested_termlist]\nreturn c_temp\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContractCompound.from_strings","title":"<code>from_strings(assumptions, guarantees, input_vars, output_vars)</code>  <code>staticmethod</code>","text":"<p>Create contract from several lists of strings.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>List[list[str]]</code> <p>contract's assumptions.</p> required <code>guarantees</code> <code>List[list[str]]</code> <p>contract's guarantees.</p> required <code>input_vars</code> <code>List[str]</code> <p>input variables of contract.</p> required <code>output_vars</code> <code>List[str]</code> <p>output variables of contract.</p> required <p>Returns:</p> Type Description <code>PolyhedralIoContractCompound</code> <p>A polyhedral contract built from the arguments provided.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>@staticmethod\ndef from_strings(\nassumptions: List[list[str]],\nguarantees: List[list[str]],\ninput_vars: List[str],\noutput_vars: List[str],\n) -&gt; PolyhedralIoContractCompound:\n\"\"\"\n    Create contract from several lists of strings.\n    Args:\n        assumptions: contract's assumptions.\n        guarantees: contract's guarantees.\n        input_vars: input variables of contract.\n        output_vars: output variables of contract.\n    Returns:\n        A polyhedral contract built from the arguments provided.\n    \"\"\"\na: List[PolyhedralTermList] = []\nif assumptions:\nfor termlist_str in assumptions:\na_termlist = [item for x in termlist_str for item in serializer.polyhedral_termlist_from_string(x)]\na.append(PolyhedralTermList(a_termlist))\ng: List[PolyhedralTermList] = []\nif guarantees:\nfor termlist_str in guarantees:\ng_termlist = [item for x in termlist_str for item in serializer.polyhedral_termlist_from_string(x)]\ng.append(PolyhedralTermList(g_termlist))\nreturn PolyhedralIoContractCompound(\ninput_vars=[Var(x) for x in input_vars],\noutput_vars=[Var(x) for x in output_vars],\nassumptions=NestedPolyhedra(a, force_empty_intersection=True),\nguarantees=NestedPolyhedra(g, force_empty_intersection=False),\n)\n</code></pre>"},{"location":"polyhedral-contracts/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContractCompound.to_dict","title":"<code>to_dict()</code>","text":"<p>Map contract into a user-readable dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def to_dict(self) -&gt; dict:\n\"\"\"\n    Map contract into a user-readable dictionary.\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\nc_temp = {}\nc_temp[\"input_vars\"] = [str(x) for x in self.inputvars]\nc_temp[\"output_vars\"] = [str(x) for x in self.outputvars]\nc_temp[\"assumptions\"] = [x.to_str_list() for x in self.a.nested_termlist]\nc_temp[\"guarantees\"] = [x.to_str_list() for x in self.g.nested_termlist]\nreturn c_temp\n</code></pre>"},{"location":"smt-contracts/","title":"SmtContracts","text":"<p>Specializes IO contract into contracts with SMT assumptions and guarantees.</p>"},{"location":"smt-contracts/#pacti.contracts.smt_iocontract.SmtIoContract","title":"<code>SmtIoContract</code>","text":"<p>               Bases: <code>IoContract</code></p> <p>IO Contracts with assumptions and guarantees expressed as SMT constraints.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>class SmtIoContract(IoContract):\n\"\"\"IO Contracts with assumptions and guarantees expressed as SMT constraints.\"\"\"\ndef rename_variables(self, variable_mappings: List[Tuple[str, str]]) -&gt; SmtIoContract:\n\"\"\"\n        Rename variables in a contract.\n        Args:\n            variable_mappings: Variables to be replaced.\n        Returns:\n            A contract with `source_var` replaced by `target_var`.\n        \"\"\"\nnew_contract = self.copy()\nfor mapping in variable_mappings:\nnew_contract = new_contract.rename_variable(Var(mapping[0]), Var(mapping[1]))\nreturn new_contract\ndef to_machine_dict(self) -&gt; ser_contract:\n\"\"\"\n        Map contract into a machine-optimized dictionary.\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\nreturn self.to_dict()\ndef to_dict(self) -&gt; ser_contract:\n\"\"\"\n        Map contract into a user-readable dictionary.\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\nc_temp: ser_contract = {\n\"input_vars\": [str(x) for x in self.inputvars],\n\"output_vars\": [str(x) for x in self.outputvars],\n\"assumptions\": self.a.to_str_list(),\n\"guarantees\": self.g.to_str_list(),\n}\nreturn c_temp  # noqa: WPS331 c_temp only used for `return`\n@staticmethod\ndef from_z3_terms(\nassumptions: List[z3.BoolRef],\nguarantees: List[z3.BoolRef],\ninput_vars: List[str],\noutput_vars: List[str],\nsimplify: bool = True,\n) -&gt; SmtIoContract:\n\"\"\"\n        Create contract from several lists of z3 terms.\n        Args:\n            assumptions: contract's assumptions.\n            guarantees: contract's guarantees.\n            input_vars: input variables of contract.\n            output_vars: output variables of contract.\n            simplify: whether to simplify the guarantees with respect to the assumptions.\n        Returns:\n            An SMT contract built from the arguments provided.\n        \"\"\"\na: List[SmtTerm] = []\nif assumptions:\na = [SmtTerm(x) for x in assumptions]\ng: List[SmtTerm] = []\nif guarantees:\ng = [SmtTerm(x) for x in guarantees]\nreturn SmtIoContract(\ninput_vars=[Var(x) for x in input_vars],\noutput_vars=[Var(x) for x in output_vars],\nassumptions=SmtTermList(a),\nguarantees=SmtTermList(g),\nsimplify=simplify,\n)\ndef compose(\nself,\nother: SmtIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\n) -&gt; SmtIoContract:\n\"\"\"Compose SMT contracts.\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n        Returns:\n            The abstracted composition of the two contracts.\n        \"\"\"\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose(other, [Var(x) for x in vars_to_keep], simplify)\ndef compose_tactics(\nself,\nother: SmtIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtIoContract, List[TacticStatistics]]:\n\"\"\"Compose SMT contracts.\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n            tactics_order:\n                The order of tactics to try for variable term elimination.\n        Returns:\n            The tuple of the abstracted composition of the two contracts and of the list of tactics used.\n        \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose_tactics(other, [Var(x) for x in vars_to_keep], simplify, tactics_order)\ndef quotient(  # noqa: WPS612\nself: SmtIoContract,\nother: SmtIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\n) -&gt; SmtIoContract:\n\"\"\"Quotient SMT contracts.\n        Compute the quotient of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n        Returns:\n            The abstracted quotient of the two contracts.\n        \"\"\"\nreturn super().quotient(other, additional_inputs, simplify)\ndef quotient_tactics(\nself: SmtIoContract,\nother: SmtIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtIoContract, List[TacticStatistics]]:\n\"\"\"Quotient SMT contracts with support for specifying the order of tactics and measuring their use.\n        Compute the quotient of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n            tactics_order:\n                The order of tactics to try for variable term elimination.\n        Returns:\n            The tuple of the abstracted quotient of the two contracts and of the list of tactics used.\n        \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nreturn super().quotient_tactics(other, additional_inputs, simplify, tactics_order)\n</code></pre>"},{"location":"smt-contracts/#pacti.contracts.smt_iocontract.SmtIoContract.compose","title":"<code>compose(other, vars_to_keep=None, simplify=True)</code>","text":"<p>Compose SMT contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SmtIoContract</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Optional[List[str]]</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <p>Returns:</p> Type Description <code>SmtIoContract</code> <p>The abstracted composition of the two contracts.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def compose(\nself,\nother: SmtIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\n) -&gt; SmtIoContract:\n\"\"\"Compose SMT contracts.\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n    Returns:\n        The abstracted composition of the two contracts.\n    \"\"\"\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose(other, [Var(x) for x in vars_to_keep], simplify)\n</code></pre>"},{"location":"smt-contracts/#pacti.contracts.smt_iocontract.SmtIoContract.compose_tactics","title":"<code>compose_tactics(other, vars_to_keep=None, simplify=True, tactics_order=None)</code>","text":"<p>Compose SMT contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SmtIoContract</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Optional[List[str]]</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>The order of tactics to try for variable term elimination.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[SmtIoContract, List[TacticStatistics]]</code> <p>The tuple of the abstracted composition of the two contracts and of the list of tactics used.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def compose_tactics(\nself,\nother: SmtIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtIoContract, List[TacticStatistics]]:\n\"\"\"Compose SMT contracts.\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n        tactics_order:\n            The order of tactics to try for variable term elimination.\n    Returns:\n        The tuple of the abstracted composition of the two contracts and of the list of tactics used.\n    \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose_tactics(other, [Var(x) for x in vars_to_keep], simplify, tactics_order)\n</code></pre>"},{"location":"smt-contracts/#pacti.contracts.smt_iocontract.SmtIoContract.from_z3_terms","title":"<code>from_z3_terms(assumptions, guarantees, input_vars, output_vars, simplify=True)</code>  <code>staticmethod</code>","text":"<p>Create contract from several lists of z3 terms.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>List[BoolRef]</code> <p>contract's assumptions.</p> required <code>guarantees</code> <code>List[BoolRef]</code> <p>contract's guarantees.</p> required <code>input_vars</code> <code>List[str]</code> <p>input variables of contract.</p> required <code>output_vars</code> <code>List[str]</code> <p>output variables of contract.</p> required <code>simplify</code> <code>bool</code> <p>whether to simplify the guarantees with respect to the assumptions.</p> <code>True</code> <p>Returns:</p> Type Description <code>SmtIoContract</code> <p>An SMT contract built from the arguments provided.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>@staticmethod\ndef from_z3_terms(\nassumptions: List[z3.BoolRef],\nguarantees: List[z3.BoolRef],\ninput_vars: List[str],\noutput_vars: List[str],\nsimplify: bool = True,\n) -&gt; SmtIoContract:\n\"\"\"\n    Create contract from several lists of z3 terms.\n    Args:\n        assumptions: contract's assumptions.\n        guarantees: contract's guarantees.\n        input_vars: input variables of contract.\n        output_vars: output variables of contract.\n        simplify: whether to simplify the guarantees with respect to the assumptions.\n    Returns:\n        An SMT contract built from the arguments provided.\n    \"\"\"\na: List[SmtTerm] = []\nif assumptions:\na = [SmtTerm(x) for x in assumptions]\ng: List[SmtTerm] = []\nif guarantees:\ng = [SmtTerm(x) for x in guarantees]\nreturn SmtIoContract(\ninput_vars=[Var(x) for x in input_vars],\noutput_vars=[Var(x) for x in output_vars],\nassumptions=SmtTermList(a),\nguarantees=SmtTermList(g),\nsimplify=simplify,\n)\n</code></pre>"},{"location":"smt-contracts/#pacti.contracts.smt_iocontract.SmtIoContract.quotient","title":"<code>quotient(other, additional_inputs=None, simplify=True)</code>","text":"<p>Quotient SMT contracts.</p> <p>Compute the quotient of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SmtIoContract</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <p>Returns:</p> Type Description <code>SmtIoContract</code> <p>The abstracted quotient of the two contracts.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def quotient(  # noqa: WPS612\nself: SmtIoContract,\nother: SmtIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\n) -&gt; SmtIoContract:\n\"\"\"Quotient SMT contracts.\n    Compute the quotient of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n    Returns:\n        The abstracted quotient of the two contracts.\n    \"\"\"\nreturn super().quotient(other, additional_inputs, simplify)\n</code></pre>"},{"location":"smt-contracts/#pacti.contracts.smt_iocontract.SmtIoContract.quotient_tactics","title":"<code>quotient_tactics(other, additional_inputs=None, simplify=True, tactics_order=None)</code>","text":"<p>Quotient SMT contracts with support for specifying the order of tactics and measuring their use.</p> <p>Compute the quotient of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SmtIoContract</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>The order of tactics to try for variable term elimination.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[SmtIoContract, List[TacticStatistics]]</code> <p>The tuple of the abstracted quotient of the two contracts and of the list of tactics used.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def quotient_tactics(\nself: SmtIoContract,\nother: SmtIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtIoContract, List[TacticStatistics]]:\n\"\"\"Quotient SMT contracts with support for specifying the order of tactics and measuring their use.\n    Compute the quotient of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n        tactics_order:\n            The order of tactics to try for variable term elimination.\n    Returns:\n        The tuple of the abstracted quotient of the two contracts and of the list of tactics used.\n    \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nreturn super().quotient_tactics(other, additional_inputs, simplify, tactics_order)\n</code></pre>"},{"location":"smt-contracts/#pacti.contracts.smt_iocontract.SmtIoContract.rename_variables","title":"<code>rename_variables(variable_mappings)</code>","text":"<p>Rename variables in a contract.</p> <p>Parameters:</p> Name Type Description Default <code>variable_mappings</code> <code>List[Tuple[str, str]]</code> <p>Variables to be replaced.</p> required <p>Returns:</p> Type Description <code>SmtIoContract</code> <p>A contract with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def rename_variables(self, variable_mappings: List[Tuple[str, str]]) -&gt; SmtIoContract:\n\"\"\"\n    Rename variables in a contract.\n    Args:\n        variable_mappings: Variables to be replaced.\n    Returns:\n        A contract with `source_var` replaced by `target_var`.\n    \"\"\"\nnew_contract = self.copy()\nfor mapping in variable_mappings:\nnew_contract = new_contract.rename_variable(Var(mapping[0]), Var(mapping[1]))\nreturn new_contract\n</code></pre>"},{"location":"smt-contracts/#pacti.contracts.smt_iocontract.SmtIoContract.to_dict","title":"<code>to_dict()</code>","text":"<p>Map contract into a user-readable dictionary.</p> <p>Returns:</p> Type Description <code>ser_contract</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def to_dict(self) -&gt; ser_contract:\n\"\"\"\n    Map contract into a user-readable dictionary.\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\nc_temp: ser_contract = {\n\"input_vars\": [str(x) for x in self.inputvars],\n\"output_vars\": [str(x) for x in self.outputvars],\n\"assumptions\": self.a.to_str_list(),\n\"guarantees\": self.g.to_str_list(),\n}\nreturn c_temp  # noqa: WPS331 c_temp only used for `return`\n</code></pre>"},{"location":"smt-contracts/#pacti.contracts.smt_iocontract.SmtIoContract.to_machine_dict","title":"<code>to_machine_dict()</code>","text":"<p>Map contract into a machine-optimized dictionary.</p> <p>Returns:</p> Type Description <code>ser_contract</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def to_machine_dict(self) -&gt; ser_contract:\n\"\"\"\n    Map contract into a machine-optimized dictionary.\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\nreturn self.to_dict()\n</code></pre>"},{"location":"smt/","title":"SmtTems","text":"<p>Support for SMT constraints.</p> <p>Module provides support for SMT expressions as constraints.</p>"},{"location":"smt/#pacti.terms.smt.smt.SmtTerm","title":"<code>SmtTerm</code>","text":"<p>               Bases: <code>Term</code></p> <p>SMT terms.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>class SmtTerm(Term):\n\"\"\"SMT terms.\"\"\"\ndef __init__(self, expression: z3.BoolRef):  # noqa: WPS231  too much cognitive complexity\n\"\"\"\n        Constructor for SmtTerm.\n        Usage:\n            SMT terms are initialized by passing an SMT expression.\n        Args:\n            expression: A boolean expression involving uninterpreted atoms.\n        Raises:\n            ValueError: Unsupported argument type.\n        \"\"\"\nself.expression: z3.BoolRef\nif isinstance(expression, z3.BoolRef):\nself.expression = copy.deepcopy(expression)\nelse:\nraise ValueError()\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError()\nreturn str(self) == str(other)\ndef __str__(self) -&gt; str:\n# return SmtTerm.add_globally(_expr_to_str(self.expression))\nreturn str(self.expression)\ndef __hash__(self) -&gt; int:\nreturn hash(str(self))\ndef __repr__(self) -&gt; str:\nreturn \"&lt;Term {0}&gt;\".format(self)\n@property\ndef atoms(self) -&gt; List[str]:  # noqa: A003\n\"\"\"\n        Atoms appearing in term.\n        Returns:\n            List of atoms referenced in term.\n        \"\"\"\nreturn _get_z3_literals(self.expression)\n@property\ndef vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"\n        Variables appearing in term.\n        Returns:\n            List of variables referenced in term.\n        \"\"\"\nreturn [Var(atom) for atom in self.atoms]\ndef contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n        Tell whether term contains a given variable.\n        Args:\n            var_to_seek: The variable that we are seeking in the current term.\n        Returns:\n            `True` if the syntax of the term refers to the given variable;\n                `False` otherwise.\n        \"\"\"\nreturn var_to_seek in self.vars\ndef copy(self) -&gt; SmtTerm:\n\"\"\"\n        Generates copy of term.\n        Returns:\n            Copy of term.\n        \"\"\"\nexpression = copy.deepcopy(self.expression)\nreturn SmtTerm(expression)\ndef rename_variable(self, source_var: Var, target_var: Var) -&gt; SmtTerm:\n\"\"\"\n        Rename a variable in a term.\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n        Returns:\n            A term with `source_var` replaced by `target_var`.\n        \"\"\"\nret_expr = _rename_expr(self.expression, source_var.name, target_var.name)\nreturn SmtTerm(ret_expr)\ndef is_tautology(self) -&gt; bool:\n\"\"\"\n        Tell whether term is a tautology.\n        Returns:\n            True if tautology.\n        \"\"\"\nreturn _is_tautology(self.expression)\ndef is_sat(self) -&gt; bool:\n\"\"\"\n        Tell whether term is a satisfiable.\n        Returns:\n            True if satisfiable.\n        \"\"\"\nreturn _is_sat(self.expression)\ndef contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n        Tell whether Term contains the given behavior.\n        Args:\n            behavior:\n                The behavior in question.\n        Returns:\n            True if the behavior satisfies the constraint; false otherwise.\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\nvariables_to_substitute: List[Var] = list(behavior.keys())\nif list_diff(self.vars, variables_to_substitute):\nraise ValueError(\"Not all variables assigned\")\nnew_expression = copy.deepcopy(self.expression)\nrelevant_variables: List[Var] = list_intersection(variables_to_substitute, self.vars)\nfor elim_var in relevant_variables:\nnew_expression = _replace_var_with_val(new_expression, elim_var.name, behavior[elim_var])\nreturn _is_tautology(new_expression)\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTerm.atoms","title":"<code>atoms</code>  <code>property</code>","text":"<p>Atoms appearing in term.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of atoms referenced in term.</p>"},{"location":"smt/#pacti.terms.smt.smt.SmtTerm.vars","title":"<code>vars</code>  <code>property</code>","text":"<p>Variables appearing in term.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>List of variables referenced in term.</p>"},{"location":"smt/#pacti.terms.smt.smt.SmtTerm.__init__","title":"<code>__init__(expression)</code>","text":"<p>Constructor for SmtTerm.</p> Usage <p>SMT terms are initialized by passing an SMT expression.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>BoolRef</code> <p>A boolean expression involving uninterpreted atoms.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Unsupported argument type.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def __init__(self, expression: z3.BoolRef):  # noqa: WPS231  too much cognitive complexity\n\"\"\"\n    Constructor for SmtTerm.\n    Usage:\n        SMT terms are initialized by passing an SMT expression.\n    Args:\n        expression: A boolean expression involving uninterpreted atoms.\n    Raises:\n        ValueError: Unsupported argument type.\n    \"\"\"\nself.expression: z3.BoolRef\nif isinstance(expression, z3.BoolRef):\nself.expression = copy.deepcopy(expression)\nelse:\nraise ValueError()\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTerm.contains_behavior","title":"<code>contains_behavior(behavior)</code>","text":"<p>Tell whether Term contains the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Dict[Var, numeric]</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraint; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n    Tell whether Term contains the given behavior.\n    Args:\n        behavior:\n            The behavior in question.\n    Returns:\n        True if the behavior satisfies the constraint; false otherwise.\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\nvariables_to_substitute: List[Var] = list(behavior.keys())\nif list_diff(self.vars, variables_to_substitute):\nraise ValueError(\"Not all variables assigned\")\nnew_expression = copy.deepcopy(self.expression)\nrelevant_variables: List[Var] = list_intersection(variables_to_substitute, self.vars)\nfor elim_var in relevant_variables:\nnew_expression = _replace_var_with_val(new_expression, elim_var.name, behavior[elim_var])\nreturn _is_tautology(new_expression)\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTerm.contains_var","title":"<code>contains_var(var_to_seek)</code>","text":"<p>Tell whether term contains a given variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_to_seek</code> <code>Var</code> <p>The variable that we are seeking in the current term.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the syntax of the term refers to the given variable; <code>False</code> otherwise.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n    Tell whether term contains a given variable.\n    Args:\n        var_to_seek: The variable that we are seeking in the current term.\n    Returns:\n        `True` if the syntax of the term refers to the given variable;\n            `False` otherwise.\n    \"\"\"\nreturn var_to_seek in self.vars\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTerm.copy","title":"<code>copy()</code>","text":"<p>Generates copy of term.</p> <p>Returns:</p> Type Description <code>SmtTerm</code> <p>Copy of term.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def copy(self) -&gt; SmtTerm:\n\"\"\"\n    Generates copy of term.\n    Returns:\n        Copy of term.\n    \"\"\"\nexpression = copy.deepcopy(self.expression)\nreturn SmtTerm(expression)\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTerm.is_sat","title":"<code>is_sat()</code>","text":"<p>Tell whether term is a satisfiable.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if satisfiable.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def is_sat(self) -&gt; bool:\n\"\"\"\n    Tell whether term is a satisfiable.\n    Returns:\n        True if satisfiable.\n    \"\"\"\nreturn _is_sat(self.expression)\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTerm.is_tautology","title":"<code>is_tautology()</code>","text":"<p>Tell whether term is a tautology.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if tautology.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def is_tautology(self) -&gt; bool:\n\"\"\"\n    Tell whether term is a tautology.\n    Returns:\n        True if tautology.\n    \"\"\"\nreturn _is_tautology(self.expression)\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTerm.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a term.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>SmtTerm</code> <p>A term with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def rename_variable(self, source_var: Var, target_var: Var) -&gt; SmtTerm:\n\"\"\"\n    Rename a variable in a term.\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n    Returns:\n        A term with `source_var` replaced by `target_var`.\n    \"\"\"\nret_expr = _rename_expr(self.expression, source_var.name, target_var.name)\nreturn SmtTerm(ret_expr)\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTermList","title":"<code>SmtTermList</code>","text":"<p>               Bases: <code>TermList</code></p> <p>A TermList of SmtTerm instances.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>class SmtTermList(TermList):  # noqa: WPS338\n\"\"\"A TermList of SmtTerm instances.\"\"\"\ndef __init__(self, terms: Optional[List[SmtTerm]] = None):\n\"\"\"\n        Constructor for SmtTermList.\n        Args:\n            terms: A list of SmtTerm objects.\n        Raises:\n            ValueError: incorrect argument type provided.\n        \"\"\"\nif terms is None:\nself.terms = []\nelif all(isinstance(t, SmtTerm) for t in terms):\nself.terms = terms.copy()\nelse:\nraise ValueError(\"SmtTermList constructor argument must be a list of SmtTerms.\")\ndef __str__(self) -&gt; str:\nres = \"[\\n  \"\nres += \"\\n  \".join(self.to_str_list())\nres += \"\\n]\"\nreturn res\ndef __hash__(self) -&gt; int:\nreturn hash(tuple(self.terms))\ndef __le__(self, other: SmtTermList) -&gt; bool:\nreturn self.refines(other)\ndef is_semantically_equivalent_to(self, other: SmtTermList) -&gt; bool:\n\"\"\"\n        Tell whether two termlists are semantically equivalent.\n        Args:\n            other:\n                The termlist against which we compare self.\n        Returns:\n            True if the two termlists are semantically equivalent.\n        \"\"\"\nreturn self.refines(other) and other.refines(self)\ndef to_str_list(self) -&gt; List[str]:\n\"\"\"\n        Convert termlist into a list of strings.\n        Returns:\n            A list of strings corresponding to the terms of the termlist.\n        \"\"\"\nreturn [str(term) for term in self.terms]\ndef contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n        Tell whether TermList contains the given behavior.\n        Args:\n            behavior:\n                The behavior in question.\n        Returns:\n            True if the behavior satisfies the constraints; false otherwise.\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\nfor term in self.terms:\ntry:\nif not term.contains_behavior(behavior):\nreturn False\nexcept ValueError as e:\nraise ValueError(e)\nreturn True\ndef _to_smtexpr(self) -&gt; z3.BoolRef:\nreturn z3.And(*[xs.expression for xs in self.terms])\n@staticmethod\ndef _transform_term(  # noqa: WPS231  too much cognitive complexity\nterm: SmtTerm,\ncontext: SmtTermList,\nvars_to_elim: list,\nrefine: bool,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtTerm, SmtTermList]:\nnew_term: SmtTerm\n# Check whether there is something to do with this term\nif list_intersection(vars_to_elim, term.vars):\natoms_to_elim = list(map(str, list_intersection(vars_to_elim, list_union(term.vars, context.vars))))\nreference_term = SmtTerm(_elim_variables(term.expression, context._to_smtexpr(), atoms_to_elim, refine))\nnew_term = reference_term.copy()\nfinal_context = context.copy()\n# now check whether we can find equivalent \"in-context\" semantics using a reduced context\nif simplify:\ngolden_compare = context | SmtTermList([reference_term])\nindices_removed: List[int] = []\nfor i, _ in enumerate(context.terms):\ntest_context = SmtTermList(list_remove_indices(context.terms, indices_removed + [i]))\ntest_term = SmtTerm(\n_elim_variables(term.expression, test_context._to_smtexpr(), atoms_to_elim, refine)\n)\ntest_compare = context | SmtTermList([test_term])\nif (golden_compare).is_semantically_equivalent_to(test_compare):\nindices_removed.append(i)\nnew_term = test_term.copy()\nfinal_context = test_context.copy()\nelse:\nnew_term = term.copy()\nfinal_context = context.copy()\nif not new_term.is_sat():\nraise ValueError(\"Computed term is empty\")\nreturn new_term, final_context\ndef _transform_termlist(  # noqa: WPS231  too much cognitive complexity\nself,\ncontext: SmtTermList,\nvars_to_elim: list,\nrefine: bool,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtTermList, TacticStatistics]:\nnew_terms = []\n# only keep the context with relevant variables\nrelevant_terms = []\nfor term in context.terms:\nif list_intersection(term.vars, vars_to_elim):\nrelevant_terms.append(term)\nrelevant_context = SmtTermList(relevant_terms)\nfor term in self.terms:\ntry:\nnew_term, _ = SmtTermList._transform_term(\nterm, relevant_context, vars_to_elim, refine, simplify, tactics_order\n)\nexcept ValueError as e:\nraise ValueError(e)\nnew_terms.append(new_term)\nreturn SmtTermList(new_terms), []\ndef elim_vars_by_refining(  # noqa: WPS231  too much cognitive complexity\nself,\ncontext: SmtTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtTermList, TacticStatistics]:\n\"\"\"\n        Eliminate variables from SmtTermList by refining it in context.\n        Example:\n            Suppose the current list of terms is $\\\\{x + y \\\\le 6\\\\}$, the\n            context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n            contain variable $y$. Then the current TermList could be\n            refined to $\\\\{x \\\\le 1\\\\}$ because $x \\\\le 1\n            \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x + y \\\\le 6$.\n        Args:\n            context:\n                The TermList providing the context for the refinement.\n            vars_to_elim:\n                Variables that should not appear in the resulting term.\n            simplify:\n                Whether to perform simplifications.\n            tactics_order:\n                Optionally, the order of tactics to invoke during transformation.\n        Returns:\n            A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n                and which, in the context provided, imply the terms contained in the\n                calling termlist; and (b) the list of tuples, for each processed term, of\n                the tactic used, time spend, and tactic invocation count.\n        Raises:\n            ValueError: Self has empty intersection with its context.\n        \"\"\"\ntry:\nreturn self._transform_termlist(\ncontext=context, vars_to_elim=vars_to_elim, refine=True, simplify=simplify, tactics_order=tactics_order\n)\nexcept ValueError as e:\nraise ValueError(e)\ndef elim_vars_by_relaxing(\nself,\ncontext: SmtTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtTermList, TacticStatistics]:\n\"\"\"\n        Eliminate variables from SmtTemList by abstracting it in context.\n        Example:\n            Suppose the current list of terms is $\\\\{x - y \\\\le 6\\\\}$, the\n            context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n            contain variable $y$. Then the current TermList could be\n            relaxed to $\\\\{x \\\\le 11\\\\}$ because $x - y \\\\le 6\n            \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x \\\\le 11$.\n        Args:\n            context:\n                The TermList providing the context for the transformation.\n            vars_to_elim:\n                Variables that should not appear in the relaxed terms.\n            simplify:\n                Whether to perform simplifications.\n            tactics_order:\n                Optionally, the order of tactics to invoke during transformation.\n        Returns:\n            A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n                and which, in the context provided, are implied by the terms\n                contained in the calling termlist; and (b) the list of tuples, for each\n                processed term, of the tactic used, time spend, and tactic invocation count.\n        \"\"\"\nreturn self._transform_termlist(\ncontext=context, vars_to_elim=vars_to_elim, refine=False, simplify=simplify, tactics_order=tactics_order\n)\ndef simplify(self, context: Optional[SmtTermList] = None) -&gt; SmtTermList:\n\"\"\"\n        Remove redundant terms in the TermList using the provided context.\n        Example:\n            Suppose the TermList is $\\\\{x - 2y \\\\le 5, x - y \\\\le 0\\\\}$ and\n            the context is $\\\\{x + y \\\\le 0\\\\}$. Then the TermList could be\n            simplified to $\\\\{x - y \\\\le 0\\\\}$.\n        Args:\n            context:\n                The TermList providing the context for the simplification.\n        Returns:\n            A new TermList with redundant terms removed using the provided context.\n        \"\"\"\nnewterms: List[SmtTerm] = []\nexternal_context = SmtTermList([])\nif context:\nexternal_context = context\nfor i, term_under_analysis in enumerate(self.terms):\nuseful_context = SmtTermList(newterms) | SmtTermList(self.terms[i + 1 :]) | external_context\nif not useful_context.refines(SmtTermList([term_under_analysis])):\nnewterms.append(term_under_analysis.copy())\nreturn SmtTermList(newterms)\ndef refines(self, other: SmtTermList) -&gt; bool:\n\"\"\"\n        Tells whether the argument is a larger specification.\n        Args:\n            other:\n                TermList against which we are comparing self.\n        Returns:\n            self &lt;= other\n        \"\"\"\nantecedent = self._to_smtexpr()\nconsequent = other._to_smtexpr()\ntest_expr: z3.BoolRef = z3.Implies(antecedent, consequent)\nreturn _is_tautology(test_expr)\ndef is_empty(self) -&gt; bool:\n\"\"\"\n        Tell whether the argument has no satisfying assignments.\n        Returns:\n            True if constraints cannot be satisfied.\n        \"\"\"\ntest_expr = self._to_smtexpr()\nif _is_sat(test_expr):  # noqa: WPS531 if condition can be simplified\nreturn False\nreturn True\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTermList.__init__","title":"<code>__init__(terms=None)</code>","text":"<p>Constructor for SmtTermList.</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>Optional[List[SmtTerm]]</code> <p>A list of SmtTerm objects.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>incorrect argument type provided.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def __init__(self, terms: Optional[List[SmtTerm]] = None):\n\"\"\"\n    Constructor for SmtTermList.\n    Args:\n        terms: A list of SmtTerm objects.\n    Raises:\n        ValueError: incorrect argument type provided.\n    \"\"\"\nif terms is None:\nself.terms = []\nelif all(isinstance(t, SmtTerm) for t in terms):\nself.terms = terms.copy()\nelse:\nraise ValueError(\"SmtTermList constructor argument must be a list of SmtTerms.\")\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTermList.contains_behavior","title":"<code>contains_behavior(behavior)</code>","text":"<p>Tell whether TermList contains the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Dict[Var, numeric]</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraints; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n    Tell whether TermList contains the given behavior.\n    Args:\n        behavior:\n            The behavior in question.\n    Returns:\n        True if the behavior satisfies the constraints; false otherwise.\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\nfor term in self.terms:\ntry:\nif not term.contains_behavior(behavior):\nreturn False\nexcept ValueError as e:\nraise ValueError(e)\nreturn True\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTermList.elim_vars_by_refining","title":"<code>elim_vars_by_refining(context, vars_to_elim, simplify=True, tactics_order=None)</code>","text":"<p>Eliminate variables from SmtTermList by refining it in context.</p> Example <p>Suppose the current list of terms is \\(\\{x + y \\le 6\\}\\), the context is \\(\\{y \\le 5\\}\\), and the resulting terms should not contain variable \\(y\\). Then the current TermList could be refined to \\(\\{x \\le 1\\}\\) because \\(x \\le 1 \\;\\land\\; y \\le 5 \\Rightarrow x + y \\le 6\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>SmtTermList</code> <p>The TermList providing the context for the refinement.</p> required <code>vars_to_elim</code> <code>list</code> <p>Variables that should not appear in the resulting term.</p> required <code>simplify</code> <code>bool</code> <p>Whether to perform simplifications.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>Optionally, the order of tactics to invoke during transformation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[SmtTermList, TacticStatistics]</code> <p>A tuple of (a) a list of terms not containing any variables in <code>vars_to_elim</code> and which, in the context provided, imply the terms contained in the calling termlist; and (b) the list of tuples, for each processed term, of the tactic used, time spend, and tactic invocation count.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Self has empty intersection with its context.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def elim_vars_by_refining(  # noqa: WPS231  too much cognitive complexity\nself,\ncontext: SmtTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtTermList, TacticStatistics]:\n\"\"\"\n    Eliminate variables from SmtTermList by refining it in context.\n    Example:\n        Suppose the current list of terms is $\\\\{x + y \\\\le 6\\\\}$, the\n        context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n        contain variable $y$. Then the current TermList could be\n        refined to $\\\\{x \\\\le 1\\\\}$ because $x \\\\le 1\n        \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x + y \\\\le 6$.\n    Args:\n        context:\n            The TermList providing the context for the refinement.\n        vars_to_elim:\n            Variables that should not appear in the resulting term.\n        simplify:\n            Whether to perform simplifications.\n        tactics_order:\n            Optionally, the order of tactics to invoke during transformation.\n    Returns:\n        A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, imply the terms contained in the\n            calling termlist; and (b) the list of tuples, for each processed term, of\n            the tactic used, time spend, and tactic invocation count.\n    Raises:\n        ValueError: Self has empty intersection with its context.\n    \"\"\"\ntry:\nreturn self._transform_termlist(\ncontext=context, vars_to_elim=vars_to_elim, refine=True, simplify=simplify, tactics_order=tactics_order\n)\nexcept ValueError as e:\nraise ValueError(e)\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTermList.elim_vars_by_relaxing","title":"<code>elim_vars_by_relaxing(context, vars_to_elim, simplify=True, tactics_order=None)</code>","text":"<p>Eliminate variables from SmtTemList by abstracting it in context.</p> Example <p>Suppose the current list of terms is \\(\\{x - y \\le 6\\}\\), the context is \\(\\{y \\le 5\\}\\), and the resulting terms should not contain variable \\(y\\). Then the current TermList could be relaxed to \\(\\{x \\le 11\\}\\) because \\(x - y \\le 6 \\;\\land\\; y \\le 5 \\Rightarrow x \\le 11\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>SmtTermList</code> <p>The TermList providing the context for the transformation.</p> required <code>vars_to_elim</code> <code>list</code> <p>Variables that should not appear in the relaxed terms.</p> required <code>simplify</code> <code>bool</code> <p>Whether to perform simplifications.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>Optionally, the order of tactics to invoke during transformation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[SmtTermList, TacticStatistics]</code> <p>A tuple of (a) a list of terms not containing any variables in <code>vars_to_elim</code> and which, in the context provided, are implied by the terms contained in the calling termlist; and (b) the list of tuples, for each processed term, of the tactic used, time spend, and tactic invocation count.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def elim_vars_by_relaxing(\nself,\ncontext: SmtTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtTermList, TacticStatistics]:\n\"\"\"\n    Eliminate variables from SmtTemList by abstracting it in context.\n    Example:\n        Suppose the current list of terms is $\\\\{x - y \\\\le 6\\\\}$, the\n        context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n        contain variable $y$. Then the current TermList could be\n        relaxed to $\\\\{x \\\\le 11\\\\}$ because $x - y \\\\le 6\n        \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x \\\\le 11$.\n    Args:\n        context:\n            The TermList providing the context for the transformation.\n        vars_to_elim:\n            Variables that should not appear in the relaxed terms.\n        simplify:\n            Whether to perform simplifications.\n        tactics_order:\n            Optionally, the order of tactics to invoke during transformation.\n    Returns:\n        A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, are implied by the terms\n            contained in the calling termlist; and (b) the list of tuples, for each\n            processed term, of the tactic used, time spend, and tactic invocation count.\n    \"\"\"\nreturn self._transform_termlist(\ncontext=context, vars_to_elim=vars_to_elim, refine=False, simplify=simplify, tactics_order=tactics_order\n)\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTermList.is_empty","title":"<code>is_empty()</code>","text":"<p>Tell whether the argument has no satisfying assignments.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if constraints cannot be satisfied.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def is_empty(self) -&gt; bool:\n\"\"\"\n    Tell whether the argument has no satisfying assignments.\n    Returns:\n        True if constraints cannot be satisfied.\n    \"\"\"\ntest_expr = self._to_smtexpr()\nif _is_sat(test_expr):  # noqa: WPS531 if condition can be simplified\nreturn False\nreturn True\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTermList.is_semantically_equivalent_to","title":"<code>is_semantically_equivalent_to(other)</code>","text":"<p>Tell whether two termlists are semantically equivalent.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SmtTermList</code> <p>The termlist against which we compare self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the two termlists are semantically equivalent.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def is_semantically_equivalent_to(self, other: SmtTermList) -&gt; bool:\n\"\"\"\n    Tell whether two termlists are semantically equivalent.\n    Args:\n        other:\n            The termlist against which we compare self.\n    Returns:\n        True if the two termlists are semantically equivalent.\n    \"\"\"\nreturn self.refines(other) and other.refines(self)\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTermList.refines","title":"<code>refines(other)</code>","text":"<p>Tells whether the argument is a larger specification.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SmtTermList</code> <p>TermList against which we are comparing self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>self &lt;= other</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def refines(self, other: SmtTermList) -&gt; bool:\n\"\"\"\n    Tells whether the argument is a larger specification.\n    Args:\n        other:\n            TermList against which we are comparing self.\n    Returns:\n        self &lt;= other\n    \"\"\"\nantecedent = self._to_smtexpr()\nconsequent = other._to_smtexpr()\ntest_expr: z3.BoolRef = z3.Implies(antecedent, consequent)\nreturn _is_tautology(test_expr)\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTermList.simplify","title":"<code>simplify(context=None)</code>","text":"<p>Remove redundant terms in the TermList using the provided context.</p> Example <p>Suppose the TermList is \\(\\{x - 2y \\le 5, x - y \\le 0\\}\\) and the context is \\(\\{x + y \\le 0\\}\\). Then the TermList could be simplified to \\(\\{x - y \\le 0\\}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Optional[SmtTermList]</code> <p>The TermList providing the context for the simplification.</p> <code>None</code> <p>Returns:</p> Type Description <code>SmtTermList</code> <p>A new TermList with redundant terms removed using the provided context.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def simplify(self, context: Optional[SmtTermList] = None) -&gt; SmtTermList:\n\"\"\"\n    Remove redundant terms in the TermList using the provided context.\n    Example:\n        Suppose the TermList is $\\\\{x - 2y \\\\le 5, x - y \\\\le 0\\\\}$ and\n        the context is $\\\\{x + y \\\\le 0\\\\}$. Then the TermList could be\n        simplified to $\\\\{x - y \\\\le 0\\\\}$.\n    Args:\n        context:\n            The TermList providing the context for the simplification.\n    Returns:\n        A new TermList with redundant terms removed using the provided context.\n    \"\"\"\nnewterms: List[SmtTerm] = []\nexternal_context = SmtTermList([])\nif context:\nexternal_context = context\nfor i, term_under_analysis in enumerate(self.terms):\nuseful_context = SmtTermList(newterms) | SmtTermList(self.terms[i + 1 :]) | external_context\nif not useful_context.refines(SmtTermList([term_under_analysis])):\nnewterms.append(term_under_analysis.copy())\nreturn SmtTermList(newterms)\n</code></pre>"},{"location":"smt/#pacti.terms.smt.smt.SmtTermList.to_str_list","title":"<code>to_str_list()</code>","text":"<p>Convert termlist into a list of strings.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings corresponding to the terms of the termlist.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def to_str_list(self) -&gt; List[str]:\n\"\"\"\n    Convert termlist into a list of strings.\n    Returns:\n        A list of strings corresponding to the terms of the termlist.\n    \"\"\"\nreturn [str(term) for term in self.terms]\n</code></pre>"},{"location":"team/","title":"Team","text":"<p>The Pacti development team is led by Inigo Incer and consists of Apurva Badithela, Josefine Graebener, Piergiuseppe Mallozzi, Ayush Pandey, Nicolas Rouquette, and Sheng-Jung Yu.</p> <p>The Pacti project is advised by  Albert Benveniste, Benoit Caillaud, Richard M. Murray, Alberto Sangiovanni-Vincentelli, and Sanjit A. Seshia.</p>"},{"location":"docs/getting_started/","title":"Getting Started","text":"<p>Pacti helps designers to reason about specifications and to manipulate them. These specifications are given to Pacti as assume-guarantee contracts, which are requirements of the form (assumptions, guarantees).</p> <p>For Pacti, every contract has four elements:</p> <ul> <li>Input variables</li> <li>Output variables</li> <li>Assumptions: constraints whose satisfaction requires the object under specification to deliver the contract's guarantees. In Pacti, assumptions can only refer to the input variables of the contract.</li> <li>Guarantees: constraints that the object under specification can be expected to deliver when the contract's assumptions are met. In Pacti, guarantees can only refer to the input or output variables of the contract.</li> </ul> <p>The interface of a contract is the set of its input and output variables.</p> <p>The algebra of contracts has been extensively researched and peer-reviewed by experts\u2014see Benveniste et al. 2018, Incer 2022, and references therein. Contracts provide mathematical rigor to several tasks of relevance to system design. The algebra of contracts contains operations that generate new contracts from existing ones, i.e., the algebra is closed under these operations. We can use the algebra of contracts to address the following tasks:</p> <ul> <li> <p>Building systems. Suppose that we have specified contracts for a set of subsystems. We can define a system as the assembly of such subsystems. The operation of composition allows us to compute the contract of such a system from the contracts of the assembled subsystems. In other words, composition provides a mechanism for computing system contracts from subsystem contracts.</p> </li> <li> <p>Patching systems. The operation of quotient allows us to compute the contract of a subsystem that needs to be composed with an existing subsystem so that the resulting system composition meets a top-level contract. In other words, the quotient finds contracts of missing subsystems from contracts for the system and a partial implementation.</p> </li> <li> <p>Validity of decompositions. Refinement allows us to tell when a contract is more relaxed, or less demanding than another. When a subsystem satisfies a contract, it is guaranteed to satisfy a more relaxed contract. When a system contract is broken into an assembly of subsystem contracts, refinement allows us to tell whether this decomposition is a valid refinement of the system-level contract.</p> </li> <li> <p>Fusing viewpoints. The operation of merging allows us to generate a single contract whose assumptions and guarantees require the satisfaction of the assumptions and guarantees of the merged contracts, respectively. In other words, merging fuses multiple contract viewpoints, a common operation in concurrent design.</p> </li> </ul>"},{"location":"docs/getting_started/#computing-system-specifications","title":"Computing system specifications","text":"<p>Consider the following system:</p> <p></p> Component Contract Inputs Outputs Assumptions Guarantees \\(M\\) <code>contract1</code> <code>i</code> <code>o</code> <code>|i| &lt;= 2</code> <code>o &lt;= i &lt;= 2o + 2</code> \\(M'\\) <code>contract2</code> <code>o</code> <code>o_p</code> <code>-1 &lt;= o &lt;= 1/5</code> <code>o_p &lt;= o</code> <p>We can use Pacti to obtain the contract of the system that assembles these two components as follows: </p> <pre><code>from pacti.contracts import PolyhedralIoContract\ncontract1 = PolyhedralIoContract.from_strings(\ninput_vars=[\"i\"],\noutput_vars=[\"o\"],\nassumptions=[\"|i| &lt;= 2\"],\nguarantees=[\"o - i &lt;= 0\", \"i - 2o &lt;= 2\"]\n)\ncontract2 = PolyhedralIoContract.from_strings(\ninput_vars=[\"o\"],\noutput_vars=[\"o_p\"],\nassumptions=[\"o &lt;= 0.2\", \"-o &lt;= 1\"],\nguarantees=[\"o_p - o &lt;= 0\"]\n)\nsystem_contract = contract1.compose(contract2)\nprint(system_contract)\n</code></pre> <pre><code>InVars: [i]\nOutVars:[o_p]\nA: [\n  i &lt;= 0.2\n  -0.5 i &lt;= 0\n]\nG: [\n  -i + o_p &lt;= 0\n]\n</code></pre> <p>Pacti gives us the specification of the system. Note that the resulting contract only involves the top-level input and output variables, having eliminated the intermediate variable, <code>o</code>.</p>"},{"location":"docs/getting_started/#system-diagnostics","title":"System diagnostics","text":"<p>Suppose that we want to build a system as shown in the figure above, with subsystem \\(M_1\\) replacing \\(M\\), as specified below:</p> Component Contract Inputs Outputs Assumptions Guarantees \\(M_1\\) <code>contract1_n</code> <code>i</code> <code>o</code> <code>|i| &lt;= 2</code> <code>|o| &lt;= 3</code> \\(M'\\) <code>contract2</code> <code>o</code> <code>o_p</code> <code>-1 &lt;= o &lt;= 1/5</code> <code>o_p &lt;= o</code> <p>The Pacti specification then becomes the following:</p> <pre><code>contract1_n = PolyhedralIoContract.from_strings(\ninput_vars=[\"i\"],\noutput_vars=[\"o\"],\nassumptions=[\"|i| &lt;= 2\"],\nguarantees=[\"|o| &lt;= 3\"]\n)\ntry:\nnew_system_contract = contract1_n.compose(contract2)\nexcept ValueError as e:\nprint(\"Composition error: {0}\".format(e))\n</code></pre> <pre><code>Composition error: Could not eliminate variables ['o', 'o_p']\nby refining the assumptions \n[\n  o &lt;= 0.2\n  -o &lt;= 1\n]\nusing guarantees \n[\n  |i| &lt;= 2\n  |o| &lt;= 3\n]\n</code></pre> <p>Pacti is unable to compute a system specification. In this case, this is due to the fact that our guarantee <code>|o| &lt;= 3</code> for \\(M_1\\) does not satisfy the assumptions of <code>contract2</code>.</p>"},{"location":"docs/getting_started/#specifications-of-missing-subsystems","title":"Specifications of missing subsystems","text":"<p>Now consider the situation shown in the following diagram:</p> <p></p> <p>We wish to implement a system \\(M\\) given an available subsystem \\(M'\\) as described below.</p> Component Contract Inputs Outputs Assumptions Guarantees \\(M\\) <code>contract_top_level</code> <code>i</code> <code>o_p</code> <code>|i| &lt;= 1</code> <code>o_p = 2i + 1</code> \\(M'\\) <code>contract_existing_subsystem</code> <code>i</code> <code>o</code> <code>|i| &lt;= 2</code> <code>o = 2i</code> <p>We use Pacti's quotient operation to obtain the specification of the missing subsystem corresponding to the question mark above so that the resulting object meets the specification <code>contract_top_level</code>. The following codifies this missing subsystem problem:</p> <pre><code>contract_top_level = PolyhedralIoContract.from_strings(\ninput_vars=[\"i\"],\noutput_vars=[\"o_p\"],\nassumptions=[\"|i| &lt;= 1\"],\nguarantees=[\"o_p - 2i = 1\"]\n)\ncontract_existing_subsystem = PolyhedralIoContract.from_strings(\ninput_vars=[\"i\"],\noutput_vars=[\"o\"],\nassumptions=[\"|i| &lt;= 2\"],\nguarantees=[\"o - 2i = 0\"]\n)\ncontract_missing_subsystem = contract_top_level.quotient(contract_existing_subsystem)\nprint(contract_missing_subsystem)\n</code></pre> <pre><code>InVars: [o]\nOutVars:[o_p]\nA: [\n  |o| &lt;= 2\n]\nG: [\n  -o + o_p = 1\n]\n</code></pre> <p>Observe that Pacti tells us that the missing subsystem's specification has input <code>o</code> and output <code>o_p</code>. The resulting specification is guaranteed to implement the top-level system when composed with the contract of the existing subsystem. We can verify this:</p> <pre><code># compose quotient\nnew_system = contract_missing_subsystem.compose(contract_existing_subsystem)\nprint(new_system.refines(contract_top_level))\n</code></pre> <pre><code>True\n</code></pre>"},{"location":"docs/getting_started/#fusing-viewpoints","title":"Fusing viewpoints","text":"<p>Suppose that we have two specifications for a subsystem, corresponding to different viewpoints, as shown in the following table:</p> Viewpoint Contract Inputs Outputs Assumptions Guarantees Functionality <code>functionality_viewpoint</code> <code>i</code> <code>o</code> <code>|i| &lt;= 2</code> <code>o = 2i + 1</code> Power <code>power_viewpoint</code> <code>temp</code> <code>P</code> <code>temp &lt;= 90</code> <code>P &lt;= 2.1</code> <p>We can use contract merging to obtain a single specification for the subsystem:</p> <pre><code>functionality_viewpoint = PolyhedralIoContract.from_strings(\ninput_vars=[\"i\"],\noutput_vars=[\"o\"],\nassumptions=[\"|i| &lt;= 2\"],\nguarantees=[\"o - 2i = 1\"]\n)\npower_viewpoint = PolyhedralIoContract.from_strings(\ninput_vars=[\"temp\"],\noutput_vars=[\"P\"],\nassumptions=[\"temp &lt;= 90\"],\nguarantees=[\"P &lt;= 2.1\"]\n)\nsubsystem_contract = functionality_viewpoint.merge(power_viewpoint)\nprint(subsystem_contract)\n</code></pre> <pre><code>InVars: [i, temp]\nOutVars:[o, P]\nA: [\n  |i| &lt;= 2\n  temp &lt;= 90\n]\nG: [\n  -2 i + o = 1\n  P &lt;= 2.1\n]\n</code></pre>"},{"location":"docs/getting_started/#to-learn-more","title":"To learn more","text":"<p>These examples illustrate some analysis tasks we can carry out with Pacti. The <code>case_studies</code> folder contains discussions of the application of Pacti in various design disciplines.</p>"},{"location":"docs/getting_started/#references","title":"References","text":"<p> Benveniste et al. 2018</p> <p>Benveniste, A., Caillaud, B., Nickovic, D., Passerone, R., Raclet, J-B., Reinkemeier, P., Sangiovanni-Vincentelli, A., Damm, W., Henzinger, T. A., and Larsen, K. G. Contracts for system design. Foundations and Trends\u00ae in Electronic Design Automation 12, no. 2-3 (2018): 124-400.</p> <p> Incer 2022</p> <p>Incer, I. The Algebra of Contracts. PhD Thesis. University of California, Berkeley, 2022.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pacti<ul> <li>__version__</li> <li>contracts<ul> <li>polyhedral_iocontract</li> <li>smt_iocontract</li> </ul> </li> <li>iocontract<ul> <li>compundiocontract</li> <li>iocontract</li> </ul> </li> <li>terms<ul> <li>polyhedra<ul> <li>polyhedra</li> <li>serializer</li> <li>syntax<ul> <li>data</li> <li>grammar</li> </ul> </li> </ul> </li> <li>smt<ul> <li>smt</li> </ul> </li> </ul> </li> <li>utils<ul> <li>errors</li> <li>fileio</li> <li>lists</li> <li>plots</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/pacti/","title":"Index","text":""},{"location":"reference/pacti/__version__/","title":"version","text":"<p>Set the Pacti package version in this file</p>"},{"location":"reference/pacti/contracts/","title":"Index","text":""},{"location":"reference/pacti/contracts/polyhedral_iocontract/","title":"Polyhedral iocontract","text":"<p>Specializes IO contract into contracts with polyhedral assumptions and guarantees.</p>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.NestedPolyhedra","title":"<code>NestedPolyhedra</code>","text":"<p>               Bases: <code>NestedTermList</code></p> <p>A collection of polyhedral termlists interpreted as their disjunction.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>class NestedPolyhedra(NestedTermList):\n\"\"\"A collection of polyhedral termlists interpreted as their disjunction.\"\"\"\ndef __init__(  # noqa: WPS612 useless overwritten __init__\nself, nested_termlist: List[PolyhedralTermList], force_empty_intersection: bool\n):\n\"\"\"\n        Class constructor.\n        Args:\n            nested_termlist: A list of terms contained by TermList.\n            force_empty_intersection: Raise error if the termlists are not disjoint.\n        \"\"\"\nsuper().__init__(nested_termlist, force_empty_intersection)\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.NestedPolyhedra.__init__","title":"<code>__init__(nested_termlist, force_empty_intersection)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>nested_termlist</code> <code>List[PolyhedralTermList]</code> <p>A list of terms contained by TermList.</p> required <code>force_empty_intersection</code> <code>bool</code> <p>Raise error if the termlists are not disjoint.</p> required Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def __init__(  # noqa: WPS612 useless overwritten __init__\nself, nested_termlist: List[PolyhedralTermList], force_empty_intersection: bool\n):\n\"\"\"\n    Class constructor.\n    Args:\n        nested_termlist: A list of terms contained by TermList.\n        force_empty_intersection: Raise error if the termlists are not disjoint.\n    \"\"\"\nsuper().__init__(nested_termlist, force_empty_intersection)\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract","title":"<code>PolyhedralIoContract</code>","text":"<p>               Bases: <code>IoContract</code></p> <p>IO Contracts with assumptions and guarantees expressed as polyhedral constraints.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>class PolyhedralIoContract(IoContract):\n\"\"\"IO Contracts with assumptions and guarantees expressed as polyhedral constraints.\"\"\"\ndef rename_variables(self, variable_mappings: List[Tuple[str, str]]) -&gt; PolyhedralIoContract:\n\"\"\"\n        Rename variables in a contract.\n        Args:\n            variable_mappings: Variables to be replaced.\n        Returns:\n            A contract with `source_var` replaced by `target_var`.\n        \"\"\"\nnew_contract = self.copy()\nfor mapping in variable_mappings:\nnew_contract = new_contract.rename_variable(Var(mapping[0]), Var(mapping[1]))\nreturn new_contract\ndef to_machine_dict(self) -&gt; ser_contract:\n\"\"\"\n        Map contract into a machine-optimized dictionary.\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\ninput_vars = [str(x) for x in self.inputvars]\noutput_vars = [str(x) for x in self.outputvars]\nassumptions: List[ser_pt] = [\n{\n\"constant\": float(term.constant),\n\"coefficients\": {str(k): float(v) for k, v in term.variables.items()},\n}\nfor term in self.a.terms\n]\nguarantees: List[ser_pt] = [\n{\n\"constant\": float(term.constant),\n\"coefficients\": {str(k): float(v) for k, v in term.variables.items()},\n}\nfor term in self.g.terms\n]\nreturn {\n\"input_vars\": input_vars,\n\"output_vars\": output_vars,\n\"assumptions\": assumptions,\n\"guarantees\": guarantees,\n}\ndef to_dict(self) -&gt; dict:\n\"\"\"\n        Map contract into a user-readable dictionary.\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\nc_temp = {}\nc_temp[\"input_vars\"] = [str(x) for x in self.inputvars]\nc_temp[\"output_vars\"] = [str(x) for x in self.outputvars]\nc_temp[\"assumptions\"] = self.a.to_str_list()\nc_temp[\"guarantees\"] = self.g.to_str_list()\nreturn c_temp\n@staticmethod\ndef from_strings(\nassumptions: List[str],\nguarantees: List[str],\ninput_vars: List[str],\noutput_vars: List[str],\nsimplify: bool = True,\n) -&gt; PolyhedralIoContract:\n\"\"\"\n        Create contract from several lists of strings.\n        Args:\n            assumptions: contract's assumptions.\n            guarantees: contract's guarantees.\n            input_vars: input variables of contract.\n            output_vars: output variables of contract.\n            simplify: whether to simplify the guarantees with respect to the assumptions.\n        Returns:\n            A polyhedral contract built from the arguments provided.\n        \"\"\"\na: List[PolyhedralTerm] = []\nif assumptions:\na = [item for x in assumptions for item in serializer.polyhedral_termlist_from_string(x)]\ng: List[PolyhedralTerm] = []\nif guarantees:\ng = [item for x in guarantees for item in serializer.polyhedral_termlist_from_string(x)]\nreturn PolyhedralIoContract(\ninput_vars=[Var(x) for x in input_vars],\noutput_vars=[Var(x) for x in output_vars],\nassumptions=PolyhedralTermList(a),\nguarantees=PolyhedralTermList(g),\nsimplify=simplify,\n)\n@staticmethod\ndef from_dict(contract: dict, simplify: bool = True) -&gt; PolyhedralIoContract:\n\"\"\"\n        Create contract from a dictionary.\n        Args:\n            contract: a dictionary containing the contract's data.\n            simplify: whether to simplify the guarantees with respect to the assumptions.\n        Returns:\n            A polyhedral contract built from the arguments provided.\n        Raises:\n            ValueError: dictionary provided was not well-formed.\n        \"\"\"\nif not isinstance(contract, dict):\nraise ValueError(\"A dict type contract is expected.\")\nfor kw in (\"assumptions\", \"guarantees\", \"input_vars\", \"output_vars\"):\nif kw not in contract:\nraise ValueError(f\"Passed dictionary does not have key {kw}.\")\nif all(isinstance(x, dict) for x in contract[\"assumptions\"]):\na = PolyhedralTermList(\n[\nPolyhedralTerm({Var(k): v for k, v in x[\"coefficients\"].items()}, float(x[\"constant\"]))\nfor x in contract[\"assumptions\"]\n]\n)\nelse:\nraise ValueError(\"Assumptions must be a list of dicts.\")\nif all(isinstance(x, dict) for x in contract[\"guarantees\"]):\ng = PolyhedralTermList(\n[\nPolyhedralTerm({Var(k): v for k, v in x[\"coefficients\"].items()}, float(x[\"constant\"]))\nfor x in contract[\"guarantees\"]\n]\n)\nelse:\nraise ValueError(\"Guarantees must be a list of dicts.\")\nreturn PolyhedralIoContract(\ninput_vars=[Var(x) for x in contract[\"input_vars\"]],\noutput_vars=[Var(x) for x in contract[\"output_vars\"]],\nassumptions=a,\nguarantees=g,\nsimplify=simplify,\n)\ndef compose(\nself,\nother: PolyhedralIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\n) -&gt; PolyhedralIoContract:\n\"\"\"Compose polyhedral contracts.\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n        Returns:\n            The abstracted composition of the two contracts.\n        \"\"\"\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose(other, [Var(x) for x in vars_to_keep], simplify)\ndef compose_tactics(\nself,\nother: PolyhedralIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralIoContract, List[TacticStatistics]]:\n\"\"\"Compose polyhedral contracts.\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n            tactics_order:\n                The order of tactics to try for variable term elimination.\n        Returns:\n            The tuple of the abstracted composition of the two contracts and of the list of tactics used.\n        \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose_tactics(other, [Var(x) for x in vars_to_keep], simplify, tactics_order)\ndef quotient(  # noqa: WPS612\nself: PolyhedralIoContract,\nother: PolyhedralIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\n) -&gt; PolyhedralIoContract:\n\"\"\"Quotient polyhedral contracts.\n        Compute the quotient of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n        Returns:\n            The abstracted quotient of the two contracts.\n        \"\"\"\nreturn super().quotient(other, additional_inputs, simplify)\ndef quotient_tactics(\nself: PolyhedralIoContract,\nother: PolyhedralIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralIoContract, List[TacticStatistics]]:\n\"\"\"Quotient polyhedral contracts with support for specifying the order of tactics and measuring their use.\n        Compute the quotient of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n            tactics_order:\n                The order of tactics to try for variable term elimination.\n        Returns:\n            The tuple of the abstracted quotient of the two contracts and of the list of tactics used.\n        \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nreturn super().quotient_tactics(other, additional_inputs, simplify, tactics_order)\ndef optimize(self, expr: str, maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"Optimize linear objective over the contract.\n        Compute the optima of a linear objective over the assumptions and\n        guarantees of the contract.\n        Args:\n            expr:\n                linear objective being optimized.\n            maximize:\n                Maximize if True; minimize if False.\n        Returns:\n            The optimal value of the objective in the context of the contract.\n        \"\"\"\nnew_expr = expr + \" &lt;= 0\"\nvariables = serializer.polyhedral_termlist_from_string(new_expr)[0].variables\nconstraints: PolyhedralTermList = self.a | self.g\nreturn constraints.optimize(objective=variables, maximize=maximize)\ndef get_variable_bounds(\nself, var: str\n) -&gt; Tuple[Optional[numeric], Optional[numeric]]:  # noqa: VNE002 variable 'var' should be clarified\n\"\"\"Obtain bounds for a variable in the context of a contract.\n        Args:\n            var:\n                variable whose bounds are sought.\n        Returns:\n            The minimum and maximum values for the variable in the context of the contract.\n        \"\"\"\nmaximum = self.optimize(var, maximize=True)\nminimum = self.optimize(var, maximize=False)\nreturn minimum, maximum\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.compose","title":"<code>compose(other, vars_to_keep=None, simplify=True)</code>","text":"<p>Compose polyhedral contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralIoContract</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Optional[List[str]]</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <p>Returns:</p> Type Description <code>PolyhedralIoContract</code> <p>The abstracted composition of the two contracts.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def compose(\nself,\nother: PolyhedralIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\n) -&gt; PolyhedralIoContract:\n\"\"\"Compose polyhedral contracts.\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n    Returns:\n        The abstracted composition of the two contracts.\n    \"\"\"\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose(other, [Var(x) for x in vars_to_keep], simplify)\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.compose_tactics","title":"<code>compose_tactics(other, vars_to_keep=None, simplify=True, tactics_order=None)</code>","text":"<p>Compose polyhedral contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralIoContract</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Optional[List[str]]</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>The order of tactics to try for variable term elimination.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[PolyhedralIoContract, List[TacticStatistics]]</code> <p>The tuple of the abstracted composition of the two contracts and of the list of tactics used.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def compose_tactics(\nself,\nother: PolyhedralIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralIoContract, List[TacticStatistics]]:\n\"\"\"Compose polyhedral contracts.\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n        tactics_order:\n            The order of tactics to try for variable term elimination.\n    Returns:\n        The tuple of the abstracted composition of the two contracts and of the list of tactics used.\n    \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose_tactics(other, [Var(x) for x in vars_to_keep], simplify, tactics_order)\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.from_dict","title":"<code>from_dict(contract, simplify=True)</code>  <code>staticmethod</code>","text":"<p>Create contract from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>contract</code> <code>dict</code> <p>a dictionary containing the contract's data.</p> required <code>simplify</code> <code>bool</code> <p>whether to simplify the guarantees with respect to the assumptions.</p> <code>True</code> <p>Returns:</p> Type Description <code>PolyhedralIoContract</code> <p>A polyhedral contract built from the arguments provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>dictionary provided was not well-formed.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>@staticmethod\ndef from_dict(contract: dict, simplify: bool = True) -&gt; PolyhedralIoContract:\n\"\"\"\n    Create contract from a dictionary.\n    Args:\n        contract: a dictionary containing the contract's data.\n        simplify: whether to simplify the guarantees with respect to the assumptions.\n    Returns:\n        A polyhedral contract built from the arguments provided.\n    Raises:\n        ValueError: dictionary provided was not well-formed.\n    \"\"\"\nif not isinstance(contract, dict):\nraise ValueError(\"A dict type contract is expected.\")\nfor kw in (\"assumptions\", \"guarantees\", \"input_vars\", \"output_vars\"):\nif kw not in contract:\nraise ValueError(f\"Passed dictionary does not have key {kw}.\")\nif all(isinstance(x, dict) for x in contract[\"assumptions\"]):\na = PolyhedralTermList(\n[\nPolyhedralTerm({Var(k): v for k, v in x[\"coefficients\"].items()}, float(x[\"constant\"]))\nfor x in contract[\"assumptions\"]\n]\n)\nelse:\nraise ValueError(\"Assumptions must be a list of dicts.\")\nif all(isinstance(x, dict) for x in contract[\"guarantees\"]):\ng = PolyhedralTermList(\n[\nPolyhedralTerm({Var(k): v for k, v in x[\"coefficients\"].items()}, float(x[\"constant\"]))\nfor x in contract[\"guarantees\"]\n]\n)\nelse:\nraise ValueError(\"Guarantees must be a list of dicts.\")\nreturn PolyhedralIoContract(\ninput_vars=[Var(x) for x in contract[\"input_vars\"]],\noutput_vars=[Var(x) for x in contract[\"output_vars\"]],\nassumptions=a,\nguarantees=g,\nsimplify=simplify,\n)\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.from_strings","title":"<code>from_strings(assumptions, guarantees, input_vars, output_vars, simplify=True)</code>  <code>staticmethod</code>","text":"<p>Create contract from several lists of strings.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>List[str]</code> <p>contract's assumptions.</p> required <code>guarantees</code> <code>List[str]</code> <p>contract's guarantees.</p> required <code>input_vars</code> <code>List[str]</code> <p>input variables of contract.</p> required <code>output_vars</code> <code>List[str]</code> <p>output variables of contract.</p> required <code>simplify</code> <code>bool</code> <p>whether to simplify the guarantees with respect to the assumptions.</p> <code>True</code> <p>Returns:</p> Type Description <code>PolyhedralIoContract</code> <p>A polyhedral contract built from the arguments provided.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>@staticmethod\ndef from_strings(\nassumptions: List[str],\nguarantees: List[str],\ninput_vars: List[str],\noutput_vars: List[str],\nsimplify: bool = True,\n) -&gt; PolyhedralIoContract:\n\"\"\"\n    Create contract from several lists of strings.\n    Args:\n        assumptions: contract's assumptions.\n        guarantees: contract's guarantees.\n        input_vars: input variables of contract.\n        output_vars: output variables of contract.\n        simplify: whether to simplify the guarantees with respect to the assumptions.\n    Returns:\n        A polyhedral contract built from the arguments provided.\n    \"\"\"\na: List[PolyhedralTerm] = []\nif assumptions:\na = [item for x in assumptions for item in serializer.polyhedral_termlist_from_string(x)]\ng: List[PolyhedralTerm] = []\nif guarantees:\ng = [item for x in guarantees for item in serializer.polyhedral_termlist_from_string(x)]\nreturn PolyhedralIoContract(\ninput_vars=[Var(x) for x in input_vars],\noutput_vars=[Var(x) for x in output_vars],\nassumptions=PolyhedralTermList(a),\nguarantees=PolyhedralTermList(g),\nsimplify=simplify,\n)\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.get_variable_bounds","title":"<code>get_variable_bounds(var)</code>","text":"<p>Obtain bounds for a variable in the context of a contract.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>variable whose bounds are sought.</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[numeric], Optional[numeric]]</code> <p>The minimum and maximum values for the variable in the context of the contract.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def get_variable_bounds(\nself, var: str\n) -&gt; Tuple[Optional[numeric], Optional[numeric]]:  # noqa: VNE002 variable 'var' should be clarified\n\"\"\"Obtain bounds for a variable in the context of a contract.\n    Args:\n        var:\n            variable whose bounds are sought.\n    Returns:\n        The minimum and maximum values for the variable in the context of the contract.\n    \"\"\"\nmaximum = self.optimize(var, maximize=True)\nminimum = self.optimize(var, maximize=False)\nreturn minimum, maximum\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.optimize","title":"<code>optimize(expr, maximize=True)</code>","text":"<p>Optimize linear objective over the contract.</p> <p>Compute the optima of a linear objective over the assumptions and guarantees of the contract.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>linear objective being optimized.</p> required <code>maximize</code> <code>bool</code> <p>Maximize if True; minimize if False.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[numeric]</code> <p>The optimal value of the objective in the context of the contract.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def optimize(self, expr: str, maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"Optimize linear objective over the contract.\n    Compute the optima of a linear objective over the assumptions and\n    guarantees of the contract.\n    Args:\n        expr:\n            linear objective being optimized.\n        maximize:\n            Maximize if True; minimize if False.\n    Returns:\n        The optimal value of the objective in the context of the contract.\n    \"\"\"\nnew_expr = expr + \" &lt;= 0\"\nvariables = serializer.polyhedral_termlist_from_string(new_expr)[0].variables\nconstraints: PolyhedralTermList = self.a | self.g\nreturn constraints.optimize(objective=variables, maximize=maximize)\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.quotient","title":"<code>quotient(other, additional_inputs=None, simplify=True)</code>","text":"<p>Quotient polyhedral contracts.</p> <p>Compute the quotient of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralIoContract</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <p>Returns:</p> Type Description <code>PolyhedralIoContract</code> <p>The abstracted quotient of the two contracts.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def quotient(  # noqa: WPS612\nself: PolyhedralIoContract,\nother: PolyhedralIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\n) -&gt; PolyhedralIoContract:\n\"\"\"Quotient polyhedral contracts.\n    Compute the quotient of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n    Returns:\n        The abstracted quotient of the two contracts.\n    \"\"\"\nreturn super().quotient(other, additional_inputs, simplify)\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.quotient_tactics","title":"<code>quotient_tactics(other, additional_inputs=None, simplify=True, tactics_order=None)</code>","text":"<p>Quotient polyhedral contracts with support for specifying the order of tactics and measuring their use.</p> <p>Compute the quotient of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralIoContract</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>The order of tactics to try for variable term elimination.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[PolyhedralIoContract, List[TacticStatistics]]</code> <p>The tuple of the abstracted quotient of the two contracts and of the list of tactics used.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def quotient_tactics(\nself: PolyhedralIoContract,\nother: PolyhedralIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralIoContract, List[TacticStatistics]]:\n\"\"\"Quotient polyhedral contracts with support for specifying the order of tactics and measuring their use.\n    Compute the quotient of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n        tactics_order:\n            The order of tactics to try for variable term elimination.\n    Returns:\n        The tuple of the abstracted quotient of the two contracts and of the list of tactics used.\n    \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nreturn super().quotient_tactics(other, additional_inputs, simplify, tactics_order)\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.rename_variables","title":"<code>rename_variables(variable_mappings)</code>","text":"<p>Rename variables in a contract.</p> <p>Parameters:</p> Name Type Description Default <code>variable_mappings</code> <code>List[Tuple[str, str]]</code> <p>Variables to be replaced.</p> required <p>Returns:</p> Type Description <code>PolyhedralIoContract</code> <p>A contract with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def rename_variables(self, variable_mappings: List[Tuple[str, str]]) -&gt; PolyhedralIoContract:\n\"\"\"\n    Rename variables in a contract.\n    Args:\n        variable_mappings: Variables to be replaced.\n    Returns:\n        A contract with `source_var` replaced by `target_var`.\n    \"\"\"\nnew_contract = self.copy()\nfor mapping in variable_mappings:\nnew_contract = new_contract.rename_variable(Var(mapping[0]), Var(mapping[1]))\nreturn new_contract\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.to_dict","title":"<code>to_dict()</code>","text":"<p>Map contract into a user-readable dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def to_dict(self) -&gt; dict:\n\"\"\"\n    Map contract into a user-readable dictionary.\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\nc_temp = {}\nc_temp[\"input_vars\"] = [str(x) for x in self.inputvars]\nc_temp[\"output_vars\"] = [str(x) for x in self.outputvars]\nc_temp[\"assumptions\"] = self.a.to_str_list()\nc_temp[\"guarantees\"] = self.g.to_str_list()\nreturn c_temp\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContract.to_machine_dict","title":"<code>to_machine_dict()</code>","text":"<p>Map contract into a machine-optimized dictionary.</p> <p>Returns:</p> Type Description <code>ser_contract</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def to_machine_dict(self) -&gt; ser_contract:\n\"\"\"\n    Map contract into a machine-optimized dictionary.\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\ninput_vars = [str(x) for x in self.inputvars]\noutput_vars = [str(x) for x in self.outputvars]\nassumptions: List[ser_pt] = [\n{\n\"constant\": float(term.constant),\n\"coefficients\": {str(k): float(v) for k, v in term.variables.items()},\n}\nfor term in self.a.terms\n]\nguarantees: List[ser_pt] = [\n{\n\"constant\": float(term.constant),\n\"coefficients\": {str(k): float(v) for k, v in term.variables.items()},\n}\nfor term in self.g.terms\n]\nreturn {\n\"input_vars\": input_vars,\n\"output_vars\": output_vars,\n\"assumptions\": assumptions,\n\"guarantees\": guarantees,\n}\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContractCompound","title":"<code>PolyhedralIoContractCompound</code>","text":"<p>               Bases: <code>IoContractCompound</code></p> <p>Compound IO contract with polyhedral assumptions and guarantees.</p> <p>Attributes:</p> Name Type Description <code>inputvars</code> <p>Variables which are inputs of the implementations of the contract.</p> <code>outputvars</code> <p>Variables which are outputs of the implementations of the contract.</p> <code>a</code> <code>NestedTermlist_t</code> <p>Contract assumptions.</p> <code>g</code> <code>NestedTermlist_t</code> <p>Contract guarantees.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>class PolyhedralIoContractCompound(IoContractCompound):\n\"\"\"\n    Compound IO contract with polyhedral assumptions and guarantees.\n    Attributes:\n        inputvars:\n            Variables which are inputs of the implementations of the contract.\n        outputvars:\n            Variables which are outputs of the implementations of the contract.\n        a: Contract assumptions.\n        g: Contract guarantees.\n    \"\"\"\n@staticmethod\ndef from_strings(\nassumptions: List[list[str]],\nguarantees: List[list[str]],\ninput_vars: List[str],\noutput_vars: List[str],\n) -&gt; PolyhedralIoContractCompound:\n\"\"\"\n        Create contract from several lists of strings.\n        Args:\n            assumptions: contract's assumptions.\n            guarantees: contract's guarantees.\n            input_vars: input variables of contract.\n            output_vars: output variables of contract.\n        Returns:\n            A polyhedral contract built from the arguments provided.\n        \"\"\"\na: List[PolyhedralTermList] = []\nif assumptions:\nfor termlist_str in assumptions:\na_termlist = [item for x in termlist_str for item in serializer.polyhedral_termlist_from_string(x)]\na.append(PolyhedralTermList(a_termlist))\ng: List[PolyhedralTermList] = []\nif guarantees:\nfor termlist_str in guarantees:\ng_termlist = [item for x in termlist_str for item in serializer.polyhedral_termlist_from_string(x)]\ng.append(PolyhedralTermList(g_termlist))\nreturn PolyhedralIoContractCompound(\ninput_vars=[Var(x) for x in input_vars],\noutput_vars=[Var(x) for x in output_vars],\nassumptions=NestedPolyhedra(a, force_empty_intersection=True),\nguarantees=NestedPolyhedra(g, force_empty_intersection=False),\n)\ndef to_dict(self) -&gt; dict:\n\"\"\"\n        Map contract into a user-readable dictionary.\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\nc_temp = {}\nc_temp[\"input_vars\"] = [str(x) for x in self.inputvars]\nc_temp[\"output_vars\"] = [str(x) for x in self.outputvars]\nc_temp[\"assumptions\"] = [x.to_str_list() for x in self.a.nested_termlist]\nc_temp[\"guarantees\"] = [x.to_str_list() for x in self.g.nested_termlist]\nreturn c_temp\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContractCompound.from_strings","title":"<code>from_strings(assumptions, guarantees, input_vars, output_vars)</code>  <code>staticmethod</code>","text":"<p>Create contract from several lists of strings.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>List[list[str]]</code> <p>contract's assumptions.</p> required <code>guarantees</code> <code>List[list[str]]</code> <p>contract's guarantees.</p> required <code>input_vars</code> <code>List[str]</code> <p>input variables of contract.</p> required <code>output_vars</code> <code>List[str]</code> <p>output variables of contract.</p> required <p>Returns:</p> Type Description <code>PolyhedralIoContractCompound</code> <p>A polyhedral contract built from the arguments provided.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>@staticmethod\ndef from_strings(\nassumptions: List[list[str]],\nguarantees: List[list[str]],\ninput_vars: List[str],\noutput_vars: List[str],\n) -&gt; PolyhedralIoContractCompound:\n\"\"\"\n    Create contract from several lists of strings.\n    Args:\n        assumptions: contract's assumptions.\n        guarantees: contract's guarantees.\n        input_vars: input variables of contract.\n        output_vars: output variables of contract.\n    Returns:\n        A polyhedral contract built from the arguments provided.\n    \"\"\"\na: List[PolyhedralTermList] = []\nif assumptions:\nfor termlist_str in assumptions:\na_termlist = [item for x in termlist_str for item in serializer.polyhedral_termlist_from_string(x)]\na.append(PolyhedralTermList(a_termlist))\ng: List[PolyhedralTermList] = []\nif guarantees:\nfor termlist_str in guarantees:\ng_termlist = [item for x in termlist_str for item in serializer.polyhedral_termlist_from_string(x)]\ng.append(PolyhedralTermList(g_termlist))\nreturn PolyhedralIoContractCompound(\ninput_vars=[Var(x) for x in input_vars],\noutput_vars=[Var(x) for x in output_vars],\nassumptions=NestedPolyhedra(a, force_empty_intersection=True),\nguarantees=NestedPolyhedra(g, force_empty_intersection=False),\n)\n</code></pre>"},{"location":"reference/pacti/contracts/polyhedral_iocontract/#pacti.contracts.polyhedral_iocontract.PolyhedralIoContractCompound.to_dict","title":"<code>to_dict()</code>","text":"<p>Map contract into a user-readable dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\src\\pacti\\contracts\\polyhedral_iocontract.py</code> <pre><code>def to_dict(self) -&gt; dict:\n\"\"\"\n    Map contract into a user-readable dictionary.\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\nc_temp = {}\nc_temp[\"input_vars\"] = [str(x) for x in self.inputvars]\nc_temp[\"output_vars\"] = [str(x) for x in self.outputvars]\nc_temp[\"assumptions\"] = [x.to_str_list() for x in self.a.nested_termlist]\nc_temp[\"guarantees\"] = [x.to_str_list() for x in self.g.nested_termlist]\nreturn c_temp\n</code></pre>"},{"location":"reference/pacti/contracts/smt_iocontract/","title":"Smt iocontract","text":"<p>Specializes IO contract into contracts with SMT assumptions and guarantees.</p>"},{"location":"reference/pacti/contracts/smt_iocontract/#pacti.contracts.smt_iocontract.SmtIoContract","title":"<code>SmtIoContract</code>","text":"<p>               Bases: <code>IoContract</code></p> <p>IO Contracts with assumptions and guarantees expressed as SMT constraints.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>class SmtIoContract(IoContract):\n\"\"\"IO Contracts with assumptions and guarantees expressed as SMT constraints.\"\"\"\ndef rename_variables(self, variable_mappings: List[Tuple[str, str]]) -&gt; SmtIoContract:\n\"\"\"\n        Rename variables in a contract.\n        Args:\n            variable_mappings: Variables to be replaced.\n        Returns:\n            A contract with `source_var` replaced by `target_var`.\n        \"\"\"\nnew_contract = self.copy()\nfor mapping in variable_mappings:\nnew_contract = new_contract.rename_variable(Var(mapping[0]), Var(mapping[1]))\nreturn new_contract\ndef to_machine_dict(self) -&gt; ser_contract:\n\"\"\"\n        Map contract into a machine-optimized dictionary.\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\nreturn self.to_dict()\ndef to_dict(self) -&gt; ser_contract:\n\"\"\"\n        Map contract into a user-readable dictionary.\n        Returns:\n            A dictionary containing the contract's information.\n        \"\"\"\nc_temp: ser_contract = {\n\"input_vars\": [str(x) for x in self.inputvars],\n\"output_vars\": [str(x) for x in self.outputvars],\n\"assumptions\": self.a.to_str_list(),\n\"guarantees\": self.g.to_str_list(),\n}\nreturn c_temp  # noqa: WPS331 c_temp only used for `return`\n@staticmethod\ndef from_z3_terms(\nassumptions: List[z3.BoolRef],\nguarantees: List[z3.BoolRef],\ninput_vars: List[str],\noutput_vars: List[str],\nsimplify: bool = True,\n) -&gt; SmtIoContract:\n\"\"\"\n        Create contract from several lists of z3 terms.\n        Args:\n            assumptions: contract's assumptions.\n            guarantees: contract's guarantees.\n            input_vars: input variables of contract.\n            output_vars: output variables of contract.\n            simplify: whether to simplify the guarantees with respect to the assumptions.\n        Returns:\n            An SMT contract built from the arguments provided.\n        \"\"\"\na: List[SmtTerm] = []\nif assumptions:\na = [SmtTerm(x) for x in assumptions]\ng: List[SmtTerm] = []\nif guarantees:\ng = [SmtTerm(x) for x in guarantees]\nreturn SmtIoContract(\ninput_vars=[Var(x) for x in input_vars],\noutput_vars=[Var(x) for x in output_vars],\nassumptions=SmtTermList(a),\nguarantees=SmtTermList(g),\nsimplify=simplify,\n)\ndef compose(\nself,\nother: SmtIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\n) -&gt; SmtIoContract:\n\"\"\"Compose SMT contracts.\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n        Returns:\n            The abstracted composition of the two contracts.\n        \"\"\"\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose(other, [Var(x) for x in vars_to_keep], simplify)\ndef compose_tactics(\nself,\nother: SmtIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtIoContract, List[TacticStatistics]]:\n\"\"\"Compose SMT contracts.\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n            tactics_order:\n                The order of tactics to try for variable term elimination.\n        Returns:\n            The tuple of the abstracted composition of the two contracts and of the list of tactics used.\n        \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose_tactics(other, [Var(x) for x in vars_to_keep], simplify, tactics_order)\ndef quotient(  # noqa: WPS612\nself: SmtIoContract,\nother: SmtIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\n) -&gt; SmtIoContract:\n\"\"\"Quotient SMT contracts.\n        Compute the quotient of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n        Returns:\n            The abstracted quotient of the two contracts.\n        \"\"\"\nreturn super().quotient(other, additional_inputs, simplify)\ndef quotient_tactics(\nself: SmtIoContract,\nother: SmtIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtIoContract, List[TacticStatistics]]:\n\"\"\"Quotient SMT contracts with support for specifying the order of tactics and measuring their use.\n        Compute the quotient of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n            tactics_order:\n                The order of tactics to try for variable term elimination.\n        Returns:\n            The tuple of the abstracted quotient of the two contracts and of the list of tactics used.\n        \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nreturn super().quotient_tactics(other, additional_inputs, simplify, tactics_order)\n</code></pre>"},{"location":"reference/pacti/contracts/smt_iocontract/#pacti.contracts.smt_iocontract.SmtIoContract.compose","title":"<code>compose(other, vars_to_keep=None, simplify=True)</code>","text":"<p>Compose SMT contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SmtIoContract</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Optional[List[str]]</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <p>Returns:</p> Type Description <code>SmtIoContract</code> <p>The abstracted composition of the two contracts.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def compose(\nself,\nother: SmtIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\n) -&gt; SmtIoContract:\n\"\"\"Compose SMT contracts.\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n    Returns:\n        The abstracted composition of the two contracts.\n    \"\"\"\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose(other, [Var(x) for x in vars_to_keep], simplify)\n</code></pre>"},{"location":"reference/pacti/contracts/smt_iocontract/#pacti.contracts.smt_iocontract.SmtIoContract.compose_tactics","title":"<code>compose_tactics(other, vars_to_keep=None, simplify=True, tactics_order=None)</code>","text":"<p>Compose SMT contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SmtIoContract</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Optional[List[str]]</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>The order of tactics to try for variable term elimination.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[SmtIoContract, List[TacticStatistics]]</code> <p>The tuple of the abstracted composition of the two contracts and of the list of tactics used.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def compose_tactics(\nself,\nother: SmtIoContract,\nvars_to_keep: Optional[List[str]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtIoContract, List[TacticStatistics]]:\n\"\"\"Compose SMT contracts.\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n        tactics_order:\n            The order of tactics to try for variable term elimination.\n    Returns:\n        The tuple of the abstracted composition of the two contracts and of the list of tactics used.\n    \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif vars_to_keep is None:\nvars_to_keep = []\nreturn super().compose_tactics(other, [Var(x) for x in vars_to_keep], simplify, tactics_order)\n</code></pre>"},{"location":"reference/pacti/contracts/smt_iocontract/#pacti.contracts.smt_iocontract.SmtIoContract.from_z3_terms","title":"<code>from_z3_terms(assumptions, guarantees, input_vars, output_vars, simplify=True)</code>  <code>staticmethod</code>","text":"<p>Create contract from several lists of z3 terms.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>List[BoolRef]</code> <p>contract's assumptions.</p> required <code>guarantees</code> <code>List[BoolRef]</code> <p>contract's guarantees.</p> required <code>input_vars</code> <code>List[str]</code> <p>input variables of contract.</p> required <code>output_vars</code> <code>List[str]</code> <p>output variables of contract.</p> required <code>simplify</code> <code>bool</code> <p>whether to simplify the guarantees with respect to the assumptions.</p> <code>True</code> <p>Returns:</p> Type Description <code>SmtIoContract</code> <p>An SMT contract built from the arguments provided.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>@staticmethod\ndef from_z3_terms(\nassumptions: List[z3.BoolRef],\nguarantees: List[z3.BoolRef],\ninput_vars: List[str],\noutput_vars: List[str],\nsimplify: bool = True,\n) -&gt; SmtIoContract:\n\"\"\"\n    Create contract from several lists of z3 terms.\n    Args:\n        assumptions: contract's assumptions.\n        guarantees: contract's guarantees.\n        input_vars: input variables of contract.\n        output_vars: output variables of contract.\n        simplify: whether to simplify the guarantees with respect to the assumptions.\n    Returns:\n        An SMT contract built from the arguments provided.\n    \"\"\"\na: List[SmtTerm] = []\nif assumptions:\na = [SmtTerm(x) for x in assumptions]\ng: List[SmtTerm] = []\nif guarantees:\ng = [SmtTerm(x) for x in guarantees]\nreturn SmtIoContract(\ninput_vars=[Var(x) for x in input_vars],\noutput_vars=[Var(x) for x in output_vars],\nassumptions=SmtTermList(a),\nguarantees=SmtTermList(g),\nsimplify=simplify,\n)\n</code></pre>"},{"location":"reference/pacti/contracts/smt_iocontract/#pacti.contracts.smt_iocontract.SmtIoContract.quotient","title":"<code>quotient(other, additional_inputs=None, simplify=True)</code>","text":"<p>Quotient SMT contracts.</p> <p>Compute the quotient of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SmtIoContract</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <p>Returns:</p> Type Description <code>SmtIoContract</code> <p>The abstracted quotient of the two contracts.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def quotient(  # noqa: WPS612\nself: SmtIoContract,\nother: SmtIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\n) -&gt; SmtIoContract:\n\"\"\"Quotient SMT contracts.\n    Compute the quotient of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n    Returns:\n        The abstracted quotient of the two contracts.\n    \"\"\"\nreturn super().quotient(other, additional_inputs, simplify)\n</code></pre>"},{"location":"reference/pacti/contracts/smt_iocontract/#pacti.contracts.smt_iocontract.SmtIoContract.quotient_tactics","title":"<code>quotient_tactics(other, additional_inputs=None, simplify=True, tactics_order=None)</code>","text":"<p>Quotient SMT contracts with support for specifying the order of tactics and measuring their use.</p> <p>Compute the quotient of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SmtIoContract</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>The order of tactics to try for variable term elimination.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[SmtIoContract, List[TacticStatistics]]</code> <p>The tuple of the abstracted quotient of the two contracts and of the list of tactics used.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def quotient_tactics(\nself: SmtIoContract,\nother: SmtIoContract,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtIoContract, List[TacticStatistics]]:\n\"\"\"Quotient SMT contracts with support for specifying the order of tactics and measuring their use.\n    Compute the quotient of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n        tactics_order:\n            The order of tactics to try for variable term elimination.\n    Returns:\n        The tuple of the abstracted quotient of the two contracts and of the list of tactics used.\n    \"\"\"\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nreturn super().quotient_tactics(other, additional_inputs, simplify, tactics_order)\n</code></pre>"},{"location":"reference/pacti/contracts/smt_iocontract/#pacti.contracts.smt_iocontract.SmtIoContract.rename_variables","title":"<code>rename_variables(variable_mappings)</code>","text":"<p>Rename variables in a contract.</p> <p>Parameters:</p> Name Type Description Default <code>variable_mappings</code> <code>List[Tuple[str, str]]</code> <p>Variables to be replaced.</p> required <p>Returns:</p> Type Description <code>SmtIoContract</code> <p>A contract with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def rename_variables(self, variable_mappings: List[Tuple[str, str]]) -&gt; SmtIoContract:\n\"\"\"\n    Rename variables in a contract.\n    Args:\n        variable_mappings: Variables to be replaced.\n    Returns:\n        A contract with `source_var` replaced by `target_var`.\n    \"\"\"\nnew_contract = self.copy()\nfor mapping in variable_mappings:\nnew_contract = new_contract.rename_variable(Var(mapping[0]), Var(mapping[1]))\nreturn new_contract\n</code></pre>"},{"location":"reference/pacti/contracts/smt_iocontract/#pacti.contracts.smt_iocontract.SmtIoContract.to_dict","title":"<code>to_dict()</code>","text":"<p>Map contract into a user-readable dictionary.</p> <p>Returns:</p> Type Description <code>ser_contract</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def to_dict(self) -&gt; ser_contract:\n\"\"\"\n    Map contract into a user-readable dictionary.\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\nc_temp: ser_contract = {\n\"input_vars\": [str(x) for x in self.inputvars],\n\"output_vars\": [str(x) for x in self.outputvars],\n\"assumptions\": self.a.to_str_list(),\n\"guarantees\": self.g.to_str_list(),\n}\nreturn c_temp  # noqa: WPS331 c_temp only used for `return`\n</code></pre>"},{"location":"reference/pacti/contracts/smt_iocontract/#pacti.contracts.smt_iocontract.SmtIoContract.to_machine_dict","title":"<code>to_machine_dict()</code>","text":"<p>Map contract into a machine-optimized dictionary.</p> <p>Returns:</p> Type Description <code>ser_contract</code> <p>A dictionary containing the contract's information.</p> Source code in <code>pacti\\src\\pacti\\contracts\\smt_iocontract.py</code> <pre><code>def to_machine_dict(self) -&gt; ser_contract:\n\"\"\"\n    Map contract into a machine-optimized dictionary.\n    Returns:\n        A dictionary containing the contract's information.\n    \"\"\"\nreturn self.to_dict()\n</code></pre>"},{"location":"reference/pacti/iocontract/","title":"Index","text":""},{"location":"reference/pacti/iocontract/compundiocontract/","title":"Compundiocontract","text":"<p>Functionality for IO contracts with assumptions and guarantees expressed as disconnected convex sets.</p>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.IoContractCompound","title":"<code>IoContractCompound</code>","text":"<p>               Bases: <code>Generic[NestedTermlist_t]</code></p> <p>Basic type for a compound IO contract.</p> <p>Attributes:</p> Name Type Description <code>inputvars</code> <p>Variables which are inputs of the implementations of the contract.</p> <code>outputvars</code> <p>Variables which are outputs of the implementations of the contract.</p> <code>a</code> <code>NestedTermlist_t</code> <p>Contract assumptions.</p> <code>g</code> <code>NestedTermlist_t</code> <p>Contract guarantees.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\compundiocontract.py</code> <pre><code>class IoContractCompound(Generic[NestedTermlist_t]):\n\"\"\"\n    Basic type for a compound IO contract.\n    Attributes:\n        inputvars:\n            Variables which are inputs of the implementations of the contract.\n        outputvars:\n            Variables which are outputs of the implementations of the contract.\n        a: Contract assumptions.\n        g: Contract guarantees.\n    \"\"\"\ndef __init__(\nself, assumptions: NestedTermlist_t, guarantees: NestedTermlist_t, input_vars: List[Var], output_vars: List[Var]\n):\n\"\"\"\n        Class constructor.\n        Args:\n            assumptions: The assumptions of the contract.\n            guarantees: The guarantees of the contract.\n            input_vars: The input variables of the contract.\n            output_vars: The output variables of the contract.\n        Raises:\n            ValueError: Arguments provided does not produce a valid IO contract.\n        \"\"\"\nlogging.debug(\"Constructor assumptions\")\nlogging.debug(assumptions)\nlogging.debug(\"Constructor guarantees\")\nlogging.debug(guarantees)\n# make sure the input and output variables have no repeated entries\nif len(input_vars) != len(set(input_vars)):\nraise ValueError(\n\"The following input variables appear multiple times in argument %s\"\n% (set(list_diff(input_vars, list(set(input_vars)))))\n)\nif len(output_vars) != len(set(output_vars)):\nraise ValueError(\n\"The following output variables appear multiple times in argument %s\"\n% (set(list_diff(output_vars, list(set(output_vars)))))\n)\n# make sure the input &amp; output variables are disjoint\nif list_intersection(input_vars, output_vars):\nraise ValueError(\n\"The following variables appear in inputs and outputs: %s\"\n% (list_intersection(input_vars, output_vars))\n)\n# make sure the assumptions only contain input variables\nif list_diff(assumptions.vars, input_vars):\nraise ValueError(\n\"The following variables appear in the assumptions but are not inputs: %s\"\n% (list_diff(assumptions.vars, input_vars))\n)\n# make sure the guarantees only contain input or output variables\nif list_diff(guarantees.vars, list_union(input_vars, output_vars)):\nraise ValueError(\n\"The guarantees contain the following variables which are neither\"\n\"inputs nor outputs: %s. Inputs: %s. Outputs: %s. Guarantees: %s\"\n% (list_diff(guarantees.vars, list_union(input_vars, output_vars)), input_vars, output_vars, guarantees)\n)\nself.a: NestedTermlist_t = assumptions.copy(True)\nself.g: NestedTermlist_t = guarantees.copy(False)\nself.inputvars = input_vars.copy()\nself.outputvars = output_vars.copy()\n# simplify the guarantees with the assumptions\n# self.g = self.g.simplify(self.a)\ndef __str__(self) -&gt; str:\nreturn (\n\"InVars: \"\n+ \"[\"\n+ \", \".join([v.name for v in self.inputvars])\n+ \"]\"\n+ \"\\nOutVars:\"\n+ \"[\"\n+ \", \".join([v.name for v in self.outputvars])\n+ \"]\"\n+ \"\\nA: \"\n+ str(self.a)\n+ \"\\n\"\n+ \"G: \"\n+ str(self.g)\n)\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError\nreturn (\nself.inputvars == other.inputvars\nand self.outputvars == self.outputvars\nand self.a == other.a\nand self.g == other.g\n)\ndef merge(self: IoContractCompound_t, other: IoContractCompound_t) -&gt; IoContractCompound_t:\n\"\"\"\n        Compute the merging operation for two contracts.\n        Compute the merging operation of the two given contracts. No\n        abstraction/refinement is applied.\n        Args:\n            other: The contract with which we are merging self.\n        Returns:\n            The result of merging.\n        \"\"\"\ninput_vars = list_union(self.inputvars, other.inputvars)\noutput_vars = list_union(self.outputvars, other.outputvars)\nassumptions = self.a.intersect(other.a, force_empty_intersection=True)\nguarantees = self.g.intersect(other.g, force_empty_intersection=False)\nreturn type(self)(assumptions, guarantees, input_vars, output_vars)\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.IoContractCompound.__init__","title":"<code>__init__(assumptions, guarantees, input_vars, output_vars)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>NestedTermlist_t</code> <p>The assumptions of the contract.</p> required <code>guarantees</code> <code>NestedTermlist_t</code> <p>The guarantees of the contract.</p> required <code>input_vars</code> <code>List[Var]</code> <p>The input variables of the contract.</p> required <code>output_vars</code> <code>List[Var]</code> <p>The output variables of the contract.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Arguments provided does not produce a valid IO contract.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\compundiocontract.py</code> <pre><code>def __init__(\nself, assumptions: NestedTermlist_t, guarantees: NestedTermlist_t, input_vars: List[Var], output_vars: List[Var]\n):\n\"\"\"\n    Class constructor.\n    Args:\n        assumptions: The assumptions of the contract.\n        guarantees: The guarantees of the contract.\n        input_vars: The input variables of the contract.\n        output_vars: The output variables of the contract.\n    Raises:\n        ValueError: Arguments provided does not produce a valid IO contract.\n    \"\"\"\nlogging.debug(\"Constructor assumptions\")\nlogging.debug(assumptions)\nlogging.debug(\"Constructor guarantees\")\nlogging.debug(guarantees)\n# make sure the input and output variables have no repeated entries\nif len(input_vars) != len(set(input_vars)):\nraise ValueError(\n\"The following input variables appear multiple times in argument %s\"\n% (set(list_diff(input_vars, list(set(input_vars)))))\n)\nif len(output_vars) != len(set(output_vars)):\nraise ValueError(\n\"The following output variables appear multiple times in argument %s\"\n% (set(list_diff(output_vars, list(set(output_vars)))))\n)\n# make sure the input &amp; output variables are disjoint\nif list_intersection(input_vars, output_vars):\nraise ValueError(\n\"The following variables appear in inputs and outputs: %s\"\n% (list_intersection(input_vars, output_vars))\n)\n# make sure the assumptions only contain input variables\nif list_diff(assumptions.vars, input_vars):\nraise ValueError(\n\"The following variables appear in the assumptions but are not inputs: %s\"\n% (list_diff(assumptions.vars, input_vars))\n)\n# make sure the guarantees only contain input or output variables\nif list_diff(guarantees.vars, list_union(input_vars, output_vars)):\nraise ValueError(\n\"The guarantees contain the following variables which are neither\"\n\"inputs nor outputs: %s. Inputs: %s. Outputs: %s. Guarantees: %s\"\n% (list_diff(guarantees.vars, list_union(input_vars, output_vars)), input_vars, output_vars, guarantees)\n)\nself.a: NestedTermlist_t = assumptions.copy(True)\nself.g: NestedTermlist_t = guarantees.copy(False)\nself.inputvars = input_vars.copy()\nself.outputvars = output_vars.copy()\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.IoContractCompound.merge","title":"<code>merge(other)</code>","text":"<p>Compute the merging operation for two contracts.</p> <p>Compute the merging operation of the two given contracts. No abstraction/refinement is applied.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContractCompound_t</code> <p>The contract with which we are merging self.</p> required <p>Returns:</p> Type Description <code>IoContractCompound_t</code> <p>The result of merging.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\compundiocontract.py</code> <pre><code>def merge(self: IoContractCompound_t, other: IoContractCompound_t) -&gt; IoContractCompound_t:\n\"\"\"\n    Compute the merging operation for two contracts.\n    Compute the merging operation of the two given contracts. No\n    abstraction/refinement is applied.\n    Args:\n        other: The contract with which we are merging self.\n    Returns:\n        The result of merging.\n    \"\"\"\ninput_vars = list_union(self.inputvars, other.inputvars)\noutput_vars = list_union(self.outputvars, other.outputvars)\nassumptions = self.a.intersect(other.a, force_empty_intersection=True)\nguarantees = self.g.intersect(other.g, force_empty_intersection=False)\nreturn type(self)(assumptions, guarantees, input_vars, output_vars)\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList","title":"<code>NestedTermList</code>","text":"<p>A collection of termlists interpreted as their disjunction.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\compundiocontract.py</code> <pre><code>class NestedTermList:\n\"\"\"A collection of termlists interpreted as their disjunction.\"\"\"\ndef __init__(  # noqa: WPS231 too much cognitive complexity\nself, nested_termlist: List[TermList_t], force_empty_intersection: bool\n):\n\"\"\"\n        Class constructor.\n        Args:\n            nested_termlist: A list of terms contained by TermList.\n            force_empty_intersection: Raise error if the termlists are not disjoint.\n        Raises:\n            ValueError: argument has separate termlists with nonempty intersection.\n        \"\"\"\n# make sure the elements of the argument don't intersect\nif force_empty_intersection:\nfor i, tli in enumerate(nested_termlist):\nfor j, tlj in enumerate(nested_termlist):\nif j &gt; i:\nintersection = tli | tlj\nif not intersection.is_empty():\nraise ValueError(\"Terms %s and %s have nonempty intersection\" % (tli, tlj))\nself.nested_termlist: List[TermList_t] = []\nfor tl in nested_termlist:\nself.nested_termlist.append(tl.copy())\ndef __str__(self) -&gt; str:\nif self.nested_termlist:\nres = [str(tl) for tl in self.nested_termlist]\nreturn \"\\nor \\n\".join(res)\nreturn \"true\"\ndef __le__(self, other: object) -&gt; bool:  # noqa: WPS231 too much cognitive complexity\nif not isinstance(other, type(self)):\nraise ValueError()\nfor this_tl in self.nested_termlist:\nfound = False\nfor that_tl in other.nested_termlist:\nif this_tl &lt;= that_tl:\nfound = True\nbreak\nif not found:\nreturn False\nreturn True\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError()\nreturn self &lt;= other &lt;= self\ndef simplify(self: NestedTermlist_t, context: NestedTermlist_t, force_empty_intersection: bool) -&gt; NestedTermlist_t:\n\"\"\"\n        Remove redundant terms in nested termlist.\n        Args:\n            context: Nested termlist serving as context for simplification.\n            force_empty_intersection: Make sure the resulting termlists have empty intersection.\n        Returns:\n            A contract with redundant terms removed in nested termlist.\n        \"\"\"\nnew_nested_tl = []\nfor self_tl in self.nested_termlist:\nfor context_tl in context.nested_termlist:\ntry:\nnew_tl = self_tl.simplify(context_tl)\nexcept ValueError:\nnew_tl = self_tl.copy()\ncontinue\nnew_nested_tl.append(new_tl)\nreturn type(self)(new_nested_tl, force_empty_intersection)\ndef intersect(self: NestedTermlist_t, other: NestedTermlist_t, force_empty_intersection: bool) -&gt; NestedTermlist_t:\n\"\"\"\n        Semantically intersect two nested termlists.\n        Args:\n            other: second argument to intersection.\n            force_empty_intersection: Raise error if termlists are not disjoint.\n        Returns:\n            The nested termlist for the intersection.\n        \"\"\"\nnew_nested_tl = []\nfor self_tl in self.nested_termlist:\nfor other_tl in other.nested_termlist:\nnew_tl = self_tl | other_tl\nif not new_tl.is_empty():\nnew_nested_tl.append(new_tl)\nreturn type(self)(new_nested_tl, force_empty_intersection)\n@property\ndef vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"The list of variables contained in this nested termlist.\n        Returns:\n            List of variables referenced in nested termlist.\n        \"\"\"\nvarlist: List[Var] = []\nfor tl in self.nested_termlist:\nvarlist = list_union(varlist, tl.vars)\nreturn varlist\ndef copy(self: NestedTermlist_t, force_empty_intersection: bool) -&gt; NestedTermlist_t:\n\"\"\"\n        Makes copy of nested termlist.\n        Args:\n            force_empty_intersection: Raise error if the termlists are not disjoint.\n        Returns:\n            Copy of nested termlist.\n        \"\"\"\nreturn type(self)([tl.copy() for tl in self.nested_termlist], force_empty_intersection)\ndef contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n        Tell whether constraints contain the given behavior.\n        Args:\n            behavior:\n                The behavior in question.\n        Returns:\n            True if the behavior satisfies the constraints; false otherwise.\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\nfor tl in self.nested_termlist:\ntry:\nif tl.contains_behavior(behavior):\nreturn True\nexcept ValueError as e:\nraise ValueError from e\nreturn False\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList.vars","title":"<code>vars</code>  <code>property</code>","text":"<p>The list of variables contained in this nested termlist.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>List of variables referenced in nested termlist.</p>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList.__init__","title":"<code>__init__(nested_termlist, force_empty_intersection)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>nested_termlist</code> <code>List[TermList_t]</code> <p>A list of terms contained by TermList.</p> required <code>force_empty_intersection</code> <code>bool</code> <p>Raise error if the termlists are not disjoint.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>argument has separate termlists with nonempty intersection.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\compundiocontract.py</code> <pre><code>def __init__(  # noqa: WPS231 too much cognitive complexity\nself, nested_termlist: List[TermList_t], force_empty_intersection: bool\n):\n\"\"\"\n    Class constructor.\n    Args:\n        nested_termlist: A list of terms contained by TermList.\n        force_empty_intersection: Raise error if the termlists are not disjoint.\n    Raises:\n        ValueError: argument has separate termlists with nonempty intersection.\n    \"\"\"\n# make sure the elements of the argument don't intersect\nif force_empty_intersection:\nfor i, tli in enumerate(nested_termlist):\nfor j, tlj in enumerate(nested_termlist):\nif j &gt; i:\nintersection = tli | tlj\nif not intersection.is_empty():\nraise ValueError(\"Terms %s and %s have nonempty intersection\" % (tli, tlj))\nself.nested_termlist: List[TermList_t] = []\nfor tl in nested_termlist:\nself.nested_termlist.append(tl.copy())\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList.contains_behavior","title":"<code>contains_behavior(behavior)</code>","text":"<p>Tell whether constraints contain the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Dict[Var, numeric]</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraints; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\compundiocontract.py</code> <pre><code>def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n    Tell whether constraints contain the given behavior.\n    Args:\n        behavior:\n            The behavior in question.\n    Returns:\n        True if the behavior satisfies the constraints; false otherwise.\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\nfor tl in self.nested_termlist:\ntry:\nif tl.contains_behavior(behavior):\nreturn True\nexcept ValueError as e:\nraise ValueError from e\nreturn False\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList.copy","title":"<code>copy(force_empty_intersection)</code>","text":"<p>Makes copy of nested termlist.</p> <p>Parameters:</p> Name Type Description Default <code>force_empty_intersection</code> <code>bool</code> <p>Raise error if the termlists are not disjoint.</p> required <p>Returns:</p> Type Description <code>NestedTermlist_t</code> <p>Copy of nested termlist.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\compundiocontract.py</code> <pre><code>def copy(self: NestedTermlist_t, force_empty_intersection: bool) -&gt; NestedTermlist_t:\n\"\"\"\n    Makes copy of nested termlist.\n    Args:\n        force_empty_intersection: Raise error if the termlists are not disjoint.\n    Returns:\n        Copy of nested termlist.\n    \"\"\"\nreturn type(self)([tl.copy() for tl in self.nested_termlist], force_empty_intersection)\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList.intersect","title":"<code>intersect(other, force_empty_intersection)</code>","text":"<p>Semantically intersect two nested termlists.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>NestedTermlist_t</code> <p>second argument to intersection.</p> required <code>force_empty_intersection</code> <code>bool</code> <p>Raise error if termlists are not disjoint.</p> required <p>Returns:</p> Type Description <code>NestedTermlist_t</code> <p>The nested termlist for the intersection.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\compundiocontract.py</code> <pre><code>def intersect(self: NestedTermlist_t, other: NestedTermlist_t, force_empty_intersection: bool) -&gt; NestedTermlist_t:\n\"\"\"\n    Semantically intersect two nested termlists.\n    Args:\n        other: second argument to intersection.\n        force_empty_intersection: Raise error if termlists are not disjoint.\n    Returns:\n        The nested termlist for the intersection.\n    \"\"\"\nnew_nested_tl = []\nfor self_tl in self.nested_termlist:\nfor other_tl in other.nested_termlist:\nnew_tl = self_tl | other_tl\nif not new_tl.is_empty():\nnew_nested_tl.append(new_tl)\nreturn type(self)(new_nested_tl, force_empty_intersection)\n</code></pre>"},{"location":"reference/pacti/iocontract/compundiocontract/#pacti.iocontract.compundiocontract.NestedTermList.simplify","title":"<code>simplify(context, force_empty_intersection)</code>","text":"<p>Remove redundant terms in nested termlist.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>NestedTermlist_t</code> <p>Nested termlist serving as context for simplification.</p> required <code>force_empty_intersection</code> <code>bool</code> <p>Make sure the resulting termlists have empty intersection.</p> required <p>Returns:</p> Type Description <code>NestedTermlist_t</code> <p>A contract with redundant terms removed in nested termlist.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\compundiocontract.py</code> <pre><code>def simplify(self: NestedTermlist_t, context: NestedTermlist_t, force_empty_intersection: bool) -&gt; NestedTermlist_t:\n\"\"\"\n    Remove redundant terms in nested termlist.\n    Args:\n        context: Nested termlist serving as context for simplification.\n        force_empty_intersection: Make sure the resulting termlists have empty intersection.\n    Returns:\n        A contract with redundant terms removed in nested termlist.\n    \"\"\"\nnew_nested_tl = []\nfor self_tl in self.nested_termlist:\nfor context_tl in context.nested_termlist:\ntry:\nnew_tl = self_tl.simplify(context_tl)\nexcept ValueError:\nnew_tl = self_tl.copy()\ncontinue\nnew_nested_tl.append(new_tl)\nreturn type(self)(new_nested_tl, force_empty_intersection)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/","title":"Iocontract","text":"<p>IoContracts definitions.</p> <p>IoContracts contains Pacti's basic definitions: Var, Term, TemList, and IoContract. Var creates variables; Term is an abstract class representing constraints; a TermList (also an abstract class) is a collection of terms semantically equivalent to the term which is the conjunction of all terms contained in the TermList; IoContract is an assume-guarantee specification consisting of assumptions, guarantees, and input and output variables. The assumptions and guarantees are given by TermLists. Assumptions make predicates only on inputs, and guarantees on both input and outputs (and no other variable).</p> <p>This module implements all supported contract operations and relations. In order to instantiate contracts and perform this operations, it is necessary to extend Term and TermList with specific constraint formalisms.</p>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract","title":"<code>IoContract</code>","text":"<p>               Bases: <code>Generic[TermList_t]</code></p> <p>Basic type for an IO contract.</p> <p>Attributes:</p> Name Type Description <code>inputvars</code> <p>Variables which are inputs of the implementations of the contract.</p> <code>outputvars</code> <p>Variables which are outputs of the implementations of the contract.</p> <code>a(TermList)</code> <p>Contract assumptions.</p> <code>g(TermList)</code> <p>Contract guarantees.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>class IoContract(Generic[TermList_t]):\n\"\"\"\n    Basic type for an IO contract.\n    Attributes:\n        inputvars:\n            Variables which are inputs of the implementations of the contract.\n        outputvars:\n            Variables which are outputs of the implementations of the contract.\n        a(TermList): Contract assumptions.\n        g(TermList): Contract guarantees.\n    \"\"\"\ndef __init__(\nself,\nassumptions: TermList_t,\nguarantees: TermList_t,\ninput_vars: List[Var],\noutput_vars: List[Var],\nsimplify: bool = True,\n) -&gt; None:\n\"\"\"\n        Class constructor.\n        Args:\n            assumptions: The assumptions of the contract.\n            guarantees: The guarantees of the contract.\n            input_vars: The input variables of the contract.\n            output_vars: The output variables of the contract.\n            simplify: Whether to simplify the guarantees with respect to the assumptions.\n        Raises:\n            IncompatibleArgsError: Arguments provided does not produce a valid IO contract.\n        \"\"\"\n# make sure the input and output variables have no repeated entries\nif len(input_vars) != len(set(input_vars)):\nraise IncompatibleArgsError(\n\"The following input variables appear multiple times in argument %s\"\n% (set(list_diff(input_vars, list(set(input_vars)))))\n)\nif len(output_vars) != len(set(output_vars)):\nraise IncompatibleArgsError(\n\"The following output variables appear multiple times in argument %s\"\n% (set(list_diff(output_vars, list(set(output_vars)))))\n)\n# make sure the input &amp; output variables are disjoint\nif list_intersection(input_vars, output_vars):\nraise IncompatibleArgsError(\n\"The following variables appear in inputs and outputs: %s\"\n% (list_intersection(input_vars, output_vars))\n)\n# make sure the assumptions only contain input variables\nif list_diff(assumptions.vars, input_vars):\nraise IncompatibleArgsError(\n\"The following variables appear in the assumptions but are not inputs: %s\"\n% (list_diff(assumptions.vars, input_vars))\n)\n# make sure the guarantees only contain input or output variables\nif list_diff(guarantees.vars, list_union(input_vars, output_vars)):\nraise IncompatibleArgsError(\n\"The guarantees contain the following variables which are neither\"\n\"inputs nor outputs: %s. Inputs: %s. Outputs: %s. Guarantees: %s\"\n% (list_diff(guarantees.vars, list_union(input_vars, output_vars)), input_vars, output_vars, guarantees)\n)\nself.a: TermList_t = assumptions.copy()\nself.inputvars = input_vars.copy()\nself.outputvars = output_vars.copy()\nif simplify:\nself.g = guarantees.simplify(self.a)\nelse:\nself.g = guarantees.copy()\ndef simplify(self) -&gt; None:\n\"\"\"Simplifies guarantees given assumptions.\"\"\"\nself.g = self.g.simplify(self.a)\n@property\ndef vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"\n        The list of variables in the interface of the contract.\n        Returns:\n            Input and output variables of the contract.\n        \"\"\"\nreturn list_union(self.inputvars, self.outputvars)\ndef __str__(self) -&gt; str:\nreturn (\n\"InVars: \"\n+ \"[\"\n+ \", \".join([v.name for v in self.inputvars])\n+ \"]\"\n+ \"\\nOutVars:\"\n+ \"[\"\n+ \", \".join([v.name for v in self.outputvars])\n+ \"]\"\n+ \"\\nA: \"\n+ str(self.a)\n+ \"\\n\"\n+ \"G: \"\n+ str(self.g)\n)\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError\nreturn (\nself.inputvars == other.inputvars\nand self.outputvars == self.outputvars\nand self.a == other.a\nand self.g == other.g\n)\ndef __hash__(self) -&gt; int:\nreturn hash((tuple(self.inputvars), tuple(self.outputvars), self.a, self.g))\ndef rename_variable(  # noqa: WPS231 too much cognitive complexity\nself: IoContract_t, source_var: Var, target_var: Var\n) -&gt; IoContract_t:\n\"\"\"\n        Rename a variable in a contract.\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n        Returns:\n            A contract with `source_var` replaced by `target_var`.\n        Raises:\n            IncompatibleArgsError: The new variable is both an input and output of the resulting contract.\n        \"\"\"\ninputvars = self.inputvars.copy()\noutputvars = self.outputvars.copy()\nassumptions = self.a.copy()\nguarantees = self.g.copy()\nif source_var != target_var:\nif source_var in inputvars:\nif target_var in outputvars:\nraise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\nelif target_var not in inputvars:\ninputvars[inputvars.index(source_var)] = target_var\nelse:\ninputvars.remove(source_var)\nassumptions = assumptions.rename_variable(source_var, target_var)\nguarantees = guarantees.rename_variable(source_var, target_var)\nelif source_var in outputvars:\nif target_var in inputvars:\nraise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\nelif target_var not in outputvars:\noutputvars[outputvars.index(source_var)] = target_var\nelse:\noutputvars.remove(source_var)\nassumptions = assumptions.rename_variable(source_var, target_var)\nguarantees = guarantees.rename_variable(source_var, target_var)\nreturn type(self)(assumptions, guarantees, inputvars, outputvars)\ndef copy(self: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n        Makes copy of contract.\n        Returns:\n            Copy of contract.\n        \"\"\"\ninputvars = self.inputvars.copy()\noutputvars = self.outputvars.copy()\nassumptions = self.a.copy()\nguarantees = self.g.copy()\nreturn type(self)(assumptions, guarantees, inputvars, outputvars)\ndef __le__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError()\nreturn self.refines(other)\ndef __repr__(self) -&gt; str:\nreturn \"&lt;Var {0}&gt;\".format(self)\ndef can_compose_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether the contract can be composed with another contract.\n        Args:\n            other:\n                Contract whose possibility to compose with self we are\n                verifying.\n        Returns:\n            True if the contracts can be composed. False otherwise.\n        \"\"\"\n# make sure lists of output variables don't intersect\nreturn len(list_intersection(self.outputvars, other.outputvars)) == 0\ndef can_quotient_by(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether the contract can quotiented by another contract.\n        Args:\n            other: potential quotient by which self would be quotiented.\n        Returns:\n            True if the IO profiles of the contracts allow the quotient to\n                exist. False otherwise.\n        \"\"\"\n# make sure the top level outputs not contained in outputs of the\n# existing component do not intersect with the inputs of the existing\n# component\nreturn len(list_intersection(list_diff(self.outputvars, other.outputvars), other.inputvars)) == 0\ndef shares_io_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether two contracts have the same IO signature.\n        Args:\n            other: contract whose IO signature is compared with self.\n        Returns:\n            True if the contracts have the same IO profile.\n        \"\"\"\nreturn lists_equal(self.inputvars, other.inputvars) &amp; lists_equal(self.outputvars, other.outputvars)\ndef refines(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n        Tell whether the given contract is a refinement of another.\n        Return self &lt;= other.\n        Args:\n            other: contract being compared with self.\n        Returns:\n            True if the calling contract refines the argument.\n        Raises:\n            IncompatibleArgsError: Refinement cannot be computed.\n        \"\"\"\nif not self.shares_io_with(other):\nraise IncompatibleArgsError(\"Contracts do not share IO\")\nassumptions_check: bool = other.a &lt;= self.a\nguarantees_check: bool = (self.g | other.a) &lt;= (other.g | other.a)\nreturn assumptions_check and guarantees_check\ndef compose(\nself: IoContract_t,\nother: IoContract_t,\nvars_to_keep: Any = None,\nsimplify: bool = True,\n) -&gt; IoContract_t:\n\"\"\"Compose IO contracts.\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n        Returns:\n            The abstracted composition of the two contracts.\n        \"\"\"\nresult, _ = self.compose_tactics(other, vars_to_keep, simplify)\nreturn result\ndef compose_tactics(  # noqa: WPS231\nself: IoContract_t,\nother: IoContract_t,\nvars_to_keep: Any = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[IoContract_t, List[TacticStatistics]]:  # noqa: WPS231\n\"\"\"Compose IO contracts with support for specifying the order of tactics and measuring their use.\n        Compute the composition of the two given contracts and abstract the\n        result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The second contract being composed.\n            vars_to_keep:\n                A list of variables that should be kept as top-level outputs.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n            tactics_order:\n                The order of tactics to try for variable term elimination.\n        Returns:\n            A tuple of the abstracted composition of the two contracts and of the list of tactics used.\n        Raises:\n            IncompatibleArgsError: An error occurred during composition.\n        \"\"\"\nif tactics_order is None:\ntactics_order = []\nif vars_to_keep is None:\nvars_to_keep = []\nconflict_vars = list_diff(vars_to_keep, list_union(self.outputvars, other.outputvars))\nif conflict_vars:\nraise IncompatibleArgsError(\"Asked to keep variables %s, which are not outputs\" % (conflict_vars))\nlogging.debug(\"Composing contracts \\n%s and \\n%s\", self, other)\nintvars = list_union(\nlist_intersection(self.outputvars, other.inputvars), list_intersection(self.inputvars, other.outputvars)\n)\ninputvars = list_diff(list_union(self.inputvars, other.inputvars), intvars)\noutputvars = list_diff(list_union(self.outputvars, other.outputvars), intvars)\n# remove requested variables\nintvars = list_diff(intvars, vars_to_keep)\noutputvars = list_union(outputvars, vars_to_keep)\nselfinputconst = self.a.vars\notherinputconst = other.a.vars\ncycle_present = (\nlen(list_intersection(self.inputvars, other.outputvars)) &gt; 0\nand len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\n)\nassumptions_forbidden_vars = list_union(intvars, outputvars)\nif not self.can_compose_with(other):\nraise IncompatibleArgsError(\n\"Cannot compose the following contracts due to incompatible IO profiles:\\n %s \\n %s\" % (self, other)\n)\nother_helps_self = len(list_intersection(other.outputvars, self.inputvars)) &gt; 0\nself_helps_other = len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\nother_drives_const_inputs = len(list_intersection(other.outputvars, selfinputconst)) &gt; 0\nself_drives_const_inputs = len(list_intersection(self.outputvars, otherinputconst)) &gt; 0\ntactics_used: List[TacticStatistics] = []\n# process assumptions\nif cycle_present and (other_drives_const_inputs or self_drives_const_inputs):\nraise IncompatibleArgsError(\"Cannot compose contracts due to feedback\")\nelif self_helps_other and not other_helps_self:\nlogging.debug(\"Assumption computation: self provides context for other\")\n(new_a, used) = other.a.elim_vars_by_refining(\nself.a | self.g, assumptions_forbidden_vars, simplify=True, tactics_order=tactics_order\n)\ntactics_used.append(used)\nconflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\nif conflict_variables:\nraise IncompatibleArgsError(\n\"Could not eliminate variables {}\\n\".format([str(x) for x in assumptions_forbidden_vars])\n+ \"by refining the assumptions \\n{}\\n\".format(new_a.get_terms_with_vars(assumptions_forbidden_vars))\n+ \"using guarantees \\n{}\\n\".format(self.a | self.g)\n)\nassumptions = new_a | self.a\nelif other_helps_self and not self_helps_other:\nlogging.debug(\"****** Assumption computation: other provides context for self\")\n(new_a, used) = self.a.elim_vars_by_refining(\nother.a | other.g, assumptions_forbidden_vars, simplify=True, tactics_order=tactics_order\n)\ntactics_used.append(used)\nconflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\nif conflict_variables:\nraise IncompatibleArgsError(\n\"Could not eliminate variables {}\".format([str(x) for x in assumptions_forbidden_vars])\n+ \" by refining the assumptions \\n{}\\n\".format(\nnew_a.get_terms_with_vars(assumptions_forbidden_vars)\n)\n+ \"using guarantees \\n{}\\n\".format(other.a | other.g)\n)\nassumptions = new_a | other.a\n# contracts can't help each other\nelse:\nlogging.debug(\"****** Assumption computation: other provides context for self\")\nassumptions = self.a | other.a\nlogging.debug(\"Assumption computation: computed assumptions:\\n%s\", assumptions)\nif simplify:\nassumptions = assumptions.simplify()\n# process guarantees\nlogging.debug(\"****** Computing guarantees\")\ng1_t = self.g.copy()\ng2_t = other.g.copy()\n(g1, used) = g1_t.elim_vars_by_relaxing(g2_t, intvars, simplify, tactics_order)\ntactics_used.append(used)\n(g2, used) = g2_t.elim_vars_by_relaxing(g1_t, intvars, simplify, tactics_order)\ntactics_used.append(used)\nallguarantees = g1 | g2\n(allguarantees, used) = allguarantees.elim_vars_by_relaxing(assumptions, intvars, simplify, tactics_order)\ntactics_used.append(used)\n# eliminate terms with forbidden vars\nterms_to_elim = allguarantees.get_terms_with_vars(intvars)\nallguarantees -= terms_to_elim\nreturn type(self)(assumptions, allguarantees, inputvars, outputvars), tactics_used\ndef quotient(\nself: IoContract_t,\nother: IoContract_t,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\n) -&gt; IoContract_t:\n\"\"\"Compute the contract quotient.\n        Compute the quotient self/other of the two given contracts and refine\n        the result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n        Returns:\n            The refined quotient self/other.\n        \"\"\"\nresult, _ = self.quotient_tactics(other, additional_inputs, simplify)\nreturn result\ndef quotient_tactics(  # noqa: WPS231\nself: IoContract_t,\nother: IoContract_t,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[IoContract_t, List[TacticStatistics]]:\n\"\"\"Compute the contract quotient with support for specifying the order of tactics and measuring their use.\n        Compute the quotient self/other of the two given contracts and refine\n        the result in such a way that the result is a well-defined IO contract,\n        i.e., that assumptions refer only to inputs, and guarantees to both\n        inputs and outputs.\n        Args:\n            other:\n                The contract by which we take the quotient.\n            additional_inputs:\n                Additional variables that the quotient is allowed to consider as\n                inputs. These variables can be either top level-inputs or\n                outputs of the other argument.\n            simplify:\n                Whether to simplify the result of variable elimination by refining or relaxing.\n            tactics_order:\n                The order of tactics to try for variable term elimination.\n        Returns:\n            A tuple of the refined quotient self/other and the list of tactics used.\n        Raises:\n            IncompatibleArgsError: Arguments provided are incompatible with computation of the quotient.\n        \"\"\"\nif tactics_order is None:\ntactics_order = []\nif not additional_inputs:\nadditional_inputs = []\nif not self.can_quotient_by(other):\nraise IncompatibleArgsError(\"Contracts cannot be quotiented due to incompatible IO\")\nif list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)):\nraise IncompatibleArgsError(\n\"The additional inputs %s are neither top level inputs nor existing component outputs\"\n% (list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)))\n)\noutputvars = list_union(\nlist_diff(self.outputvars, other.outputvars), list_diff(other.inputvars, self.inputvars)\n)\ninputvars = list_union(list_diff(self.inputvars, other.inputvars), list_diff(other.outputvars, self.outputvars))\ninputvars = list_union(inputvars, additional_inputs)\nintvars = list_union(\nlist_intersection(self.outputvars, other.outputvars), list_intersection(self.inputvars, other.inputvars)\n)\nintvars = list_diff(intvars, additional_inputs)\ntactics_used: List[TacticStatistics] = []\n# get assumptions\nlogging.debug(\"Computing quotient assumptions\")\nassumptions = copy.deepcopy(self.a)\nempty_context = type(assumptions)([])\nif assumptions.refines(other.a):\nlogging.debug(\"Extending top-level assumptions with divisor's guarantees\")\nassumptions = assumptions | other.g\n(assumptions, used) = assumptions.elim_vars_by_relaxing(\nempty_context, list_union(intvars, outputvars), simplify, tactics_order\n)\ntactics_used.append(used)\nlogging.debug(\"Assumptions after processing: %s\", assumptions)\n# get guarantees\nlogging.debug(\"Computing quotient guarantees\")\nguarantees: TermList_t = self.g\nlogging.debug(\"Using existing guarantees to aid system-level guarantees\")\ntry:  # noqa: WPS229\n(guarantees, used) = guarantees.elim_vars_by_refining(other.g | self.a, intvars, simplify, tactics_order)\ntactics_used.append(used)\nexcept ValueError:\nguarantees = self.g\nlogging.debug(\"Guarantees are %s\" % (guarantees))\nlogging.debug(\"Using system-level assumptions to aid quotient guarantees\")\nguarantees = guarantees | other.a\ntry:  # noqa: WPS229\n(guarantees, used) = guarantees.elim_vars_by_refining(self.a, intvars, simplify, tactics_order)\ntactics_used.append(used)\nexcept ValueError:\n...\nlogging.debug(\"Guarantees after processing: %s\", guarantees)\nconflict_variables = list_intersection(guarantees.vars, intvars)\nif conflict_variables:\nraise IncompatibleArgsError(\n\"Could not eliminate variables \\n{}\".format([str(x) for x in conflict_variables])\n+ \"by refining the guarantees \\n{}\\n\".format(guarantees.get_terms_with_vars(intvars))\n)\nreturn type(self)(assumptions, guarantees, inputvars, outputvars), tactics_used\ndef merge(self: IoContract_t, other: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n        Compute the merging operation for two contracts.\n        Compute the merging operation of the two given contracts. No\n        abstraction/refinement is applied.\n        Args:\n            other: The contract with which we are merging self.\n        Returns:\n            The result of merging.\n        Raises:\n            IncompatibleArgsError: trying to merge different contract types.\n        \"\"\"\nif not isinstance(self, type(other)):\nraise IncompatibleArgsError(\"Asked to merge incompatible contracts\")\ninput_vars = list_union(self.inputvars, other.inputvars)\noutput_vars = list_union(self.outputvars, other.outputvars)\nassumptions = self.a | other.a\nguarantees = self.g | other.g\nreturn type(self)(assumptions, guarantees, input_vars, output_vars)\ndef contains_environment(self, component: TermList) -&gt; bool:\n\"\"\"\n        Tell whether a component is a valid environment for the contract.\n        Args:\n            component: The component in question.\n        Returns:\n            True if the component is a valid environment; false otherwise.\n        \"\"\"\nreturn component &lt;= self.a\ndef contains_implementation(self, component: TermList) -&gt; bool:\n\"\"\"\n        Tell whether a component is a valid implementation for the contract.\n        Args:\n            component:\n                The component in question.\n        Returns:\n            True if the component is a valid implementation; false otherwise.\n        \"\"\"\nreturn (component | self.a) &lt;= (self.g | self.a)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.vars","title":"<code>vars</code>  <code>property</code>","text":"<p>The list of variables in the interface of the contract.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>Input and output variables of the contract.</p>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.__init__","title":"<code>__init__(assumptions, guarantees, input_vars, output_vars, simplify=True)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>assumptions</code> <code>TermList_t</code> <p>The assumptions of the contract.</p> required <code>guarantees</code> <code>TermList_t</code> <p>The guarantees of the contract.</p> required <code>input_vars</code> <code>List[Var]</code> <p>The input variables of the contract.</p> required <code>output_vars</code> <code>List[Var]</code> <p>The output variables of the contract.</p> required <code>simplify</code> <code>bool</code> <p>Whether to simplify the guarantees with respect to the assumptions.</p> <code>True</code> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>Arguments provided does not produce a valid IO contract.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def __init__(\nself,\nassumptions: TermList_t,\nguarantees: TermList_t,\ninput_vars: List[Var],\noutput_vars: List[Var],\nsimplify: bool = True,\n) -&gt; None:\n\"\"\"\n    Class constructor.\n    Args:\n        assumptions: The assumptions of the contract.\n        guarantees: The guarantees of the contract.\n        input_vars: The input variables of the contract.\n        output_vars: The output variables of the contract.\n        simplify: Whether to simplify the guarantees with respect to the assumptions.\n    Raises:\n        IncompatibleArgsError: Arguments provided does not produce a valid IO contract.\n    \"\"\"\n# make sure the input and output variables have no repeated entries\nif len(input_vars) != len(set(input_vars)):\nraise IncompatibleArgsError(\n\"The following input variables appear multiple times in argument %s\"\n% (set(list_diff(input_vars, list(set(input_vars)))))\n)\nif len(output_vars) != len(set(output_vars)):\nraise IncompatibleArgsError(\n\"The following output variables appear multiple times in argument %s\"\n% (set(list_diff(output_vars, list(set(output_vars)))))\n)\n# make sure the input &amp; output variables are disjoint\nif list_intersection(input_vars, output_vars):\nraise IncompatibleArgsError(\n\"The following variables appear in inputs and outputs: %s\"\n% (list_intersection(input_vars, output_vars))\n)\n# make sure the assumptions only contain input variables\nif list_diff(assumptions.vars, input_vars):\nraise IncompatibleArgsError(\n\"The following variables appear in the assumptions but are not inputs: %s\"\n% (list_diff(assumptions.vars, input_vars))\n)\n# make sure the guarantees only contain input or output variables\nif list_diff(guarantees.vars, list_union(input_vars, output_vars)):\nraise IncompatibleArgsError(\n\"The guarantees contain the following variables which are neither\"\n\"inputs nor outputs: %s. Inputs: %s. Outputs: %s. Guarantees: %s\"\n% (list_diff(guarantees.vars, list_union(input_vars, output_vars)), input_vars, output_vars, guarantees)\n)\nself.a: TermList_t = assumptions.copy()\nself.inputvars = input_vars.copy()\nself.outputvars = output_vars.copy()\nif simplify:\nself.g = guarantees.simplify(self.a)\nelse:\nself.g = guarantees.copy()\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.can_compose_with","title":"<code>can_compose_with(other)</code>","text":"<p>Tell whether the contract can be composed with another contract.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>Contract whose possibility to compose with self we are verifying.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the contracts can be composed. False otherwise.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def can_compose_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether the contract can be composed with another contract.\n    Args:\n        other:\n            Contract whose possibility to compose with self we are\n            verifying.\n    Returns:\n        True if the contracts can be composed. False otherwise.\n    \"\"\"\n# make sure lists of output variables don't intersect\nreturn len(list_intersection(self.outputvars, other.outputvars)) == 0\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.can_quotient_by","title":"<code>can_quotient_by(other)</code>","text":"<p>Tell whether the contract can quotiented by another contract.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>potential quotient by which self would be quotiented.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the IO profiles of the contracts allow the quotient to exist. False otherwise.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def can_quotient_by(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether the contract can quotiented by another contract.\n    Args:\n        other: potential quotient by which self would be quotiented.\n    Returns:\n        True if the IO profiles of the contracts allow the quotient to\n            exist. False otherwise.\n    \"\"\"\n# make sure the top level outputs not contained in outputs of the\n# existing component do not intersect with the inputs of the existing\n# component\nreturn len(list_intersection(list_diff(self.outputvars, other.outputvars), other.inputvars)) == 0\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.compose","title":"<code>compose(other, vars_to_keep=None, simplify=True)</code>","text":"<p>Compose IO contracts.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Any</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <p>Returns:</p> Type Description <code>IoContract_t</code> <p>The abstracted composition of the two contracts.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def compose(\nself: IoContract_t,\nother: IoContract_t,\nvars_to_keep: Any = None,\nsimplify: bool = True,\n) -&gt; IoContract_t:\n\"\"\"Compose IO contracts.\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n    Returns:\n        The abstracted composition of the two contracts.\n    \"\"\"\nresult, _ = self.compose_tactics(other, vars_to_keep, simplify)\nreturn result\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.compose_tactics","title":"<code>compose_tactics(other, vars_to_keep=None, simplify=True, tactics_order=None)</code>","text":"<p>Compose IO contracts with support for specifying the order of tactics and measuring their use.</p> <p>Compute the composition of the two given contracts and abstract the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The second contract being composed.</p> required <code>vars_to_keep</code> <code>Any</code> <p>A list of variables that should be kept as top-level outputs.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>The order of tactics to try for variable term elimination.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[IoContract_t, List[TacticStatistics]]</code> <p>A tuple of the abstracted composition of the two contracts and of the list of tactics used.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>An error occurred during composition.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def compose_tactics(  # noqa: WPS231\nself: IoContract_t,\nother: IoContract_t,\nvars_to_keep: Any = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[IoContract_t, List[TacticStatistics]]:  # noqa: WPS231\n\"\"\"Compose IO contracts with support for specifying the order of tactics and measuring their use.\n    Compute the composition of the two given contracts and abstract the\n    result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The second contract being composed.\n        vars_to_keep:\n            A list of variables that should be kept as top-level outputs.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n        tactics_order:\n            The order of tactics to try for variable term elimination.\n    Returns:\n        A tuple of the abstracted composition of the two contracts and of the list of tactics used.\n    Raises:\n        IncompatibleArgsError: An error occurred during composition.\n    \"\"\"\nif tactics_order is None:\ntactics_order = []\nif vars_to_keep is None:\nvars_to_keep = []\nconflict_vars = list_diff(vars_to_keep, list_union(self.outputvars, other.outputvars))\nif conflict_vars:\nraise IncompatibleArgsError(\"Asked to keep variables %s, which are not outputs\" % (conflict_vars))\nlogging.debug(\"Composing contracts \\n%s and \\n%s\", self, other)\nintvars = list_union(\nlist_intersection(self.outputvars, other.inputvars), list_intersection(self.inputvars, other.outputvars)\n)\ninputvars = list_diff(list_union(self.inputvars, other.inputvars), intvars)\noutputvars = list_diff(list_union(self.outputvars, other.outputvars), intvars)\n# remove requested variables\nintvars = list_diff(intvars, vars_to_keep)\noutputvars = list_union(outputvars, vars_to_keep)\nselfinputconst = self.a.vars\notherinputconst = other.a.vars\ncycle_present = (\nlen(list_intersection(self.inputvars, other.outputvars)) &gt; 0\nand len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\n)\nassumptions_forbidden_vars = list_union(intvars, outputvars)\nif not self.can_compose_with(other):\nraise IncompatibleArgsError(\n\"Cannot compose the following contracts due to incompatible IO profiles:\\n %s \\n %s\" % (self, other)\n)\nother_helps_self = len(list_intersection(other.outputvars, self.inputvars)) &gt; 0\nself_helps_other = len(list_intersection(other.inputvars, self.outputvars)) &gt; 0\nother_drives_const_inputs = len(list_intersection(other.outputvars, selfinputconst)) &gt; 0\nself_drives_const_inputs = len(list_intersection(self.outputvars, otherinputconst)) &gt; 0\ntactics_used: List[TacticStatistics] = []\n# process assumptions\nif cycle_present and (other_drives_const_inputs or self_drives_const_inputs):\nraise IncompatibleArgsError(\"Cannot compose contracts due to feedback\")\nelif self_helps_other and not other_helps_self:\nlogging.debug(\"Assumption computation: self provides context for other\")\n(new_a, used) = other.a.elim_vars_by_refining(\nself.a | self.g, assumptions_forbidden_vars, simplify=True, tactics_order=tactics_order\n)\ntactics_used.append(used)\nconflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\nif conflict_variables:\nraise IncompatibleArgsError(\n\"Could not eliminate variables {}\\n\".format([str(x) for x in assumptions_forbidden_vars])\n+ \"by refining the assumptions \\n{}\\n\".format(new_a.get_terms_with_vars(assumptions_forbidden_vars))\n+ \"using guarantees \\n{}\\n\".format(self.a | self.g)\n)\nassumptions = new_a | self.a\nelif other_helps_self and not self_helps_other:\nlogging.debug(\"****** Assumption computation: other provides context for self\")\n(new_a, used) = self.a.elim_vars_by_refining(\nother.a | other.g, assumptions_forbidden_vars, simplify=True, tactics_order=tactics_order\n)\ntactics_used.append(used)\nconflict_variables = list_intersection(new_a.vars, assumptions_forbidden_vars)\nif conflict_variables:\nraise IncompatibleArgsError(\n\"Could not eliminate variables {}\".format([str(x) for x in assumptions_forbidden_vars])\n+ \" by refining the assumptions \\n{}\\n\".format(\nnew_a.get_terms_with_vars(assumptions_forbidden_vars)\n)\n+ \"using guarantees \\n{}\\n\".format(other.a | other.g)\n)\nassumptions = new_a | other.a\n# contracts can't help each other\nelse:\nlogging.debug(\"****** Assumption computation: other provides context for self\")\nassumptions = self.a | other.a\nlogging.debug(\"Assumption computation: computed assumptions:\\n%s\", assumptions)\nif simplify:\nassumptions = assumptions.simplify()\n# process guarantees\nlogging.debug(\"****** Computing guarantees\")\ng1_t = self.g.copy()\ng2_t = other.g.copy()\n(g1, used) = g1_t.elim_vars_by_relaxing(g2_t, intvars, simplify, tactics_order)\ntactics_used.append(used)\n(g2, used) = g2_t.elim_vars_by_relaxing(g1_t, intvars, simplify, tactics_order)\ntactics_used.append(used)\nallguarantees = g1 | g2\n(allguarantees, used) = allguarantees.elim_vars_by_relaxing(assumptions, intvars, simplify, tactics_order)\ntactics_used.append(used)\n# eliminate terms with forbidden vars\nterms_to_elim = allguarantees.get_terms_with_vars(intvars)\nallguarantees -= terms_to_elim\nreturn type(self)(assumptions, allguarantees, inputvars, outputvars), tactics_used\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.contains_environment","title":"<code>contains_environment(component)</code>","text":"<p>Tell whether a component is a valid environment for the contract.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>TermList</code> <p>The component in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the component is a valid environment; false otherwise.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def contains_environment(self, component: TermList) -&gt; bool:\n\"\"\"\n    Tell whether a component is a valid environment for the contract.\n    Args:\n        component: The component in question.\n    Returns:\n        True if the component is a valid environment; false otherwise.\n    \"\"\"\nreturn component &lt;= self.a\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.contains_implementation","title":"<code>contains_implementation(component)</code>","text":"<p>Tell whether a component is a valid implementation for the contract.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>TermList</code> <p>The component in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the component is a valid implementation; false otherwise.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def contains_implementation(self, component: TermList) -&gt; bool:\n\"\"\"\n    Tell whether a component is a valid implementation for the contract.\n    Args:\n        component:\n            The component in question.\n    Returns:\n        True if the component is a valid implementation; false otherwise.\n    \"\"\"\nreturn (component | self.a) &lt;= (self.g | self.a)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.copy","title":"<code>copy()</code>","text":"<p>Makes copy of contract.</p> <p>Returns:</p> Type Description <code>IoContract_t</code> <p>Copy of contract.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def copy(self: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n    Makes copy of contract.\n    Returns:\n        Copy of contract.\n    \"\"\"\ninputvars = self.inputvars.copy()\noutputvars = self.outputvars.copy()\nassumptions = self.a.copy()\nguarantees = self.g.copy()\nreturn type(self)(assumptions, guarantees, inputvars, outputvars)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.merge","title":"<code>merge(other)</code>","text":"<p>Compute the merging operation for two contracts.</p> <p>Compute the merging operation of the two given contracts. No abstraction/refinement is applied.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The contract with which we are merging self.</p> required <p>Returns:</p> Type Description <code>IoContract_t</code> <p>The result of merging.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>trying to merge different contract types.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def merge(self: IoContract_t, other: IoContract_t) -&gt; IoContract_t:\n\"\"\"\n    Compute the merging operation for two contracts.\n    Compute the merging operation of the two given contracts. No\n    abstraction/refinement is applied.\n    Args:\n        other: The contract with which we are merging self.\n    Returns:\n        The result of merging.\n    Raises:\n        IncompatibleArgsError: trying to merge different contract types.\n    \"\"\"\nif not isinstance(self, type(other)):\nraise IncompatibleArgsError(\"Asked to merge incompatible contracts\")\ninput_vars = list_union(self.inputvars, other.inputvars)\noutput_vars = list_union(self.outputvars, other.outputvars)\nassumptions = self.a | other.a\nguarantees = self.g | other.g\nreturn type(self)(assumptions, guarantees, input_vars, output_vars)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.quotient","title":"<code>quotient(other, additional_inputs=None, simplify=True)</code>","text":"<p>Compute the contract quotient.</p> <p>Compute the quotient self/other of the two given contracts and refine the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <p>Returns:</p> Type Description <code>IoContract_t</code> <p>The refined quotient self/other.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def quotient(\nself: IoContract_t,\nother: IoContract_t,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\n) -&gt; IoContract_t:\n\"\"\"Compute the contract quotient.\n    Compute the quotient self/other of the two given contracts and refine\n    the result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n    Returns:\n        The refined quotient self/other.\n    \"\"\"\nresult, _ = self.quotient_tactics(other, additional_inputs, simplify)\nreturn result\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.quotient_tactics","title":"<code>quotient_tactics(other, additional_inputs=None, simplify=True, tactics_order=None)</code>","text":"<p>Compute the contract quotient with support for specifying the order of tactics and measuring their use.</p> <p>Compute the quotient self/other of the two given contracts and refine the result in such a way that the result is a well-defined IO contract, i.e., that assumptions refer only to inputs, and guarantees to both inputs and outputs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>The contract by which we take the quotient.</p> required <code>additional_inputs</code> <code>Optional[List[Var]]</code> <p>Additional variables that the quotient is allowed to consider as inputs. These variables can be either top level-inputs or outputs of the other argument.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify the result of variable elimination by refining or relaxing.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>The order of tactics to try for variable term elimination.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[IoContract_t, List[TacticStatistics]]</code> <p>A tuple of the refined quotient self/other and the list of tactics used.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>Arguments provided are incompatible with computation of the quotient.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def quotient_tactics(  # noqa: WPS231\nself: IoContract_t,\nother: IoContract_t,\nadditional_inputs: Optional[List[Var]] = None,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[IoContract_t, List[TacticStatistics]]:\n\"\"\"Compute the contract quotient with support for specifying the order of tactics and measuring their use.\n    Compute the quotient self/other of the two given contracts and refine\n    the result in such a way that the result is a well-defined IO contract,\n    i.e., that assumptions refer only to inputs, and guarantees to both\n    inputs and outputs.\n    Args:\n        other:\n            The contract by which we take the quotient.\n        additional_inputs:\n            Additional variables that the quotient is allowed to consider as\n            inputs. These variables can be either top level-inputs or\n            outputs of the other argument.\n        simplify:\n            Whether to simplify the result of variable elimination by refining or relaxing.\n        tactics_order:\n            The order of tactics to try for variable term elimination.\n    Returns:\n        A tuple of the refined quotient self/other and the list of tactics used.\n    Raises:\n        IncompatibleArgsError: Arguments provided are incompatible with computation of the quotient.\n    \"\"\"\nif tactics_order is None:\ntactics_order = []\nif not additional_inputs:\nadditional_inputs = []\nif not self.can_quotient_by(other):\nraise IncompatibleArgsError(\"Contracts cannot be quotiented due to incompatible IO\")\nif list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)):\nraise IncompatibleArgsError(\n\"The additional inputs %s are neither top level inputs nor existing component outputs\"\n% (list_diff(additional_inputs, list_union(other.outputvars, self.inputvars)))\n)\noutputvars = list_union(\nlist_diff(self.outputvars, other.outputvars), list_diff(other.inputvars, self.inputvars)\n)\ninputvars = list_union(list_diff(self.inputvars, other.inputvars), list_diff(other.outputvars, self.outputvars))\ninputvars = list_union(inputvars, additional_inputs)\nintvars = list_union(\nlist_intersection(self.outputvars, other.outputvars), list_intersection(self.inputvars, other.inputvars)\n)\nintvars = list_diff(intvars, additional_inputs)\ntactics_used: List[TacticStatistics] = []\n# get assumptions\nlogging.debug(\"Computing quotient assumptions\")\nassumptions = copy.deepcopy(self.a)\nempty_context = type(assumptions)([])\nif assumptions.refines(other.a):\nlogging.debug(\"Extending top-level assumptions with divisor's guarantees\")\nassumptions = assumptions | other.g\n(assumptions, used) = assumptions.elim_vars_by_relaxing(\nempty_context, list_union(intvars, outputvars), simplify, tactics_order\n)\ntactics_used.append(used)\nlogging.debug(\"Assumptions after processing: %s\", assumptions)\n# get guarantees\nlogging.debug(\"Computing quotient guarantees\")\nguarantees: TermList_t = self.g\nlogging.debug(\"Using existing guarantees to aid system-level guarantees\")\ntry:  # noqa: WPS229\n(guarantees, used) = guarantees.elim_vars_by_refining(other.g | self.a, intvars, simplify, tactics_order)\ntactics_used.append(used)\nexcept ValueError:\nguarantees = self.g\nlogging.debug(\"Guarantees are %s\" % (guarantees))\nlogging.debug(\"Using system-level assumptions to aid quotient guarantees\")\nguarantees = guarantees | other.a\ntry:  # noqa: WPS229\n(guarantees, used) = guarantees.elim_vars_by_refining(self.a, intvars, simplify, tactics_order)\ntactics_used.append(used)\nexcept ValueError:\n...\nlogging.debug(\"Guarantees after processing: %s\", guarantees)\nconflict_variables = list_intersection(guarantees.vars, intvars)\nif conflict_variables:\nraise IncompatibleArgsError(\n\"Could not eliminate variables \\n{}\".format([str(x) for x in conflict_variables])\n+ \"by refining the guarantees \\n{}\\n\".format(guarantees.get_terms_with_vars(intvars))\n)\nreturn type(self)(assumptions, guarantees, inputvars, outputvars), tactics_used\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.refines","title":"<code>refines(other)</code>","text":"<p>Tell whether the given contract is a refinement of another.</p> <p>Return self &lt;= other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>contract being compared with self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the calling contract refines the argument.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>Refinement cannot be computed.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def refines(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether the given contract is a refinement of another.\n    Return self &lt;= other.\n    Args:\n        other: contract being compared with self.\n    Returns:\n        True if the calling contract refines the argument.\n    Raises:\n        IncompatibleArgsError: Refinement cannot be computed.\n    \"\"\"\nif not self.shares_io_with(other):\nraise IncompatibleArgsError(\"Contracts do not share IO\")\nassumptions_check: bool = other.a &lt;= self.a\nguarantees_check: bool = (self.g | other.a) &lt;= (other.g | other.a)\nreturn assumptions_check and guarantees_check\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a contract.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>IoContract_t</code> <p>A contract with <code>source_var</code> replaced by <code>target_var</code>.</p> <p>Raises:</p> Type Description <code>IncompatibleArgsError</code> <p>The new variable is both an input and output of the resulting contract.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def rename_variable(  # noqa: WPS231 too much cognitive complexity\nself: IoContract_t, source_var: Var, target_var: Var\n) -&gt; IoContract_t:\n\"\"\"\n    Rename a variable in a contract.\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n    Returns:\n        A contract with `source_var` replaced by `target_var`.\n    Raises:\n        IncompatibleArgsError: The new variable is both an input and output of the resulting contract.\n    \"\"\"\ninputvars = self.inputvars.copy()\noutputvars = self.outputvars.copy()\nassumptions = self.a.copy()\nguarantees = self.g.copy()\nif source_var != target_var:\nif source_var in inputvars:\nif target_var in outputvars:\nraise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\nelif target_var not in inputvars:\ninputvars[inputvars.index(source_var)] = target_var\nelse:\ninputvars.remove(source_var)\nassumptions = assumptions.rename_variable(source_var, target_var)\nguarantees = guarantees.rename_variable(source_var, target_var)\nelif source_var in outputvars:\nif target_var in inputvars:\nraise IncompatibleArgsError(\"Making variable %s both an input and output\" % (target_var))\nelif target_var not in outputvars:\noutputvars[outputvars.index(source_var)] = target_var\nelse:\noutputvars.remove(source_var)\nassumptions = assumptions.rename_variable(source_var, target_var)\nguarantees = guarantees.rename_variable(source_var, target_var)\nreturn type(self)(assumptions, guarantees, inputvars, outputvars)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.shares_io_with","title":"<code>shares_io_with(other)</code>","text":"<p>Tell whether two contracts have the same IO signature.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IoContract_t</code> <p>contract whose IO signature is compared with self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the contracts have the same IO profile.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def shares_io_with(self: IoContract_t, other: IoContract_t) -&gt; bool:\n\"\"\"\n    Tell whether two contracts have the same IO signature.\n    Args:\n        other: contract whose IO signature is compared with self.\n    Returns:\n        True if the contracts have the same IO profile.\n    \"\"\"\nreturn lists_equal(self.inputvars, other.inputvars) &amp; lists_equal(self.outputvars, other.outputvars)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.IoContract.simplify","title":"<code>simplify()</code>","text":"<p>Simplifies guarantees given assumptions.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def simplify(self) -&gt; None:\n\"\"\"Simplifies guarantees given assumptions.\"\"\"\nself.g = self.g.simplify(self.a)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term","title":"<code>Term</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Terms, or constraints, to be imposed on the system or components.</p> <p>Term is an abstract class that must be extended in order to support specific constraint languages.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>class Term(ABC):\n\"\"\"\n    Terms, or constraints, to be imposed on the system or components.\n    Term is an abstract class that must be extended in order to support specific\n    constraint languages.\n    \"\"\"\n@property\n@abstractmethod\ndef vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"Variables contained in the syntax of the term.\"\"\"\n@abstractmethod\ndef contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n        Tell whether term contains a given variable.\n        Args:\n            var_to_seek: The variable that we are seeking in the current term.\n        \"\"\"\n@abstractmethod\ndef __eq__(self, other: object) -&gt; bool:\n\"\"\"\n        Equality.\n        Args:\n            other: the object against which we are comparing self.\n        \"\"\"\n@abstractmethod\ndef __str__(self) -&gt; str:\n\"\"\"Printing support.\"\"\"\n@abstractmethod\ndef __hash__(self) -&gt; int:\n\"\"\"Hashing.\"\"\"\n@abstractmethod\ndef __repr__(self) -&gt; str:\n\"\"\"Printable representation.\"\"\"\n@abstractmethod\ndef copy(self: Term_t) -&gt; Term_t:\n\"\"\"Returns a copy of term.\"\"\"\n@abstractmethod\ndef rename_variable(self: Term_t, source_var: Var, target_var: Var) -&gt; Term_t:\n\"\"\"\n        Rename a variable in a term.\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n        Returns:\n            A term with `source_var` replaced by `target_var`.\n        \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term.vars","title":"<code>vars</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Variables contained in the syntax of the term.</p>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term.__eq__","title":"<code>__eq__(other)</code>  <code>abstractmethod</code>","text":"<p>Equality.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>the object against which we are comparing self.</p> required Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef __eq__(self, other: object) -&gt; bool:\n\"\"\"\n    Equality.\n    Args:\n        other: the object against which we are comparing self.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term.__hash__","title":"<code>__hash__()</code>  <code>abstractmethod</code>","text":"<p>Hashing.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef __hash__(self) -&gt; int:\n\"\"\"Hashing.\"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term.__repr__","title":"<code>__repr__()</code>  <code>abstractmethod</code>","text":"<p>Printable representation.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef __repr__(self) -&gt; str:\n\"\"\"Printable representation.\"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term.__str__","title":"<code>__str__()</code>  <code>abstractmethod</code>","text":"<p>Printing support.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef __str__(self) -&gt; str:\n\"\"\"Printing support.\"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term.contains_var","title":"<code>contains_var(var_to_seek)</code>  <code>abstractmethod</code>","text":"<p>Tell whether term contains a given variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_to_seek</code> <code>Var</code> <p>The variable that we are seeking in the current term.</p> required Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n    Tell whether term contains a given variable.\n    Args:\n        var_to_seek: The variable that we are seeking in the current term.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term.copy","title":"<code>copy()</code>  <code>abstractmethod</code>","text":"<p>Returns a copy of term.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef copy(self: Term_t) -&gt; Term_t:\n\"\"\"Returns a copy of term.\"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Term.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>  <code>abstractmethod</code>","text":"<p>Rename a variable in a term.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>Term_t</code> <p>A term with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef rename_variable(self: Term_t, source_var: Var, target_var: Var) -&gt; Term_t:\n\"\"\"\n    Rename a variable in a term.\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n    Returns:\n        A term with `source_var` replaced by `target_var`.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList","title":"<code>TermList</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A collection of terms, or constraints.</p> <p>A TermList is semantically equivalent to a single term which is the conjunction of all terms contained in the TermList. TermList is an abstract class that must be extended to support a specific constraint formalism.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>class TermList(ABC):\n\"\"\"\n    A collection of terms, or constraints.\n    A TermList is semantically equivalent to a single term which is the\n    conjunction of all terms contained in the TermList. TermList is an abstract\n    class that must be extended to support a specific constraint formalism.\n    \"\"\"\ndef __init__(self, term_list: Optional[List] = None):\n\"\"\"\n        Class constructor.\n        Args:\n            term_list: A list of terms contained by TermList.\n        \"\"\"\nif term_list:\nself.terms = term_list.copy()\nelse:\nself.terms = []\n@property\ndef vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"The list of variables contained in this list of terms.\n        Returns:\n            List of variables referenced in the term.\n        \"\"\"\nvarlist: List[Var] = []\nfor t in self.terms:\nvarlist = list_union(varlist, t.vars)\nreturn varlist\ndef __str__(self) -&gt; str:\nif self.terms:\nres = [str(el) for el in self.terms]\nreturn \", \".join(res)\nreturn \"true\"\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError()\nreturn self.terms == other.terms\ndef get_terms_with_vars(self: TermList_t, variable_list: List[Var]) -&gt; TermList_t:\n\"\"\"\n        Returns the list of terms which contain any of the variables indicated.\n        Args:\n            variable_list: a list of variables being sought in current TermList.\n        Returns:\n            The list of terms which contain any of the variables indicated.\n        \"\"\"\nterms = []\nfor t in self.terms:\nif list_intersection(t.vars, variable_list):\nterms.append(t)\nreturn type(self)(terms)\ndef __and__(self: TermList_t, other: TermList_t) -&gt; TermList_t:\nreturn type(self)(list_intersection(self.copy().terms, other.copy().terms))\ndef __or__(self: TermList_t, other: TermList_t) -&gt; TermList_t:\nreturn type(self)(list_union(self.copy().terms, other.copy().terms))\ndef __sub__(self: TermList_t, other: TermList_t) -&gt; TermList_t:\nreturn type(self)(list_diff(self.copy().terms, other.copy().terms))\ndef __le__(self: TermList_t, other: TermList_t) -&gt; bool:\nreturn self.refines(other)\n@abstractmethod\ndef __hash__(self) -&gt; int:\n\"\"\"Hashing.\"\"\"\ndef copy(self: TermList_t) -&gt; TermList_t:\n\"\"\"\n        Makes copy of termlist.\n        Returns:\n            Copy of termlist.\n        \"\"\"\nreturn type(self)([term.copy() for term in self.terms])\ndef rename_variable(self: TermList_t, source_var: Var, target_var: Var) -&gt; TermList_t:\n\"\"\"\n        Rename a variable in a termlist.\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n        Returns:\n            A termlist with `source_var` replaced by `target_var`.\n        \"\"\"\nreturn type(self)([term.rename_variable(source_var, target_var) for term in self.terms])\n@abstractmethod\ndef contains_behavior(self, behavior: Any) -&gt; bool:\n\"\"\"\n        Tell whether TermList contains the given behavior.\n        Args:\n            behavior:\n                The behavior in question.\n        Returns:\n            True if the behavior satisfies the constraints; false otherwise.\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\n@abstractmethod\ndef elim_vars_by_refining(\nself: TermList_t, context: TermList_t, vars_to_elim: List[Var], simplify: bool, tactics_order: List[int]\n) -&gt; Tuple[TermList_t, TacticStatistics]:\n\"\"\"\n        Eliminate variables from termlist by refining it in a context.\n        Given a context $\\\\Gamma$, and the list of terms contained in self,\n        $s$, this routine identifies a TermList $x$ lacking variables\n        vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; x}{\\\\Gamma: \\\\;\n        s}$.\n        Args:\n            context:\n                List of context terms that will be used to refine the TermList.\n            vars_to_elim:\n                Variables to be eliminated.\n            simplify:\n                Whether to simplify self in the given context before variable elimination\n            tactics_order:\n                The order of the tactics to use when transforming each term in the list.\n        Returns:\n            A tuple consisting of (a) a list of terms not containing any variables in `vars_to_elim`\n                and which, in the context provided, imply the terms contained in the\n                calling termlist; and (b) the list of tuples, for each term processed, of the tactic used,\n                time spent, and tactic invocation count.\n        \"\"\"\n@abstractmethod\ndef elim_vars_by_relaxing(\nself: TermList_t, context: TermList_t, vars_to_elim: List[Var], simplify: bool, tactics_order: List[int]\n) -&gt; Tuple[TermList_t, TacticStatistics]:\n\"\"\"\n        Eliminate variables from termlist by relaxing it in a context\n        Given a context $\\\\Gamma$, and the list of terms contained in self,\n        $s$, this routine identifies a formula $x$ lacking variables\n        vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; s}{\\\\Gamma: \\\\;\n        x}$.\n        Args:\n            context:\n                List of context terms that will be used to abstract the TermList.\n            vars_to_elim:\n                Variables that cannot be present in TermList after relaxation.\n            simplify:\n                Whether to simplify self in the given context before variable elimination\n            tactics_order:\n                The order of the tactics to use when transforming each term in the list.\n        Returns:\n            A tuple consisting of (a) a list of terms not containing any variables in `vars_to_elim`\n                and which, in the context provided, are implied by the terms\n                contained in the calling termlist; and (b) the list of tuples, for each term processed,\n                of the tactic used, time spent, and tactic invocation count.\n        \"\"\"\n@abstractmethod\ndef simplify(self: TermList_t, context: Optional[TermList_t] = None) -&gt; TermList_t:\n\"\"\"Remove redundant terms in TermList.\n        Args:\n            context:\n                List of context terms that will be used to remove redundancies in\n                the TermList.\n        Returns:\n            Let $S$ be this TermList. Simplify will return\n                $S_T = S \\\\setminus T$, where $T \\\\subseteq S$ is a maximal subset such that\n                $\\\\frac{\\\\Gamma, S_T\\\\colon \\\\; \\\\top}{\\\\Gamma, S_T\\\\colon \\\\; \\\\wedge_{t \\\\in T} t}$.\n        \"\"\"\n@abstractmethod\ndef refines(self: TermList_t, other: TermList_t) -&gt; bool:\n\"\"\"\n        Tell whether the argument is a larger specification.\n        Args:\n            other:\n                TermList against which we are comparing self.\n        Returns:\n            self &lt;= other.\n        \"\"\"\n@abstractmethod\ndef is_empty(self) -&gt; bool:\n\"\"\"\n        Tell whether the termlist has no satisfying assignments.\n        Returns:\n            True if termlist constraints cannot be satisfied.\n        \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.vars","title":"<code>vars</code>  <code>property</code>","text":"<p>The list of variables contained in this list of terms.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>List of variables referenced in the term.</p>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.__hash__","title":"<code>__hash__()</code>  <code>abstractmethod</code>","text":"<p>Hashing.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef __hash__(self) -&gt; int:\n\"\"\"Hashing.\"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.__init__","title":"<code>__init__(term_list=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>term_list</code> <code>Optional[List]</code> <p>A list of terms contained by TermList.</p> <code>None</code> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def __init__(self, term_list: Optional[List] = None):\n\"\"\"\n    Class constructor.\n    Args:\n        term_list: A list of terms contained by TermList.\n    \"\"\"\nif term_list:\nself.terms = term_list.copy()\nelse:\nself.terms = []\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.contains_behavior","title":"<code>contains_behavior(behavior)</code>  <code>abstractmethod</code>","text":"<p>Tell whether TermList contains the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Any</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraints; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef contains_behavior(self, behavior: Any) -&gt; bool:\n\"\"\"\n    Tell whether TermList contains the given behavior.\n    Args:\n        behavior:\n            The behavior in question.\n    Returns:\n        True if the behavior satisfies the constraints; false otherwise.\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.copy","title":"<code>copy()</code>","text":"<p>Makes copy of termlist.</p> <p>Returns:</p> Type Description <code>TermList_t</code> <p>Copy of termlist.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def copy(self: TermList_t) -&gt; TermList_t:\n\"\"\"\n    Makes copy of termlist.\n    Returns:\n        Copy of termlist.\n    \"\"\"\nreturn type(self)([term.copy() for term in self.terms])\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.elim_vars_by_refining","title":"<code>elim_vars_by_refining(context, vars_to_elim, simplify, tactics_order)</code>  <code>abstractmethod</code>","text":"<p>Eliminate variables from termlist by refining it in a context.</p> <p>Given a context \\(\\Gamma\\), and the list of terms contained in self, \\(s\\), this routine identifies a TermList \\(x\\) lacking variables vars_to_elim such that \\(\\frac{\\Gamma\\colon \\; x}{\\Gamma: \\; s}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>TermList_t</code> <p>List of context terms that will be used to refine the TermList.</p> required <code>vars_to_elim</code> <code>List[Var]</code> <p>Variables to be eliminated.</p> required <code>simplify</code> <code>bool</code> <p>Whether to simplify self in the given context before variable elimination</p> required <code>tactics_order</code> <code>List[int]</code> <p>The order of the tactics to use when transforming each term in the list.</p> required <p>Returns:</p> Type Description <code>Tuple[TermList_t, TacticStatistics]</code> <p>A tuple consisting of (a) a list of terms not containing any variables in <code>vars_to_elim</code> and which, in the context provided, imply the terms contained in the calling termlist; and (b) the list of tuples, for each term processed, of the tactic used, time spent, and tactic invocation count.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef elim_vars_by_refining(\nself: TermList_t, context: TermList_t, vars_to_elim: List[Var], simplify: bool, tactics_order: List[int]\n) -&gt; Tuple[TermList_t, TacticStatistics]:\n\"\"\"\n    Eliminate variables from termlist by refining it in a context.\n    Given a context $\\\\Gamma$, and the list of terms contained in self,\n    $s$, this routine identifies a TermList $x$ lacking variables\n    vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; x}{\\\\Gamma: \\\\;\n    s}$.\n    Args:\n        context:\n            List of context terms that will be used to refine the TermList.\n        vars_to_elim:\n            Variables to be eliminated.\n        simplify:\n            Whether to simplify self in the given context before variable elimination\n        tactics_order:\n            The order of the tactics to use when transforming each term in the list.\n    Returns:\n        A tuple consisting of (a) a list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, imply the terms contained in the\n            calling termlist; and (b) the list of tuples, for each term processed, of the tactic used,\n            time spent, and tactic invocation count.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.elim_vars_by_relaxing","title":"<code>elim_vars_by_relaxing(context, vars_to_elim, simplify, tactics_order)</code>  <code>abstractmethod</code>","text":"<p>Eliminate variables from termlist by relaxing it in a context</p> <p>Given a context \\(\\Gamma\\), and the list of terms contained in self, \\(s\\), this routine identifies a formula \\(x\\) lacking variables vars_to_elim such that \\(\\frac{\\Gamma\\colon \\; s}{\\Gamma: \\; x}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>TermList_t</code> <p>List of context terms that will be used to abstract the TermList.</p> required <code>vars_to_elim</code> <code>List[Var]</code> <p>Variables that cannot be present in TermList after relaxation.</p> required <code>simplify</code> <code>bool</code> <p>Whether to simplify self in the given context before variable elimination</p> required <code>tactics_order</code> <code>List[int]</code> <p>The order of the tactics to use when transforming each term in the list.</p> required <p>Returns:</p> Type Description <code>Tuple[TermList_t, TacticStatistics]</code> <p>A tuple consisting of (a) a list of terms not containing any variables in <code>vars_to_elim</code> and which, in the context provided, are implied by the terms contained in the calling termlist; and (b) the list of tuples, for each term processed, of the tactic used, time spent, and tactic invocation count.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef elim_vars_by_relaxing(\nself: TermList_t, context: TermList_t, vars_to_elim: List[Var], simplify: bool, tactics_order: List[int]\n) -&gt; Tuple[TermList_t, TacticStatistics]:\n\"\"\"\n    Eliminate variables from termlist by relaxing it in a context\n    Given a context $\\\\Gamma$, and the list of terms contained in self,\n    $s$, this routine identifies a formula $x$ lacking variables\n    vars_to_elim such that $\\\\frac{\\\\Gamma\\\\colon \\\\; s}{\\\\Gamma: \\\\;\n    x}$.\n    Args:\n        context:\n            List of context terms that will be used to abstract the TermList.\n        vars_to_elim:\n            Variables that cannot be present in TermList after relaxation.\n        simplify:\n            Whether to simplify self in the given context before variable elimination\n        tactics_order:\n            The order of the tactics to use when transforming each term in the list.\n    Returns:\n        A tuple consisting of (a) a list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, are implied by the terms\n            contained in the calling termlist; and (b) the list of tuples, for each term processed,\n            of the tactic used, time spent, and tactic invocation count.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.get_terms_with_vars","title":"<code>get_terms_with_vars(variable_list)</code>","text":"<p>Returns the list of terms which contain any of the variables indicated.</p> <p>Parameters:</p> Name Type Description Default <code>variable_list</code> <code>List[Var]</code> <p>a list of variables being sought in current TermList.</p> required <p>Returns:</p> Type Description <code>TermList_t</code> <p>The list of terms which contain any of the variables indicated.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def get_terms_with_vars(self: TermList_t, variable_list: List[Var]) -&gt; TermList_t:\n\"\"\"\n    Returns the list of terms which contain any of the variables indicated.\n    Args:\n        variable_list: a list of variables being sought in current TermList.\n    Returns:\n        The list of terms which contain any of the variables indicated.\n    \"\"\"\nterms = []\nfor t in self.terms:\nif list_intersection(t.vars, variable_list):\nterms.append(t)\nreturn type(self)(terms)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.is_empty","title":"<code>is_empty()</code>  <code>abstractmethod</code>","text":"<p>Tell whether the termlist has no satisfying assignments.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if termlist constraints cannot be satisfied.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef is_empty(self) -&gt; bool:\n\"\"\"\n    Tell whether the termlist has no satisfying assignments.\n    Returns:\n        True if termlist constraints cannot be satisfied.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.refines","title":"<code>refines(other)</code>  <code>abstractmethod</code>","text":"<p>Tell whether the argument is a larger specification.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>TermList_t</code> <p>TermList against which we are comparing self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>self &lt;= other.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef refines(self: TermList_t, other: TermList_t) -&gt; bool:\n\"\"\"\n    Tell whether the argument is a larger specification.\n    Args:\n        other:\n            TermList against which we are comparing self.\n    Returns:\n        self &lt;= other.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a termlist.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>TermList_t</code> <p>A termlist with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def rename_variable(self: TermList_t, source_var: Var, target_var: Var) -&gt; TermList_t:\n\"\"\"\n    Rename a variable in a termlist.\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n    Returns:\n        A termlist with `source_var` replaced by `target_var`.\n    \"\"\"\nreturn type(self)([term.rename_variable(source_var, target_var) for term in self.terms])\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.TermList.simplify","title":"<code>simplify(context=None)</code>  <code>abstractmethod</code>","text":"<p>Remove redundant terms in TermList.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Optional[TermList_t]</code> <p>List of context terms that will be used to remove redundancies in the TermList.</p> <code>None</code> <p>Returns:</p> Type Description <code>TermList_t</code> <p>Let \\(S\\) be this TermList. Simplify will return \\(S_T = S \\setminus T\\), where \\(T \\subseteq S\\) is a maximal subset such that \\(\\frac{\\Gamma, S_T\\colon \\; \\top}{\\Gamma, S_T\\colon \\; \\wedge_{t \\in T} t}\\).</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>@abstractmethod\ndef simplify(self: TermList_t, context: Optional[TermList_t] = None) -&gt; TermList_t:\n\"\"\"Remove redundant terms in TermList.\n    Args:\n        context:\n            List of context terms that will be used to remove redundancies in\n            the TermList.\n    Returns:\n        Let $S$ be this TermList. Simplify will return\n            $S_T = S \\\\setminus T$, where $T \\\\subseteq S$ is a maximal subset such that\n            $\\\\frac{\\\\Gamma, S_T\\\\colon \\\\; \\\\top}{\\\\Gamma, S_T\\\\colon \\\\; \\\\wedge_{t \\\\in T} t}$.\n    \"\"\"\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Var","title":"<code>Var</code>","text":"<p>Variables used in system modeling.</p> <p>Variables allow us to name an entity for which we want to write constraints.</p> Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>class Var:\n\"\"\"\n    Variables used in system modeling.\n    Variables allow us to name an entity for which we want to write constraints.\n    \"\"\"\ndef __init__(self, varname: str):\n\"\"\"\n        Constructor for Var.\n        Args:\n            varname: The name of the variable.\n        \"\"\"\nself._name = str(varname)\n@property\ndef name(self) -&gt; str:\n\"\"\"The name of the variable.\n        Returns:\n            The name of the variable.\n        \"\"\"\nreturn self._name\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError()\nreturn self.name == other.name\ndef __str__(self) -&gt; str:\nreturn self.name\ndef __hash__(self) -&gt; int:\nreturn hash(self.name)\ndef __repr__(self) -&gt; str:\nreturn \"&lt;Var {0}&gt;\".format(self.name)\n</code></pre>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Var.name","title":"<code>name</code>  <code>property</code>","text":"<p>The name of the variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the variable.</p>"},{"location":"reference/pacti/iocontract/iocontract/#pacti.iocontract.iocontract.Var.__init__","title":"<code>__init__(varname)</code>","text":"<p>Constructor for Var.</p> <p>Parameters:</p> Name Type Description Default <code>varname</code> <code>str</code> <p>The name of the variable.</p> required Source code in <code>pacti\\src\\pacti\\iocontract\\iocontract.py</code> <pre><code>def __init__(self, varname: str):\n\"\"\"\n    Constructor for Var.\n    Args:\n        varname: The name of the variable.\n    \"\"\"\nself._name = str(varname)\n</code></pre>"},{"location":"reference/pacti/terms/","title":"Index","text":""},{"location":"reference/pacti/terms/polyhedra/","title":"Index","text":""},{"location":"reference/pacti/terms/polyhedra/polyhedra/","title":"Polyhedra","text":"<p>Support for linear inequality constraints, i.e., polyhedra.</p> <p>Module provides support for linear inequalities as constraints, i.e., the constraints are of the form \\(\\sum_{i} a_i x_i \\le c\\), where the \\(x_i\\) are variables and the \\(a_i\\) and \\(c\\) are constants.</p>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm","title":"<code>PolyhedralTerm</code>","text":"<p>               Bases: <code>Term</code></p> <p>Polyhedral terms are linear inequalities over a list of variables.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>class PolyhedralTerm(Term):\n\"\"\"Polyhedral terms are linear inequalities over a list of variables.\"\"\"\n# Constructor: get (i) a dictionary whose keys are variables and whose\n# values are the coefficients of those variables in the term, and (b) a\n# constant. The term is assumed to be in the form \\Sigma_i a_i v_i +\n# constant &lt;= 0\ndef __init__(self, variables: Dict[Var, numeric], constant: numeric):\n\"\"\"\n        Constructor for PolyhedralTerm.\n        Usage:\n            Polyhedral terms are initialized as follows:\n            ```\n                variables = {Var('x'):2, Var('y'):3}\n                constant = 3\n                term = PolyhedralTerm(variables, constant)\n            ```\n            `variables` is a dictionary whose keys are `Var` instances,\n            and `constant` is a number. Thus, our example represents the\n            expression $2x + 3y \\\\le 3$.\n        Args:\n            variables: A dictionary mapping Var keys to numeric values.\n            constant: A numeric value on the right of the inequality.\n        Raises:\n            ValueError: Unsupported argument type.\n        \"\"\"\nvariable_dict = {}\nfor key, value in variables.items():\nif value != 0:\nif isinstance(key, str):\nraise ValueError(\"Unsupported argument type\")\nelse:\nvariable_dict[key] = float(value)\nself.variables = variable_dict\nself.constant = float(constant)\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError()\nmatch = self.variables.keys() == other.variables.keys()\nif match:\nfor k, v in self.variables.items():\nmatch = match and np.equal(v, other.variables[k])\nreturn match and np.equal(self.constant, other.constant)\ndef __str__(self) -&gt; str:\nvarlist = list(self.variables.items())\nvarlist.sort(key=lambda x: str(x[0]))\nres = \" + \".join([str(coeff) + \"*\" + var.name for var, coeff in varlist])\nres += \" &lt;= \" + str(self.constant)\nreturn res\ndef __hash__(self) -&gt; int:\nreturn hash(str(self))\ndef __repr__(self) -&gt; str:\nreturn \"&lt;Term {0}&gt;\".format(self)\ndef __add__(self, other: object) -&gt; PolyhedralTerm:\nif not isinstance(other, type(self)):\nraise ValueError()\nvarlist = list_union(self.vars, other.vars)\nvariables = {}\nfor var in varlist:  # noqa: VNE002\nvariables[var] = self.get_coefficient(var) + other.get_coefficient(var)\nreturn PolyhedralTerm(variables, self.constant + other.constant)\ndef copy(self) -&gt; PolyhedralTerm:\n\"\"\"\n        Generates copy of polyhedral term.\n        Returns:\n            Copy of term.\n        \"\"\"\nreturn PolyhedralTerm(self.variables, self.constant)\ndef rename_variable(self, source_var: Var, target_var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n        Rename a variable in a term.\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n        Returns:\n            A term with `source_var` replaced by `target_var`.\n        \"\"\"\nnew_term = self.copy()\nif source_var in self.vars:\nif target_var not in self.vars:\nnew_term.variables[target_var] = 0\nnew_term.variables[target_var] += new_term.variables[source_var]\nnew_term = new_term.remove_variable(source_var)\nreturn new_term\n@property\ndef vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"\n        Variables appearing in term with a nonzero coefficient.\n        Example:\n            For the term $ax + by \\\\le c$ with variables $x$ and\n            $y$, this function returns the list $\\\\{x, y\\\\}$ if\n            $a$ and $b$ are nonzero.\n        Returns:\n            List of variables referenced in term.\n        \"\"\"\nvarlist = self.variables.keys()\nreturn list(varlist)\ndef contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n        Tell whether term contains a given variable.\n        Args:\n            var_to_seek: The variable that we are seeking in the current term.\n        Returns:\n            `True` if the syntax of the term refers to the given variable;\n                `False` otherwise.\n        \"\"\"\nreturn var_to_seek in self.vars\ndef get_coefficient(self, var: Var) -&gt; numeric:  # noqa: VNE002\n\"\"\"\n        Output the coefficient multiplying the given variable in the term.\n        Args:\n            var: The variable whose coefficient we are seeking.\n        Returns:\n            The coefficient corresponding to variable in the term.\n        \"\"\"\nif self.contains_var(var):\nreturn self.variables[var]\nreturn 0\ndef get_polarity(self, var: Var, polarity: bool = True) -&gt; bool:  # noqa: VNE002\n\"\"\"\n        Check if variable matches given polarity\n        The polarity of a variable in a term is defined as the polarity of the\n        coefficient that multiplies it in a term, e.g., the variables $x$\n        and $y$ in the term $-2x + y \\\\le 3$ have negative and\n        positive polarities respectively.\n        Args:\n            var: The variable whose polarity in the term we are seeking.\n            polarity: The polarity that we are comparing against the variable's polarity.\n        Returns:\n            `True` if the variable's polarity matches `polarity` and\n                `False` otherwise. If the variable's coefficient in the term\n                is zero, return `True`.\n        \"\"\"\nif polarity:\nreturn self.variables[var] &gt;= 0\nreturn self.variables[var] &lt;= 0\ndef get_sign(self, var: Var) -&gt; int:  # noqa: VNE002\n\"\"\"\n        Get the sign of the variable in term.\n        The sign of a variable in a term is defined as the sign of the\n        coefficient that multiplies it in a term, e.g., the variables $x$\n        and $y$ in the term $-2x + y \\\\le 3$ have $-1$ and\n        $+1$ polarities respectively. $0$ has $+1$ sign.\n        Args:\n            var: The variable whose polarity in the term we are seeking.\n        Returns:\n            The sign of the variable in the term.\n        \"\"\"\nif self.get_polarity(var=var, polarity=True):\nreturn 1\nreturn -1\ndef get_matching_vars(self, variable_polarity: Dict[Var, bool]) -&gt; List[Var]:\n\"\"\"\n        Get list of variables whose polarities match the polarities requested.\n        Example:\n        ```\n            x = Var('x')\n            y = Var('y')\n            z = Var('z')\n            variables = {x:-2, y:3}\n            constant  = 4\n            term = PolyhedralTerm(variables, constant)\n            polarities = {y:True}\n            term.get_matching_vars(polarities)\n        ```\n        The last call returns `{y, z}` because the variable y matches the\n        requested polarity in the term, and the variable z has a zero\n        coefficient.\n        Args:\n            variable_polarity: A dictionary mapping Var instances to Boolean\n                values indicating the polarity of the given variable.\n        Returns:\n            If all variables in the term match the polarities specified in the\n                argument, the routine returns the matching variables.  Otherwise,\n                it returns an empty list.\n        \"\"\"\nvariable_list = []\nfor var in variable_polarity.keys():  # noqa: VNE002\nif self.contains_var(var):\nif (self.get_polarity(var=var, polarity=True) == variable_polarity[var]) or (  # noqa: WPS337\nself.get_coefficient(var) == 0\n):\nvariable_list.append(var)\nelse:\nvariable_list = []\nbreak\nreturn variable_list\ndef remove_variable(self, var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n        Eliminates a variable from a term.\n        Args:\n            var: variable to be eliminated.\n        Returns:\n            A new term with the variable eliminated.\n        \"\"\"\nif self.contains_var(var):\nthat = self.copy()\nthat.variables.pop(var)\nreturn that\nreturn self.copy()\ndef multiply(self, factor: numeric) -&gt; PolyhedralTerm:\n\"\"\"Multiplies a term by a constant factor.\n        For example, multiplying the term $2x + 3y \\\\le 4$ by the factor 2\n        yields $4x + 6y \\\\le 8$.\n        Args:\n            factor: element by which the term is multiplied.\n        Returns:\n            A new term which is the result of the given term multiplied by\n            `factor`.\n        \"\"\"\nvariables = {key: factor * val for key, val in self.variables.items()}\nreturn PolyhedralTerm(variables, factor * self.constant)\ndef substitute_variable(self, var: Var, subst_with_term: PolyhedralTerm) -&gt; PolyhedralTerm:  # noqa: VNE002\n\"\"\"\n        Substitutes a specified variable in a term with a given term.\n        Example:\n            In the term $2x - y \\\\le 6$, substituting y by the term\n            $x + z \\\\le 5$ yields $x - z \\\\le 1$. Observe that the\n            substituting term is understood as an equality.\n        Args:\n            var: The term variable to be substituted.\n            subst_with_term: The term used to replace var.\n        Returns:\n            A new term in which the variable is substituted with the given term\n                understood as an equality.\n        \"\"\"\nif self.contains_var(var):\nlogging.debug(f\"Substituting var {var} in term {self} with {subst_with_term}\")\nterm = subst_with_term.multiply(self.get_coefficient(var))\nthat = self.remove_variable(var)\nlogging.debug(that)\nreturn that + term\nreturn self.copy()\ndef isolate_variable(self, var_to_isolate: Var) -&gt; PolyhedralTerm:\n\"\"\"\n        Isolate a variable in a term.\n        Example:\n            In the term $-2x + y \\\\le 6$ understood as equality, isolating the\n            variable $x$ yields $x = 0.5 y - 3$, which in PolyhedralTerm\n            notation we express as $0.5 y &lt;= -3$.\n        Args:\n            var_to_isolate: The variable to be isolated.\n        Returns:\n            A new term which corresponds to the isolation of the indicated\n                variable.\n        Raises:\n            ValueError: the indicated variable is not contained in the term.\n        \"\"\"\nif var_to_isolate not in self.vars:\nraise ValueError(\"Variable %s is not a term variable\" % (var_to_isolate))\nreturn PolyhedralTerm(\nvariables={\nk: -v / self.get_coefficient(var_to_isolate) for k, v in self.variables.items() if k != var_to_isolate\n},\nconstant=-self.constant / self.get_coefficient(var_to_isolate),\n)\n@staticmethod\ndef to_symbolic(term: PolyhedralTerm) -&gt; Any:\n\"\"\"\n        Translates the variable terms of a PolyhedralTerm into a sympy expression.\n        Example:\n            The code\n            ```\n                x = Var('x') y = Var('y') variables = {x:-2, y:3} constant  = 4\n                term = PolyhedralTerm(variables, constant) expression =\n                PolyhedralTerm.to_symbolic(term)\n            ```\n            yields the expression $-2x + 3y - 4$.\n        Args:\n            term:\n                The term whose coefficients and variables are to be translated\n                to sympy's data structure.\n        Returns:\n            Sympy expression corresponding to PolyhedralTerm.\n        \"\"\"\nex = -term.constant\nfor var in term.vars:  # noqa: VNE002\nsv = sympy.symbols(var.name)\nex += sv * term.get_coefficient(var)\nreturn ex\n@staticmethod\ndef to_term(expression: sympy.core.expr.Expr) -&gt; PolyhedralTerm:\n\"\"\"\n        Translates a sympy expression into a PolyhedralTerm.\n        Example:\n            The expression $2x + 3y - 1$ is translated into\n            `PolyhedralTerm(variables={x:2, y:3}, constant=1)`.\n        Args:\n            expression: The symbolic expression to be translated.\n        Returns:\n            PolyhedralTerm corresponding to sympy expression.\n        \"\"\"\nexpression_coefficients: dict = expression.as_coefficients_dict()\nlogging.debug(expression_coefficients)\nkeys = list(expression_coefficients.keys())\nvariable_dict = {}\nconstant = 0\nfor key in keys:\nlogging.debug(type(key))\nif isinstance(key, (str, sympy.core.symbol.Symbol)):\nvar = Var(str(key))  # noqa: VNE002\nvariable_dict[var] = expression_coefficients[key]\nelse:\nconstant = constant - expression_coefficients[key] * key\nreturn PolyhedralTerm(variable_dict, constant)\n@staticmethod\ndef term_to_polytope(term: PolyhedralTerm, variable_list: List[Var]) -&gt; Tuple[List[numeric], numeric]:\n\"\"\"\n        Transform a term into a vector according to the given order.\n        Example:\n            The term $3x + 5y -2z \\\\le 7$ with `variable_list = [y,\n            x, w, z]` yields the tuple `[5, 3, 0, -2], 7`.\n        Args:\n            term: The term to be transformed.\n            variable_list:\n                A list of variables indicating the order of appearance of\n                variable coefficients.\n        Returns:\n            A tuple consisting of (i) the ordered list of coefficients and (ii)\n                the term's constant.\n        \"\"\"\ncoeffs = []\nfor var in variable_list:  # noqa: VNE002\ncoeffs.append(term.get_coefficient(var))\nreturn coeffs, term.constant\n@staticmethod\ndef polytope_to_term(poly: List[numeric], const: numeric, variables: List[Var]) -&gt; PolyhedralTerm:\n\"\"\"\n        Transform a list of coefficients and variables into a PolyhedralTerm.\n        Args:\n            poly: An ordered list of coefficients.\n            const: The term's coefficient.\n            variables: The variables corresponding to the list of coefficients.\n        Returns:\n            A PolyhedralTerm corresponding to the provided data.\n        \"\"\"\nassert len(poly) == len(variables)\nvariable_dict = {}\nfor i, var in enumerate(variables):  # noqa: VNE002\nvariable_dict[var] = poly[i]\nreturn PolyhedralTerm(variable_dict, const)\n@staticmethod\ndef solve_for_variables(context: PolyhedralTermList, vars_to_elim: List[Var]) -&gt; dict:\n\"\"\"\n        Interpret termlist as equality and solve system of equations.\n        Args:\n            context:\n                The list of terms to be solved. Each term will be interpreted as\n                an equality.\n            vars_to_elim:\n                The list of variables whose solutions will be sought.\n        Assumptions: the number of equations matches the number of vars_to_elim\n        contained in the terms.\n        Returns:\n            A dictionary mapping variables to their solutions. The solutions are\n                expressed as PolyhedralTerm instances.\n        \"\"\"\nlogging.debug(\"GetVals: %s Vars: %s\", context, vars_to_elim)\nvars_to_solve = list_intersection(context.vars, vars_to_elim)\nassert len(context.terms) == len(vars_to_solve)\nexprs = [PolyhedralTerm.to_symbolic(term) for term in context.terms]\nlogging.debug(\"Solving %s\", exprs)\nvars_to_solve_symb = [sympy.symbols(var.name) for var in vars_to_solve]\nsols = sympy.solve(exprs, *vars_to_solve_symb)\nlogging.debug(sols)\nif len(sols) &gt; 0:\nreturn {Var(str(key)): PolyhedralTerm.to_term(sols[key]) for key in sols.keys()}\nreturn {}\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.vars","title":"<code>vars</code>  <code>property</code>","text":"<p>Variables appearing in term with a nonzero coefficient.</p> Example <p>For the term \\(ax + by \\le c\\) with variables \\(x\\) and \\(y\\), this function returns the list \\(\\{x, y\\}\\) if \\(a\\) and \\(b\\) are nonzero.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>List of variables referenced in term.</p>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.__init__","title":"<code>__init__(variables, constant)</code>","text":"<p>Constructor for PolyhedralTerm.</p> Usage <p>Polyhedral terms are initialized as follows:</p> <pre><code>    variables = {Var('x'):2, Var('y'):3}\n    constant = 3\n    term = PolyhedralTerm(variables, constant)\n</code></pre> <p><code>variables</code> is a dictionary whose keys are <code>Var</code> instances, and <code>constant</code> is a number. Thus, our example represents the expression \\(2x + 3y \\le 3\\).</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>Dict[Var, numeric]</code> <p>A dictionary mapping Var keys to numeric values.</p> required <code>constant</code> <code>numeric</code> <p>A numeric value on the right of the inequality.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Unsupported argument type.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def __init__(self, variables: Dict[Var, numeric], constant: numeric):\n\"\"\"\n    Constructor for PolyhedralTerm.\n    Usage:\n        Polyhedral terms are initialized as follows:\n        ```\n            variables = {Var('x'):2, Var('y'):3}\n            constant = 3\n            term = PolyhedralTerm(variables, constant)\n        ```\n        `variables` is a dictionary whose keys are `Var` instances,\n        and `constant` is a number. Thus, our example represents the\n        expression $2x + 3y \\\\le 3$.\n    Args:\n        variables: A dictionary mapping Var keys to numeric values.\n        constant: A numeric value on the right of the inequality.\n    Raises:\n        ValueError: Unsupported argument type.\n    \"\"\"\nvariable_dict = {}\nfor key, value in variables.items():\nif value != 0:\nif isinstance(key, str):\nraise ValueError(\"Unsupported argument type\")\nelse:\nvariable_dict[key] = float(value)\nself.variables = variable_dict\nself.constant = float(constant)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.contains_var","title":"<code>contains_var(var_to_seek)</code>","text":"<p>Tell whether term contains a given variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_to_seek</code> <code>Var</code> <p>The variable that we are seeking in the current term.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the syntax of the term refers to the given variable; <code>False</code> otherwise.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n    Tell whether term contains a given variable.\n    Args:\n        var_to_seek: The variable that we are seeking in the current term.\n    Returns:\n        `True` if the syntax of the term refers to the given variable;\n            `False` otherwise.\n    \"\"\"\nreturn var_to_seek in self.vars\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.copy","title":"<code>copy()</code>","text":"<p>Generates copy of polyhedral term.</p> <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>Copy of term.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def copy(self) -&gt; PolyhedralTerm:\n\"\"\"\n    Generates copy of polyhedral term.\n    Returns:\n        Copy of term.\n    \"\"\"\nreturn PolyhedralTerm(self.variables, self.constant)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_coefficient","title":"<code>get_coefficient(var)</code>","text":"<p>Output the coefficient multiplying the given variable in the term.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The variable whose coefficient we are seeking.</p> required <p>Returns:</p> Type Description <code>numeric</code> <p>The coefficient corresponding to variable in the term.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_coefficient(self, var: Var) -&gt; numeric:  # noqa: VNE002\n\"\"\"\n    Output the coefficient multiplying the given variable in the term.\n    Args:\n        var: The variable whose coefficient we are seeking.\n    Returns:\n        The coefficient corresponding to variable in the term.\n    \"\"\"\nif self.contains_var(var):\nreturn self.variables[var]\nreturn 0\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_matching_vars","title":"<code>get_matching_vars(variable_polarity)</code>","text":"<p>Get list of variables whose polarities match the polarities requested.</p> <p>Example:</p> <pre><code>    x = Var('x')\n    y = Var('y')\n    z = Var('z')\n    variables = {x:-2, y:3}\n    constant  = 4\n    term = PolyhedralTerm(variables, constant)\n    polarities = {y:True}\n    term.get_matching_vars(polarities)\n</code></pre> <p>The last call returns <code>{y, z}</code> because the variable y matches the requested polarity in the term, and the variable z has a zero coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>variable_polarity</code> <code>Dict[Var, bool]</code> <p>A dictionary mapping Var instances to Boolean values indicating the polarity of the given variable.</p> required <p>Returns:</p> Type Description <code>List[Var]</code> <p>If all variables in the term match the polarities specified in the argument, the routine returns the matching variables.  Otherwise, it returns an empty list.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_matching_vars(self, variable_polarity: Dict[Var, bool]) -&gt; List[Var]:\n\"\"\"\n    Get list of variables whose polarities match the polarities requested.\n    Example:\n    ```\n        x = Var('x')\n        y = Var('y')\n        z = Var('z')\n        variables = {x:-2, y:3}\n        constant  = 4\n        term = PolyhedralTerm(variables, constant)\n        polarities = {y:True}\n        term.get_matching_vars(polarities)\n    ```\n    The last call returns `{y, z}` because the variable y matches the\n    requested polarity in the term, and the variable z has a zero\n    coefficient.\n    Args:\n        variable_polarity: A dictionary mapping Var instances to Boolean\n            values indicating the polarity of the given variable.\n    Returns:\n        If all variables in the term match the polarities specified in the\n            argument, the routine returns the matching variables.  Otherwise,\n            it returns an empty list.\n    \"\"\"\nvariable_list = []\nfor var in variable_polarity.keys():  # noqa: VNE002\nif self.contains_var(var):\nif (self.get_polarity(var=var, polarity=True) == variable_polarity[var]) or (  # noqa: WPS337\nself.get_coefficient(var) == 0\n):\nvariable_list.append(var)\nelse:\nvariable_list = []\nbreak\nreturn variable_list\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_polarity","title":"<code>get_polarity(var, polarity=True)</code>","text":"<p>Check if variable matches given polarity</p> <p>The polarity of a variable in a term is defined as the polarity of the coefficient that multiplies it in a term, e.g., the variables \\(x\\) and \\(y\\) in the term \\(-2x + y \\le 3\\) have negative and positive polarities respectively.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The variable whose polarity in the term we are seeking.</p> required <code>polarity</code> <code>bool</code> <p>The polarity that we are comparing against the variable's polarity.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the variable's polarity matches <code>polarity</code> and <code>False</code> otherwise. If the variable's coefficient in the term is zero, return <code>True</code>.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_polarity(self, var: Var, polarity: bool = True) -&gt; bool:  # noqa: VNE002\n\"\"\"\n    Check if variable matches given polarity\n    The polarity of a variable in a term is defined as the polarity of the\n    coefficient that multiplies it in a term, e.g., the variables $x$\n    and $y$ in the term $-2x + y \\\\le 3$ have negative and\n    positive polarities respectively.\n    Args:\n        var: The variable whose polarity in the term we are seeking.\n        polarity: The polarity that we are comparing against the variable's polarity.\n    Returns:\n        `True` if the variable's polarity matches `polarity` and\n            `False` otherwise. If the variable's coefficient in the term\n            is zero, return `True`.\n    \"\"\"\nif polarity:\nreturn self.variables[var] &gt;= 0\nreturn self.variables[var] &lt;= 0\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.get_sign","title":"<code>get_sign(var)</code>","text":"<p>Get the sign of the variable in term.</p> <p>The sign of a variable in a term is defined as the sign of the coefficient that multiplies it in a term, e.g., the variables \\(x\\) and \\(y\\) in the term \\(-2x + y \\le 3\\) have \\(-1\\) and \\(+1\\) polarities respectively. \\(0\\) has \\(+1\\) sign.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The variable whose polarity in the term we are seeking.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sign of the variable in the term.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def get_sign(self, var: Var) -&gt; int:  # noqa: VNE002\n\"\"\"\n    Get the sign of the variable in term.\n    The sign of a variable in a term is defined as the sign of the\n    coefficient that multiplies it in a term, e.g., the variables $x$\n    and $y$ in the term $-2x + y \\\\le 3$ have $-1$ and\n    $+1$ polarities respectively. $0$ has $+1$ sign.\n    Args:\n        var: The variable whose polarity in the term we are seeking.\n    Returns:\n        The sign of the variable in the term.\n    \"\"\"\nif self.get_polarity(var=var, polarity=True):\nreturn 1\nreturn -1\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.isolate_variable","title":"<code>isolate_variable(var_to_isolate)</code>","text":"<p>Isolate a variable in a term.</p> Example <p>In the term \\(-2x + y \\le 6\\) understood as equality, isolating the variable \\(x\\) yields \\(x = 0.5 y - 3\\), which in PolyhedralTerm notation we express as \\(0.5 y &lt;= -3\\).</p> <p>Parameters:</p> Name Type Description Default <code>var_to_isolate</code> <code>Var</code> <p>The variable to be isolated.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term which corresponds to the isolation of the indicated variable.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>the indicated variable is not contained in the term.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def isolate_variable(self, var_to_isolate: Var) -&gt; PolyhedralTerm:\n\"\"\"\n    Isolate a variable in a term.\n    Example:\n        In the term $-2x + y \\\\le 6$ understood as equality, isolating the\n        variable $x$ yields $x = 0.5 y - 3$, which in PolyhedralTerm\n        notation we express as $0.5 y &lt;= -3$.\n    Args:\n        var_to_isolate: The variable to be isolated.\n    Returns:\n        A new term which corresponds to the isolation of the indicated\n            variable.\n    Raises:\n        ValueError: the indicated variable is not contained in the term.\n    \"\"\"\nif var_to_isolate not in self.vars:\nraise ValueError(\"Variable %s is not a term variable\" % (var_to_isolate))\nreturn PolyhedralTerm(\nvariables={\nk: -v / self.get_coefficient(var_to_isolate) for k, v in self.variables.items() if k != var_to_isolate\n},\nconstant=-self.constant / self.get_coefficient(var_to_isolate),\n)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.multiply","title":"<code>multiply(factor)</code>","text":"<p>Multiplies a term by a constant factor.</p> <p>For example, multiplying the term \\(2x + 3y \\le 4\\) by the factor 2 yields \\(4x + 6y \\le 8\\).</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>numeric</code> <p>element by which the term is multiplied.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term which is the result of the given term multiplied by</p> <code>PolyhedralTerm</code> <p><code>factor</code>.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def multiply(self, factor: numeric) -&gt; PolyhedralTerm:\n\"\"\"Multiplies a term by a constant factor.\n    For example, multiplying the term $2x + 3y \\\\le 4$ by the factor 2\n    yields $4x + 6y \\\\le 8$.\n    Args:\n        factor: element by which the term is multiplied.\n    Returns:\n        A new term which is the result of the given term multiplied by\n        `factor`.\n    \"\"\"\nvariables = {key: factor * val for key, val in self.variables.items()}\nreturn PolyhedralTerm(variables, factor * self.constant)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.polytope_to_term","title":"<code>polytope_to_term(poly, const, variables)</code>  <code>staticmethod</code>","text":"<p>Transform a list of coefficients and variables into a PolyhedralTerm.</p> <p>Parameters:</p> Name Type Description Default <code>poly</code> <code>List[numeric]</code> <p>An ordered list of coefficients.</p> required <code>const</code> <code>numeric</code> <p>The term's coefficient.</p> required <code>variables</code> <code>List[Var]</code> <p>The variables corresponding to the list of coefficients.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A PolyhedralTerm corresponding to the provided data.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef polytope_to_term(poly: List[numeric], const: numeric, variables: List[Var]) -&gt; PolyhedralTerm:\n\"\"\"\n    Transform a list of coefficients and variables into a PolyhedralTerm.\n    Args:\n        poly: An ordered list of coefficients.\n        const: The term's coefficient.\n        variables: The variables corresponding to the list of coefficients.\n    Returns:\n        A PolyhedralTerm corresponding to the provided data.\n    \"\"\"\nassert len(poly) == len(variables)\nvariable_dict = {}\nfor i, var in enumerate(variables):  # noqa: VNE002\nvariable_dict[var] = poly[i]\nreturn PolyhedralTerm(variable_dict, const)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.remove_variable","title":"<code>remove_variable(var)</code>","text":"<p>Eliminates a variable from a term.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>variable to be eliminated.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term with the variable eliminated.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def remove_variable(self, var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n    Eliminates a variable from a term.\n    Args:\n        var: variable to be eliminated.\n    Returns:\n        A new term with the variable eliminated.\n    \"\"\"\nif self.contains_var(var):\nthat = self.copy()\nthat.variables.pop(var)\nreturn that\nreturn self.copy()\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a term.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A term with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def rename_variable(self, source_var: Var, target_var: Var) -&gt; PolyhedralTerm:\n\"\"\"\n    Rename a variable in a term.\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n    Returns:\n        A term with `source_var` replaced by `target_var`.\n    \"\"\"\nnew_term = self.copy()\nif source_var in self.vars:\nif target_var not in self.vars:\nnew_term.variables[target_var] = 0\nnew_term.variables[target_var] += new_term.variables[source_var]\nnew_term = new_term.remove_variable(source_var)\nreturn new_term\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.solve_for_variables","title":"<code>solve_for_variables(context, vars_to_elim)</code>  <code>staticmethod</code>","text":"<p>Interpret termlist as equality and solve system of equations.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PolyhedralTermList</code> <p>The list of terms to be solved. Each term will be interpreted as an equality.</p> required <code>vars_to_elim</code> <code>List[Var]</code> <p>The list of variables whose solutions will be sought.</p> required <p>Assumptions: the number of equations matches the number of vars_to_elim contained in the terms.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary mapping variables to their solutions. The solutions are expressed as PolyhedralTerm instances.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef solve_for_variables(context: PolyhedralTermList, vars_to_elim: List[Var]) -&gt; dict:\n\"\"\"\n    Interpret termlist as equality and solve system of equations.\n    Args:\n        context:\n            The list of terms to be solved. Each term will be interpreted as\n            an equality.\n        vars_to_elim:\n            The list of variables whose solutions will be sought.\n    Assumptions: the number of equations matches the number of vars_to_elim\n    contained in the terms.\n    Returns:\n        A dictionary mapping variables to their solutions. The solutions are\n            expressed as PolyhedralTerm instances.\n    \"\"\"\nlogging.debug(\"GetVals: %s Vars: %s\", context, vars_to_elim)\nvars_to_solve = list_intersection(context.vars, vars_to_elim)\nassert len(context.terms) == len(vars_to_solve)\nexprs = [PolyhedralTerm.to_symbolic(term) for term in context.terms]\nlogging.debug(\"Solving %s\", exprs)\nvars_to_solve_symb = [sympy.symbols(var.name) for var in vars_to_solve]\nsols = sympy.solve(exprs, *vars_to_solve_symb)\nlogging.debug(sols)\nif len(sols) &gt; 0:\nreturn {Var(str(key)): PolyhedralTerm.to_term(sols[key]) for key in sols.keys()}\nreturn {}\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.substitute_variable","title":"<code>substitute_variable(var, subst_with_term)</code>","text":"<p>Substitutes a specified variable in a term with a given term.</p> Example <p>In the term \\(2x - y \\le 6\\), substituting y by the term \\(x + z \\le 5\\) yields \\(x - z \\le 1\\). Observe that the substituting term is understood as an equality.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Var</code> <p>The term variable to be substituted.</p> required <code>subst_with_term</code> <code>PolyhedralTerm</code> <p>The term used to replace var.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A new term in which the variable is substituted with the given term understood as an equality.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def substitute_variable(self, var: Var, subst_with_term: PolyhedralTerm) -&gt; PolyhedralTerm:  # noqa: VNE002\n\"\"\"\n    Substitutes a specified variable in a term with a given term.\n    Example:\n        In the term $2x - y \\\\le 6$, substituting y by the term\n        $x + z \\\\le 5$ yields $x - z \\\\le 1$. Observe that the\n        substituting term is understood as an equality.\n    Args:\n        var: The term variable to be substituted.\n        subst_with_term: The term used to replace var.\n    Returns:\n        A new term in which the variable is substituted with the given term\n            understood as an equality.\n    \"\"\"\nif self.contains_var(var):\nlogging.debug(f\"Substituting var {var} in term {self} with {subst_with_term}\")\nterm = subst_with_term.multiply(self.get_coefficient(var))\nthat = self.remove_variable(var)\nlogging.debug(that)\nreturn that + term\nreturn self.copy()\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.term_to_polytope","title":"<code>term_to_polytope(term, variable_list)</code>  <code>staticmethod</code>","text":"<p>Transform a term into a vector according to the given order.</p> Example <p>The term \\(3x + 5y -2z \\le 7\\) with <code>variable_list = [y, x, w, z]</code> yields the tuple <code>[5, 3, 0, -2], 7</code>.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>PolyhedralTerm</code> <p>The term to be transformed.</p> required <code>variable_list</code> <code>List[Var]</code> <p>A list of variables indicating the order of appearance of variable coefficients.</p> required <p>Returns:</p> Type Description <code>Tuple[List[numeric], numeric]</code> <p>A tuple consisting of (i) the ordered list of coefficients and (ii) the term's constant.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef term_to_polytope(term: PolyhedralTerm, variable_list: List[Var]) -&gt; Tuple[List[numeric], numeric]:\n\"\"\"\n    Transform a term into a vector according to the given order.\n    Example:\n        The term $3x + 5y -2z \\\\le 7$ with `variable_list = [y,\n        x, w, z]` yields the tuple `[5, 3, 0, -2], 7`.\n    Args:\n        term: The term to be transformed.\n        variable_list:\n            A list of variables indicating the order of appearance of\n            variable coefficients.\n    Returns:\n        A tuple consisting of (i) the ordered list of coefficients and (ii)\n            the term's constant.\n    \"\"\"\ncoeffs = []\nfor var in variable_list:  # noqa: VNE002\ncoeffs.append(term.get_coefficient(var))\nreturn coeffs, term.constant\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.to_symbolic","title":"<code>to_symbolic(term)</code>  <code>staticmethod</code>","text":"<p>Translates the variable terms of a PolyhedralTerm into a sympy expression.</p> Example <p>The code</p> <pre><code>    x = Var('x') y = Var('y') variables = {x:-2, y:3} constant  = 4\n    term = PolyhedralTerm(variables, constant) expression =\n    PolyhedralTerm.to_symbolic(term)\n</code></pre> <p>yields the expression \\(-2x + 3y - 4\\).</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>PolyhedralTerm</code> <p>The term whose coefficients and variables are to be translated to sympy's data structure.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Sympy expression corresponding to PolyhedralTerm.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef to_symbolic(term: PolyhedralTerm) -&gt; Any:\n\"\"\"\n    Translates the variable terms of a PolyhedralTerm into a sympy expression.\n    Example:\n        The code\n        ```\n            x = Var('x') y = Var('y') variables = {x:-2, y:3} constant  = 4\n            term = PolyhedralTerm(variables, constant) expression =\n            PolyhedralTerm.to_symbolic(term)\n        ```\n        yields the expression $-2x + 3y - 4$.\n    Args:\n        term:\n            The term whose coefficients and variables are to be translated\n            to sympy's data structure.\n    Returns:\n        Sympy expression corresponding to PolyhedralTerm.\n    \"\"\"\nex = -term.constant\nfor var in term.vars:  # noqa: VNE002\nsv = sympy.symbols(var.name)\nex += sv * term.get_coefficient(var)\nreturn ex\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTerm.to_term","title":"<code>to_term(expression)</code>  <code>staticmethod</code>","text":"<p>Translates a sympy expression into a PolyhedralTerm.</p> Example <p>The expression \\(2x + 3y - 1\\) is translated into <code>PolyhedralTerm(variables={x:2, y:3}, constant=1)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>Expr</code> <p>The symbolic expression to be translated.</p> required <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>PolyhedralTerm corresponding to sympy expression.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef to_term(expression: sympy.core.expr.Expr) -&gt; PolyhedralTerm:\n\"\"\"\n    Translates a sympy expression into a PolyhedralTerm.\n    Example:\n        The expression $2x + 3y - 1$ is translated into\n        `PolyhedralTerm(variables={x:2, y:3}, constant=1)`.\n    Args:\n        expression: The symbolic expression to be translated.\n    Returns:\n        PolyhedralTerm corresponding to sympy expression.\n    \"\"\"\nexpression_coefficients: dict = expression.as_coefficients_dict()\nlogging.debug(expression_coefficients)\nkeys = list(expression_coefficients.keys())\nvariable_dict = {}\nconstant = 0\nfor key in keys:\nlogging.debug(type(key))\nif isinstance(key, (str, sympy.core.symbol.Symbol)):\nvar = Var(str(key))  # noqa: VNE002\nvariable_dict[var] = expression_coefficients[key]\nelse:\nconstant = constant - expression_coefficients[key] * key\nreturn PolyhedralTerm(variable_dict, constant)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList","title":"<code>PolyhedralTermList</code>","text":"<p>               Bases: <code>TermList</code></p> <p>A TermList of PolyhedralTerm instances.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>class PolyhedralTermList(TermList):  # noqa: WPS338\n\"\"\"A TermList of PolyhedralTerm instances.\"\"\"\ndef __init__(self, terms: Optional[List[PolyhedralTerm]] = None):\n\"\"\"\n        Constructor for PolyhedralTermList.\n        Usage:\n            PolyhedralTermList objects are initialized as follows:\n            ```\n                term1 = PolyhedralTerm({Var('x'):2, Var('y'):3}, 3)\n                term2 = PolyhedralTerm({Var('x'):-1, Var('y'):2}, 4)\n                pt_list = [term1, term2]\n                termlist = PolyhedralTermList(pt_list)\n            ```\n            Our example represents the constraints $\\\\{2x + 3y \\\\le 3, -x + 2y \\\\le 4\\\\}$.\n        Args:\n            terms: A list of PolyhedralTerm objects.\n        Raises:\n            ValueError: incorrect argument type provided.\n        \"\"\"\nif terms is None:\nself.terms = []\nelif all(isinstance(t, PolyhedralTerm) for t in terms):\nself.terms = terms.copy()\nelse:\nraise ValueError(\"PolyhedralTermList constructor argument must be a list of PolyhedralTerms.\")\ndef __str__(self) -&gt; str:\nres = \"[\\n  \"\nres += \"\\n  \".join(self.to_str_list())\nres += \"\\n]\"\nreturn res\ndef __hash__(self) -&gt; int:\nreturn hash(tuple(self.terms))\ndef to_str_list(self) -&gt; List[str]:\n\"\"\"\n        Convert termlist into a list of strings.\n        Returns:\n            A list of strings corresponding to the terms of the termlist.\n        \"\"\"\nstr_list = []\nts = self.terms.copy()\nwhile ts:\ns, rest = serializer.polyhedral_term_list_to_strings(ts)\nstr_list.append(s)\nts = rest\nreturn str_list\ndef evaluate(self, var_values: Dict[Var, numeric]) -&gt; PolyhedralTermList:  # noqa: WPS231\n\"\"\"\n        Replace variables in termlist with given values.\n        Args:\n            var_values:\n                The values that variables will take.\n        Returns:\n            A new PolyhedralTermList in which the variables have been\n                substituted with the values provided.\n        Raises:\n            ValueError: constraints are unsatisfiable under these valuation of variables.\n        \"\"\"\nnew_list = []\nfor term in self.terms:\nnew_term = term.copy()\nfor var, val in var_values.items():  # noqa: VNE002\nnew_term = new_term.substitute_variable(\nvar=var, subst_with_term=PolyhedralTerm(variables={}, constant=-val)\n)\n# we may have eliminated all variables after substitution\nif not new_term.vars:\nif new_term.constant &lt; 0:\nraise ValueError(\"Term %s not satisfied\" % (term))\nelse:\ncontinue  # noqa: WPS503\nnew_list.append(new_term)\nreturn PolyhedralTermList(new_list)\ndef contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n        Tell whether TermList contains the given behavior.\n        Args:\n            behavior:\n                The behavior in question.\n        Returns:\n            True if the behavior satisfies the constraints; false otherwise.\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\nexcess_vars = list_diff(self.vars, list(behavior.keys()))\nif excess_vars:\nraise ValueError(\"The variables %s were not assigned values\" % (excess_vars))\nretval = True\ntry:\nself.evaluate(behavior)\nexcept ValueError:\nretval = False\nreturn retval\ndef elim_vars_by_refining(\nself,\ncontext: PolyhedralTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralTermList, TacticStatistics]:\n\"\"\"\n        Eliminate variables from PolyhedralTermList by refining it in context.\n        Example:\n            Suppose the current list of terms is $\\\\{x + y \\\\le 6\\\\}$, the\n            context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n            contain variable $y$. Then the current TermList could be\n            refined to $\\\\{x \\\\le 1\\\\}$ because $x \\\\le 1\n            \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x + y \\\\le 6$.\n        Args:\n            context:\n                The TermList providing the context for the refinement.\n            vars_to_elim:\n                Variables that should not appear in the resulting term.\n            simplify:\n                Whether to perform simplifications.\n            tactics_order:\n                Optionally, the order of tactics to invoke during transformation.\n        Returns:\n            A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n                and which, in the context provided, imply the terms contained in the\n                calling termlist; and (b) the list of tuples, for each processed term, of\n                the tactic used, time spend, and tactic invocation count.\n        Raises:\n            ValueError: Self has empty intersection with its context.\n        \"\"\"\nlogging.debug(\"Refining from terms: %s\", self)\nlogging.debug(\"Context: %s\", context)\nlogging.debug(\"Vars to elim: %s\", vars_to_elim)\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif simplify:\ntry:\ntermlist = self.simplify(context)\nexcept ValueError as e:\nraise ValueError(\n\"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n) from e\nelse:\ntermlist = self\ntry:\nreturn termlist._transform(\ncontext=context, vars_to_elim=vars_to_elim, refine=True, simplify=simplify, tactics_order=tactics_order\n)\nexcept ValueError as e:\nraise ValueError(\n\"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n+ \"by refining terms \\n{}\\n\".format(self)\n+ \"in context \\n{}\\n\".format(context)\n+ \"was not possible\"\n) from e\ndef lacks_constraints(self) -&gt; bool:\n\"\"\"\n        Tell whether TermList is empty.\n        Returns:\n            True if empty. False otherwise.\n        \"\"\"\nreturn len(self.terms) == 0\ndef elim_vars_by_relaxing(\nself,\ncontext: PolyhedralTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralTermList, TacticStatistics]:\n\"\"\"\n        Eliminate variables from PolyhedralTermList by abstracting it in context.\n        Example:\n            Suppose the current list of terms is $\\\\{x - y \\\\le 6\\\\}$, the\n            context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n            contain variable $y$. Then the current TermList could be\n            relaxed to $\\\\{x \\\\le 11\\\\}$ because $x - y \\\\le 6\n            \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x \\\\le 11$.\n        Args:\n            context:\n                The TermList providing the context for the transformation.\n            vars_to_elim:\n                Variables that should not appear in the relaxed terms.\n            simplify:\n                Whether to perform simplifications.\n            tactics_order:\n                Optionally, the order of tactics to invoke during transformation.\n        Returns:\n            A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n                and which, in the context provided, are implied by the terms\n                contained in the calling termlist; and (b) the list of tuples, for each\n                processed term, of the tactic used, time spend, and tactic invocation count.\n        Raises:\n            ValueError: Constraints have empty intersection with context.\n        \"\"\"\nlogging.debug(\"Relaxing with context\")\nlogging.debug(\"Relaxing from terms %s\", self)\nlogging.debug(\"Context: %s\", context)\nlogging.debug(\"Vars to elim: %s\", vars_to_elim)\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif simplify:\ntry:\ntermlist = self.simplify(context)\nexcept ValueError as e:\nraise ValueError(\n\"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n) from e\nelse:\ntermlist = self.copy()\ntry:\n(termlist, tactics_data) = termlist._transform(\ncontext=context, vars_to_elim=vars_to_elim, refine=False, simplify=simplify, tactics_order=tactics_order\n)\nexcept ValueError as e:\nraise ValueError(\n\"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n+ \"by relaxing terms \\n{}\\n\".format(self)\n+ \"in context \\n{}\\n\".format(context)\n+ \"was not possible\"\n) from e\n# eliminate terms containing the variables to be eliminated\nterms_to_elim = termlist.get_terms_with_vars(vars_to_elim)\ntermlist.terms = list_diff(termlist.terms, terms_to_elim.terms)\nreturn termlist, tactics_data\ndef simplify(self, context: Optional[PolyhedralTermList] = None) -&gt; PolyhedralTermList:\n\"\"\"\n        Remove redundant terms in the PolyhedralTermList using the provided context.\n        Example:\n            Suppose the TermList is $\\\\{x - 2y \\\\le 5, x - y \\\\le 0\\\\}$ and\n            the context is $\\\\{x + y \\\\le 0\\\\}$. Then the TermList could be\n            simplified to $\\\\{x - y \\\\le 0\\\\}$.\n        Args:\n            context:\n                The TermList providing the context for the simplification.\n        Returns:\n            A new PolyhedralTermList with redundant terms removed using the provided context.\n        Raises:\n            ValueError: The intersection of self and context is empty.\n        \"\"\"\nlogging.debug(\"Starting simplification procedure\")\nlogging.debug(\"Simplifying terms: %s\", self)\nlogging.debug(\"Context: %s\", context)\nif context:\nnew_self = self - context\nresult = PolyhedralTermList.termlist_to_polytope(new_self, context)\nelse:\nresult = PolyhedralTermList.termlist_to_polytope(self, PolyhedralTermList())\nvariables = result[0]\nself_mat = result[1]\nself_cons = result[2]\nctx_mat = result[3]\nctx_cons = result[4]\n# logging.debug(\"Polytope is \\n%s\", self_mat)\ntry:\na_red, b_red = PolyhedralTermList.reduce_polytope(self_mat, self_cons, ctx_mat, ctx_cons)\nexcept ValueError as e:\nraise ValueError(\n\"The constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n) from e\nlogging.debug(\"Reduction: \\n%s\", a_red)\nsimplified = PolyhedralTermList.polytope_to_termlist(a_red, b_red, variables)\nlogging.debug(\"Back to terms: \\n%s\", simplified)\nreturn simplified\ndef refines(self, other: PolyhedralTermList) -&gt; bool:\n\"\"\"\n        Tells whether the argument is a larger specification.\n        Args:\n            other:\n                TermList against which we are comparing self.\n        Returns:\n            self &lt;= other\n        \"\"\"\nlogging.debug(\"Verifying refinement\")\nlogging.debug(\"LH term: %s\", self)\nlogging.debug(\"RH term: %s\", other)\nif other.lacks_constraints():\nreturn True\nif self.lacks_constraints():\nreturn False\nvariables, self_mat, self_cons, ctx_mat, ctx_cons = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\nself, other\n)\nlogging.debug(\"Polytope is \\n%s\", self_mat)\nreturn PolyhedralTermList.verify_polytope_containment(self_mat, self_cons, ctx_mat, ctx_cons)\ndef is_empty(self) -&gt; bool:\n\"\"\"\n        Tell whether the argument has no satisfying assignments.\n        Returns:\n            True if constraints cannot be satisfied.\n        \"\"\"\n_, self_mat, self_cons, _, _ = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\nself, PolyhedralTermList([])\n)\nlogging.debug(\"Polytope is \\n%s\", self_mat)\nreturn PolyhedralTermList.is_polytope_empty(self_mat, self_cons)\n# Returns:\n# - transformed term list\n# - a list of tuples of the tactic used, time spent, and invocation count\ndef _transform(\nself,\ncontext: PolyhedralTermList,\nvars_to_elim: list,\nrefine: bool,\nsimplify: bool,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralTermList, TacticStatistics]:\nlogging.debug(\"Transforming: %s\", self)\nlogging.debug(\"Context terms: %s\", context)\nlogging.debug(\"Variables to eliminate: %s\", vars_to_elim)\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nterm_list = list(self.terms)\nnew_terms = self.copy()\n# List to store the tuples of the tactic used, time spent, and invocation count\ntactics_used: TacticStatistics = []\nfor i, term in enumerate(term_list):\nif list_intersection(term.vars, vars_to_elim):\ncopy_new_terms = new_terms.copy()\ncopy_new_terms.terms.remove(term)\nhelpers = context | copy_new_terms\ntry:\n(new_term, tactic_num, tactic_time, tactic_count) = PolyhedralTermList._transform_term(\nterm, helpers, vars_to_elim, refine, tactics_order\n)\nexcept ValueError:\nnew_term = term.copy()\ntactic_num = 0\ntactic_time = 0\ntactic_count = 0\ntactics_used.append((tactic_num, tactic_time, tactic_count))\nelse:\nnew_term = term.copy()\nnew_terms.terms[i] = new_term\nthat = PolyhedralTermList(new_terms.terms)\n# the last step needs to be a simplification\nlogging.debug(\"Ending transformation with simplification\")\nif simplify:\nreturn that.simplify(context), tactics_used\nreturn that, tactics_used\ndef optimize(self, objective: Dict[Var, numeric], maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"\n        Optimizes a linear expression in the feasible region of the termlist.\n        Args:\n            objective:\n                The objective to optimize.\n            maximize:\n                If true, the routine maximizes; it minimizes otherwise.\n        Returns:\n            The optimal value of the objective. If the objective is unbounded, None is returned.\n        Raises:\n            ValueError: Constraints are likely unfeasible.\n        \"\"\"\nobj = PolyhedralTermList([PolyhedralTerm(variables=objective, constant=0)])\n_, self_mat, self_cons, obj_mat, _ = PolyhedralTermList.termlist_to_polytope(self, obj)  # noqa: WPS236\npolarity = 1\nif maximize:\npolarity = -1\nres = linprog(c=polarity * obj_mat[0], A_ub=self_mat, b_ub=self_cons, bounds=(None, None))\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nif res[\"status\"] == 3:\nreturn None\nelif res[\"status\"] == 0:\nfun_val: float = res[\"fun\"]\nreturn polarity * fun_val\nraise ValueError(\"Constraints are unfeasible\")\n@staticmethod\ndef termlist_to_polytope(\nterms: PolyhedralTermList, context: PolyhedralTermList\n) -&gt; Tuple[List[Var], np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n\"\"\"\n        Converts a list of terms with its context into matrix-vector pairs.\n        Example:\n            Suppose the list of terms is $\\\\{x+y \\\\le 1, x - y \\\\le 4\\\\}$\n            and the context is $\\\\{x + 4w \\\\le 5\\\\}$. The routine extracts\n            all variables and generates an order for them, say, $[x, w,\n            y]$. Then the routine returns matrix-vector pairs for both the terms\n            TermList and the context. It returns $A = \\\\left(\n            \\\\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\\\\\\\ 1 &amp;0 &amp;-1\n            \\\\end{smallmatrix}\\\\right)$ and $b = \\\\left(\n            \\\\begin{smallmatrix} 1 \\\\\\\\ 4 \\\\end{smallmatrix}\\\\right)$ for the\n            current TermList and $A_{c} = \\\\left( \\\\begin{smallmatrix} 1 &amp;\n            4 &amp; 0 \\\\end{smallmatrix}\\\\right)$ and $b_c = \\\\left(\n            \\\\begin{smallmatrix} 5 \\\\end{smallmatrix}\\\\right)$ for the context.\n        Args:\n            terms:\n                list of terms to convert to matrix-vector form.\n            context:\n                Context terms to convert to matrix-vector form.\n        Returns:\n            A tuple `variables, A, b, a_h, b_h` consisting of the variable\n                order and the matrix-vector pairs for the terms and the context.\n        \"\"\"\nvariables = list(list_union(terms.vars, context.vars))\na = []\nb = []\nfor term in terms.terms:\npol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\na.append(pol)\nb.append(coeff)\na_h = []\nb_h = []\nfor term in context.terms:\npol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\na_h.append(pol)\nb_h.append(coeff)\nif len(context.terms) == 0:\na_h_ret = np.array([[]])\nelse:\na_h_ret = np.array(a_h)\n# logging.debug(\"a is \\n%s\", a)\nreturn variables, np.array(a), np.array(b), a_h_ret, np.array(b_h)\n@staticmethod\ndef polytope_to_termlist(matrix: np.ndarray, vector: np.ndarray, variables: List[Var]) -&gt; PolyhedralTermList:\n\"\"\"\n        Transforms a matrix-vector pair into a PolyhedralTermList.\n        Args:\n            matrix:\n                The matrix of the pair.\n            vector:\n                The vector of the pair.\n            variables:\n                A list indicating the variable which corresponds to each column\n                of the matrix.\n        Returns:\n            The PolyhedralTermList corresponding to the given data.\n        \"\"\"\nterm_list = []\n# logging.debug(\"Poly is \" + str(polytope))\n# logging.debug(\"matrix is %s\", matrix)\nif len(matrix.shape) &gt; 1:\nn, m = matrix.shape\nassert m == len(variables)\nelse:\nn = matrix.shape[0]\nm = 0\nfor i in range(n):\nrow = list(matrix[i])\nconst = vector[i]\nterm = PolyhedralTerm.polytope_to_term(row, const, variables)\nterm_list.append(term)\nreturn PolyhedralTermList(list(term_list))\n@staticmethod\ndef reduce_polytope(  # noqa: WPS231\na: np.ndarray, b: np.ndarray, a_help: Optional[np.ndarray] = None, b_help: Optional[np.ndarray] = None\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"\n        Eliminate redundant constraints from a given polytope.\n        Args:\n            a:\n                Matrix of H-representation of polytope to reduce.\n            b:\n                Vector of H-representation of polytope to reduce.\n            a_help:\n                Matrix of H-representation of context polytope.\n            b_help:\n                Vector of H-representation of context polytope.\n        Raises:\n            ValueError: The intersection of given polytope with its context is empty.\n        Returns:\n            a_temp: Matrix of H-representation of reduced polytope.\n            b_temp: Vector of H-representation of reduced polytope.\n        \"\"\"\nif not isinstance(a_help, np.ndarray):\na_help = np.array([[]])\nif not isinstance(b_help, np.ndarray):\nb_help = np.array([])\nif len(a.shape) &gt; 1:\nn, m = a.shape\nelse:\nn = a.shape[0]\nm = 0\nn_h, m_h = a_help.shape\nhelper_present = n_h * m_h &gt; 0\nassert n == len(b), \"n is {} and b is {}\".format(n, b)\nif helper_present:\nassert n_h == len(b_help)\nelse:\nassert len(b_help) == 0\nif helper_present and m &gt; 0:\nassert m_h == m\nif n == 0:\nreturn a, b\nif n == 1 and not helper_present:\nreturn a, b\ni = 0\na_temp = np.copy(a)\nb_temp = np.copy(b)\nwhile i &lt; n:\nobjective = a_temp[i, :] * -1\nb_temp[i] += 1\nif helper_present:\na_opt = np.concatenate((a_temp, a_help), axis=0)\nb_opt = np.concatenate((b_temp, b_help))\nelse:\na_opt = a_temp\nb_opt = b_temp\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nres = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\nb_temp[i] -= 1\nif res[\"status\"] == 3 or (res[\"status\"] == 0 and -res[\"fun\"] &lt;= b_temp[i]):  # noqa: WPS309\nlogging.debug(\"Can remove\")\na_temp = np.delete(a_temp, i, 0)\nb_temp = np.delete(b_temp, i)\nn -= 1\nelse:\ni += 1\nif res[\"status\"] == 2:\nraise ValueError(\"The constraints are unsatisfiable\")\nreturn a_temp, b_temp\n@staticmethod\ndef verify_polytope_containment(  # noqa: WPS231\na_l: Optional[np.ndarray] = None,\nb_l: Optional[np.ndarray] = None,\na_r: Optional[np.ndarray] = None,\nb_r: Optional[np.ndarray] = None,\n) -&gt; bool:\n\"\"\"\n        Tell whether a polytope is contained in another.\n        Args:\n            a_l:\n                Matrix of H-representation of polytope on LHS of inequality.\n            b_l:\n                Vector of H-representation of polytope on LHS of inequality.\n            a_r:\n                Matrix of H-representation of polytope on RHS of inequality.\n            b_r:\n                Vector of H-representation of polytope on RHS of inequality.\n        Returns:\n            True if left polytope is contained in right polytope. False otherwise.\n        \"\"\"\nif not isinstance(a_l, np.ndarray):\na_l = np.array([[]])\nif not isinstance(a_r, np.ndarray):\na_r = np.array([[]])\nif not isinstance(b_l, np.ndarray):\nb_l = np.array([])\nif not isinstance(b_r, np.ndarray):\nb_r = np.array([])\n# If the LHS is empty, it is a refinement\nif PolyhedralTermList.is_polytope_empty(a_l, b_l):\nreturn True\n# If the RHS is empty, but not the LHS, not a refinement\nif PolyhedralTermList.is_polytope_empty(a_r, b_r):\nreturn False\n# If no side is empty, check whether the RHS terms are included in the\n# LHS\nn_l, m_l = a_l.shape\nn_r, m_r = a_r.shape\nassert m_l == m_r\nassert n_l == len(b_l)\nassert n_r == len(b_r)\nis_refinement = True\nfor i in range(n_r):\nconstraint = a_r[[i], :]\nobjective = constraint * -1\nb_temp = b_r[i] + 1\nlogging.debug(\"Optimization objective: \\n%s\", objective)\nlogging.debug(\"a_l is \\n%s\", a_l)\nlogging.debug(\"a_r is \\n%s\", a_r)\nlogging.debug(\"b_l is \\n%s\", b_l)\nlogging.debug(\"b_r is \\n%s\", b_r)\na_opt = np.concatenate((a_l, constraint), axis=0)\nb_opt = np.concatenate((b_l, np.array([b_temp])))\nres = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\nb_temp -= 1\nif res[\"status\"] == 2:\nis_refinement = False\nbreak\nelse:\nif -res[\"fun\"] &lt;= b_temp:  # noqa: WPS309\nlogging.debug(\"Redundant constraint\")\nelse:\nis_refinement = False\nbreak\nlogging.debug(\"Optimal value: %s\", -res[\"fun\"])\nlogging.debug(\"Results: %s\", res)\nreturn is_refinement\n@staticmethod\ndef is_polytope_empty(a: np.ndarray, b: np.ndarray) -&gt; bool:\n\"\"\"\n        Say whether a polytope is empty.\n        Args:\n            a:\n                Matrix of H-representation of polytope to verify.\n            b:\n                Vector of H-representation of polytope to verify.\n        Returns:\n            True if empty. False otherwise.\n        Raises:\n            ValueError: Numerical difficulties encountered.\n        \"\"\"\nlogging.debug(\"Verifying polytope emptiness: a is %s a.shape is %s, b is %s\", a, a.shape, b)\nif len(a) == 0:\nreturn False\nn, m = a.shape\nif n * m == 0:\nreturn False\nassert n == len(b)\nobjective = np.zeros((1, m))\nres = linprog(c=objective, A_ub=a, b_ub=b, bounds=(None, None))  # ,options={'tol':0.000001})\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nif res[\"status\"] == 2:\nreturn True\nelif res[\"status\"] in {0, 3}:\nreturn False\nraise ValueError(\"Cannot decide emptiness\")\n@staticmethod\ndef _get_kaykobad_context(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[List[PolyhedralTerm], List[Var]]:\nforbidden_vars = list_intersection(vars_to_elim, term.vars)\nother_forbibben_vars = list_diff(vars_to_elim, term.vars)\nn = len(forbidden_vars)\nmatrix_row_terms = []  # type: List[PolyhedralTerm]\npartial_sums = [float(0) for i in range(n)]\ntransform_coeff = -1\nif refine:\ntransform_coeff = 1\nmatrix_contains_others = False\n# We add a row to the matrix in each iteration\nfor i, i_var in enumerate(forbidden_vars):\nrow_found = False\nlogging.debug(\"Iterating for variable %s\", i_var)\nfor context_term in list_diff(context.terms, matrix_row_terms):\nlogging.debug(\"Analyzing context term %s\", context_term)\nif context_term == term:\ncontinue\nterm_is_invalid = False\n# make sure the term does not include other forbidden variables\nfor var in other_forbibben_vars:  # noqa: VNE002\nif context_term.get_coefficient(var) != 0:\nterm_is_invalid = True\nlogging.debug(\"Term contains other forbidden vars\")\nbreak\nif term_is_invalid:\ncontinue\n# 1. Verify Kaykobad pair: sign of nonzero matrix terms\nfor var in forbidden_vars:  # noqa: VNE002\nif context_term.get_coefficient(var) != 0:\nif transform_coeff * context_term.get_sign(var) != term.get_sign(var):\nterm_is_invalid = True\n# logging.debug(\"Failed first matrix-vector verification\")\nbreak\n# 2. Verify Kaykobad pair: matrix diagonal terms\nif context_term.get_coefficient(i_var) == 0 or term_is_invalid:\n# logging.debug(\"Failed second matrix-vector verification\")\ncontinue\n# 3. Verify Kaykobad pair: relation between matrix and vector\nresiduals = [float(0) for i in range(n)]\nfor j, j_var in enumerate(forbidden_vars):\n# logging.debug(\"Verifying third condition on variable %s\", j_var)\nif j != i:\nresiduals[j] = (\nterm.get_sign(j_var)\n* context_term.get_coefficient(j_var)\n* term.get_coefficient(i_var)\n/ context_term.get_coefficient(i_var)\n)\nif np.abs(term.get_coefficient(j_var)) &lt;= partial_sums[j] + residuals[j]:\n# logging.debug(\"q coefficient: %s\", term.get_coefficient(j_var))\n# logging.debug(\"RHS: %s\", partial_sums[j] + residuals[j])\nterm_is_invalid = True\n# logging.debug(\"Failed third matrix-vector verification\")\nbreak\nif not term_is_invalid:\nmatrix_contains_others = (\nmatrix_contains_others or len(list_diff(context_term.vars, forbidden_vars)) &gt; 0\n)\nrow_found = True\nfor j in range(n):\npartial_sums[j] += residuals[j]\nmatrix_row_terms.append(context_term)\nbreak\nif not row_found:\nraise ValueError(\"Could not find the {}th row of matrix\".format(i))\nif (not matrix_contains_others) and len(list_diff(term.vars, vars_to_elim)) == 0:\nraise ValueError(\"Found context will produce empty transformation\")\n# logging.debug(\"Matrix row terms %s\", matrix_row_terms)\nreturn matrix_row_terms, forbidden_vars\n@staticmethod\ndef _context_reduction(\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool, strategy: int\n) -&gt; PolyhedralTerm:\nlogging.debug(\"********** Context reduction\")\nlogging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\ntry:\nif strategy == 1:\nmatrix_row_terms, forbidden_vars = PolyhedralTermList._get_kaykobad_context(\nterm, context, vars_to_elim, refine\n)\nelif strategy == 5:\nmatrix_row_terms, forbidden_vars = PolyhedralTermList._get_tlp_context(\nterm, context, vars_to_elim, refine\n)\nelse:\nraise ValueError(\"Unknown strategy\")\nexcept ValueError:\nlogging.debug(\"Could not transform %s using Context reduction\", term)\nraise ValueError(\"Could not transform term {}\".format(term))\nmatrix_row_terms_tl = PolyhedralTermList(list(matrix_row_terms))\nsols = PolyhedralTerm.solve_for_variables(matrix_row_terms_tl, list(forbidden_vars))\n# logging.debug(\"Sols %s\", sols)\nresult = term.copy()\n# logging.debug(\"Result is %s\", result)\nfor var in sols.keys():  # noqa: VNE002\nresult = result.substitute_variable(var, sols[var])\nlogging.debug(\"Term %s transformed to %s\", term, result)\nreturn result\n@staticmethod\ndef _tactic_1(\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nlogging.debug(\"********** Tactic 1\")\nreturn PolyhedralTermList._context_reduction(term, context, vars_to_elim, refine, 1), 1\n@staticmethod\ndef _tactic_2(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nlogging.debug(\"************ Tactic 2\")\nlogging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\nconflict_vars = list_intersection(vars_to_elim, term.vars)\nnew_context_list = []\n# Extract from context the terms that only contain forbidden vars\nfor context_term in context.terms:\nif not list_diff(context_term.vars, vars_to_elim):\nif context_term != term:\nnew_context_list.append(context_term.copy())\nlogging.debug(\"This is what we kept\")\nfor el in new_context_list:\nlogging.debug(el)\nif not new_context_list:\nraise ValueError(\"No term contains only irrelevant variables\")\nif list_diff(conflict_vars, PolyhedralTermList(new_context_list).vars):\nraise ValueError(\"Tactic 2 unsuccessful\")\n# now optimize\nretval = PolyhedralTermList.termlist_to_polytope(PolyhedralTermList(new_context_list), PolyhedralTermList([]))\nvariables = retval[0]\nnew_context_mat = retval[1]\nnew_context_cons = retval[2]\npolarity = 1\nif refine:\npolarity = -1\nobjective = [polarity * term.get_coefficient(var) for var in variables]\nlogging.debug(new_context_mat)\nlogging.debug(new_context_cons)\nlogging.debug(objective)\nres = linprog(c=objective, A_ub=new_context_mat, b_ub=new_context_cons, bounds=(None, None))\nif res[\"status\"] in {2, 3}:\n# unbounded\n# return term.copy()\nraise ValueError(\"Tactic 2 did not succeed\")\nreplacement = polarity * res[\"fun\"]\n# replace the irrelevant variables with new findings in term\nresult = term.copy()\nfor var in vars_to_elim:  # noqa: VNE002\nresult = result.remove_variable(var)\nresult.constant -= replacement\n# check vacuity\nif not result.vars:\nreturn term.copy(), 1\nreturn result, 1\n@staticmethod\ndef _tactic_6(\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nlogging.debug(\"************ Tactic 6\")\nlogging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\nconflict_vars = list_intersection(vars_to_elim, term.vars)\nconflict_coeff = {var: term.get_coefficient(var) for var in conflict_vars}\nnew_term = term.copy()\nfor var in conflict_vars:  # noqa: VNE002 variable name 'var' should be clarified\nnew_term = new_term.remove_variable(var)\nnew_term.variables[Var(\"_\")] = 1\n# modify the context\nsubst_term_vars = {Var(\"_\"): 1.0 / conflict_coeff[conflict_vars[0]]}\nfor var in conflict_vars:  # noqa: VNE002 variable name 'var' should be clarified\nif var != conflict_vars[0]:\nsubst_term_vars[var] = -conflict_coeff[var] / conflict_coeff[conflict_vars[0]]\nsubst_term = PolyhedralTerm(variables=subst_term_vars, constant=0)\nnew_context = PolyhedralTermList(\n[el.copy().substitute_variable(conflict_vars[0], subst_term) for el in context.terms]\n)\n# now we use tactic 1\nnew_elims = list_diff(list_union(vars_to_elim, [Var(\"_\")]), [conflict_vars[0]])\ntry:\nresult, count = PolyhedralTermList._tactic_1(new_term, new_context, new_elims, refine)\nexcept ValueError as e:  # noqa: WPS329 Found useless `except` case\nraise e\nlogging.debug(\"************ Leaving Tactic 6\")\nlogging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\nreturn result, count\n@staticmethod\ndef _tactic_4(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool, no_vars: List[Var]\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nlogging.debug(\"************ Tactic 4\")\nlogging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\nif not refine:\nraise ValueError(\"Only refinement is supported\")\nconflict_vars = list_intersection(vars_to_elim, term.vars)\nif len(conflict_vars) &gt; 1:\nraise ValueError(\"Tactic 4 unsuccessful\")\nvar_to_elim = conflict_vars[0]\ngoal_context: List[PolyhedralTerm] = []\nuseful_context: List[PolyhedralTerm] = []\npolarity = -1\nif refine:\npolarity = 1\nfor context_term in context.terms:\nif list_intersection(context_term.vars, no_vars):\ncontinue\ncoeff = context_term.get_coefficient(var_to_elim)\nif coeff != 0 and polarity * coeff * term.get_coefficient(var_to_elim) &gt; 0:\ntemp_conflict_vars = list_intersection(context_term.vars, vars_to_elim)\nif len(temp_conflict_vars) == 1:\ngoal_context.append(context_term.copy())\nif len(temp_conflict_vars) == 2:\nuseful_context.append(context_term.copy())\nif not useful_context and not goal_context:\nraise ValueError(\"Tactic 4 unsuccessful\")\ntotal_calls = 1\nif goal_context:\nreturn term.substitute_variable(var_to_elim, goal_context[0].isolate_variable(var_to_elim)), total_calls\n############\nfor useful_term in useful_context:\nnew_context = context.copy()\nnew_context.terms.remove(useful_term)\nnew_term = useful_term.isolate_variable(var_to_elim)\nnew_no_vars = no_vars.copy()\nnew_no_vars.append(var_to_elim)\ntry:  # noqa: WPS229\nreturn_term, recursive_count = PolyhedralTermList._tactic_4(\nnew_term, new_context, vars_to_elim, refine, new_no_vars\n)\ntotal_calls += recursive_count\nif return_term is None:\ncontinue\nreturn term.substitute_variable(var_to_elim, return_term), total_calls\nexcept ValueError:\ntotal_calls += 1\nreturn None, total_calls\n@staticmethod\ndef _get_tlp_context(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[List[PolyhedralTerm], List[Var]]:\nforbidden_vars = list_intersection(vars_to_elim, term.vars)\nmatrix_row_terms = []\nvar_list, B, b, _, _ = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236, N806\nterms=context, context=PolyhedralTermList([])\n)\nobjective = np.array([term.get_coefficient(var) if var in forbidden_vars else 0 for var in var_list])\nif refine:\nobjective *= -1\nres = linprog(c=objective, A_ub=B, b_ub=b, bounds=(None, None))\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nif res[\"status\"] == 3:\nraise ValueError(\"Unbounded\")\nelif res[\"status\"] != 0:\nraise ValueError(\"Constraints are unfeasible\")\nnum_vars_to_elim = len(forbidden_vars)\nslack = res[\"slack\"]\nindices = np.where(np.isclose(slack, 0))[0]\nassert len(indices) &gt;= num_vars_to_elim\nterms_added = 0\nfor index in indices:\ncontext_term = context.terms[index]\nif list_intersection(context_term.vars, forbidden_vars):\nmatrix_row_terms.append(context_term)\nterms_added += 1\nif terms_added == num_vars_to_elim:\nbreak\nif terms_added &lt; num_vars_to_elim:\nraise ValueError(\"Context has insufficient information\")\nreturn matrix_row_terms, forbidden_vars\n@staticmethod\ndef _tactic_5(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nlogging.debug(\"************ Tactic 5\")\nreturn PolyhedralTermList._context_reduction(term, context, vars_to_elim, refine, 5), 1\n@staticmethod\ndef _tactic_3(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nlogging.debug(\"************ Tactic 3\")\nlogging.debug(\"Vars_to_elim %s \\nTerm %s \\nContext %s \" % (vars_to_elim, term, context))\nconflict_vars = list_intersection(vars_to_elim, term.vars)\nif conflict_vars:\nct_var = conflict_vars[0]\nfor index, ct_term in enumerate(context.terms):\nif ct_var in ct_term.vars:\ncoeff_test = refine and (term.get_polarity(ct_var) == ct_term.get_polarity(ct_var))\ncoeff_test = coeff_test or (\n(not refine) and (term.get_polarity(ct_var) != ct_term.get_polarity(ct_var))\n)\nif coeff_test:\nct_conflict_vars = list_intersection(vars_to_elim, ct_term.vars)\nif all(ele in conflict_vars for ele in ct_conflict_vars):\nreplacement_expr = ct_term.isolate_variable(ct_var)\nnew_term = term.substitute_variable(ct_var, replacement_expr)\nnew_context = context.copy()\nnew_context.terms.pop(index)\ntry:\nreturn PolyhedralTermList._tactic_3(new_term, new_context, vars_to_elim, refine)[0], 1\nexcept ValueError:\npass\nraise ValueError(\"Failed\")\nreturn term.copy(), 1\n@staticmethod\ndef _tactic_trivial(  # noqa: WPS231\nterm: PolyhedralTerm, context: PolyhedralTermList, vars_to_elim: list, refine: bool\n) -&gt; Tuple[Optional[PolyhedralTerm], int]:\nreturn term.copy(), 1\nTACTICS = {  # noqa: WPS115\n1: _tactic_1.__func__,  # type: ignore\n2: _tactic_2.__func__,  # type: ignore\n3: _tactic_3.__func__,  # type: ignore\n4: lambda term, context, vars_to_elim, refine: PolyhedralTermList._tactic_4(\nterm, context, vars_to_elim, refine, []\n),\n5: _tactic_5.__func__,  # type: ignore\n6: _tactic_6.__func__,  # type: ignore\n7: _tactic_trivial.__func__,  # type: ignore\n}\n# Return:\n# - transformed term\n# - successful tactic number, if &gt; 0; 0 if no applicable tactic, -1 if all tactics failed\n# - count of tactic invocations if successful\n@staticmethod\ndef _transform_term(  # noqa: WPS231\nterm: PolyhedralTerm,\ncontext: PolyhedralTermList,\nvars_to_elim: list,\nrefine: bool,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralTerm, int, float, int]:\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif not list_intersection(term.vars, vars_to_elim):\nraise ValueError(\"Irrelevant transform term call!\")\nlogging.debug(\"Transforming term: %s\", term)\nlogging.debug(\"Context: %s\", context)\nfor tactic_num in tactics_order:  # noqa WPS327\ntry:  # noqa: WPS229\nta = time.time()\nve = vars_to_elim.copy()\nif len(ve) &gt; 2:\nve[1] = vars_to_elim[2]\nve[2] = vars_to_elim[1]\nresult, count = PolyhedralTermList.TACTICS[tactic_num](term, context, ve, refine)\ntb = time.time()\nif result is not None:\nreturn result, tactic_num, tb - ta, count\nexcept ValueError:\ncontinue\nreturn term.copy(), -1, 0, 0\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.__init__","title":"<code>__init__(terms=None)</code>","text":"<p>Constructor for PolyhedralTermList.</p> Usage <p>PolyhedralTermList objects are initialized as follows:</p> <pre><code>    term1 = PolyhedralTerm({Var('x'):2, Var('y'):3}, 3)\n    term2 = PolyhedralTerm({Var('x'):-1, Var('y'):2}, 4)\n    pt_list = [term1, term2]\n    termlist = PolyhedralTermList(pt_list)\n</code></pre> <p>Our example represents the constraints \\(\\{2x + 3y \\le 3, -x + 2y \\le 4\\}\\).</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>Optional[List[PolyhedralTerm]]</code> <p>A list of PolyhedralTerm objects.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>incorrect argument type provided.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def __init__(self, terms: Optional[List[PolyhedralTerm]] = None):\n\"\"\"\n    Constructor for PolyhedralTermList.\n    Usage:\n        PolyhedralTermList objects are initialized as follows:\n        ```\n            term1 = PolyhedralTerm({Var('x'):2, Var('y'):3}, 3)\n            term2 = PolyhedralTerm({Var('x'):-1, Var('y'):2}, 4)\n            pt_list = [term1, term2]\n            termlist = PolyhedralTermList(pt_list)\n        ```\n        Our example represents the constraints $\\\\{2x + 3y \\\\le 3, -x + 2y \\\\le 4\\\\}$.\n    Args:\n        terms: A list of PolyhedralTerm objects.\n    Raises:\n        ValueError: incorrect argument type provided.\n    \"\"\"\nif terms is None:\nself.terms = []\nelif all(isinstance(t, PolyhedralTerm) for t in terms):\nself.terms = terms.copy()\nelse:\nraise ValueError(\"PolyhedralTermList constructor argument must be a list of PolyhedralTerms.\")\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.contains_behavior","title":"<code>contains_behavior(behavior)</code>","text":"<p>Tell whether TermList contains the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Dict[Var, numeric]</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraints; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n    Tell whether TermList contains the given behavior.\n    Args:\n        behavior:\n            The behavior in question.\n    Returns:\n        True if the behavior satisfies the constraints; false otherwise.\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\nexcess_vars = list_diff(self.vars, list(behavior.keys()))\nif excess_vars:\nraise ValueError(\"The variables %s were not assigned values\" % (excess_vars))\nretval = True\ntry:\nself.evaluate(behavior)\nexcept ValueError:\nretval = False\nreturn retval\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.elim_vars_by_refining","title":"<code>elim_vars_by_refining(context, vars_to_elim, simplify=True, tactics_order=None)</code>","text":"<p>Eliminate variables from PolyhedralTermList by refining it in context.</p> Example <p>Suppose the current list of terms is \\(\\{x + y \\le 6\\}\\), the context is \\(\\{y \\le 5\\}\\), and the resulting terms should not contain variable \\(y\\). Then the current TermList could be refined to \\(\\{x \\le 1\\}\\) because \\(x \\le 1 \\;\\land\\; y \\le 5 \\Rightarrow x + y \\le 6\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PolyhedralTermList</code> <p>The TermList providing the context for the refinement.</p> required <code>vars_to_elim</code> <code>list</code> <p>Variables that should not appear in the resulting term.</p> required <code>simplify</code> <code>bool</code> <p>Whether to perform simplifications.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>Optionally, the order of tactics to invoke during transformation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[PolyhedralTermList, TacticStatistics]</code> <p>A tuple of (a) a list of terms not containing any variables in <code>vars_to_elim</code> and which, in the context provided, imply the terms contained in the calling termlist; and (b) the list of tuples, for each processed term, of the tactic used, time spend, and tactic invocation count.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Self has empty intersection with its context.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def elim_vars_by_refining(\nself,\ncontext: PolyhedralTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralTermList, TacticStatistics]:\n\"\"\"\n    Eliminate variables from PolyhedralTermList by refining it in context.\n    Example:\n        Suppose the current list of terms is $\\\\{x + y \\\\le 6\\\\}$, the\n        context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n        contain variable $y$. Then the current TermList could be\n        refined to $\\\\{x \\\\le 1\\\\}$ because $x \\\\le 1\n        \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x + y \\\\le 6$.\n    Args:\n        context:\n            The TermList providing the context for the refinement.\n        vars_to_elim:\n            Variables that should not appear in the resulting term.\n        simplify:\n            Whether to perform simplifications.\n        tactics_order:\n            Optionally, the order of tactics to invoke during transformation.\n    Returns:\n        A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, imply the terms contained in the\n            calling termlist; and (b) the list of tuples, for each processed term, of\n            the tactic used, time spend, and tactic invocation count.\n    Raises:\n        ValueError: Self has empty intersection with its context.\n    \"\"\"\nlogging.debug(\"Refining from terms: %s\", self)\nlogging.debug(\"Context: %s\", context)\nlogging.debug(\"Vars to elim: %s\", vars_to_elim)\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif simplify:\ntry:\ntermlist = self.simplify(context)\nexcept ValueError as e:\nraise ValueError(\n\"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n) from e\nelse:\ntermlist = self\ntry:\nreturn termlist._transform(\ncontext=context, vars_to_elim=vars_to_elim, refine=True, simplify=simplify, tactics_order=tactics_order\n)\nexcept ValueError as e:\nraise ValueError(\n\"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n+ \"by refining terms \\n{}\\n\".format(self)\n+ \"in context \\n{}\\n\".format(context)\n+ \"was not possible\"\n) from e\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.elim_vars_by_relaxing","title":"<code>elim_vars_by_relaxing(context, vars_to_elim, simplify=True, tactics_order=None)</code>","text":"<p>Eliminate variables from PolyhedralTermList by abstracting it in context.</p> Example <p>Suppose the current list of terms is \\(\\{x - y \\le 6\\}\\), the context is \\(\\{y \\le 5\\}\\), and the resulting terms should not contain variable \\(y\\). Then the current TermList could be relaxed to \\(\\{x \\le 11\\}\\) because \\(x - y \\le 6 \\;\\land\\; y \\le 5 \\Rightarrow x \\le 11\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PolyhedralTermList</code> <p>The TermList providing the context for the transformation.</p> required <code>vars_to_elim</code> <code>list</code> <p>Variables that should not appear in the relaxed terms.</p> required <code>simplify</code> <code>bool</code> <p>Whether to perform simplifications.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>Optionally, the order of tactics to invoke during transformation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[PolyhedralTermList, TacticStatistics]</code> <p>A tuple of (a) a list of terms not containing any variables in <code>vars_to_elim</code> and which, in the context provided, are implied by the terms contained in the calling termlist; and (b) the list of tuples, for each processed term, of the tactic used, time spend, and tactic invocation count.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Constraints have empty intersection with context.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def elim_vars_by_relaxing(\nself,\ncontext: PolyhedralTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[PolyhedralTermList, TacticStatistics]:\n\"\"\"\n    Eliminate variables from PolyhedralTermList by abstracting it in context.\n    Example:\n        Suppose the current list of terms is $\\\\{x - y \\\\le 6\\\\}$, the\n        context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n        contain variable $y$. Then the current TermList could be\n        relaxed to $\\\\{x \\\\le 11\\\\}$ because $x - y \\\\le 6\n        \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x \\\\le 11$.\n    Args:\n        context:\n            The TermList providing the context for the transformation.\n        vars_to_elim:\n            Variables that should not appear in the relaxed terms.\n        simplify:\n            Whether to perform simplifications.\n        tactics_order:\n            Optionally, the order of tactics to invoke during transformation.\n    Returns:\n        A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, are implied by the terms\n            contained in the calling termlist; and (b) the list of tuples, for each\n            processed term, of the tactic used, time spend, and tactic invocation count.\n    Raises:\n        ValueError: Constraints have empty intersection with context.\n    \"\"\"\nlogging.debug(\"Relaxing with context\")\nlogging.debug(\"Relaxing from terms %s\", self)\nlogging.debug(\"Context: %s\", context)\nlogging.debug(\"Vars to elim: %s\", vars_to_elim)\nif tactics_order is None:\ntactics_order = TACTICS_ORDER\nif simplify:\ntry:\ntermlist = self.simplify(context)\nexcept ValueError as e:\nraise ValueError(\n\"Provided constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n) from e\nelse:\ntermlist = self.copy()\ntry:\n(termlist, tactics_data) = termlist._transform(\ncontext=context, vars_to_elim=vars_to_elim, refine=False, simplify=simplify, tactics_order=tactics_order\n)\nexcept ValueError as e:\nraise ValueError(\n\"The elimination of variables \\n{}\\n\".format([str(x) for x in vars_to_elim])\n+ \"by relaxing terms \\n{}\\n\".format(self)\n+ \"in context \\n{}\\n\".format(context)\n+ \"was not possible\"\n) from e\n# eliminate terms containing the variables to be eliminated\nterms_to_elim = termlist.get_terms_with_vars(vars_to_elim)\ntermlist.terms = list_diff(termlist.terms, terms_to_elim.terms)\nreturn termlist, tactics_data\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.evaluate","title":"<code>evaluate(var_values)</code>","text":"<p>Replace variables in termlist with given values.</p> <p>Parameters:</p> Name Type Description Default <code>var_values</code> <code>Dict[Var, numeric]</code> <p>The values that variables will take.</p> required <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>A new PolyhedralTermList in which the variables have been substituted with the values provided.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>constraints are unsatisfiable under these valuation of variables.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def evaluate(self, var_values: Dict[Var, numeric]) -&gt; PolyhedralTermList:  # noqa: WPS231\n\"\"\"\n    Replace variables in termlist with given values.\n    Args:\n        var_values:\n            The values that variables will take.\n    Returns:\n        A new PolyhedralTermList in which the variables have been\n            substituted with the values provided.\n    Raises:\n        ValueError: constraints are unsatisfiable under these valuation of variables.\n    \"\"\"\nnew_list = []\nfor term in self.terms:\nnew_term = term.copy()\nfor var, val in var_values.items():  # noqa: VNE002\nnew_term = new_term.substitute_variable(\nvar=var, subst_with_term=PolyhedralTerm(variables={}, constant=-val)\n)\n# we may have eliminated all variables after substitution\nif not new_term.vars:\nif new_term.constant &lt; 0:\nraise ValueError(\"Term %s not satisfied\" % (term))\nelse:\ncontinue  # noqa: WPS503\nnew_list.append(new_term)\nreturn PolyhedralTermList(new_list)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.is_empty","title":"<code>is_empty()</code>","text":"<p>Tell whether the argument has no satisfying assignments.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if constraints cannot be satisfied.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def is_empty(self) -&gt; bool:\n\"\"\"\n    Tell whether the argument has no satisfying assignments.\n    Returns:\n        True if constraints cannot be satisfied.\n    \"\"\"\n_, self_mat, self_cons, _, _ = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\nself, PolyhedralTermList([])\n)\nlogging.debug(\"Polytope is \\n%s\", self_mat)\nreturn PolyhedralTermList.is_polytope_empty(self_mat, self_cons)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.is_polytope_empty","title":"<code>is_polytope_empty(a, b)</code>  <code>staticmethod</code>","text":"<p>Say whether a polytope is empty.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Matrix of H-representation of polytope to verify.</p> required <code>b</code> <code>ndarray</code> <p>Vector of H-representation of polytope to verify.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if empty. False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Numerical difficulties encountered.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef is_polytope_empty(a: np.ndarray, b: np.ndarray) -&gt; bool:\n\"\"\"\n    Say whether a polytope is empty.\n    Args:\n        a:\n            Matrix of H-representation of polytope to verify.\n        b:\n            Vector of H-representation of polytope to verify.\n    Returns:\n        True if empty. False otherwise.\n    Raises:\n        ValueError: Numerical difficulties encountered.\n    \"\"\"\nlogging.debug(\"Verifying polytope emptiness: a is %s a.shape is %s, b is %s\", a, a.shape, b)\nif len(a) == 0:\nreturn False\nn, m = a.shape\nif n * m == 0:\nreturn False\nassert n == len(b)\nobjective = np.zeros((1, m))\nres = linprog(c=objective, A_ub=a, b_ub=b, bounds=(None, None))  # ,options={'tol':0.000001})\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nif res[\"status\"] == 2:\nreturn True\nelif res[\"status\"] in {0, 3}:\nreturn False\nraise ValueError(\"Cannot decide emptiness\")\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.lacks_constraints","title":"<code>lacks_constraints()</code>","text":"<p>Tell whether TermList is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if empty. False otherwise.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def lacks_constraints(self) -&gt; bool:\n\"\"\"\n    Tell whether TermList is empty.\n    Returns:\n        True if empty. False otherwise.\n    \"\"\"\nreturn len(self.terms) == 0\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.optimize","title":"<code>optimize(objective, maximize=True)</code>","text":"<p>Optimizes a linear expression in the feasible region of the termlist.</p> <p>Parameters:</p> Name Type Description Default <code>objective</code> <code>Dict[Var, numeric]</code> <p>The objective to optimize.</p> required <code>maximize</code> <code>bool</code> <p>If true, the routine maximizes; it minimizes otherwise.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[numeric]</code> <p>The optimal value of the objective. If the objective is unbounded, None is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Constraints are likely unfeasible.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def optimize(self, objective: Dict[Var, numeric], maximize: bool = True) -&gt; Optional[numeric]:\n\"\"\"\n    Optimizes a linear expression in the feasible region of the termlist.\n    Args:\n        objective:\n            The objective to optimize.\n        maximize:\n            If true, the routine maximizes; it minimizes otherwise.\n    Returns:\n        The optimal value of the objective. If the objective is unbounded, None is returned.\n    Raises:\n        ValueError: Constraints are likely unfeasible.\n    \"\"\"\nobj = PolyhedralTermList([PolyhedralTerm(variables=objective, constant=0)])\n_, self_mat, self_cons, obj_mat, _ = PolyhedralTermList.termlist_to_polytope(self, obj)  # noqa: WPS236\npolarity = 1\nif maximize:\npolarity = -1\nres = linprog(c=polarity * obj_mat[0], A_ub=self_mat, b_ub=self_cons, bounds=(None, None))\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nif res[\"status\"] == 3:\nreturn None\nelif res[\"status\"] == 0:\nfun_val: float = res[\"fun\"]\nreturn polarity * fun_val\nraise ValueError(\"Constraints are unfeasible\")\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.polytope_to_termlist","title":"<code>polytope_to_termlist(matrix, vector, variables)</code>  <code>staticmethod</code>","text":"<p>Transforms a matrix-vector pair into a PolyhedralTermList.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>The matrix of the pair.</p> required <code>vector</code> <code>ndarray</code> <p>The vector of the pair.</p> required <code>variables</code> <code>List[Var]</code> <p>A list indicating the variable which corresponds to each column of the matrix.</p> required <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>The PolyhedralTermList corresponding to the given data.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef polytope_to_termlist(matrix: np.ndarray, vector: np.ndarray, variables: List[Var]) -&gt; PolyhedralTermList:\n\"\"\"\n    Transforms a matrix-vector pair into a PolyhedralTermList.\n    Args:\n        matrix:\n            The matrix of the pair.\n        vector:\n            The vector of the pair.\n        variables:\n            A list indicating the variable which corresponds to each column\n            of the matrix.\n    Returns:\n        The PolyhedralTermList corresponding to the given data.\n    \"\"\"\nterm_list = []\n# logging.debug(\"Poly is \" + str(polytope))\n# logging.debug(\"matrix is %s\", matrix)\nif len(matrix.shape) &gt; 1:\nn, m = matrix.shape\nassert m == len(variables)\nelse:\nn = matrix.shape[0]\nm = 0\nfor i in range(n):\nrow = list(matrix[i])\nconst = vector[i]\nterm = PolyhedralTerm.polytope_to_term(row, const, variables)\nterm_list.append(term)\nreturn PolyhedralTermList(list(term_list))\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.reduce_polytope","title":"<code>reduce_polytope(a, b, a_help=None, b_help=None)</code>  <code>staticmethod</code>","text":"<p>Eliminate redundant constraints from a given polytope.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Matrix of H-representation of polytope to reduce.</p> required <code>b</code> <code>ndarray</code> <p>Vector of H-representation of polytope to reduce.</p> required <code>a_help</code> <code>Optional[ndarray]</code> <p>Matrix of H-representation of context polytope.</p> <code>None</code> <code>b_help</code> <code>Optional[ndarray]</code> <p>Vector of H-representation of context polytope.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>The intersection of given polytope with its context is empty.</p> <p>Returns:</p> Name Type Description <code>a_temp</code> <code>ndarray</code> <p>Matrix of H-representation of reduced polytope.</p> <code>b_temp</code> <code>ndarray</code> <p>Vector of H-representation of reduced polytope.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef reduce_polytope(  # noqa: WPS231\na: np.ndarray, b: np.ndarray, a_help: Optional[np.ndarray] = None, b_help: Optional[np.ndarray] = None\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"\n    Eliminate redundant constraints from a given polytope.\n    Args:\n        a:\n            Matrix of H-representation of polytope to reduce.\n        b:\n            Vector of H-representation of polytope to reduce.\n        a_help:\n            Matrix of H-representation of context polytope.\n        b_help:\n            Vector of H-representation of context polytope.\n    Raises:\n        ValueError: The intersection of given polytope with its context is empty.\n    Returns:\n        a_temp: Matrix of H-representation of reduced polytope.\n        b_temp: Vector of H-representation of reduced polytope.\n    \"\"\"\nif not isinstance(a_help, np.ndarray):\na_help = np.array([[]])\nif not isinstance(b_help, np.ndarray):\nb_help = np.array([])\nif len(a.shape) &gt; 1:\nn, m = a.shape\nelse:\nn = a.shape[0]\nm = 0\nn_h, m_h = a_help.shape\nhelper_present = n_h * m_h &gt; 0\nassert n == len(b), \"n is {} and b is {}\".format(n, b)\nif helper_present:\nassert n_h == len(b_help)\nelse:\nassert len(b_help) == 0\nif helper_present and m &gt; 0:\nassert m_h == m\nif n == 0:\nreturn a, b\nif n == 1 and not helper_present:\nreturn a, b\ni = 0\na_temp = np.copy(a)\nb_temp = np.copy(b)\nwhile i &lt; n:\nobjective = a_temp[i, :] * -1\nb_temp[i] += 1\nif helper_present:\na_opt = np.concatenate((a_temp, a_help), axis=0)\nb_opt = np.concatenate((b_temp, b_help))\nelse:\na_opt = a_temp\nb_opt = b_temp\n# Linprog's status values\n# 0 : Optimization proceeding nominally.\n# 1 : Iteration limit reached.\n# 2 : Problem appears to be infeasible.\n# 3 : Problem appears to be unbounded.\n# 4 : Numerical difficulties encountered.\nres = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\nb_temp[i] -= 1\nif res[\"status\"] == 3 or (res[\"status\"] == 0 and -res[\"fun\"] &lt;= b_temp[i]):  # noqa: WPS309\nlogging.debug(\"Can remove\")\na_temp = np.delete(a_temp, i, 0)\nb_temp = np.delete(b_temp, i)\nn -= 1\nelse:\ni += 1\nif res[\"status\"] == 2:\nraise ValueError(\"The constraints are unsatisfiable\")\nreturn a_temp, b_temp\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.refines","title":"<code>refines(other)</code>","text":"<p>Tells whether the argument is a larger specification.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralTermList</code> <p>TermList against which we are comparing self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>self &lt;= other</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def refines(self, other: PolyhedralTermList) -&gt; bool:\n\"\"\"\n    Tells whether the argument is a larger specification.\n    Args:\n        other:\n            TermList against which we are comparing self.\n    Returns:\n        self &lt;= other\n    \"\"\"\nlogging.debug(\"Verifying refinement\")\nlogging.debug(\"LH term: %s\", self)\nlogging.debug(\"RH term: %s\", other)\nif other.lacks_constraints():\nreturn True\nif self.lacks_constraints():\nreturn False\nvariables, self_mat, self_cons, ctx_mat, ctx_cons = PolyhedralTermList.termlist_to_polytope(  # noqa: WPS236\nself, other\n)\nlogging.debug(\"Polytope is \\n%s\", self_mat)\nreturn PolyhedralTermList.verify_polytope_containment(self_mat, self_cons, ctx_mat, ctx_cons)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.simplify","title":"<code>simplify(context=None)</code>","text":"<p>Remove redundant terms in the PolyhedralTermList using the provided context.</p> Example <p>Suppose the TermList is \\(\\{x - 2y \\le 5, x - y \\le 0\\}\\) and the context is \\(\\{x + y \\le 0\\}\\). Then the TermList could be simplified to \\(\\{x - y \\le 0\\}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Optional[PolyhedralTermList]</code> <p>The TermList providing the context for the simplification.</p> <code>None</code> <p>Returns:</p> Type Description <code>PolyhedralTermList</code> <p>A new PolyhedralTermList with redundant terms removed using the provided context.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>The intersection of self and context is empty.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def simplify(self, context: Optional[PolyhedralTermList] = None) -&gt; PolyhedralTermList:\n\"\"\"\n    Remove redundant terms in the PolyhedralTermList using the provided context.\n    Example:\n        Suppose the TermList is $\\\\{x - 2y \\\\le 5, x - y \\\\le 0\\\\}$ and\n        the context is $\\\\{x + y \\\\le 0\\\\}$. Then the TermList could be\n        simplified to $\\\\{x - y \\\\le 0\\\\}$.\n    Args:\n        context:\n            The TermList providing the context for the simplification.\n    Returns:\n        A new PolyhedralTermList with redundant terms removed using the provided context.\n    Raises:\n        ValueError: The intersection of self and context is empty.\n    \"\"\"\nlogging.debug(\"Starting simplification procedure\")\nlogging.debug(\"Simplifying terms: %s\", self)\nlogging.debug(\"Context: %s\", context)\nif context:\nnew_self = self - context\nresult = PolyhedralTermList.termlist_to_polytope(new_self, context)\nelse:\nresult = PolyhedralTermList.termlist_to_polytope(self, PolyhedralTermList())\nvariables = result[0]\nself_mat = result[1]\nself_cons = result[2]\nctx_mat = result[3]\nctx_cons = result[4]\n# logging.debug(\"Polytope is \\n%s\", self_mat)\ntry:\na_red, b_red = PolyhedralTermList.reduce_polytope(self_mat, self_cons, ctx_mat, ctx_cons)\nexcept ValueError as e:\nraise ValueError(\n\"The constraints \\n{}\\n\".format(self) + \"are unsatisfiable in context \\n{}\".format(context)\n) from e\nlogging.debug(\"Reduction: \\n%s\", a_red)\nsimplified = PolyhedralTermList.polytope_to_termlist(a_red, b_red, variables)\nlogging.debug(\"Back to terms: \\n%s\", simplified)\nreturn simplified\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.termlist_to_polytope","title":"<code>termlist_to_polytope(terms, context)</code>  <code>staticmethod</code>","text":"<p>Converts a list of terms with its context into matrix-vector pairs.</p> Example <p>Suppose the list of terms is \\(\\{x+y \\le 1, x - y \\le 4\\}\\) and the context is \\(\\{x + 4w \\le 5\\}\\). The routine extracts all variables and generates an order for them, say, \\([x, w, y]\\). Then the routine returns matrix-vector pairs for both the terms TermList and the context. It returns \\(A = \\left( \\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\\\ 1 &amp;0 &amp;-1 \\end{smallmatrix}\\right)\\) and \\(b = \\left( \\begin{smallmatrix} 1 \\\\ 4 \\end{smallmatrix}\\right)\\) for the current TermList and \\(A_{c} = \\left( \\begin{smallmatrix} 1 &amp; 4 &amp; 0 \\end{smallmatrix}\\right)\\) and \\(b_c = \\left( \\begin{smallmatrix} 5 \\end{smallmatrix}\\right)\\) for the context.</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>PolyhedralTermList</code> <p>list of terms to convert to matrix-vector form.</p> required <code>context</code> <code>PolyhedralTermList</code> <p>Context terms to convert to matrix-vector form.</p> required <p>Returns:</p> Type Description <code>Tuple[List[Var], ndarray, ndarray, ndarray, ndarray]</code> <p>A tuple <code>variables, A, b, a_h, b_h</code> consisting of the variable order and the matrix-vector pairs for the terms and the context.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef termlist_to_polytope(\nterms: PolyhedralTermList, context: PolyhedralTermList\n) -&gt; Tuple[List[Var], np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n\"\"\"\n    Converts a list of terms with its context into matrix-vector pairs.\n    Example:\n        Suppose the list of terms is $\\\\{x+y \\\\le 1, x - y \\\\le 4\\\\}$\n        and the context is $\\\\{x + 4w \\\\le 5\\\\}$. The routine extracts\n        all variables and generates an order for them, say, $[x, w,\n        y]$. Then the routine returns matrix-vector pairs for both the terms\n        TermList and the context. It returns $A = \\\\left(\n        \\\\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\\\\\\\ 1 &amp;0 &amp;-1\n        \\\\end{smallmatrix}\\\\right)$ and $b = \\\\left(\n        \\\\begin{smallmatrix} 1 \\\\\\\\ 4 \\\\end{smallmatrix}\\\\right)$ for the\n        current TermList and $A_{c} = \\\\left( \\\\begin{smallmatrix} 1 &amp;\n        4 &amp; 0 \\\\end{smallmatrix}\\\\right)$ and $b_c = \\\\left(\n        \\\\begin{smallmatrix} 5 \\\\end{smallmatrix}\\\\right)$ for the context.\n    Args:\n        terms:\n            list of terms to convert to matrix-vector form.\n        context:\n            Context terms to convert to matrix-vector form.\n    Returns:\n        A tuple `variables, A, b, a_h, b_h` consisting of the variable\n            order and the matrix-vector pairs for the terms and the context.\n    \"\"\"\nvariables = list(list_union(terms.vars, context.vars))\na = []\nb = []\nfor term in terms.terms:\npol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\na.append(pol)\nb.append(coeff)\na_h = []\nb_h = []\nfor term in context.terms:\npol, coeff = PolyhedralTerm.term_to_polytope(term, variables)\na_h.append(pol)\nb_h.append(coeff)\nif len(context.terms) == 0:\na_h_ret = np.array([[]])\nelse:\na_h_ret = np.array(a_h)\n# logging.debug(\"a is \\n%s\", a)\nreturn variables, np.array(a), np.array(b), a_h_ret, np.array(b_h)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.to_str_list","title":"<code>to_str_list()</code>","text":"<p>Convert termlist into a list of strings.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings corresponding to the terms of the termlist.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>def to_str_list(self) -&gt; List[str]:\n\"\"\"\n    Convert termlist into a list of strings.\n    Returns:\n        A list of strings corresponding to the terms of the termlist.\n    \"\"\"\nstr_list = []\nts = self.terms.copy()\nwhile ts:\ns, rest = serializer.polyhedral_term_list_to_strings(ts)\nstr_list.append(s)\nts = rest\nreturn str_list\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/polyhedra/#pacti.terms.polyhedra.polyhedra.PolyhedralTermList.verify_polytope_containment","title":"<code>verify_polytope_containment(a_l=None, b_l=None, a_r=None, b_r=None)</code>  <code>staticmethod</code>","text":"<p>Tell whether a polytope is contained in another.</p> <p>Parameters:</p> Name Type Description Default <code>a_l</code> <code>Optional[ndarray]</code> <p>Matrix of H-representation of polytope on LHS of inequality.</p> <code>None</code> <code>b_l</code> <code>Optional[ndarray]</code> <p>Vector of H-representation of polytope on LHS of inequality.</p> <code>None</code> <code>a_r</code> <code>Optional[ndarray]</code> <p>Matrix of H-representation of polytope on RHS of inequality.</p> <code>None</code> <code>b_r</code> <code>Optional[ndarray]</code> <p>Vector of H-representation of polytope on RHS of inequality.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if left polytope is contained in right polytope. False otherwise.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\polyhedra.py</code> <pre><code>@staticmethod\ndef verify_polytope_containment(  # noqa: WPS231\na_l: Optional[np.ndarray] = None,\nb_l: Optional[np.ndarray] = None,\na_r: Optional[np.ndarray] = None,\nb_r: Optional[np.ndarray] = None,\n) -&gt; bool:\n\"\"\"\n    Tell whether a polytope is contained in another.\n    Args:\n        a_l:\n            Matrix of H-representation of polytope on LHS of inequality.\n        b_l:\n            Vector of H-representation of polytope on LHS of inequality.\n        a_r:\n            Matrix of H-representation of polytope on RHS of inequality.\n        b_r:\n            Vector of H-representation of polytope on RHS of inequality.\n    Returns:\n        True if left polytope is contained in right polytope. False otherwise.\n    \"\"\"\nif not isinstance(a_l, np.ndarray):\na_l = np.array([[]])\nif not isinstance(a_r, np.ndarray):\na_r = np.array([[]])\nif not isinstance(b_l, np.ndarray):\nb_l = np.array([])\nif not isinstance(b_r, np.ndarray):\nb_r = np.array([])\n# If the LHS is empty, it is a refinement\nif PolyhedralTermList.is_polytope_empty(a_l, b_l):\nreturn True\n# If the RHS is empty, but not the LHS, not a refinement\nif PolyhedralTermList.is_polytope_empty(a_r, b_r):\nreturn False\n# If no side is empty, check whether the RHS terms are included in the\n# LHS\nn_l, m_l = a_l.shape\nn_r, m_r = a_r.shape\nassert m_l == m_r\nassert n_l == len(b_l)\nassert n_r == len(b_r)\nis_refinement = True\nfor i in range(n_r):\nconstraint = a_r[[i], :]\nobjective = constraint * -1\nb_temp = b_r[i] + 1\nlogging.debug(\"Optimization objective: \\n%s\", objective)\nlogging.debug(\"a_l is \\n%s\", a_l)\nlogging.debug(\"a_r is \\n%s\", a_r)\nlogging.debug(\"b_l is \\n%s\", b_l)\nlogging.debug(\"b_r is \\n%s\", b_r)\na_opt = np.concatenate((a_l, constraint), axis=0)\nb_opt = np.concatenate((b_l, np.array([b_temp])))\nres = linprog(c=objective, A_ub=a_opt, b_ub=b_opt, bounds=(None, None))  # ,options={'tol':0.000001})\nb_temp -= 1\nif res[\"status\"] == 2:\nis_refinement = False\nbreak\nelse:\nif -res[\"fun\"] &lt;= b_temp:  # noqa: WPS309\nlogging.debug(\"Redundant constraint\")\nelse:\nis_refinement = False\nbreak\nlogging.debug(\"Optimal value: %s\", -res[\"fun\"])\nlogging.debug(\"Results: %s\", res)\nreturn is_refinement\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/serializer/","title":"Serializer","text":"<p>Transformations between polyhedral structures and strings.</p>"},{"location":"reference/pacti/terms/polyhedra/serializer/#pacti.terms.polyhedra.serializer.polyhedral_term_list_to_strings","title":"<code>polyhedral_term_list_to_strings(terms)</code>","text":"<p>Convert a list of polyhedral terms into a list of strings, one term at a time.</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>List[PolyhedralTerm]</code> <p>the list of terms.</p> required <p>Returns:</p> Type Description <code>Tuple[str, List[PolyhedralTerm]]</code> <p>String representation of the first constraint and list of items not yet serialized.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\serializer.py</code> <pre><code>def polyhedral_term_list_to_strings(  # noqa: WPS231 too much cognitive complexity\nterms: List[PolyhedralTerm],\n) -&gt; Tuple[str, List[PolyhedralTerm]]:\n\"\"\"\n    Convert a list of polyhedral terms into a list of strings, one term at a time.\n    Args:\n        terms: the list of terms.\n    Returns:\n        String representation of the first constraint and list of items not yet serialized.\n    \"\"\"\nif not terms:\nreturn \"\", []\ntp = terms[0]\nts = terms[1:]\nfor tn in ts:\nif _are_polyhedral_terms_opposite(tp, tn):\n# tp has the form: LHS\n# tn has the form: -(LHS)\nif _are_numbers_approximatively_equal(tp.constant, -tn.constant):\n# inverse of rule 4\n# rewrite as 2 terms given input match: LHS = RHS\n# pos: LHS &lt;= RHS\n# neg: -(LHS) &lt;= -(RHS)\ns = _lhs_str(tp) + \" = \" + _number_to_string(tp.constant)\nts.remove(tn)\nreturn s, ts\nelse:\ncondition = _are_numbers_approximatively_equal(\ntp.constant, float(0)\n) and _are_numbers_approximatively_equal(tn.constant, float(0))\nif condition:\n# inverse of rule 3\n# rewrite as 2 terms given input match: | LHS | = 0\n# pos: LHS &lt;= 0\n# neg: -(LHS) &lt;= 0\ns = \"|\" + _lhs_str(tp) + \"| = 0\"\nts.remove(tn)\nreturn s, ts\nelif _are_numbers_approximatively_equal(tp.constant, tn.constant):\n# inverse of rule 2\n# rewrite as 2 terms given input match: | LHS | &lt;= RHS\n# pos: LHS &lt;= RHS\n# neg: -(LHS) &lt;= RHS\ns = \"|\" + _lhs_str(tp) + \"| &lt;= \" + _number_to_string(tp.constant)\nts.remove(tn)\nreturn s, ts\ns = _lhs_str(tp) + \" &lt;= \" + _number_to_string(tp.constant)\nreturn s, ts\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/serializer/#pacti.terms.polyhedra.serializer.polyhedral_termlist_from_string","title":"<code>polyhedral_termlist_from_string(str_rep)</code>","text":"<p>Transform a linear expression into a polyhedral termlist.</p> <p>Parameters:</p> Name Type Description Default <code>str_rep</code> <code>str</code> <p>The linear expression passed as a string.</p> required <p>Returns:</p> Type Description <code>List[PolyhedralTerm]</code> <p>A PolyhedralTermList representing the input expression.</p> <p>Raises:</p> Type Description <code>PolyhedralSyntaxException</code> <p>constraint syntax error w.r.t the polyhedral term grammar.</p> <code>ValueError</code> <p>Number of tokens invalid.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\serializer.py</code> <pre><code>def polyhedral_termlist_from_string(str_rep: str) -&gt; List[PolyhedralTerm]:\n\"\"\"\n    Transform a linear expression into a polyhedral termlist.\n    Args:\n        str_rep: The linear expression passed as a string.\n    Returns:\n        A PolyhedralTermList representing the input expression.\n    Raises:\n        PolyhedralSyntaxException: constraint syntax error w.r.t the polyhedral term grammar.\n        ValueError: Number of tokens invalid.\n    \"\"\"\ntry:\ntokens: pp.ParseResults = expression.parse_string(str_rep, parse_all=True)\nexcept pp.ParseBaseException as pe:\nraise PolyhedralSyntaxException(pe, str_rep)\nif len(tokens) == 1:\ne = tokens[0]\nif isinstance(e, PolyhedralSyntaxExpression):\nreturn _expression_to_polyhedral_terms(str_rep, e)\nraise ValueError(f\"Polyhedral term syntax unrecognized in: {str_rep}\")\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/serializer/#pacti.terms.polyhedra.serializer.validate_contract_dict","title":"<code>validate_contract_dict(contract, contract_name, machine_representation)</code>","text":"<p>Tell whether a contract dictionary can be read as a polyhedral contract.</p> <p>Parameters:</p> Name Type Description Default <code>contract</code> <code>Dict</code> <p>a dictionary to be analyzed.</p> required <code>contract_name</code> <code>str</code> <p>a name for the contract (used for error reporting).</p> required <code>machine_representation</code> <code>bool</code> <p>the provided dictionary is machine-optimized.</p> required <p>Raises:</p> Type Description <code>ContractFormatError</code> <p>the provided contract is not well-formed.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\serializer.py</code> <pre><code>def validate_contract_dict(  # noqa: WPS231 too much cognitive complexity\ncontract: Dict, contract_name: str, machine_representation: bool\n) -&gt; None:\n\"\"\"\n    Tell whether a contract dictionary can be read as a polyhedral contract.\n    Args:\n        contract: a dictionary to be analyzed.\n        contract_name: a name for the contract (used for error reporting).\n        machine_representation: the provided dictionary is machine-optimized.\n    Raises:\n        ContractFormatError: the provided contract is not well-formed.\n    \"\"\"\nif not isinstance(contract, dict):\nprint(contract)\nraise ContractFormatError(\"Each contract should be a dictionary\")\nkeywords = [\"assumptions\", \"guarantees\", \"input_vars\", \"output_vars\"]\nstr_list_kw = [\"input_vars\", \"output_vars\"]\nif not machine_representation:\nstr_list_kw += [\"assumptions\", \"guarantees\"]\nfor kw in keywords:\nif kw not in contract:\nraise ContractFormatError(f'Keyword \"{kw}\" not found in contract {contract_name}')\nvalue = contract[kw]\nif not isinstance(value, list):\nraise ContractFormatError(f'The \"{kw}\" in contract {contract_name} should be a list')\nif kw in str_list_kw:\nfor str_item in value:\nif not isinstance(str_item, str):\nraise ContractFormatError(f\"The {kw} in contract {contract_name} should be defined as strings\")\nelif machine_representation:\nfor index, clause in enumerate(value):\n_check_clause(clause, f\"{contract_name}:{kw}{index}\")\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/","title":"Index","text":""},{"location":"reference/pacti/terms/polyhedra/syntax/data/","title":"Data","text":"<p>Basis data structures for polyhedral parsing.</p>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxAbsoluteTerm","title":"<code>PolyhedralSyntaxAbsoluteTerm</code>  <code>dataclass</code>","text":"<p>Represents an absolute list of terms with an optional coefficient.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>@dataclasses.dataclass\nclass PolyhedralSyntaxAbsoluteTerm:\n\"\"\"Represents an absolute list of terms with an optional coefficient.\"\"\"\nterm_list: PolyhedralSyntaxTermList\ncoefficient: Optional[float] = dataclasses.field(default=None)\ndef __repr__(self) -&gt; str:\ns = f\"|{self.term_list}|\"\nif self.coefficient is None:\nreturn s\nreturn f\"{self.coefficient}{s}\"\ndef is_positive(self: \"PolyhedralSyntaxAbsoluteTerm\") -&gt; bool:\n\"\"\"\n        Checks whether this PolyhedralSyntaxAbsoluteTerm is positive.\n        Returns:\n            True if either there is no coefficient or the coefficient is positive.\n        \"\"\"\nif self.coefficient is None:\nreturn True\nreturn self.coefficient &gt; 0\ndef negate(self: \"PolyhedralSyntaxAbsoluteTerm\") -&gt; \"PolyhedralSyntaxAbsoluteTerm\":\n\"\"\"\n        Negated PolyhedralSyntaxAbsoluteTerm.\n        Returns:\n            A negated copy of this PolyhedralSyntaxAbsoluteTerm.\n        \"\"\"\nif self.coefficient is None:\nreturn PolyhedralSyntaxAbsoluteTerm(term_list=self.term_list, coefficient=-1.0)\nreturn PolyhedralSyntaxAbsoluteTerm(term_list=self.term_list, coefficient=self.coefficient * -1.0)\ndef same_term_list(self, other: \"PolyhedralSyntaxAbsoluteTerm\") -&gt; bool:\n\"\"\"\n        Check whether this PolyhedralSyntaxAbsoluteTerm has the same term_list as other.\n        Args:\n            other: Another PolyhedralSyntaxAbsoluteTerm\n        Returns:\n            True if the representation of self's term_list is equal to that of other's.\n        \"\"\"\ns = f\"{self.term_list}\"\no = f\"{other.term_list}\"\nreturn s == o\ndef to_term_list(self: \"PolyhedralSyntaxAbsoluteTerm\") -&gt; PolyhedralSyntaxTermList:\n\"\"\"\n        Converts an PolyhedralSyntaxAbsoluteTerm into a PolyhedralSyntaxTermList.\n        Returns:\n            A PolyhedralSyntaxTermList with the PolyhedralSyntaxAbsoluteTerm coefficient\n            applied as a multiplier for the constant and factors of the term_list.\n        \"\"\"\nif self.coefficient is None:\nm = 1.0\nelse:\nm = self.coefficient\nc = m * self.term_list.constant\nfs: Dict[str, float] = {}\nfor f, v in self.term_list.factors.items():\nfs[f] = m * v\nreturn PolyhedralSyntaxTermList(constant=c, factors=fs)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxAbsoluteTerm.is_positive","title":"<code>is_positive()</code>","text":"<p>Checks whether this PolyhedralSyntaxAbsoluteTerm is positive.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if either there is no coefficient or the coefficient is positive.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>def is_positive(self: \"PolyhedralSyntaxAbsoluteTerm\") -&gt; bool:\n\"\"\"\n    Checks whether this PolyhedralSyntaxAbsoluteTerm is positive.\n    Returns:\n        True if either there is no coefficient or the coefficient is positive.\n    \"\"\"\nif self.coefficient is None:\nreturn True\nreturn self.coefficient &gt; 0\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxAbsoluteTerm.negate","title":"<code>negate()</code>","text":"<p>Negated PolyhedralSyntaxAbsoluteTerm.</p> <p>Returns:</p> Type Description <code>PolyhedralSyntaxAbsoluteTerm</code> <p>A negated copy of this PolyhedralSyntaxAbsoluteTerm.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>def negate(self: \"PolyhedralSyntaxAbsoluteTerm\") -&gt; \"PolyhedralSyntaxAbsoluteTerm\":\n\"\"\"\n    Negated PolyhedralSyntaxAbsoluteTerm.\n    Returns:\n        A negated copy of this PolyhedralSyntaxAbsoluteTerm.\n    \"\"\"\nif self.coefficient is None:\nreturn PolyhedralSyntaxAbsoluteTerm(term_list=self.term_list, coefficient=-1.0)\nreturn PolyhedralSyntaxAbsoluteTerm(term_list=self.term_list, coefficient=self.coefficient * -1.0)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxAbsoluteTerm.same_term_list","title":"<code>same_term_list(other)</code>","text":"<p>Check whether this PolyhedralSyntaxAbsoluteTerm has the same term_list as other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralSyntaxAbsoluteTerm</code> <p>Another PolyhedralSyntaxAbsoluteTerm</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the representation of self's term_list is equal to that of other's.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>def same_term_list(self, other: \"PolyhedralSyntaxAbsoluteTerm\") -&gt; bool:\n\"\"\"\n    Check whether this PolyhedralSyntaxAbsoluteTerm has the same term_list as other.\n    Args:\n        other: Another PolyhedralSyntaxAbsoluteTerm\n    Returns:\n        True if the representation of self's term_list is equal to that of other's.\n    \"\"\"\ns = f\"{self.term_list}\"\no = f\"{other.term_list}\"\nreturn s == o\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxAbsoluteTerm.to_term_list","title":"<code>to_term_list()</code>","text":"<p>Converts an PolyhedralSyntaxAbsoluteTerm into a PolyhedralSyntaxTermList.</p> <p>Returns:</p> Type Description <code>PolyhedralSyntaxTermList</code> <p>A PolyhedralSyntaxTermList with the PolyhedralSyntaxAbsoluteTerm coefficient</p> <code>PolyhedralSyntaxTermList</code> <p>applied as a multiplier for the constant and factors of the term_list.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>def to_term_list(self: \"PolyhedralSyntaxAbsoluteTerm\") -&gt; PolyhedralSyntaxTermList:\n\"\"\"\n    Converts an PolyhedralSyntaxAbsoluteTerm into a PolyhedralSyntaxTermList.\n    Returns:\n        A PolyhedralSyntaxTermList with the PolyhedralSyntaxAbsoluteTerm coefficient\n        applied as a multiplier for the constant and factors of the term_list.\n    \"\"\"\nif self.coefficient is None:\nm = 1.0\nelse:\nm = self.coefficient\nc = m * self.term_list.constant\nfs: Dict[str, float] = {}\nfor f, v in self.term_list.factors.items():\nfs[f] = m * v\nreturn PolyhedralSyntaxTermList(constant=c, factors=fs)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxAbsoluteTermList","title":"<code>PolyhedralSyntaxAbsoluteTermList</code>  <code>dataclass</code>","text":"<p>Represents lists of absolute terms and of terms.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>@dataclasses.dataclass\nclass PolyhedralSyntaxAbsoluteTermList:\n\"\"\"Represents lists of absolute terms and of terms.\"\"\"\nterm_list: PolyhedralSyntaxTermList\nabsolute_term_list: List[PolyhedralSyntaxAbsoluteTerm] = dataclasses.field(default_factory=list)\ndef __repr__(self) -&gt; str:\ns = f\"{self.term_list}\"\nfor a in self.absolute_term_list:\nif a.is_positive():\ns += f\" + {a}\"\nelse:\ns += f\" {a}\"\nreturn s\ndef expand(self) -&gt; List[PolyhedralSyntaxTermList]:\n\"\"\"\n        Expand all positive/negative combinations of the absolute_term_list into PolyhedralSyntaxTermList.\n        Each expanded PolyhedralSyntaxTermList corresponds to combining the\n        term_list of a given PolyhedralSyntaxAbsoluteTerm with one of all\n        possible combinations of the positive and negative variants of the\n        absolute_term_list elements. If n is the length of the\n        absolute_term_list, then the result has 2^n PolyhedralSyntaxTermList,\n        one for each of the positive/negative combinations of each\n        absolute_term_list element combined with the term_list.\n        Returns:\n            A list of PolyhedralSyntaxTermList instances.\n        \"\"\"\nif len(self.absolute_term_list) == 0:\nreturn [self.term_list]\nexpanded: List[PolyhedralSyntaxTermList] = []\nif len(self.absolute_term_list) &gt; 0:\nfor tl in _generate_absolute_term_combinations(self.absolute_term_list):\ntlc = PolyhedralSyntaxTermList(\nconstant=self.term_list.constant, factors=self.term_list.factors.copy()\n).add(tl)\nexpanded.append(tlc)\nelse:\nexpanded.append(\nPolyhedralSyntaxTermList(constant=self.term_list.constant, factors=self.term_list.factors.copy())\n)\nreturn expanded\ndef negate(self) -&gt; \"PolyhedralSyntaxAbsoluteTermList\":\n\"\"\"\n        Negated PolyhedralSyntaxAbsoluteTermList\n        Returns:\n            An PolyhedralSyntaxAbsoluteTermList with negated term_list and all absolute_term_list negated.\n        \"\"\"\nreturn PolyhedralSyntaxAbsoluteTermList(\nterm_list=self.term_list.negate(), absolute_term_list=[at.negate() for at in self.absolute_term_list]\n)\ndef add(self, other: \"PolyhedralSyntaxAbsoluteTermList\") -&gt; \"PolyhedralSyntaxAbsoluteTermList\":\n\"\"\"\n        Addition for PolyhedralSyntaxAbsoluteTermList\n        Args:\n            other: An PolyhedralSyntaxAbsoluteTermList to add to self.\n        Returns:\n            An PolyhedralSyntaxAbsoluteTermList with the term_list added\n        \"\"\"\natl = self.absolute_term_list.copy()\nfor at in other.absolute_term_list:\natl = _combine_or_append(atl, at)\nreturn PolyhedralSyntaxAbsoluteTermList(term_list=self.term_list.add(other.term_list), absolute_term_list=atl)\ndef is_constant(self) -&gt; bool:\n\"\"\"\n        Is this PolyhedralSyntaxAbsoluteTermList equivalent to a constant.\n        Returns:\n            True if there are no PolyhedralSyntaxAbsoluteTermList and no factors in the term_list.\n        \"\"\"\nreturn len(self.absolute_term_list) == 0 and len(self.term_list.factors) == 0\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxAbsoluteTermList.add","title":"<code>add(other)</code>","text":"<p>Addition for PolyhedralSyntaxAbsoluteTermList</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralSyntaxAbsoluteTermList</code> <p>An PolyhedralSyntaxAbsoluteTermList to add to self.</p> required <p>Returns:</p> Type Description <code>PolyhedralSyntaxAbsoluteTermList</code> <p>An PolyhedralSyntaxAbsoluteTermList with the term_list added</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>def add(self, other: \"PolyhedralSyntaxAbsoluteTermList\") -&gt; \"PolyhedralSyntaxAbsoluteTermList\":\n\"\"\"\n    Addition for PolyhedralSyntaxAbsoluteTermList\n    Args:\n        other: An PolyhedralSyntaxAbsoluteTermList to add to self.\n    Returns:\n        An PolyhedralSyntaxAbsoluteTermList with the term_list added\n    \"\"\"\natl = self.absolute_term_list.copy()\nfor at in other.absolute_term_list:\natl = _combine_or_append(atl, at)\nreturn PolyhedralSyntaxAbsoluteTermList(term_list=self.term_list.add(other.term_list), absolute_term_list=atl)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxAbsoluteTermList.expand","title":"<code>expand()</code>","text":"<p>Expand all positive/negative combinations of the absolute_term_list into PolyhedralSyntaxTermList.</p> <p>Each expanded PolyhedralSyntaxTermList corresponds to combining the term_list of a given PolyhedralSyntaxAbsoluteTerm with one of all possible combinations of the positive and negative variants of the absolute_term_list elements. If n is the length of the absolute_term_list, then the result has 2^n PolyhedralSyntaxTermList, one for each of the positive/negative combinations of each absolute_term_list element combined with the term_list.</p> <p>Returns:</p> Type Description <code>List[PolyhedralSyntaxTermList]</code> <p>A list of PolyhedralSyntaxTermList instances.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>def expand(self) -&gt; List[PolyhedralSyntaxTermList]:\n\"\"\"\n    Expand all positive/negative combinations of the absolute_term_list into PolyhedralSyntaxTermList.\n    Each expanded PolyhedralSyntaxTermList corresponds to combining the\n    term_list of a given PolyhedralSyntaxAbsoluteTerm with one of all\n    possible combinations of the positive and negative variants of the\n    absolute_term_list elements. If n is the length of the\n    absolute_term_list, then the result has 2^n PolyhedralSyntaxTermList,\n    one for each of the positive/negative combinations of each\n    absolute_term_list element combined with the term_list.\n    Returns:\n        A list of PolyhedralSyntaxTermList instances.\n    \"\"\"\nif len(self.absolute_term_list) == 0:\nreturn [self.term_list]\nexpanded: List[PolyhedralSyntaxTermList] = []\nif len(self.absolute_term_list) &gt; 0:\nfor tl in _generate_absolute_term_combinations(self.absolute_term_list):\ntlc = PolyhedralSyntaxTermList(\nconstant=self.term_list.constant, factors=self.term_list.factors.copy()\n).add(tl)\nexpanded.append(tlc)\nelse:\nexpanded.append(\nPolyhedralSyntaxTermList(constant=self.term_list.constant, factors=self.term_list.factors.copy())\n)\nreturn expanded\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxAbsoluteTermList.is_constant","title":"<code>is_constant()</code>","text":"<p>Is this PolyhedralSyntaxAbsoluteTermList equivalent to a constant.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if there are no PolyhedralSyntaxAbsoluteTermList and no factors in the term_list.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>def is_constant(self) -&gt; bool:\n\"\"\"\n    Is this PolyhedralSyntaxAbsoluteTermList equivalent to a constant.\n    Returns:\n        True if there are no PolyhedralSyntaxAbsoluteTermList and no factors in the term_list.\n    \"\"\"\nreturn len(self.absolute_term_list) == 0 and len(self.term_list.factors) == 0\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxAbsoluteTermList.negate","title":"<code>negate()</code>","text":"<p>Negated PolyhedralSyntaxAbsoluteTermList</p> <p>Returns:</p> Type Description <code>PolyhedralSyntaxAbsoluteTermList</code> <p>An PolyhedralSyntaxAbsoluteTermList with negated term_list and all absolute_term_list negated.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>def negate(self) -&gt; \"PolyhedralSyntaxAbsoluteTermList\":\n\"\"\"\n    Negated PolyhedralSyntaxAbsoluteTermList\n    Returns:\n        An PolyhedralSyntaxAbsoluteTermList with negated term_list and all absolute_term_list negated.\n    \"\"\"\nreturn PolyhedralSyntaxAbsoluteTermList(\nterm_list=self.term_list.negate(), absolute_term_list=[at.negate() for at in self.absolute_term_list]\n)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxEqlExpression","title":"<code>PolyhedralSyntaxEqlExpression</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PolyhedralSyntaxExpression</code></p> <p>Represents a linear equality expression with a left and right side PolyhedralSyntaxTermList.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>@dataclasses.dataclass\nclass PolyhedralSyntaxEqlExpression(PolyhedralSyntaxExpression):\n\"\"\"Represents a linear equality expression with a left and right side PolyhedralSyntaxTermList.\"\"\"\nlhs: PolyhedralSyntaxTermList\nrhs: PolyhedralSyntaxTermList\noperator: PolyhedralSyntaxOperator = dataclasses.field(init=False)\ndef __post_init__(self) -&gt; None:\n# For the validity of the following supression, see\n# https://github.com/wemake-services/wemake-python-styleguide/issues/1926\nself.operator = PolyhedralSyntaxOperator.eql  # noqa: WPS601 Found shadowed class attribute.\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxExpression","title":"<code>PolyhedralSyntaxExpression</code>  <code>dataclass</code>","text":"<p>Base class a linear expression with an operator in between sides.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>@dataclasses.dataclass\nclass PolyhedralSyntaxExpression:\n\"\"\"Base class a linear expression with an operator in between sides.\"\"\"\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxIneqExpression","title":"<code>PolyhedralSyntaxIneqExpression</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PolyhedralSyntaxExpression</code></p> <p>Represents a linear inequality expression with 2 or more sides of type PolyhedralSyntaxAbsoluteTermList.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>@dataclasses.dataclass\nclass PolyhedralSyntaxIneqExpression(PolyhedralSyntaxExpression):\n\"\"\"Represents a linear inequality expression with 2 or more sides of type PolyhedralSyntaxAbsoluteTermList.\"\"\"\noperator: PolyhedralSyntaxOperator\nsides: List[PolyhedralSyntaxAbsoluteTermList] = dataclasses.field(default_factory=list)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxOperator","title":"<code>PolyhedralSyntaxOperator</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the different kinds of expression operators.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>class PolyhedralSyntaxOperator(Enum):\n\"\"\"Represents the different kinds of expression operators.\"\"\"\neql = 1\nleq = 2\ngeq = 3\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxTermList","title":"<code>PolyhedralSyntaxTermList</code>  <code>dataclass</code>","text":"<p>Represents a reduced list of syntactic terms (variables with a multiplicative coefficient) with an additive constant.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>@dataclasses.dataclass\nclass PolyhedralSyntaxTermList:\n\"\"\"Represents a reduced list of syntactic terms (variables with a multiplicative coefficient) with an additive constant.\"\"\"\nconstant: float\nfactors: Dict[str, float] = dataclasses.field(default_factory=dict)\ndef is_positive(self: \"PolyhedralSyntaxTermList\") -&gt; bool:\n\"\"\"\n        Checks whether the TermList is positive.\n        Returns:\n            True if either the constant is positive or, if the first ordered factor is positive.\n        \"\"\"\nif self.constant &gt; 0:\nreturn True\nelif self.constant &lt; 0:\nreturn False\nvar = sorted(self.factors)[0]\nreturn self.factors[var] &gt; 0\ndef negate(self: \"PolyhedralSyntaxTermList\") -&gt; \"PolyhedralSyntaxTermList\":\n\"\"\"\n        Negated PolyhedralSyntaxTermList\n        Returns:\n            A PolyhedralSyntaxTermList with the negated constant and all factors negated.\n        \"\"\"\nc = -self.constant\nfs = {}\nfor f, v in self.factors.items():\nfs[f] = -v\nreturn PolyhedralSyntaxTermList(constant=c, factors=fs)\ndef add(self: \"PolyhedralSyntaxTermList\", other: \"PolyhedralSyntaxTermList\") -&gt; \"PolyhedralSyntaxTermList\":\n\"\"\"\n        Addition for PolyhedralSyntaxTermList.\n        Args:\n            other: a PolyhedralSyntaxTermList to add to self.\n        Returns:\n            A new PolyhedralSyntaxTermList with the sum of the constants and with the factors added by their variables.\n        \"\"\"\nfs = self.factors.copy()\nfor f, v in other.factors.items():\nif f in fs:\nfs[f] += v\nfv = f\"{fs[f]}\"\nif fv == \"0.0\":\nfs.pop(f)\nelif fv == \"-0.0\":\nfs.pop(f)\nelse:\nfs[f] = v\nreturn PolyhedralSyntaxTermList(constant=self.constant + other.constant, factors=fs)\ndef to_polyhedral_term(self: \"PolyhedralSyntaxTermList\") -&gt; PolyhedralTerm:\n\"\"\"\n        Converts a PolyhedralSyntaxTermList to a PolyhedralTerm.\n        Returns:\n            A PolyhedralTerm with the right-hand-side constant as the negated constant of the PolyhedralSyntaxTermList\n            and left-hand-side variables mapped from the PolyhedralSyntaxTermList variables with their multiplicative coefficients.\n        \"\"\"\nfs: Dict[Var, numeric] = {Var(k): v for k, v in self.factors.items()}\nreturn PolyhedralTerm(variables=fs, constant=-self.constant)\ndef __repr__(self) -&gt; str:\nif self.constant == 0:\ns = \"\"\nelse:\ns = f\"{self.constant}\"\nfor var in sorted(self.factors):\nf: float = self.factors[var]\nif len(s) == 0:\ns = _factor_repr(f, var)\nelse:\nif f &gt; 0:\ns += f\" + {_factor_repr(f, var)}\"\nelse:\ns += f\" - {_factor_repr(abs(f), var)}\"\nreturn s\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxTermList.add","title":"<code>add(other)</code>","text":"<p>Addition for PolyhedralSyntaxTermList.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PolyhedralSyntaxTermList</code> <p>a PolyhedralSyntaxTermList to add to self.</p> required <p>Returns:</p> Type Description <code>PolyhedralSyntaxTermList</code> <p>A new PolyhedralSyntaxTermList with the sum of the constants and with the factors added by their variables.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>def add(self: \"PolyhedralSyntaxTermList\", other: \"PolyhedralSyntaxTermList\") -&gt; \"PolyhedralSyntaxTermList\":\n\"\"\"\n    Addition for PolyhedralSyntaxTermList.\n    Args:\n        other: a PolyhedralSyntaxTermList to add to self.\n    Returns:\n        A new PolyhedralSyntaxTermList with the sum of the constants and with the factors added by their variables.\n    \"\"\"\nfs = self.factors.copy()\nfor f, v in other.factors.items():\nif f in fs:\nfs[f] += v\nfv = f\"{fs[f]}\"\nif fv == \"0.0\":\nfs.pop(f)\nelif fv == \"-0.0\":\nfs.pop(f)\nelse:\nfs[f] = v\nreturn PolyhedralSyntaxTermList(constant=self.constant + other.constant, factors=fs)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxTermList.is_positive","title":"<code>is_positive()</code>","text":"<p>Checks whether the TermList is positive.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if either the constant is positive or, if the first ordered factor is positive.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>def is_positive(self: \"PolyhedralSyntaxTermList\") -&gt; bool:\n\"\"\"\n    Checks whether the TermList is positive.\n    Returns:\n        True if either the constant is positive or, if the first ordered factor is positive.\n    \"\"\"\nif self.constant &gt; 0:\nreturn True\nelif self.constant &lt; 0:\nreturn False\nvar = sorted(self.factors)[0]\nreturn self.factors[var] &gt; 0\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxTermList.negate","title":"<code>negate()</code>","text":"<p>Negated PolyhedralSyntaxTermList</p> <p>Returns:</p> Type Description <code>PolyhedralSyntaxTermList</code> <p>A PolyhedralSyntaxTermList with the negated constant and all factors negated.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>def negate(self: \"PolyhedralSyntaxTermList\") -&gt; \"PolyhedralSyntaxTermList\":\n\"\"\"\n    Negated PolyhedralSyntaxTermList\n    Returns:\n        A PolyhedralSyntaxTermList with the negated constant and all factors negated.\n    \"\"\"\nc = -self.constant\nfs = {}\nfor f, v in self.factors.items():\nfs[f] = -v\nreturn PolyhedralSyntaxTermList(constant=c, factors=fs)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/data/#pacti.terms.polyhedra.syntax.data.PolyhedralSyntaxTermList.to_polyhedral_term","title":"<code>to_polyhedral_term()</code>","text":"<p>Converts a PolyhedralSyntaxTermList to a PolyhedralTerm.</p> <p>Returns:</p> Type Description <code>PolyhedralTerm</code> <p>A PolyhedralTerm with the right-hand-side constant as the negated constant of the PolyhedralSyntaxTermList</p> <code>PolyhedralTerm</code> <p>and left-hand-side variables mapped from the PolyhedralSyntaxTermList variables with their multiplicative coefficients.</p> Source code in <code>pacti\\src\\pacti\\terms\\polyhedra\\syntax\\data.py</code> <pre><code>def to_polyhedral_term(self: \"PolyhedralSyntaxTermList\") -&gt; PolyhedralTerm:\n\"\"\"\n    Converts a PolyhedralSyntaxTermList to a PolyhedralTerm.\n    Returns:\n        A PolyhedralTerm with the right-hand-side constant as the negated constant of the PolyhedralSyntaxTermList\n        and left-hand-side variables mapped from the PolyhedralSyntaxTermList variables with their multiplicative coefficients.\n    \"\"\"\nfs: Dict[Var, numeric] = {Var(k): v for k, v in self.factors.items()}\nreturn PolyhedralTerm(variables=fs, constant=-self.constant)\n</code></pre>"},{"location":"reference/pacti/terms/polyhedra/syntax/grammar/","title":"Grammar","text":"<p>Grammar for polyhedral terms.</p>"},{"location":"reference/pacti/terms/smt/","title":"Index","text":""},{"location":"reference/pacti/terms/smt/smt/","title":"Smt","text":"<p>Support for SMT constraints.</p> <p>Module provides support for SMT expressions as constraints.</p>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTerm","title":"<code>SmtTerm</code>","text":"<p>               Bases: <code>Term</code></p> <p>SMT terms.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>class SmtTerm(Term):\n\"\"\"SMT terms.\"\"\"\ndef __init__(self, expression: z3.BoolRef):  # noqa: WPS231  too much cognitive complexity\n\"\"\"\n        Constructor for SmtTerm.\n        Usage:\n            SMT terms are initialized by passing an SMT expression.\n        Args:\n            expression: A boolean expression involving uninterpreted atoms.\n        Raises:\n            ValueError: Unsupported argument type.\n        \"\"\"\nself.expression: z3.BoolRef\nif isinstance(expression, z3.BoolRef):\nself.expression = copy.deepcopy(expression)\nelse:\nraise ValueError()\ndef __eq__(self, other: object) -&gt; bool:\nif not isinstance(other, type(self)):\nraise ValueError()\nreturn str(self) == str(other)\ndef __str__(self) -&gt; str:\n# return SmtTerm.add_globally(_expr_to_str(self.expression))\nreturn str(self.expression)\ndef __hash__(self) -&gt; int:\nreturn hash(str(self))\ndef __repr__(self) -&gt; str:\nreturn \"&lt;Term {0}&gt;\".format(self)\n@property\ndef atoms(self) -&gt; List[str]:  # noqa: A003\n\"\"\"\n        Atoms appearing in term.\n        Returns:\n            List of atoms referenced in term.\n        \"\"\"\nreturn _get_z3_literals(self.expression)\n@property\ndef vars(self) -&gt; List[Var]:  # noqa: A003\n\"\"\"\n        Variables appearing in term.\n        Returns:\n            List of variables referenced in term.\n        \"\"\"\nreturn [Var(atom) for atom in self.atoms]\ndef contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n        Tell whether term contains a given variable.\n        Args:\n            var_to_seek: The variable that we are seeking in the current term.\n        Returns:\n            `True` if the syntax of the term refers to the given variable;\n                `False` otherwise.\n        \"\"\"\nreturn var_to_seek in self.vars\ndef copy(self) -&gt; SmtTerm:\n\"\"\"\n        Generates copy of term.\n        Returns:\n            Copy of term.\n        \"\"\"\nexpression = copy.deepcopy(self.expression)\nreturn SmtTerm(expression)\ndef rename_variable(self, source_var: Var, target_var: Var) -&gt; SmtTerm:\n\"\"\"\n        Rename a variable in a term.\n        Args:\n            source_var: The variable to be replaced.\n            target_var: The new variable.\n        Returns:\n            A term with `source_var` replaced by `target_var`.\n        \"\"\"\nret_expr = _rename_expr(self.expression, source_var.name, target_var.name)\nreturn SmtTerm(ret_expr)\ndef is_tautology(self) -&gt; bool:\n\"\"\"\n        Tell whether term is a tautology.\n        Returns:\n            True if tautology.\n        \"\"\"\nreturn _is_tautology(self.expression)\ndef is_sat(self) -&gt; bool:\n\"\"\"\n        Tell whether term is a satisfiable.\n        Returns:\n            True if satisfiable.\n        \"\"\"\nreturn _is_sat(self.expression)\ndef contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n        Tell whether Term contains the given behavior.\n        Args:\n            behavior:\n                The behavior in question.\n        Returns:\n            True if the behavior satisfies the constraint; false otherwise.\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\nvariables_to_substitute: List[Var] = list(behavior.keys())\nif list_diff(self.vars, variables_to_substitute):\nraise ValueError(\"Not all variables assigned\")\nnew_expression = copy.deepcopy(self.expression)\nrelevant_variables: List[Var] = list_intersection(variables_to_substitute, self.vars)\nfor elim_var in relevant_variables:\nnew_expression = _replace_var_with_val(new_expression, elim_var.name, behavior[elim_var])\nreturn _is_tautology(new_expression)\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTerm.atoms","title":"<code>atoms</code>  <code>property</code>","text":"<p>Atoms appearing in term.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of atoms referenced in term.</p>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTerm.vars","title":"<code>vars</code>  <code>property</code>","text":"<p>Variables appearing in term.</p> <p>Returns:</p> Type Description <code>List[Var]</code> <p>List of variables referenced in term.</p>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTerm.__init__","title":"<code>__init__(expression)</code>","text":"<p>Constructor for SmtTerm.</p> Usage <p>SMT terms are initialized by passing an SMT expression.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>BoolRef</code> <p>A boolean expression involving uninterpreted atoms.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Unsupported argument type.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def __init__(self, expression: z3.BoolRef):  # noqa: WPS231  too much cognitive complexity\n\"\"\"\n    Constructor for SmtTerm.\n    Usage:\n        SMT terms are initialized by passing an SMT expression.\n    Args:\n        expression: A boolean expression involving uninterpreted atoms.\n    Raises:\n        ValueError: Unsupported argument type.\n    \"\"\"\nself.expression: z3.BoolRef\nif isinstance(expression, z3.BoolRef):\nself.expression = copy.deepcopy(expression)\nelse:\nraise ValueError()\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTerm.contains_behavior","title":"<code>contains_behavior(behavior)</code>","text":"<p>Tell whether Term contains the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Dict[Var, numeric]</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraint; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n    Tell whether Term contains the given behavior.\n    Args:\n        behavior:\n            The behavior in question.\n    Returns:\n        True if the behavior satisfies the constraint; false otherwise.\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\nvariables_to_substitute: List[Var] = list(behavior.keys())\nif list_diff(self.vars, variables_to_substitute):\nraise ValueError(\"Not all variables assigned\")\nnew_expression = copy.deepcopy(self.expression)\nrelevant_variables: List[Var] = list_intersection(variables_to_substitute, self.vars)\nfor elim_var in relevant_variables:\nnew_expression = _replace_var_with_val(new_expression, elim_var.name, behavior[elim_var])\nreturn _is_tautology(new_expression)\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTerm.contains_var","title":"<code>contains_var(var_to_seek)</code>","text":"<p>Tell whether term contains a given variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_to_seek</code> <code>Var</code> <p>The variable that we are seeking in the current term.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the syntax of the term refers to the given variable; <code>False</code> otherwise.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def contains_var(self, var_to_seek: Var) -&gt; bool:\n\"\"\"\n    Tell whether term contains a given variable.\n    Args:\n        var_to_seek: The variable that we are seeking in the current term.\n    Returns:\n        `True` if the syntax of the term refers to the given variable;\n            `False` otherwise.\n    \"\"\"\nreturn var_to_seek in self.vars\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTerm.copy","title":"<code>copy()</code>","text":"<p>Generates copy of term.</p> <p>Returns:</p> Type Description <code>SmtTerm</code> <p>Copy of term.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def copy(self) -&gt; SmtTerm:\n\"\"\"\n    Generates copy of term.\n    Returns:\n        Copy of term.\n    \"\"\"\nexpression = copy.deepcopy(self.expression)\nreturn SmtTerm(expression)\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTerm.is_sat","title":"<code>is_sat()</code>","text":"<p>Tell whether term is a satisfiable.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if satisfiable.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def is_sat(self) -&gt; bool:\n\"\"\"\n    Tell whether term is a satisfiable.\n    Returns:\n        True if satisfiable.\n    \"\"\"\nreturn _is_sat(self.expression)\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTerm.is_tautology","title":"<code>is_tautology()</code>","text":"<p>Tell whether term is a tautology.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if tautology.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def is_tautology(self) -&gt; bool:\n\"\"\"\n    Tell whether term is a tautology.\n    Returns:\n        True if tautology.\n    \"\"\"\nreturn _is_tautology(self.expression)\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTerm.rename_variable","title":"<code>rename_variable(source_var, target_var)</code>","text":"<p>Rename a variable in a term.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>Var</code> <p>The variable to be replaced.</p> required <code>target_var</code> <code>Var</code> <p>The new variable.</p> required <p>Returns:</p> Type Description <code>SmtTerm</code> <p>A term with <code>source_var</code> replaced by <code>target_var</code>.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def rename_variable(self, source_var: Var, target_var: Var) -&gt; SmtTerm:\n\"\"\"\n    Rename a variable in a term.\n    Args:\n        source_var: The variable to be replaced.\n        target_var: The new variable.\n    Returns:\n        A term with `source_var` replaced by `target_var`.\n    \"\"\"\nret_expr = _rename_expr(self.expression, source_var.name, target_var.name)\nreturn SmtTerm(ret_expr)\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTermList","title":"<code>SmtTermList</code>","text":"<p>               Bases: <code>TermList</code></p> <p>A TermList of SmtTerm instances.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>class SmtTermList(TermList):  # noqa: WPS338\n\"\"\"A TermList of SmtTerm instances.\"\"\"\ndef __init__(self, terms: Optional[List[SmtTerm]] = None):\n\"\"\"\n        Constructor for SmtTermList.\n        Args:\n            terms: A list of SmtTerm objects.\n        Raises:\n            ValueError: incorrect argument type provided.\n        \"\"\"\nif terms is None:\nself.terms = []\nelif all(isinstance(t, SmtTerm) for t in terms):\nself.terms = terms.copy()\nelse:\nraise ValueError(\"SmtTermList constructor argument must be a list of SmtTerms.\")\ndef __str__(self) -&gt; str:\nres = \"[\\n  \"\nres += \"\\n  \".join(self.to_str_list())\nres += \"\\n]\"\nreturn res\ndef __hash__(self) -&gt; int:\nreturn hash(tuple(self.terms))\ndef __le__(self, other: SmtTermList) -&gt; bool:\nreturn self.refines(other)\ndef is_semantically_equivalent_to(self, other: SmtTermList) -&gt; bool:\n\"\"\"\n        Tell whether two termlists are semantically equivalent.\n        Args:\n            other:\n                The termlist against which we compare self.\n        Returns:\n            True if the two termlists are semantically equivalent.\n        \"\"\"\nreturn self.refines(other) and other.refines(self)\ndef to_str_list(self) -&gt; List[str]:\n\"\"\"\n        Convert termlist into a list of strings.\n        Returns:\n            A list of strings corresponding to the terms of the termlist.\n        \"\"\"\nreturn [str(term) for term in self.terms]\ndef contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n        Tell whether TermList contains the given behavior.\n        Args:\n            behavior:\n                The behavior in question.\n        Returns:\n            True if the behavior satisfies the constraints; false otherwise.\n        Raises:\n            ValueError: Not all variables in the constraints were assigned values.\n        \"\"\"\nfor term in self.terms:\ntry:\nif not term.contains_behavior(behavior):\nreturn False\nexcept ValueError as e:\nraise ValueError(e)\nreturn True\ndef _to_smtexpr(self) -&gt; z3.BoolRef:\nreturn z3.And(*[xs.expression for xs in self.terms])\n@staticmethod\ndef _transform_term(  # noqa: WPS231  too much cognitive complexity\nterm: SmtTerm,\ncontext: SmtTermList,\nvars_to_elim: list,\nrefine: bool,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtTerm, SmtTermList]:\nnew_term: SmtTerm\n# Check whether there is something to do with this term\nif list_intersection(vars_to_elim, term.vars):\natoms_to_elim = list(map(str, list_intersection(vars_to_elim, list_union(term.vars, context.vars))))\nreference_term = SmtTerm(_elim_variables(term.expression, context._to_smtexpr(), atoms_to_elim, refine))\nnew_term = reference_term.copy()\nfinal_context = context.copy()\n# now check whether we can find equivalent \"in-context\" semantics using a reduced context\nif simplify:\ngolden_compare = context | SmtTermList([reference_term])\nindices_removed: List[int] = []\nfor i, _ in enumerate(context.terms):\ntest_context = SmtTermList(list_remove_indices(context.terms, indices_removed + [i]))\ntest_term = SmtTerm(\n_elim_variables(term.expression, test_context._to_smtexpr(), atoms_to_elim, refine)\n)\ntest_compare = context | SmtTermList([test_term])\nif (golden_compare).is_semantically_equivalent_to(test_compare):\nindices_removed.append(i)\nnew_term = test_term.copy()\nfinal_context = test_context.copy()\nelse:\nnew_term = term.copy()\nfinal_context = context.copy()\nif not new_term.is_sat():\nraise ValueError(\"Computed term is empty\")\nreturn new_term, final_context\ndef _transform_termlist(  # noqa: WPS231  too much cognitive complexity\nself,\ncontext: SmtTermList,\nvars_to_elim: list,\nrefine: bool,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtTermList, TacticStatistics]:\nnew_terms = []\n# only keep the context with relevant variables\nrelevant_terms = []\nfor term in context.terms:\nif list_intersection(term.vars, vars_to_elim):\nrelevant_terms.append(term)\nrelevant_context = SmtTermList(relevant_terms)\nfor term in self.terms:\ntry:\nnew_term, _ = SmtTermList._transform_term(\nterm, relevant_context, vars_to_elim, refine, simplify, tactics_order\n)\nexcept ValueError as e:\nraise ValueError(e)\nnew_terms.append(new_term)\nreturn SmtTermList(new_terms), []\ndef elim_vars_by_refining(  # noqa: WPS231  too much cognitive complexity\nself,\ncontext: SmtTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtTermList, TacticStatistics]:\n\"\"\"\n        Eliminate variables from SmtTermList by refining it in context.\n        Example:\n            Suppose the current list of terms is $\\\\{x + y \\\\le 6\\\\}$, the\n            context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n            contain variable $y$. Then the current TermList could be\n            refined to $\\\\{x \\\\le 1\\\\}$ because $x \\\\le 1\n            \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x + y \\\\le 6$.\n        Args:\n            context:\n                The TermList providing the context for the refinement.\n            vars_to_elim:\n                Variables that should not appear in the resulting term.\n            simplify:\n                Whether to perform simplifications.\n            tactics_order:\n                Optionally, the order of tactics to invoke during transformation.\n        Returns:\n            A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n                and which, in the context provided, imply the terms contained in the\n                calling termlist; and (b) the list of tuples, for each processed term, of\n                the tactic used, time spend, and tactic invocation count.\n        Raises:\n            ValueError: Self has empty intersection with its context.\n        \"\"\"\ntry:\nreturn self._transform_termlist(\ncontext=context, vars_to_elim=vars_to_elim, refine=True, simplify=simplify, tactics_order=tactics_order\n)\nexcept ValueError as e:\nraise ValueError(e)\ndef elim_vars_by_relaxing(\nself,\ncontext: SmtTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtTermList, TacticStatistics]:\n\"\"\"\n        Eliminate variables from SmtTemList by abstracting it in context.\n        Example:\n            Suppose the current list of terms is $\\\\{x - y \\\\le 6\\\\}$, the\n            context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n            contain variable $y$. Then the current TermList could be\n            relaxed to $\\\\{x \\\\le 11\\\\}$ because $x - y \\\\le 6\n            \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x \\\\le 11$.\n        Args:\n            context:\n                The TermList providing the context for the transformation.\n            vars_to_elim:\n                Variables that should not appear in the relaxed terms.\n            simplify:\n                Whether to perform simplifications.\n            tactics_order:\n                Optionally, the order of tactics to invoke during transformation.\n        Returns:\n            A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n                and which, in the context provided, are implied by the terms\n                contained in the calling termlist; and (b) the list of tuples, for each\n                processed term, of the tactic used, time spend, and tactic invocation count.\n        \"\"\"\nreturn self._transform_termlist(\ncontext=context, vars_to_elim=vars_to_elim, refine=False, simplify=simplify, tactics_order=tactics_order\n)\ndef simplify(self, context: Optional[SmtTermList] = None) -&gt; SmtTermList:\n\"\"\"\n        Remove redundant terms in the TermList using the provided context.\n        Example:\n            Suppose the TermList is $\\\\{x - 2y \\\\le 5, x - y \\\\le 0\\\\}$ and\n            the context is $\\\\{x + y \\\\le 0\\\\}$. Then the TermList could be\n            simplified to $\\\\{x - y \\\\le 0\\\\}$.\n        Args:\n            context:\n                The TermList providing the context for the simplification.\n        Returns:\n            A new TermList with redundant terms removed using the provided context.\n        \"\"\"\nnewterms: List[SmtTerm] = []\nexternal_context = SmtTermList([])\nif context:\nexternal_context = context\nfor i, term_under_analysis in enumerate(self.terms):\nuseful_context = SmtTermList(newterms) | SmtTermList(self.terms[i + 1 :]) | external_context\nif not useful_context.refines(SmtTermList([term_under_analysis])):\nnewterms.append(term_under_analysis.copy())\nreturn SmtTermList(newterms)\ndef refines(self, other: SmtTermList) -&gt; bool:\n\"\"\"\n        Tells whether the argument is a larger specification.\n        Args:\n            other:\n                TermList against which we are comparing self.\n        Returns:\n            self &lt;= other\n        \"\"\"\nantecedent = self._to_smtexpr()\nconsequent = other._to_smtexpr()\ntest_expr: z3.BoolRef = z3.Implies(antecedent, consequent)\nreturn _is_tautology(test_expr)\ndef is_empty(self) -&gt; bool:\n\"\"\"\n        Tell whether the argument has no satisfying assignments.\n        Returns:\n            True if constraints cannot be satisfied.\n        \"\"\"\ntest_expr = self._to_smtexpr()\nif _is_sat(test_expr):  # noqa: WPS531 if condition can be simplified\nreturn False\nreturn True\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTermList.__init__","title":"<code>__init__(terms=None)</code>","text":"<p>Constructor for SmtTermList.</p> <p>Parameters:</p> Name Type Description Default <code>terms</code> <code>Optional[List[SmtTerm]]</code> <p>A list of SmtTerm objects.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>incorrect argument type provided.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def __init__(self, terms: Optional[List[SmtTerm]] = None):\n\"\"\"\n    Constructor for SmtTermList.\n    Args:\n        terms: A list of SmtTerm objects.\n    Raises:\n        ValueError: incorrect argument type provided.\n    \"\"\"\nif terms is None:\nself.terms = []\nelif all(isinstance(t, SmtTerm) for t in terms):\nself.terms = terms.copy()\nelse:\nraise ValueError(\"SmtTermList constructor argument must be a list of SmtTerms.\")\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTermList.contains_behavior","title":"<code>contains_behavior(behavior)</code>","text":"<p>Tell whether TermList contains the given behavior.</p> <p>Parameters:</p> Name Type Description Default <code>behavior</code> <code>Dict[Var, numeric]</code> <p>The behavior in question.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the behavior satisfies the constraints; false otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Not all variables in the constraints were assigned values.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def contains_behavior(self, behavior: Dict[Var, numeric]) -&gt; bool:\n\"\"\"\n    Tell whether TermList contains the given behavior.\n    Args:\n        behavior:\n            The behavior in question.\n    Returns:\n        True if the behavior satisfies the constraints; false otherwise.\n    Raises:\n        ValueError: Not all variables in the constraints were assigned values.\n    \"\"\"\nfor term in self.terms:\ntry:\nif not term.contains_behavior(behavior):\nreturn False\nexcept ValueError as e:\nraise ValueError(e)\nreturn True\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTermList.elim_vars_by_refining","title":"<code>elim_vars_by_refining(context, vars_to_elim, simplify=True, tactics_order=None)</code>","text":"<p>Eliminate variables from SmtTermList by refining it in context.</p> Example <p>Suppose the current list of terms is \\(\\{x + y \\le 6\\}\\), the context is \\(\\{y \\le 5\\}\\), and the resulting terms should not contain variable \\(y\\). Then the current TermList could be refined to \\(\\{x \\le 1\\}\\) because \\(x \\le 1 \\;\\land\\; y \\le 5 \\Rightarrow x + y \\le 6\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>SmtTermList</code> <p>The TermList providing the context for the refinement.</p> required <code>vars_to_elim</code> <code>list</code> <p>Variables that should not appear in the resulting term.</p> required <code>simplify</code> <code>bool</code> <p>Whether to perform simplifications.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>Optionally, the order of tactics to invoke during transformation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[SmtTermList, TacticStatistics]</code> <p>A tuple of (a) a list of terms not containing any variables in <code>vars_to_elim</code> and which, in the context provided, imply the terms contained in the calling termlist; and (b) the list of tuples, for each processed term, of the tactic used, time spend, and tactic invocation count.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Self has empty intersection with its context.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def elim_vars_by_refining(  # noqa: WPS231  too much cognitive complexity\nself,\ncontext: SmtTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtTermList, TacticStatistics]:\n\"\"\"\n    Eliminate variables from SmtTermList by refining it in context.\n    Example:\n        Suppose the current list of terms is $\\\\{x + y \\\\le 6\\\\}$, the\n        context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n        contain variable $y$. Then the current TermList could be\n        refined to $\\\\{x \\\\le 1\\\\}$ because $x \\\\le 1\n        \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x + y \\\\le 6$.\n    Args:\n        context:\n            The TermList providing the context for the refinement.\n        vars_to_elim:\n            Variables that should not appear in the resulting term.\n        simplify:\n            Whether to perform simplifications.\n        tactics_order:\n            Optionally, the order of tactics to invoke during transformation.\n    Returns:\n        A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, imply the terms contained in the\n            calling termlist; and (b) the list of tuples, for each processed term, of\n            the tactic used, time spend, and tactic invocation count.\n    Raises:\n        ValueError: Self has empty intersection with its context.\n    \"\"\"\ntry:\nreturn self._transform_termlist(\ncontext=context, vars_to_elim=vars_to_elim, refine=True, simplify=simplify, tactics_order=tactics_order\n)\nexcept ValueError as e:\nraise ValueError(e)\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTermList.elim_vars_by_relaxing","title":"<code>elim_vars_by_relaxing(context, vars_to_elim, simplify=True, tactics_order=None)</code>","text":"<p>Eliminate variables from SmtTemList by abstracting it in context.</p> Example <p>Suppose the current list of terms is \\(\\{x - y \\le 6\\}\\), the context is \\(\\{y \\le 5\\}\\), and the resulting terms should not contain variable \\(y\\). Then the current TermList could be relaxed to \\(\\{x \\le 11\\}\\) because \\(x - y \\le 6 \\;\\land\\; y \\le 5 \\Rightarrow x \\le 11\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>SmtTermList</code> <p>The TermList providing the context for the transformation.</p> required <code>vars_to_elim</code> <code>list</code> <p>Variables that should not appear in the relaxed terms.</p> required <code>simplify</code> <code>bool</code> <p>Whether to perform simplifications.</p> <code>True</code> <code>tactics_order</code> <code>Optional[List[int]]</code> <p>Optionally, the order of tactics to invoke during transformation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[SmtTermList, TacticStatistics]</code> <p>A tuple of (a) a list of terms not containing any variables in <code>vars_to_elim</code> and which, in the context provided, are implied by the terms contained in the calling termlist; and (b) the list of tuples, for each processed term, of the tactic used, time spend, and tactic invocation count.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def elim_vars_by_relaxing(\nself,\ncontext: SmtTermList,\nvars_to_elim: list,\nsimplify: bool = True,\ntactics_order: Optional[List[int]] = None,\n) -&gt; Tuple[SmtTermList, TacticStatistics]:\n\"\"\"\n    Eliminate variables from SmtTemList by abstracting it in context.\n    Example:\n        Suppose the current list of terms is $\\\\{x - y \\\\le 6\\\\}$, the\n        context is $\\\\{y \\\\le 5\\\\}$, and the resulting terms should not\n        contain variable $y$. Then the current TermList could be\n        relaxed to $\\\\{x \\\\le 11\\\\}$ because $x - y \\\\le 6\n        \\\\;\\\\land\\\\; y \\\\le 5 \\\\Rightarrow x \\\\le 11$.\n    Args:\n        context:\n            The TermList providing the context for the transformation.\n        vars_to_elim:\n            Variables that should not appear in the relaxed terms.\n        simplify:\n            Whether to perform simplifications.\n        tactics_order:\n            Optionally, the order of tactics to invoke during transformation.\n    Returns:\n        A tuple of (a) a list of terms not containing any variables in `vars_to_elim`\n            and which, in the context provided, are implied by the terms\n            contained in the calling termlist; and (b) the list of tuples, for each\n            processed term, of the tactic used, time spend, and tactic invocation count.\n    \"\"\"\nreturn self._transform_termlist(\ncontext=context, vars_to_elim=vars_to_elim, refine=False, simplify=simplify, tactics_order=tactics_order\n)\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTermList.is_empty","title":"<code>is_empty()</code>","text":"<p>Tell whether the argument has no satisfying assignments.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if constraints cannot be satisfied.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def is_empty(self) -&gt; bool:\n\"\"\"\n    Tell whether the argument has no satisfying assignments.\n    Returns:\n        True if constraints cannot be satisfied.\n    \"\"\"\ntest_expr = self._to_smtexpr()\nif _is_sat(test_expr):  # noqa: WPS531 if condition can be simplified\nreturn False\nreturn True\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTermList.is_semantically_equivalent_to","title":"<code>is_semantically_equivalent_to(other)</code>","text":"<p>Tell whether two termlists are semantically equivalent.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SmtTermList</code> <p>The termlist against which we compare self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the two termlists are semantically equivalent.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def is_semantically_equivalent_to(self, other: SmtTermList) -&gt; bool:\n\"\"\"\n    Tell whether two termlists are semantically equivalent.\n    Args:\n        other:\n            The termlist against which we compare self.\n    Returns:\n        True if the two termlists are semantically equivalent.\n    \"\"\"\nreturn self.refines(other) and other.refines(self)\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTermList.refines","title":"<code>refines(other)</code>","text":"<p>Tells whether the argument is a larger specification.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SmtTermList</code> <p>TermList against which we are comparing self.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>self &lt;= other</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def refines(self, other: SmtTermList) -&gt; bool:\n\"\"\"\n    Tells whether the argument is a larger specification.\n    Args:\n        other:\n            TermList against which we are comparing self.\n    Returns:\n        self &lt;= other\n    \"\"\"\nantecedent = self._to_smtexpr()\nconsequent = other._to_smtexpr()\ntest_expr: z3.BoolRef = z3.Implies(antecedent, consequent)\nreturn _is_tautology(test_expr)\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTermList.simplify","title":"<code>simplify(context=None)</code>","text":"<p>Remove redundant terms in the TermList using the provided context.</p> Example <p>Suppose the TermList is \\(\\{x - 2y \\le 5, x - y \\le 0\\}\\) and the context is \\(\\{x + y \\le 0\\}\\). Then the TermList could be simplified to \\(\\{x - y \\le 0\\}\\).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Optional[SmtTermList]</code> <p>The TermList providing the context for the simplification.</p> <code>None</code> <p>Returns:</p> Type Description <code>SmtTermList</code> <p>A new TermList with redundant terms removed using the provided context.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def simplify(self, context: Optional[SmtTermList] = None) -&gt; SmtTermList:\n\"\"\"\n    Remove redundant terms in the TermList using the provided context.\n    Example:\n        Suppose the TermList is $\\\\{x - 2y \\\\le 5, x - y \\\\le 0\\\\}$ and\n        the context is $\\\\{x + y \\\\le 0\\\\}$. Then the TermList could be\n        simplified to $\\\\{x - y \\\\le 0\\\\}$.\n    Args:\n        context:\n            The TermList providing the context for the simplification.\n    Returns:\n        A new TermList with redundant terms removed using the provided context.\n    \"\"\"\nnewterms: List[SmtTerm] = []\nexternal_context = SmtTermList([])\nif context:\nexternal_context = context\nfor i, term_under_analysis in enumerate(self.terms):\nuseful_context = SmtTermList(newterms) | SmtTermList(self.terms[i + 1 :]) | external_context\nif not useful_context.refines(SmtTermList([term_under_analysis])):\nnewterms.append(term_under_analysis.copy())\nreturn SmtTermList(newterms)\n</code></pre>"},{"location":"reference/pacti/terms/smt/smt/#pacti.terms.smt.smt.SmtTermList.to_str_list","title":"<code>to_str_list()</code>","text":"<p>Convert termlist into a list of strings.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings corresponding to the terms of the termlist.</p> Source code in <code>pacti\\src\\pacti\\terms\\smt\\smt.py</code> <pre><code>def to_str_list(self) -&gt; List[str]:\n\"\"\"\n    Convert termlist into a list of strings.\n    Returns:\n        A list of strings corresponding to the terms of the termlist.\n    \"\"\"\nreturn [str(term) for term in self.terms]\n</code></pre>"},{"location":"reference/pacti/utils/","title":"Index","text":""},{"location":"reference/pacti/utils/errors/","title":"Errors","text":"<p>Global error classes.</p>"},{"location":"reference/pacti/utils/errors/#pacti.utils.errors.ContractFormatError","title":"<code>ContractFormatError</code>","text":"<p>               Bases: <code>FileDataFormatError</code></p> <p>Incorrect format</p> Source code in <code>pacti\\src\\pacti\\utils\\errors.py</code> <pre><code>class ContractFormatError(FileDataFormatError):\n\"\"\"Incorrect format\"\"\"\n</code></pre>"},{"location":"reference/pacti/utils/errors/#pacti.utils.errors.FileDataFormatError","title":"<code>FileDataFormatError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Incorrect format</p> Source code in <code>pacti\\src\\pacti\\utils\\errors.py</code> <pre><code>class FileDataFormatError(Exception):\n\"\"\"Incorrect format\"\"\"\n</code></pre>"},{"location":"reference/pacti/utils/errors/#pacti.utils.errors.IncompatibleArgsError","title":"<code>IncompatibleArgsError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Argument validation errors.</p> Source code in <code>pacti\\src\\pacti\\utils\\errors.py</code> <pre><code>class IncompatibleArgsError(ValueError):\n\"\"\"Argument validation errors.\"\"\"\n</code></pre>"},{"location":"reference/pacti/utils/errors/#pacti.utils.errors.PolyhedralSyntaxConvexException","title":"<code>PolyhedralSyntaxConvexException</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ParseBaseException</code></p> <p>Polyhedral Term convexity error</p> Source code in <code>pacti\\src\\pacti\\utils\\errors.py</code> <pre><code>@dataclasses.dataclass\nclass PolyhedralSyntaxConvexException(pp.ParseBaseException):\n\"\"\"Polyhedral Term convexity error\"\"\"\nstring_input: str\nnegative_absolute_terms: List[str]\ndef __str__(self) -&gt; str:\nmsg = []\nmsg.append(\"pacti.terms.polyhedra.PolyhedralTerm non-convexity error.\")\nmsg.append(f\"Convexity requires that the parsing of '{self.string_input}'\")\nmsg.append(\nf\"yields only positive absolute value terms; but we got {len(self.negative_absolute_terms)} negative.\"\n)\nfor nat in self.negative_absolute_terms:\nmsg.append(nat)\nreturn \"\\n\".join(msg)\ndef __repr__(self) -&gt; str:\nreturn str(self)\n</code></pre>"},{"location":"reference/pacti/utils/errors/#pacti.utils.errors.PolyhedralSyntaxException","title":"<code>PolyhedralSyntaxException</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ParseBaseException</code></p> <p>Polyhedral Term syntax error</p> Source code in <code>pacti\\src\\pacti\\utils\\errors.py</code> <pre><code>@dataclasses.dataclass\nclass PolyhedralSyntaxException(pp.ParseBaseException):\n\"\"\"Polyhedral Term syntax error\"\"\"\nparse_exception: pp.ParseBaseException\nstring_input: str\ndef __str__(self) -&gt; str:\nmsg = []\nmsg.append(\"pacti.terms.polyhedra.PolyhedralTerm syntax error.\")\nmsg.append(self.parse_exception.line)\nmsg.append(\" \" * (self.parse_exception.column - 1) + \"^\")\nmsg.append(format(self.parse_exception))\nreturn \"\\n\".join(msg)\ndef __repr__(self) -&gt; str:\nreturn str(self)\n</code></pre>"},{"location":"reference/pacti/utils/fileio/","title":"Fileio","text":"<p>File IO for Pacti.</p>"},{"location":"reference/pacti/utils/fileio/#pacti.utils.fileio.read_contracts_from_file","title":"<code>read_contracts_from_file(file_name)</code>","text":"<p>Read contracts from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Name of file to read.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Unsupported contract attempted to be read.</p> <p>Returns:</p> Type Description <code>Tuple[List[IoContract], List[str]]</code> <p>A list of contracts with the elements of the file.</p> Source code in <code>pacti\\src\\pacti\\utils\\fileio.py</code> <pre><code>def read_contracts_from_file(  # noqa: WPS231 too much cognitive complexity\nfile_name: str,\n) -&gt; Tuple[List[iocontract.IoContract], List[str]]:\n\"\"\"\n    Read contracts from a file.\n    Args:\n        file_name: Name of file to read.\n    Raises:\n        ValueError: Unsupported contract attempted to be read.\n    Returns:\n        A list of contracts with the elements of the file.\n    \"\"\"\nif not os.path.isfile(file_name):\nraise ValueError(f\"The path {file_name} is not a file.\")\nwith open(file_name) as f:\nfile_data = json.load(f)\n# make sure that data is an array of dictionaries\nassert isinstance(file_data, list)\nfor entry in file_data:\nassert isinstance(entry, dict)\nassert \"type\" in entry\n# we load each contract according to the type\ncontracts: List[Any] = []\nnames = []\nfor entry in file_data:\nif entry[\"type\"] == \"PolyhedralIoContract_machine\":\npolyhedra.serializer.validate_contract_dict(entry[\"data\"], entry[\"name\"], machine_representation=True)\ncontracts.append(PolyhedralIoContract.from_dict(entry[\"data\"]))\nnames.append(entry[\"name\"])\nelif entry[\"type\"] == \"PolyhedralIoContract\":\npolyhedra.serializer.validate_contract_dict(entry[\"data\"], entry[\"name\"], machine_representation=False)\ncontracts.append(PolyhedralIoContract.from_strings(**entry[\"data\"]))\nnames.append(entry[\"name\"])\nelif entry[\"type\"] == \"PolyhedralIoContractCompound\":\ncontracts.append(PolyhedralIoContractCompound.from_strings(**entry[\"data\"]))\nnames.append(entry[\"name\"])\nelse:\nraise ValueError()\nreturn contracts, names\n</code></pre>"},{"location":"reference/pacti/utils/fileio/#pacti.utils.fileio.write_contracts_to_file","title":"<code>write_contracts_to_file(contracts, names, file_name, machine_representation=False)</code>","text":"<p>Write contracts to a file.</p> <p>Parameters:</p> Name Type Description Default <code>contracts</code> <code>List[IoContract]</code> <p>The contracts to write.</p> required <code>names</code> <code>List[str]</code> <p>The names of the contracts to keep in written file.</p> required <code>file_name</code> <code>str</code> <p>Name of file to write.</p> required <code>machine_representation</code> <code>bool</code> <p>Whether the resulting file should be optimized for machine processing.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unsupported contract type.</p> Source code in <code>pacti\\src\\pacti\\utils\\fileio.py</code> <pre><code>def write_contracts_to_file(  # noqa: WPS231 too much cognitive complexity\ncontracts: List[iocontract.IoContract],\nnames: List[str],\nfile_name: str,\nmachine_representation: bool = False,\n) -&gt; None:\n\"\"\"\n    Write contracts to a file.\n    Args:\n        contracts: The contracts to write.\n        names: The names of the contracts to keep in written file.\n        file_name: Name of file to write.\n        machine_representation: Whether the resulting file should be optimized for machine processing.\n    Raises:\n        ValueError: Unsupported contract type.\n    \"\"\"\ndata = []\nassert len(contracts) == len(names)\nfor i, c in enumerate(contracts):\nentry: Dict[str, Any] = {}\nif isinstance(c, PolyhedralIoContract):\nentry[\"name\"] = names[i]\nif machine_representation:\nentry[\"type\"] = \"PolyhedralIoContract_machine\"\nentry[\"data\"] = c.to_machine_dict()\nelse:\nentry[\"type\"] = \"PolyhedralIoContract\"\nentry[\"data\"] = c.to_dict()\nelif isinstance(c, PolyhedralIoContractCompound):\nentry[\"name\"] = names[i]\nif machine_representation:\nraise ValueError(\"Unsupported representation\")\nentry[\"type\"] = \"PolyhedralIoContractCompound\"\nentry[\"data\"] = c.to_dict()\nelse:\nraise ValueError(\"Unsupported argument type\")\ndata.append(entry)\nwith open(file_name, \"w\") as f:\nf.write(json.dumps(data, indent=2))\n</code></pre>"},{"location":"reference/pacti/utils/lists/","title":"Lists","text":"<p>Some list operations.</p>"},{"location":"reference/pacti/utils/lists/#pacti.utils.lists.list_diff","title":"<code>list_diff(list1, list2)</code>","text":"<p>Compute difference between lists.</p> <p>Parameters:</p> Name Type Description Default <code>list1</code> <code>List[Any]</code> <p>First argument.</p> required <code>list2</code> <code>List[Any]</code> <p>Second argument.</p> required <p>Returns:</p> Type Description <code>List[Any]</code> <p>A list containing the elements of the first argument which do not belong to the second.</p> Source code in <code>pacti\\src\\pacti\\utils\\lists.py</code> <pre><code>def list_diff(list1: List[Any], list2: List[Any]) -&gt; List[Any]:\n\"\"\"\n    Compute difference between lists.\n    Args:\n        list1: First argument.\n        list2: Second argument.\n    Returns:\n        A list containing the elements of the first argument which do not belong to the second.\n    \"\"\"\nreturn [el for el in list1 if (el not in list2)]\n</code></pre>"},{"location":"reference/pacti/utils/lists/#pacti.utils.lists.list_intersection","title":"<code>list_intersection(list1, list2)</code>","text":"<p>Intersect two lists.</p> <p>Parameters:</p> Name Type Description Default <code>list1</code> <code>List[Any]</code> <p>First argument.</p> required <code>list2</code> <code>List[Any]</code> <p>Second argument.</p> required <p>Returns:</p> Type Description <code>List[Any]</code> <p>A list containing the intersection of both lists.</p> Source code in <code>pacti\\src\\pacti\\utils\\lists.py</code> <pre><code>def list_intersection(list1: List[Any], list2: List[Any]) -&gt; List[Any]:\n\"\"\"\n    Intersect two lists.\n    Args:\n        list1: First argument.\n        list2: Second argument.\n    Returns:\n        A list containing the intersection of both lists.\n    \"\"\"\nreturn [el for el in list1 if el in list2]\n</code></pre>"},{"location":"reference/pacti/utils/lists/#pacti.utils.lists.list_remove_indices","title":"<code>list_remove_indices(list1, indices_to_remove)</code>","text":"<p>Create a copy of a given list with the indicated indicated indices removed</p> <p>Parameters:</p> Name Type Description Default <code>list1</code> <code>List[Any]</code> <p>List to copy.</p> required <code>indices_to_remove</code> <code>List[int]</code> <p>The indices to be removed.</p> required <p>Returns:</p> Type Description <code>List[Any]</code> <p>A new list.</p> Source code in <code>pacti\\src\\pacti\\utils\\lists.py</code> <pre><code>def list_remove_indices(list1: List[Any], indices_to_remove: List[int]) -&gt; List[Any]:\n\"\"\"\n    Create a copy of a given list with the indicated indicated indices removed\n    Args:\n        list1: List to copy.\n        indices_to_remove: The indices to be removed.\n    Returns:\n        A new list.\n    \"\"\"\nnew_list = []\nfor i, _ in enumerate(list1):\nif i not in indices_to_remove:\nnew_list.append(list1[i])\nreturn new_list\n</code></pre>"},{"location":"reference/pacti/utils/lists/#pacti.utils.lists.list_union","title":"<code>list_union(list1, list2)</code>","text":"<p>Compute the union of two lists.</p> <p>Parameters:</p> Name Type Description Default <code>list1</code> <code>List[Any]</code> <p>First argument.</p> required <code>list2</code> <code>List[Any]</code> <p>Second argument.</p> required <p>Returns:</p> Type Description <code>List[Any]</code> <p>A list containing the elements that at least one list contains.</p> Source code in <code>pacti\\src\\pacti\\utils\\lists.py</code> <pre><code>def list_union(list1: List[Any], list2: List[Any]) -&gt; List[Any]:\n\"\"\"\n    Compute the union of two lists.\n    Args:\n        list1: First argument.\n        list2: Second argument.\n    Returns:\n        A list containing the elements that at least one list contains.\n    \"\"\"\nreturn list1 + [el for el in list2 if (el not in list1)]\n</code></pre>"},{"location":"reference/pacti/utils/lists/#pacti.utils.lists.lists_equal","title":"<code>lists_equal(list1, list2)</code>","text":"<p>Tells whether two lists have the same elements.</p> <p>Parameters:</p> Name Type Description Default <code>list1</code> <code>List[Any]</code> <p>First argument.</p> required <code>list2</code> <code>List[Any]</code> <p>Second argument.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the lists are equal element-wise.</p> Source code in <code>pacti\\src\\pacti\\utils\\lists.py</code> <pre><code>def lists_equal(list1: List[Any], list2: List[Any]) -&gt; bool:\n\"\"\"\n    Tells whether two lists have the same elements.\n    Args:\n        list1: First argument.\n        list2: Second argument.\n    Returns:\n        True if the lists are equal element-wise.\n    \"\"\"\nreturn (len(list_diff(list1, list2)) == 0) and (len(list_diff(list2, list1)) == 0)\n</code></pre>"},{"location":"reference/pacti/utils/plots/","title":"Plots","text":"<p>Plotting functionality for polyhedral contracts.</p>"},{"location":"reference/pacti/utils/plots/#pacti.utils.plots.constraints_to_vertices","title":"<code>constraints_to_vertices(constraints, x_var, y_var, var_values, x_lims, y_lims)</code>","text":"<p>Return the bounding vertices of a set of constraints.</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>PolyhedralTermList</code> <p>the set of constraints.</p> required <code>x_var</code> <code>Var</code> <p>The variable among those in the constraints that will be used as the horizontal variable.</p> required <code>y_var</code> <code>Var</code> <p>The variable among those in the constraints that will be used as the vertical variable.</p> required <code>var_values</code> <code>Dict[Var, numeric]</code> <p>Values to which the rest of the variables in the constraints are set.</p> required <code>x_lims</code> <code>Tuple[numeric, numeric]</code> <p>Horizontal limits of polyhedron.</p> required <code>y_lims</code> <code>Tuple[numeric, numeric]</code> <p>Vertical limits of polyhedron.</p> required <p>Returns:</p> Type Description <code>Tuple[Tuple, Tuple]</code> <p>A tuple of x and y tuples correponding to the vertices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Arguments do not meet expectations, i.e., other variables are not set to constant values, etc.</p> Source code in <code>pacti\\src\\pacti\\utils\\plots.py</code> <pre><code>def constraints_to_vertices(\nconstraints: PolyhedralTermList,\nx_var: Var,\ny_var: Var,\nvar_values: Dict[Var, numeric],\nx_lims: Tuple[numeric, numeric],\ny_lims: Tuple[numeric, numeric],\n) -&gt; Tuple[Tuple, Tuple]:\n\"\"\"\n    Return the bounding vertices of a set of constraints.\n    Args:\n        constraints: the set of constraints.\n        x_var: The variable among those in the constraints that will be used as the horizontal variable.\n        y_var: The variable among those in the constraints that will be used as the vertical variable.\n        var_values: Values to which the rest of the variables in the constraints are set.\n        x_lims: Horizontal limits of polyhedron.\n        y_lims: Vertical limits of polyhedron.\n    Returns:\n        A tuple of x and y tuples correponding to the vertices.\n    Raises:\n        ValueError: Arguments do not meet expectations, i.e., other variables are not set to constant values, etc.\n    \"\"\"\nif not isinstance(constraints, PolyhedralTermList):\nraise ValueError(\"Expecting polyhedral constraints. Constraint type: %s\" % (type(constraints)))\nif x_var in var_values.keys():\nraise ValueError(\"x-axis variable %s can't be assigned a value\" % (x_var))\nif y_var in var_values.keys():\nraise ValueError(\"y-axis variable %s can't be assigned a value\" % (y_var))\ndiff = list_diff(constraints.vars, list_union([x_var, y_var], list(var_values.keys())))\nif diff:\nraise ValueError(\"Need to set variables %s\" % (diff))\n# for every term in the assumptions, replace all variables with the values provided\nterm_list = constraints | _gen_boundary_constraints(x_var, y_var, x_lims, y_lims)\nplot_tl = _substitute_in_termlist(term_list, var_values)\nassert not list_diff(plot_tl.vars, [x_var, y_var]), \"termlist vars: %s\" % (plot_tl.vars)\n# Now we plot the polygon\nres_tuple = PolyhedralTermList.termlist_to_polytope(plot_tl, PolyhedralTermList([]))\nvariables = res_tuple[0]\na_mat = res_tuple[1]\nb = res_tuple[2]\nif variables[0] == y_var:\n# place the x variable in first row\na_mat[:, [0, 1]] = a_mat[:, [1, 0]]  # noqa: WPS359 Found an iterable unpacking to list\nreturn _get_bounding_vertices(a_mat, b)\n</code></pre>"},{"location":"reference/pacti/utils/plots/#pacti.utils.plots.get_path","title":"<code>get_path(x0, x1, y0, y1, x_transform, y_transform, number_of_points)</code>","text":"<p>Transform a path in original coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>numeric</code> <p>x-value of the starting point of the path to transform.</p> required <code>x1</code> <code>numeric</code> <p>x-value of the final point of the path to transform.</p> required <code>y0</code> <code>numeric</code> <p>y-value of the starting point of the path to transform.</p> required <code>y1</code> <code>numeric</code> <p>y-value of the final point of the path to transform.</p> required <code>x_transform</code> <code>Callable</code> <p>function to map (x,y) values to new horizontal variable.</p> required <code>y_transform</code> <code>Callable</code> <p>function to map (x,y) values to new vertical variable.</p> required <code>number_of_points</code> <code>int</code> <p>number of points to transform on each side of (x,y) polyhedron.</p> required <p>Returns:</p> Type Description <code>Tuple[List, List]</code> <p>A tuple of x tuples and y tuples corresponding to the transformed path.</p> Source code in <code>pacti\\src\\pacti\\utils\\plots.py</code> <pre><code>def get_path(\nx0: numeric,\nx1: numeric,\ny0: numeric,\ny1: numeric,\nx_transform: Callable,\ny_transform: Callable,\nnumber_of_points: int,\n) -&gt; Tuple[List, List]:\n\"\"\"\n    Transform a path in original coordinates.\n    Args:\n        x0: x-value of the starting point of the path to transform.\n        x1: x-value of the final point of the path to transform.\n        y0: y-value of the starting point of the path to transform.\n        y1: y-value of the final point of the path to transform.\n        x_transform: function to map (x,y) values to new horizontal variable.\n        y_transform: function to map (x,y) values to new vertical variable.\n        number_of_points: number of points to transform on each side of (x,y) polyhedron.\n    Returns:\n        A tuple of x tuples and y tuples corresponding to the transformed path.\n    \"\"\"\nxx = np.linspace(x0, x1, number_of_points)\nyy = np.linspace(y0, y1, number_of_points)\nx_tranform_vec = np.vectorize(x_transform)\ny_tranform_vec = np.vectorize(y_transform)\nreturn x_tranform_vec(xx, yy).tolist(), y_tranform_vec(xx, yy).tolist()\n</code></pre>"},{"location":"reference/pacti/utils/plots/#pacti.utils.plots.plot_assumptions","title":"<code>plot_assumptions(contract, x_var, y_var, var_values, x_lims, y_lims, show=True)</code>","text":"<p>Plots the assumptions of an IoContract with polyhedral terms.</p> <p>Parameters:</p> Name Type Description Default <code>contract</code> <code>PolyhedralIoContract</code> <p>the contract whose assumptions will be plotted.</p> required <code>x_var</code> <code>Union[Var, str]</code> <p>variable mapped to the x-axis.</p> required <code>y_var</code> <code>Union[Var, str]</code> <p>variable mapped to the y-axis.</p> required <code>var_values</code> <code>Dict[Union[Var, str], numeric]</code> <p>values of other variables appearing in the assumptions.</p> required <code>x_lims</code> <code>Tuple[numeric, numeric]</code> <p>range of values in the x-axis.</p> required <code>y_lims</code> <code>Tuple[numeric, numeric]</code> <p>range of values in the y-axis.</p> required <code>show</code> <code>Optional[bool]</code> <p>If <code>True</code> (default), the figure is displayed.   If <code>False</code> the display is suppressed.</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Figure element with a single \"axes\" object showing the feasible region for the assumptions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>arguments provided failed sanity checks.</p> Source code in <code>pacti\\src\\pacti\\utils\\plots.py</code> <pre><code>def plot_assumptions(\ncontract: PolyhedralIoContract,\nx_var: Union[Var, str],\ny_var: Union[Var, str],\nvar_values: Dict[Union[Var, str], numeric],\nx_lims: Tuple[numeric, numeric],\ny_lims: Tuple[numeric, numeric],\nshow: Optional[bool] = True,\n) -&gt; MplFigure:\n\"\"\"\n    Plots the assumptions of an IoContract with polyhedral terms.\n    Args:\n        contract: the contract whose assumptions will be plotted.\n        x_var: variable mapped to the x-axis.\n        y_var: variable mapped to the y-axis.\n        var_values: values of other variables appearing in the assumptions.\n        x_lims: range of values in the x-axis.\n        y_lims: range of values in the y-axis.\n        show: If `True` (default), the figure is displayed.\n              If `False` the display is suppressed.\n    Returns:\n        Figure element with a single \"axes\" object showing the feasible region for the assumptions.\n    Raises:\n        ValueError: arguments provided failed sanity checks.\n    \"\"\"\nx_var_var = _to_var(x_var)\ny_var_var = _to_var(y_var)\nvar_values_var = _to_vals_dict(var_values)\nif x_var_var not in contract.vars:\nraise ValueError(\"Variable %s is not in an input or output variable of contract.\" % (x_var_var))\nif y_var_var not in contract.vars:\nraise ValueError(\"Variable %s is not in an input or output variable of contract.\" % (y_var_var))\nfor var in var_values_var.keys():  # noqa: VNE002\nif var not in contract.vars:\nraise ValueError(\"Var %s from var_values is not in the interface of the contract.\" % (var))\nfig = _plot_constraints(contract.a, x_var_var, y_var_var, var_values_var, x_lims, y_lims, _to_bool(show))\nax = fig.axes[0]\nax.set_title(\"Assumptions\")\nreturn fig\n</code></pre>"},{"location":"reference/pacti/utils/plots/#pacti.utils.plots.plot_guarantees","title":"<code>plot_guarantees(contract, x_var, y_var, var_values, x_lims, y_lims, new_x_var=None, new_y_var=None, x_transform=None, y_transform=None, number_of_points=30, show=True)</code>","text":"<p>Plots the guarantees and assumptions of an IoContract with polyhedral terms.</p> <p>Parameters:</p> Name Type Description Default <code>contract</code> <code>PolyhedralIoContract</code> <p>the contract whose assumptions &amp; guarantees will be plotted.</p> required <code>x_var</code> <code>Union[Var, str]</code> <p>variable mapped to the x-axis.</p> required <code>y_var</code> <code>Union[Var, str]</code> <p>variable mapped to the y-axis.</p> required <code>var_values</code> <code>Dict[Union[Var, str], numeric]</code> <p>values of other variables appearing in the assumptions &amp; guarantees.</p> required <code>x_lims</code> <code>Tuple[numeric, numeric]</code> <p>range of values in the x-axis.</p> required <code>y_lims</code> <code>Tuple[numeric, numeric]</code> <p>range of values in the y-axis.</p> required <code>new_x_var</code> <code>Optional[str]</code> <p>name of horizontal transformed variable.</p> <code>None</code> <code>new_y_var</code> <code>Optional[str]</code> <p>name of vertical transformed variable.</p> <code>None</code> <code>x_transform</code> <code>Optional[Callable[[numeric, numeric], numeric]]</code> <p>function to map (x,y) values to new horizontal variable.</p> <code>None</code> <code>y_transform</code> <code>Optional[Callable[[numeric, numeric], numeric]]</code> <p>function to map (x,y) values to new vertical variable.</p> <code>None</code> <code>number_of_points</code> <code>Optional[int]</code> <p>number of points to transform on each side of (x,y) polyhedron.</p> <code>30</code> <code>show</code> <code>Optional[bool]</code> <p>If <code>True</code> (default), the figure is displayed.   If <code>False</code> the display is suppressed.</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Figure element with a single \"axes\" object showing the feasible region for the assumptions &amp; guarantees.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>arguments provided failed sanity checks.</p> Source code in <code>pacti\\src\\pacti\\utils\\plots.py</code> <pre><code>def plot_guarantees(\ncontract: PolyhedralIoContract,\nx_var: Union[Var, str],\ny_var: Union[Var, str],\nvar_values: Dict[Union[Var, str], numeric],\nx_lims: Tuple[numeric, numeric],\ny_lims: Tuple[numeric, numeric],\nnew_x_var: Optional[str] = None,\nnew_y_var: Optional[str] = None,\nx_transform: Optional[Callable[[numeric, numeric], numeric]] = None,\ny_transform: Optional[Callable[[numeric, numeric], numeric]] = None,\nnumber_of_points: Optional[int] = 30,\nshow: Optional[bool] = True,\n) -&gt; MplFigure:\n\"\"\"\n    Plots the guarantees and assumptions of an IoContract with polyhedral terms.\n    Args:\n        contract: the contract whose assumptions &amp; guarantees will be plotted.\n        x_var: variable mapped to the x-axis.\n        y_var: variable mapped to the y-axis.\n        var_values: values of other variables appearing in the assumptions &amp; guarantees.\n        x_lims: range of values in the x-axis.\n        y_lims: range of values in the y-axis.\n        new_x_var: name of horizontal transformed variable.\n        new_y_var: name of vertical transformed variable.\n        x_transform: function to map (x,y) values to new horizontal variable.\n        y_transform: function to map (x,y) values to new vertical variable.\n        number_of_points: number of points to transform on each side of (x,y) polyhedron.\n        show: If `True` (default), the figure is displayed.\n              If `False` the display is suppressed.\n    Returns:\n        Figure element with a single \"axes\" object showing the feasible region for the assumptions &amp; guarantees.\n    Raises:\n        ValueError: arguments provided failed sanity checks.\n    \"\"\"\nx_var_var = _to_var(x_var)\ny_var_var = _to_var(y_var)\nvar_values_var = _to_vals_dict(var_values)\nif x_var_var not in contract.vars:\nraise ValueError(\"Variable %s is not in an input or output variable of contract.\" % (x_var_var))\nif y_var_var not in contract.vars:\nraise ValueError(\"Variable %s is not in an input or output variable of contract.\" % (y_var_var))\nfor var in var_values_var.keys():  # noqa: VNE002\nif var not in contract.vars:\nraise ValueError(\"Var %s from var_values is not in the interface of the contract.\" % (var))\nif x_transform is not None and y_transform is not None:\nassert new_x_var\nassert new_y_var\nassert number_of_points\nfig = _plot_transformed_constraints(\ncontract.a | contract.g,\nx_var_var,\ny_var_var,\nvar_values_var,\nx_lims,\ny_lims,\nnew_x_var,\nnew_y_var,\nx_transform,\ny_transform,\nnumber_of_points,\n_to_bool(show),\n)\nelse:\nfig = _plot_constraints(\ncontract.a | contract.g, x_var_var, y_var_var, var_values_var, x_lims, y_lims, _to_bool(show)\n)\nax = fig.axes[0]\nax.set_title(\"Guarantees\")\nreturn fig\n</code></pre>"}]}